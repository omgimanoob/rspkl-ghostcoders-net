(self["webpackChunkkimai2"] = self["webpackChunkkimai2"] || []).push([["app"],{

/***/ "./node_modules/@popperjs/core/lib/createPopper.js":
/*!*********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/createPopper.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createPopper: function() { return /* binding */ createPopper; },
/* harmony export */   detectOverflow: function() { return /* reexport safe */ _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_8__["default"]; },
/* harmony export */   popperGenerator: function() { return /* binding */ popperGenerator; }
/* harmony export */ });
/* harmony import */ var _dom_utils_getCompositeRect_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dom-utils/getCompositeRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js");
/* harmony import */ var _dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./dom-utils/getLayoutRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js");
/* harmony import */ var _dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom-utils/listScrollParents.js */ "./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js");
/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./dom-utils/getOffsetParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");
/* harmony import */ var _utils_orderModifiers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/orderModifiers.js */ "./node_modules/@popperjs/core/lib/utils/orderModifiers.js");
/* harmony import */ var _utils_debounce_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/debounce.js */ "./node_modules/@popperjs/core/lib/utils/debounce.js");
/* harmony import */ var _utils_mergeByName_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/mergeByName.js */ "./node_modules/@popperjs/core/lib/utils/mergeByName.js");
/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/detectOverflow.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom-utils/instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");









var DEFAULT_OPTIONS = {
  placement: 'bottom',
  modifiers: [],
  strategy: 'absolute'
};

function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return !args.some(function (element) {
    return !(element && typeof element.getBoundingClientRect === 'function');
  });
}

function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }

  var _generatorOptions = generatorOptions,
      _generatorOptions$def = _generatorOptions.defaultModifiers,
      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
      _generatorOptions$def2 = _generatorOptions.defaultOptions,
      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper(reference, popper, options) {
    if (options === void 0) {
      options = defaultOptions;
    }

    var state = {
      placement: 'bottom',
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference,
        popper: popper
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state: state,
      setOptions: function setOptions(setOptionsAction) {
        var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options);
        state.scrollParents = {
          reference: (0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isElement)(reference) ? (0,_dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_1__["default"])(reference) : reference.contextElement ? (0,_dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_1__["default"])(reference.contextElement) : [],
          popper: (0,_dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_1__["default"])(popper)
        }; // Orders the modifiers based on their dependencies and `phase`
        // properties

        var orderedModifiers = (0,_utils_orderModifiers_js__WEBPACK_IMPORTED_MODULE_2__["default"])((0,_utils_mergeByName_js__WEBPACK_IMPORTED_MODULE_3__["default"])([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

        state.orderedModifiers = orderedModifiers.filter(function (m) {
          return m.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }

        var _state$elements = state.elements,
            reference = _state$elements.reference,
            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
        // anymore

        if (!areValidElements(reference, popper)) {
          return;
        } // Store the reference and popper rects to be read by modifiers


        state.rects = {
          reference: (0,_dom_utils_getCompositeRect_js__WEBPACK_IMPORTED_MODULE_4__["default"])(reference, (0,_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_5__["default"])(popper), state.options.strategy === 'fixed'),
          popper: (0,_dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_6__["default"])(popper)
        }; // Modifiers have the ability to reset the current update cycle. The
        // most common use case for this is the `flip` modifier changing the
        // placement, which then needs to re-run all the modifiers, because the
        // logic was previously ran for the previous placement and is therefore
        // stale/incorrect

        state.reset = false;
        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
        // is filled with the initial data specified by the modifier. This means
        // it doesn't persist and is fresh on each update.
        // To ensure persistent data, use `${name}#persistent`

        state.orderedModifiers.forEach(function (modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });

        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }

          var _state$orderedModifie = state.orderedModifiers[index],
              fn = _state$orderedModifie.fn,
              _state$orderedModifie2 = _state$orderedModifie.options,
              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
              name = _state$orderedModifie.name;

          if (typeof fn === 'function') {
            state = fn({
              state: state,
              options: _options,
              name: name,
              instance: instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: (0,_utils_debounce_js__WEBPACK_IMPORTED_MODULE_7__["default"])(function () {
        return new Promise(function (resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };

    if (!areValidElements(reference, popper)) {
      return instance;
    }

    instance.setOptions(options).then(function (state) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state);
      }
    }); // Modifiers have the ability to execute arbitrary code before the first
    // update cycle runs. They will be executed in the same order as the update
    // cycle. This is useful when a modifier adds some persistent data that
    // other modifiers need to use, but the modifier is run after the dependent
    // one.

    function runModifierEffects() {
      state.orderedModifiers.forEach(function (_ref) {
        var name = _ref.name,
            _ref$options = _ref.options,
            options = _ref$options === void 0 ? {} : _ref$options,
            effect = _ref.effect;

        if (typeof effect === 'function') {
          var cleanupFn = effect({
            state: state,
            name: name,
            instance: instance,
            options: options
          });

          var noopFn = function noopFn() {};

          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }

    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function (fn) {
        return fn();
      });
      effectCleanupFns = [];
    }

    return instance;
  };
}
var createPopper = /*#__PURE__*/popperGenerator(); // eslint-disable-next-line import/no-unused-modules



/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/contains.js":
/*!***************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/contains.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ contains; }
/* harmony export */ });
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");

function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

  if (parent.contains(child)) {
    return true;
  } // then fallback to custom implementation with Shadow DOM support
  else if (rootNode && (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isShadowRoot)(rootNode)) {
      var next = child;

      do {
        if (next && parent.isSameNode(next)) {
          return true;
        } // $FlowFixMe[prop-missing]: need a better way to handle this...


        next = next.parentNode || next.host;
      } while (next);
    } // Give up, the result is false


  return false;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getBoundingClientRect; }
/* harmony export */ });
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _isLayoutViewport_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isLayoutViewport.js */ "./node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js");




function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }

  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }

  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;

  if (includeScale && (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element)) {
    scaleX = element.offsetWidth > 0 ? (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_1__.round)(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_1__.round)(clientRect.height) / element.offsetHeight || 1 : 1;
  }

  var _ref = (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isElement)(element) ? (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_2__["default"])(element) : window,
      visualViewport = _ref.visualViewport;

  var addVisualOffsets = !(0,_isLayoutViewport_js__WEBPACK_IMPORTED_MODULE_3__["default"])() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width: width,
    height: height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x: x,
    y: y
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getClippingRect; }
/* harmony export */ });
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _getViewportRect_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getViewportRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js");
/* harmony import */ var _getDocumentRect_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getDocumentRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js");
/* harmony import */ var _listScrollParents_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./listScrollParents.js */ "./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js");
/* harmony import */ var _getOffsetParent_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./getOffsetParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBoundingClientRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");
/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./getParentNode.js */ "./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js");
/* harmony import */ var _contains_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./contains.js */ "./node_modules/@popperjs/core/lib/dom-utils/contains.js");
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _utils_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/rectToClientRect.js */ "./node_modules/@popperjs/core/lib/utils/rectToClientRect.js");
/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../utils/math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");















function getInnerBoundingClientRect(element, strategy) {
  var rect = (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element, false, strategy === 'fixed');
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}

function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === _enums_js__WEBPACK_IMPORTED_MODULE_1__.viewport ? (0,_utils_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_2__["default"])((0,_getViewportRect_js__WEBPACK_IMPORTED_MODULE_3__["default"])(element, strategy)) : (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_4__.isElement)(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : (0,_utils_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_2__["default"])((0,_getDocumentRect_js__WEBPACK_IMPORTED_MODULE_5__["default"])((0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_6__["default"])(element)));
} // A "clipping parent" is an overflowable container with the characteristic of
// clipping (or hiding) overflowing elements with a position different from
// `initial`


function getClippingParents(element) {
  var clippingParents = (0,_listScrollParents_js__WEBPACK_IMPORTED_MODULE_7__["default"])((0,_getParentNode_js__WEBPACK_IMPORTED_MODULE_8__["default"])(element));
  var canEscapeClipping = ['absolute', 'fixed'].indexOf((0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_9__["default"])(element).position) >= 0;
  var clipperElement = canEscapeClipping && (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_4__.isHTMLElement)(element) ? (0,_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_10__["default"])(element) : element;

  if (!(0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_4__.isElement)(clipperElement)) {
    return [];
  } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414


  return clippingParents.filter(function (clippingParent) {
    return (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_4__.isElement)(clippingParent) && (0,_contains_js__WEBPACK_IMPORTED_MODULE_11__["default"])(clippingParent, clipperElement) && (0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_12__["default"])(clippingParent) !== 'body';
  });
} // Gets the maximum area that the element is visible in due to any number of
// clipping parents


function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents[0];
  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_13__.max)(rect.top, accRect.top);
    accRect.right = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_13__.min)(rect.right, accRect.right);
    accRect.bottom = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_13__.min)(rect.bottom, accRect.bottom);
    accRect.left = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_13__.max)(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getCompositeRect; }
/* harmony export */ });
/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getBoundingClientRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");
/* harmony import */ var _getNodeScroll_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./getNodeScroll.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js");
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./getWindowScrollBarX.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js");
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _isScrollParent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./isScrollParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js");
/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");









function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_0__.round)(rect.width) / element.offsetWidth || 1;
  var scaleY = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_0__.round)(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
} // Returns the composite rect of an element relative to its offsetParent.
// Composite means it takes into account transforms as well as layout.


function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }

  var isOffsetParentAnElement = (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(offsetParent);
  var offsetParentIsScaled = (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(offsetParent) && isElementScaled(offsetParent);
  var documentElement = (0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(offsetParent);
  var rect = (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_3__["default"])(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };

  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if ((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_4__["default"])(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
    (0,_isScrollParent_js__WEBPACK_IMPORTED_MODULE_5__["default"])(documentElement)) {
      scroll = (0,_getNodeScroll_js__WEBPACK_IMPORTED_MODULE_6__["default"])(offsetParent);
    }

    if ((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(offsetParent)) {
      offsets = (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_3__["default"])(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = (0,_getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_7__["default"])(documentElement);
    }
  }

  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getComputedStyle; }
/* harmony export */ });
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");

function getComputedStyle(element) {
  return (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element).getComputedStyle(element);
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getDocumentElement; }
/* harmony export */ });
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");

function getDocumentElement(element) {
  // $FlowFixMe[incompatible-return]: assume body is always available
  return (((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isElement)(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]
  element.document) || window.document).documentElement;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getDocumentRect; }
/* harmony export */ });
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");
/* harmony import */ var _getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getWindowScrollBarX.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js");
/* harmony import */ var _getWindowScroll_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getWindowScroll.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js");
/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");




 // Gets the entire size of the scrollable document area, even extending outside
// of the `<html>` and `<body>` rect bounds if horizontally scrollable

function getDocumentRect(element) {
  var _element$ownerDocumen;

  var html = (0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element);
  var winScroll = (0,_getWindowScroll_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_2__.max)(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_2__.max)(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + (0,_getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_3__["default"])(element);
  var y = -winScroll.scrollTop;

  if ((0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_4__["default"])(body || html).direction === 'rtl') {
    x += (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_2__.max)(html.clientWidth, body ? body.clientWidth : 0) - width;
  }

  return {
    width: width,
    height: height,
    x: x,
    y: y
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getHTMLElementScroll; }
/* harmony export */ });
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getLayoutRect; }
/* harmony export */ });
/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBoundingClientRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");
 // Returns the layout rect of an element relative to its offsetParent. Layout
// means it doesn't take into account transforms.

function getLayoutRect(element) {
  var clientRect = (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element); // Use the clientRect sizes if it's not been transformed.
  // Fixes https://github.com/popperjs/popper-core/issues/1223

  var width = element.offsetWidth;
  var height = element.offsetHeight;

  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }

  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }

  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: width,
    height: height
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js":
/*!******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getNodeName; }
/* harmony export */ });
function getNodeName(element) {
  return element ? (element.nodeName || '').toLowerCase() : null;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getNodeScroll; }
/* harmony export */ });
/* harmony import */ var _getWindowScroll_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindowScroll.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js");
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _getHTMLElementScroll_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getHTMLElementScroll.js */ "./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js");




function getNodeScroll(node) {
  if (node === (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node) || !(0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(node)) {
    return (0,_getWindowScroll_js__WEBPACK_IMPORTED_MODULE_2__["default"])(node);
  } else {
    return (0,_getHTMLElementScroll_js__WEBPACK_IMPORTED_MODULE_3__["default"])(node);
  }
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getOffsetParent; }
/* harmony export */ });
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _isTableElement_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./isTableElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js");
/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getParentNode.js */ "./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js");
/* harmony import */ var _utils_userAgent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/userAgent.js */ "./node_modules/@popperjs/core/lib/utils/userAgent.js");








function getTrueOffsetParent(element) {
  if (!(0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) || // https://github.com/popperjs/popper-core/issues/837
  (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element).position === 'fixed') {
    return null;
  }

  return element.offsetParent;
} // `.offsetParent` reports `null` for fixed elements, while absolute elements
// return the containing block


function getContainingBlock(element) {
  var isFirefox = /firefox/i.test((0,_utils_userAgent_js__WEBPACK_IMPORTED_MODULE_2__["default"])());
  var isIE = /Trident/i.test((0,_utils_userAgent_js__WEBPACK_IMPORTED_MODULE_2__["default"])());

  if (isIE && (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element)) {
    // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
    var elementCss = (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element);

    if (elementCss.position === 'fixed') {
      return null;
    }
  }

  var currentNode = (0,_getParentNode_js__WEBPACK_IMPORTED_MODULE_3__["default"])(element);

  if ((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isShadowRoot)(currentNode)) {
    currentNode = currentNode.host;
  }

  while ((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(currentNode) && ['html', 'body'].indexOf((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_4__["default"])(currentNode)) < 0) {
    var css = (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(currentNode); // This is non-exhaustive but covers the most common CSS properties that
    // create a containing block.
    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

    if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }

  return null;
} // Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.


function getOffsetParent(element) {
  var window = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_5__["default"])(element);
  var offsetParent = getTrueOffsetParent(element);

  while (offsetParent && (0,_isTableElement_js__WEBPACK_IMPORTED_MODULE_6__["default"])(offsetParent) && (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(offsetParent).position === 'static') {
    offsetParent = getTrueOffsetParent(offsetParent);
  }

  if (offsetParent && ((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_4__["default"])(offsetParent) === 'html' || (0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_4__["default"])(offsetParent) === 'body' && (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(offsetParent).position === 'static')) {
    return window;
  }

  return offsetParent || getContainingBlock(element) || window;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getParentNode; }
/* harmony export */ });
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");



function getParentNode(element) {
  if ((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element) === 'html') {
    return element;
  }

  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || ( // DOM Element detected
    (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isShadowRoot)(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    (0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(element) // fallback

  );
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getScrollParent; }
/* harmony export */ });
/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getParentNode.js */ "./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js");
/* harmony import */ var _isScrollParent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isScrollParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js");
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");




function getScrollParent(node) {
  if (['html', 'body', '#document'].indexOf((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node)) >= 0) {
    // $FlowFixMe[incompatible-return]: assume body is always available
    return node.ownerDocument.body;
  }

  if ((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(node) && (0,_isScrollParent_js__WEBPACK_IMPORTED_MODULE_2__["default"])(node)) {
    return node;
  }

  return getScrollParent((0,_getParentNode_js__WEBPACK_IMPORTED_MODULE_3__["default"])(node));
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getViewportRect; }
/* harmony export */ });
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getWindowScrollBarX.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js");
/* harmony import */ var _isLayoutViewport_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isLayoutViewport.js */ "./node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js");




function getViewportRect(element, strategy) {
  var win = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element);
  var html = (0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;

  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = (0,_isLayoutViewport_js__WEBPACK_IMPORTED_MODULE_2__["default"])();

    if (layoutViewport || !layoutViewport && strategy === 'fixed') {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }

  return {
    width: width,
    height: height,
    x: x + (0,_getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_3__["default"])(element),
    y: y
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js":
/*!****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getWindow.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getWindow; }
/* harmony export */ });
function getWindow(node) {
  if (node == null) {
    return window;
  }

  if (node.toString() !== '[object Window]') {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }

  return node;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getWindowScroll; }
/* harmony export */ });
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");

function getWindowScroll(node) {
  var win = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft: scrollLeft,
    scrollTop: scrollTop
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getWindowScrollBarX; }
/* harmony export */ });
/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBoundingClientRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _getWindowScroll_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindowScroll.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js");



function getWindowScrollBarX(element) {
  // If <html> has a CSS width greater than the viewport, then this will be
  // incorrect for RTL.
  // Popper 1 is broken in this case and never had a bug report so let's assume
  // it's not an issue. I don't think anyone ever specifies width on <html>
  // anyway.
  // Browsers where the left scrollbar doesn't cause an issue report `0` for
  // this (e.g. Edge 2019, IE11, Safari)
  return (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__["default"])((0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element)).left + (0,_getWindowScroll_js__WEBPACK_IMPORTED_MODULE_2__["default"])(element).scrollLeft;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isElement: function() { return /* binding */ isElement; },
/* harmony export */   isHTMLElement: function() { return /* binding */ isHTMLElement; },
/* harmony export */   isShadowRoot: function() { return /* binding */ isShadowRoot; }
/* harmony export */ });
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");


function isElement(node) {
  var OwnElement = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}

function isHTMLElement(node) {
  var OwnElement = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}

function isShadowRoot(node) {
  // IE 11 has no ShadowRoot
  if (typeof ShadowRoot === 'undefined') {
    return false;
  }

  var OwnElement = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}



/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ isLayoutViewport; }
/* harmony export */ });
/* harmony import */ var _utils_userAgent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/userAgent.js */ "./node_modules/@popperjs/core/lib/utils/userAgent.js");

function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test((0,_utils_userAgent_js__WEBPACK_IMPORTED_MODULE_0__["default"])());
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ isScrollParent; }
/* harmony export */ });
/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");

function isScrollParent(element) {
  // Firefox wants us to check `-x` and `-y` variations as well
  var _getComputedStyle = (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element),
      overflow = _getComputedStyle.overflow,
      overflowX = _getComputedStyle.overflowX,
      overflowY = _getComputedStyle.overflowY;

  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ isTableElement; }
/* harmony export */ });
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");

function isTableElement(element) {
  return ['table', 'td', 'th'].indexOf((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element)) >= 0;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js":
/*!************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ listScrollParents; }
/* harmony export */ });
/* harmony import */ var _getScrollParent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getScrollParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js");
/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getParentNode.js */ "./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js");
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _isScrollParent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isScrollParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js");




/*
given a DOM element, return the list of all scroll parents, up the list of ancesors
until we get to the top window object. This list is what we attach scroll listeners
to, because if any of these parent elements scroll, we'll need to re-calculate the
reference element's position.
*/

function listScrollParents(element, list) {
  var _element$ownerDocumen;

  if (list === void 0) {
    list = [];
  }

  var scrollParent = (0,_getScrollParent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_1__["default"])(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], (0,_isScrollParent_js__WEBPACK_IMPORTED_MODULE_2__["default"])(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
  updatedList.concat(listScrollParents((0,_getParentNode_js__WEBPACK_IMPORTED_MODULE_3__["default"])(target)));
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/enums.js":
/*!**************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/enums.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   afterMain: function() { return /* binding */ afterMain; },
/* harmony export */   afterRead: function() { return /* binding */ afterRead; },
/* harmony export */   afterWrite: function() { return /* binding */ afterWrite; },
/* harmony export */   auto: function() { return /* binding */ auto; },
/* harmony export */   basePlacements: function() { return /* binding */ basePlacements; },
/* harmony export */   beforeMain: function() { return /* binding */ beforeMain; },
/* harmony export */   beforeRead: function() { return /* binding */ beforeRead; },
/* harmony export */   beforeWrite: function() { return /* binding */ beforeWrite; },
/* harmony export */   bottom: function() { return /* binding */ bottom; },
/* harmony export */   clippingParents: function() { return /* binding */ clippingParents; },
/* harmony export */   end: function() { return /* binding */ end; },
/* harmony export */   left: function() { return /* binding */ left; },
/* harmony export */   main: function() { return /* binding */ main; },
/* harmony export */   modifierPhases: function() { return /* binding */ modifierPhases; },
/* harmony export */   placements: function() { return /* binding */ placements; },
/* harmony export */   popper: function() { return /* binding */ popper; },
/* harmony export */   read: function() { return /* binding */ read; },
/* harmony export */   reference: function() { return /* binding */ reference; },
/* harmony export */   right: function() { return /* binding */ right; },
/* harmony export */   start: function() { return /* binding */ start; },
/* harmony export */   top: function() { return /* binding */ top; },
/* harmony export */   variationPlacements: function() { return /* binding */ variationPlacements; },
/* harmony export */   viewport: function() { return /* binding */ viewport; },
/* harmony export */   write: function() { return /* binding */ write; }
/* harmony export */ });
var top = 'top';
var bottom = 'bottom';
var right = 'right';
var left = 'left';
var auto = 'auto';
var basePlacements = [top, bottom, right, left];
var start = 'start';
var end = 'end';
var clippingParents = 'clippingParents';
var viewport = 'viewport';
var popper = 'popper';
var reference = 'reference';
var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []); // modifiers that need to read the DOM

var beforeRead = 'beforeRead';
var read = 'read';
var afterRead = 'afterRead'; // pure-logic modifiers

var beforeMain = 'beforeMain';
var main = 'main';
var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

var beforeWrite = 'beforeWrite';
var write = 'write';
var afterWrite = 'afterWrite';
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/index.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   afterMain: function() { return /* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.afterMain; },
/* harmony export */   afterRead: function() { return /* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.afterRead; },
/* harmony export */   afterWrite: function() { return /* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.afterWrite; },
/* harmony export */   applyStyles: function() { return /* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__.applyStyles; },
/* harmony export */   arrow: function() { return /* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__.arrow; },
/* harmony export */   auto: function() { return /* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.auto; },
/* harmony export */   basePlacements: function() { return /* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.basePlacements; },
/* harmony export */   beforeMain: function() { return /* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.beforeMain; },
/* harmony export */   beforeRead: function() { return /* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.beforeRead; },
/* harmony export */   beforeWrite: function() { return /* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.beforeWrite; },
/* harmony export */   bottom: function() { return /* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.bottom; },
/* harmony export */   clippingParents: function() { return /* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.clippingParents; },
/* harmony export */   computeStyles: function() { return /* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__.computeStyles; },
/* harmony export */   createPopper: function() { return /* reexport safe */ _popper_js__WEBPACK_IMPORTED_MODULE_4__.createPopper; },
/* harmony export */   createPopperBase: function() { return /* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_2__.createPopper; },
/* harmony export */   createPopperLite: function() { return /* reexport safe */ _popper_lite_js__WEBPACK_IMPORTED_MODULE_5__.createPopper; },
/* harmony export */   detectOverflow: function() { return /* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_3__["default"]; },
/* harmony export */   end: function() { return /* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.end; },
/* harmony export */   eventListeners: function() { return /* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__.eventListeners; },
/* harmony export */   flip: function() { return /* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__.flip; },
/* harmony export */   hide: function() { return /* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__.hide; },
/* harmony export */   left: function() { return /* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.left; },
/* harmony export */   main: function() { return /* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.main; },
/* harmony export */   modifierPhases: function() { return /* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.modifierPhases; },
/* harmony export */   offset: function() { return /* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__.offset; },
/* harmony export */   placements: function() { return /* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.placements; },
/* harmony export */   popper: function() { return /* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper; },
/* harmony export */   popperGenerator: function() { return /* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_2__.popperGenerator; },
/* harmony export */   popperOffsets: function() { return /* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__.popperOffsets; },
/* harmony export */   preventOverflow: function() { return /* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__.preventOverflow; },
/* harmony export */   read: function() { return /* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.read; },
/* harmony export */   reference: function() { return /* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.reference; },
/* harmony export */   right: function() { return /* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.right; },
/* harmony export */   start: function() { return /* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.start; },
/* harmony export */   top: function() { return /* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.top; },
/* harmony export */   variationPlacements: function() { return /* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.variationPlacements; },
/* harmony export */   viewport: function() { return /* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.viewport; },
/* harmony export */   write: function() { return /* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.write; }
/* harmony export */ });
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modifiers/index.js */ "./node_modules/@popperjs/core/lib/modifiers/index.js");
/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./createPopper.js */ "./node_modules/@popperjs/core/lib/createPopper.js");
/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./createPopper.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _popper_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./popper.js */ "./node_modules/@popperjs/core/lib/popper.js");
/* harmony import */ var _popper_lite_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./popper-lite.js */ "./node_modules/@popperjs/core/lib/popper-lite.js");

 // eslint-disable-next-line import/no-unused-modules

 // eslint-disable-next-line import/no-unused-modules

 // eslint-disable-next-line import/no-unused-modules



/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/applyStyles.js":
/*!******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/applyStyles.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _dom_utils_getNodeName_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom-utils/getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dom-utils/instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");

 // This modifier takes the styles prepared by the `computeStyles` modifier
// and applies them to the HTMLElements such as popper and arrow

function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function (name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name]; // arrow is optional + virtual elements

    if (!(0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) || !(0,_dom_utils_getNodeName_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element)) {
      return;
    } // Flow doesn't support to extend this property, but it's the most
    // effective way to apply styles to an HTMLElement
    // $FlowFixMe[cannot-write]


    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function (name) {
      var value = attributes[name];

      if (value === false) {
        element.removeAttribute(name);
      } else {
        element.setAttribute(name, value === true ? '' : value);
      }
    });
  });
}

function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: '0',
      top: '0',
      margin: '0'
    },
    arrow: {
      position: 'absolute'
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;

  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }

  return function () {
    Object.keys(state.elements).forEach(function (name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

      var style = styleProperties.reduce(function (style, property) {
        style[property] = '';
        return style;
      }, {}); // arrow is optional + virtual elements

      if (!(0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) || !(0,_dom_utils_getNodeName_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element)) {
        return;
      }

      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function (attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'applyStyles',
  enabled: true,
  phase: 'write',
  fn: applyStyles,
  effect: effect,
  requires: ['computeStyles']
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/arrow.js":
/*!************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/arrow.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../dom-utils/getLayoutRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js");
/* harmony import */ var _dom_utils_contains_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../dom-utils/contains.js */ "./node_modules/@popperjs/core/lib/dom-utils/contains.js");
/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dom-utils/getOffsetParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");
/* harmony import */ var _utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/getMainAxisFromPlacement.js */ "./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js");
/* harmony import */ var _utils_within_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/within.js */ "./node_modules/@popperjs/core/lib/utils/within.js");
/* harmony import */ var _utils_mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/mergePaddingObject.js */ "./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js");
/* harmony import */ var _utils_expandToHashMap_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/expandToHashMap.js */ "./node_modules/@popperjs/core/lib/utils/expandToHashMap.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");








 // eslint-disable-next-line import/no-unused-modules

var toPaddingObject = function toPaddingObject(padding, state) {
  padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return (0,_utils_mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(typeof padding !== 'number' ? padding : (0,_utils_expandToHashMap_js__WEBPACK_IMPORTED_MODULE_1__["default"])(padding, _enums_js__WEBPACK_IMPORTED_MODULE_2__.basePlacements));
};

function arrow(_ref) {
  var _state$modifiersData$;

  var state = _ref.state,
      name = _ref.name,
      options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets = state.modifiersData.popperOffsets;
  var basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(state.placement);
  var axis = (0,_utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_4__["default"])(basePlacement);
  var isVertical = [_enums_js__WEBPACK_IMPORTED_MODULE_2__.left, _enums_js__WEBPACK_IMPORTED_MODULE_2__.right].indexOf(basePlacement) >= 0;
  var len = isVertical ? 'height' : 'width';

  if (!arrowElement || !popperOffsets) {
    return;
  }

  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = (0,_dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_5__["default"])(arrowElement);
  var minProp = axis === 'y' ? _enums_js__WEBPACK_IMPORTED_MODULE_2__.top : _enums_js__WEBPACK_IMPORTED_MODULE_2__.left;
  var maxProp = axis === 'y' ? _enums_js__WEBPACK_IMPORTED_MODULE_2__.bottom : _enums_js__WEBPACK_IMPORTED_MODULE_2__.right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
  var startDiff = popperOffsets[axis] - state.rects.reference[axis];
  var arrowOffsetParent = (0,_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_6__["default"])(arrowElement);
  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
  // outside of the popper bounds

  var min = paddingObject[minProp];
  var max = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset = (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_7__.within)(min, center, max); // Prevents breaking syntax highlighting...

  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
}

function effect(_ref2) {
  var state = _ref2.state,
      options = _ref2.options;
  var _options$element = options.element,
      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;

  if (arrowElement == null) {
    return;
  } // CSS selector


  if (typeof arrowElement === 'string') {
    arrowElement = state.elements.popper.querySelector(arrowElement);

    if (!arrowElement) {
      return;
    }
  }

  if (!(0,_dom_utils_contains_js__WEBPACK_IMPORTED_MODULE_8__["default"])(state.elements.popper, arrowElement)) {
    return;
  }

  state.elements.arrow = arrowElement;
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'arrow',
  enabled: true,
  phase: 'main',
  fn: arrow,
  effect: effect,
  requires: ['popperOffsets'],
  requiresIfExists: ['preventOverflow']
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/computeStyles.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/computeStyles.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mapToStyles: function() { return /* binding */ mapToStyles; }
/* harmony export */ });
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom-utils/getOffsetParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");
/* harmony import */ var _dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom-utils/getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../dom-utils/getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _dom_utils_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../dom-utils/getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _utils_getVariation_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/getVariation.js */ "./node_modules/@popperjs/core/lib/utils/getVariation.js");
/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");







 // eslint-disable-next-line import/no-unused-modules

var unsetSides = {
  top: 'auto',
  right: 'auto',
  bottom: 'auto',
  left: 'auto'
}; // Round the offsets to the nearest suitable subpixel based on the DPR.
// Zooming can change the DPR, but it seems to report a value that will
// cleanly divide the values into the appropriate subpixels.

function roundOffsetsByDPR(_ref, win) {
  var x = _ref.x,
      y = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_0__.round)(x * dpr) / dpr || 0,
    y: (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_0__.round)(y * dpr) / dpr || 0
  };
}

function mapToStyles(_ref2) {
  var _Object$assign2;

  var popper = _ref2.popper,
      popperRect = _ref2.popperRect,
      placement = _ref2.placement,
      variation = _ref2.variation,
      offsets = _ref2.offsets,
      position = _ref2.position,
      gpuAcceleration = _ref2.gpuAcceleration,
      adaptive = _ref2.adaptive,
      roundOffsets = _ref2.roundOffsets,
      isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x,
      x = _offsets$x === void 0 ? 0 : _offsets$x,
      _offsets$y = offsets.y,
      y = _offsets$y === void 0 ? 0 : _offsets$y;

  var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({
    x: x,
    y: y
  }) : {
    x: x,
    y: y
  };

  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty('x');
  var hasY = offsets.hasOwnProperty('y');
  var sideX = _enums_js__WEBPACK_IMPORTED_MODULE_1__.left;
  var sideY = _enums_js__WEBPACK_IMPORTED_MODULE_1__.top;
  var win = window;

  if (adaptive) {
    var offsetParent = (0,_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_2__["default"])(popper);
    var heightProp = 'clientHeight';
    var widthProp = 'clientWidth';

    if (offsetParent === (0,_dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_3__["default"])(popper)) {
      offsetParent = (0,_dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_4__["default"])(popper);

      if ((0,_dom_utils_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_5__["default"])(offsetParent).position !== 'static' && position === 'absolute') {
        heightProp = 'scrollHeight';
        widthProp = 'scrollWidth';
      }
    } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it


    offsetParent = offsetParent;

    if (placement === _enums_js__WEBPACK_IMPORTED_MODULE_1__.top || (placement === _enums_js__WEBPACK_IMPORTED_MODULE_1__.left || placement === _enums_js__WEBPACK_IMPORTED_MODULE_1__.right) && variation === _enums_js__WEBPACK_IMPORTED_MODULE_1__.end) {
      sideY = _enums_js__WEBPACK_IMPORTED_MODULE_1__.bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : // $FlowFixMe[prop-missing]
      offsetParent[heightProp];
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }

    if (placement === _enums_js__WEBPACK_IMPORTED_MODULE_1__.left || (placement === _enums_js__WEBPACK_IMPORTED_MODULE_1__.top || placement === _enums_js__WEBPACK_IMPORTED_MODULE_1__.bottom) && variation === _enums_js__WEBPACK_IMPORTED_MODULE_1__.end) {
      sideX = _enums_js__WEBPACK_IMPORTED_MODULE_1__.right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : // $FlowFixMe[prop-missing]
      offsetParent[widthProp];
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }

  var commonStyles = Object.assign({
    position: position
  }, adaptive && unsetSides);

  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x,
    y: y
  }, (0,_dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_3__["default"])(popper)) : {
    x: x,
    y: y
  };

  x = _ref4.x;
  y = _ref4.y;

  if (gpuAcceleration) {
    var _Object$assign;

    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }

  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
}

function computeStyles(_ref5) {
  var state = _ref5.state,
      options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration,
      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
      _options$adaptive = options.adaptive,
      adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
      _options$roundOffsets = options.roundOffsets,
      roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_6__["default"])(state.placement),
    variation: (0,_utils_getVariation_js__WEBPACK_IMPORTED_MODULE_7__["default"])(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration: gpuAcceleration,
    isFixed: state.options.strategy === 'fixed'
  };

  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive: adaptive,
      roundOffsets: roundOffsets
    })));
  }

  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: 'absolute',
      adaptive: false,
      roundOffsets: roundOffsets
    })));
  }

  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-placement': state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'computeStyles',
  enabled: true,
  phase: 'beforeWrite',
  fn: computeStyles,
  data: {}
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/eventListeners.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/eventListeners.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dom-utils/getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
 // eslint-disable-next-line import/no-unused-modules

var passive = {
  passive: true
};

function effect(_ref) {
  var state = _ref.state,
      instance = _ref.instance,
      options = _ref.options;
  var _options$scroll = options.scroll,
      scroll = _options$scroll === void 0 ? true : _options$scroll,
      _options$resize = options.resize,
      resize = _options$resize === void 0 ? true : _options$resize;
  var window = (0,_dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);

  if (scroll) {
    scrollParents.forEach(function (scrollParent) {
      scrollParent.addEventListener('scroll', instance.update, passive);
    });
  }

  if (resize) {
    window.addEventListener('resize', instance.update, passive);
  }

  return function () {
    if (scroll) {
      scrollParents.forEach(function (scrollParent) {
        scrollParent.removeEventListener('scroll', instance.update, passive);
      });
    }

    if (resize) {
      window.removeEventListener('resize', instance.update, passive);
    }
  };
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'eventListeners',
  enabled: true,
  phase: 'write',
  fn: function fn() {},
  effect: effect,
  data: {}
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/flip.js":
/*!***********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/flip.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/getOppositePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js");
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _utils_getOppositeVariationPlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/getOppositeVariationPlacement.js */ "./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js");
/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/detectOverflow.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _utils_computeAutoPlacement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/computeAutoPlacement.js */ "./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _utils_getVariation_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/getVariation.js */ "./node_modules/@popperjs/core/lib/utils/getVariation.js");






 // eslint-disable-next-line import/no-unused-modules

function getExpandedFallbackPlacements(placement) {
  if ((0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement) === _enums_js__WEBPACK_IMPORTED_MODULE_1__.auto) {
    return [];
  }

  var oppositePlacement = (0,_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(placement);
  return [(0,_utils_getOppositeVariationPlacement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(placement), oppositePlacement, (0,_utils_getOppositeVariationPlacement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(oppositePlacement)];
}

function flip(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;

  if (state.modifiersData[name]._skip) {
    return;
  }

  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
      specifiedFallbackPlacements = options.fallbackPlacements,
      padding = options.padding,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      _options$flipVariatio = options.flipVariations,
      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
      allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [(0,_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
    return acc.concat((0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement) === _enums_js__WEBPACK_IMPORTED_MODULE_1__.auto ? (0,_utils_computeAutoPlacement_js__WEBPACK_IMPORTED_MODULE_4__["default"])(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding,
      flipVariations: flipVariations,
      allowedAutoPlacements: allowedAutoPlacements
    }) : placement);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements[0];

  for (var i = 0; i < placements.length; i++) {
    var placement = placements[i];

    var _basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement);

    var isStartVariation = (0,_utils_getVariation_js__WEBPACK_IMPORTED_MODULE_5__["default"])(placement) === _enums_js__WEBPACK_IMPORTED_MODULE_1__.start;
    var isVertical = [_enums_js__WEBPACK_IMPORTED_MODULE_1__.top, _enums_js__WEBPACK_IMPORTED_MODULE_1__.bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? 'width' : 'height';
    var overflow = (0,_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_6__["default"])(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      altBoundary: altBoundary,
      padding: padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? _enums_js__WEBPACK_IMPORTED_MODULE_1__.right : _enums_js__WEBPACK_IMPORTED_MODULE_1__.left : isStartVariation ? _enums_js__WEBPACK_IMPORTED_MODULE_1__.bottom : _enums_js__WEBPACK_IMPORTED_MODULE_1__.top;

    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = (0,_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(mainVariationSide);
    }

    var altVariationSide = (0,_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(mainVariationSide);
    var checks = [];

    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }

    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }

    if (checks.every(function (check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }

    checksMap.set(placement, checks);
  }

  if (makeFallbackChecks) {
    // `2` may be desired in some cases – research later
    var numberOfChecks = flipVariations ? 3 : 1;

    var _loop = function _loop(_i) {
      var fittingPlacement = placements.find(function (placement) {
        var checks = checksMap.get(placement);

        if (checks) {
          return checks.slice(0, _i).every(function (check) {
            return check;
          });
        }
      });

      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };

    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);

      if (_ret === "break") break;
    }
  }

  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'flip',
  enabled: true,
  phase: 'main',
  fn: flip,
  requiresIfExists: ['offset'],
  data: {
    _skip: false
  }
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/hide.js":
/*!***********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/hide.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/detectOverflow.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");



function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }

  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}

function isAnySideFullyClipped(overflow) {
  return [_enums_js__WEBPACK_IMPORTED_MODULE_0__.top, _enums_js__WEBPACK_IMPORTED_MODULE_0__.right, _enums_js__WEBPACK_IMPORTED_MODULE_0__.bottom, _enums_js__WEBPACK_IMPORTED_MODULE_0__.left].some(function (side) {
    return overflow[side] >= 0;
  });
}

function hide(_ref) {
  var state = _ref.state,
      name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = (0,_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_1__["default"])(state, {
    elementContext: 'reference'
  });
  var popperAltOverflow = (0,_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_1__["default"])(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets: referenceClippingOffsets,
    popperEscapeOffsets: popperEscapeOffsets,
    isReferenceHidden: isReferenceHidden,
    hasPopperEscaped: hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-reference-hidden': isReferenceHidden,
    'data-popper-escaped': hasPopperEscaped
  });
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'hide',
  enabled: true,
  phase: 'main',
  requiresIfExists: ['preventOverflow'],
  fn: hide
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/index.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   applyStyles: function() { return /* reexport safe */ _applyStyles_js__WEBPACK_IMPORTED_MODULE_0__["default"]; },
/* harmony export */   arrow: function() { return /* reexport safe */ _arrow_js__WEBPACK_IMPORTED_MODULE_1__["default"]; },
/* harmony export */   computeStyles: function() { return /* reexport safe */ _computeStyles_js__WEBPACK_IMPORTED_MODULE_2__["default"]; },
/* harmony export */   eventListeners: function() { return /* reexport safe */ _eventListeners_js__WEBPACK_IMPORTED_MODULE_3__["default"]; },
/* harmony export */   flip: function() { return /* reexport safe */ _flip_js__WEBPACK_IMPORTED_MODULE_4__["default"]; },
/* harmony export */   hide: function() { return /* reexport safe */ _hide_js__WEBPACK_IMPORTED_MODULE_5__["default"]; },
/* harmony export */   offset: function() { return /* reexport safe */ _offset_js__WEBPACK_IMPORTED_MODULE_6__["default"]; },
/* harmony export */   popperOffsets: function() { return /* reexport safe */ _popperOffsets_js__WEBPACK_IMPORTED_MODULE_7__["default"]; },
/* harmony export */   preventOverflow: function() { return /* reexport safe */ _preventOverflow_js__WEBPACK_IMPORTED_MODULE_8__["default"]; }
/* harmony export */ });
/* harmony import */ var _applyStyles_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./applyStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/applyStyles.js");
/* harmony import */ var _arrow_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./arrow.js */ "./node_modules/@popperjs/core/lib/modifiers/arrow.js");
/* harmony import */ var _computeStyles_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./computeStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/computeStyles.js");
/* harmony import */ var _eventListeners_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./eventListeners.js */ "./node_modules/@popperjs/core/lib/modifiers/eventListeners.js");
/* harmony import */ var _flip_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./flip.js */ "./node_modules/@popperjs/core/lib/modifiers/flip.js");
/* harmony import */ var _hide_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./hide.js */ "./node_modules/@popperjs/core/lib/modifiers/hide.js");
/* harmony import */ var _offset_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./offset.js */ "./node_modules/@popperjs/core/lib/modifiers/offset.js");
/* harmony import */ var _popperOffsets_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./popperOffsets.js */ "./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js");
/* harmony import */ var _preventOverflow_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./preventOverflow.js */ "./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js");










/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/offset.js":
/*!*************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/offset.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   distanceAndSkiddingToXY: function() { return /* binding */ distanceAndSkiddingToXY; }
/* harmony export */ });
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");

 // eslint-disable-next-line import/no-unused-modules

function distanceAndSkiddingToXY(placement, rects, offset) {
  var basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement);
  var invertDistance = [_enums_js__WEBPACK_IMPORTED_MODULE_1__.left, _enums_js__WEBPACK_IMPORTED_MODULE_1__.top].indexOf(basePlacement) >= 0 ? -1 : 1;

  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
    placement: placement
  })) : offset,
      skidding = _ref[0],
      distance = _ref[1];

  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [_enums_js__WEBPACK_IMPORTED_MODULE_1__.left, _enums_js__WEBPACK_IMPORTED_MODULE_1__.right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}

function offset(_ref2) {
  var state = _ref2.state,
      options = _ref2.options,
      name = _ref2.name;
  var _options$offset = options.offset,
      offset = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = _enums_js__WEBPACK_IMPORTED_MODULE_1__.placements.reduce(function (acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement],
      x = _data$state$placement.x,
      y = _data$state$placement.y;

  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'offset',
  enabled: true,
  phase: 'main',
  requires: ['popperOffsets'],
  fn: offset
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_computeOffsets_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/computeOffsets.js */ "./node_modules/@popperjs/core/lib/utils/computeOffsets.js");


function popperOffsets(_ref) {
  var state = _ref.state,
      name = _ref.name;
  // Offsets are the actual position the popper needs to have to be
  // properly positioned near its reference element
  // This is the most basic placement, and will be adjusted by
  // the modifiers in the next step
  state.modifiersData[name] = (0,_utils_computeOffsets_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: 'absolute',
    placement: state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'popperOffsets',
  enabled: true,
  phase: 'read',
  fn: popperOffsets,
  data: {}
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/getMainAxisFromPlacement.js */ "./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js");
/* harmony import */ var _utils_getAltAxis_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/getAltAxis.js */ "./node_modules/@popperjs/core/lib/utils/getAltAxis.js");
/* harmony import */ var _utils_within_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/within.js */ "./node_modules/@popperjs/core/lib/utils/within.js");
/* harmony import */ var _dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dom-utils/getLayoutRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js");
/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../dom-utils/getOffsetParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");
/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/detectOverflow.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _utils_getVariation_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/getVariation.js */ "./node_modules/@popperjs/core/lib/utils/getVariation.js");
/* harmony import */ var _utils_getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/getFreshSideObject.js */ "./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js");
/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../utils/math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");












function preventOverflow(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;
  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      padding = options.padding,
      _options$tether = options.tether,
      tether = _options$tether === void 0 ? true : _options$tether,
      _options$tetherOffset = options.tetherOffset,
      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = (0,_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(state, {
    boundary: boundary,
    rootBoundary: rootBoundary,
    padding: padding,
    altBoundary: altBoundary
  });
  var basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(state.placement);
  var variation = (0,_utils_getVariation_js__WEBPACK_IMPORTED_MODULE_2__["default"])(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = (0,_utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(basePlacement);
  var altAxis = (0,_utils_getAltAxis_js__WEBPACK_IMPORTED_MODULE_4__["default"])(mainAxis);
  var popperOffsets = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };

  if (!popperOffsets) {
    return;
  }

  if (checkMainAxis) {
    var _offsetModifierState$;

    var mainSide = mainAxis === 'y' ? _enums_js__WEBPACK_IMPORTED_MODULE_5__.top : _enums_js__WEBPACK_IMPORTED_MODULE_5__.left;
    var altSide = mainAxis === 'y' ? _enums_js__WEBPACK_IMPORTED_MODULE_5__.bottom : _enums_js__WEBPACK_IMPORTED_MODULE_5__.right;
    var len = mainAxis === 'y' ? 'height' : 'width';
    var offset = popperOffsets[mainAxis];
    var min = offset + overflow[mainSide];
    var max = offset - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === _enums_js__WEBPACK_IMPORTED_MODULE_5__.start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === _enums_js__WEBPACK_IMPORTED_MODULE_5__.start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
    // outside the reference bounds

    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? (0,_dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_6__["default"])(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : (0,_utils_getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_7__["default"])();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
    // to include its full size in the calculation. If the reference is small
    // and near the edge of a boundary, the popper can overflow even if the
    // reference is not overflowing as well (e.g. virtual elements with no
    // width or height)

    var arrowLen = (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_8__.within)(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && (0,_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_9__["default"])(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset + maxOffset - offsetModifierValue;
    var preventedOffset = (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_8__.within)(tether ? (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_10__.min)(min, tetherMin) : min, offset, tether ? (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_10__.max)(max, tetherMax) : max);
    popperOffsets[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset;
  }

  if (checkAltAxis) {
    var _offsetModifierState$2;

    var _mainSide = mainAxis === 'x' ? _enums_js__WEBPACK_IMPORTED_MODULE_5__.top : _enums_js__WEBPACK_IMPORTED_MODULE_5__.left;

    var _altSide = mainAxis === 'x' ? _enums_js__WEBPACK_IMPORTED_MODULE_5__.bottom : _enums_js__WEBPACK_IMPORTED_MODULE_5__.right;

    var _offset = popperOffsets[altAxis];

    var _len = altAxis === 'y' ? 'height' : 'width';

    var _min = _offset + overflow[_mainSide];

    var _max = _offset - overflow[_altSide];

    var isOriginSide = [_enums_js__WEBPACK_IMPORTED_MODULE_5__.top, _enums_js__WEBPACK_IMPORTED_MODULE_5__.left].indexOf(basePlacement) !== -1;

    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;

    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;

    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;

    var _preventedOffset = tether && isOriginSide ? (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_8__.withinMaxClamp)(_tetherMin, _offset, _tetherMax) : (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_8__.within)(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);

    popperOffsets[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'preventOverflow',
  enabled: true,
  phase: 'main',
  fn: preventOverflow,
  requiresIfExists: ['offset']
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/popper-lite.js":
/*!********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/popper-lite.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createPopper: function() { return /* binding */ createPopper; },
/* harmony export */   defaultModifiers: function() { return /* binding */ defaultModifiers; },
/* harmony export */   detectOverflow: function() { return /* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_5__["default"]; },
/* harmony export */   popperGenerator: function() { return /* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_4__.popperGenerator; }
/* harmony export */ });
/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./createPopper.js */ "./node_modules/@popperjs/core/lib/createPopper.js");
/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./createPopper.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modifiers/eventListeners.js */ "./node_modules/@popperjs/core/lib/modifiers/eventListeners.js");
/* harmony import */ var _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modifiers/popperOffsets.js */ "./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js");
/* harmony import */ var _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modifiers/computeStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/computeStyles.js");
/* harmony import */ var _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modifiers/applyStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/applyStyles.js");





var defaultModifiers = [_modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_0__["default"], _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_1__["default"], _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_2__["default"], _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_3__["default"]];
var createPopper = /*#__PURE__*/(0,_createPopper_js__WEBPACK_IMPORTED_MODULE_4__.popperGenerator)({
  defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules



/***/ }),

/***/ "./node_modules/@popperjs/core/lib/popper.js":
/*!***************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/popper.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   applyStyles: function() { return /* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.applyStyles; },
/* harmony export */   arrow: function() { return /* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.arrow; },
/* harmony export */   computeStyles: function() { return /* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.computeStyles; },
/* harmony export */   createPopper: function() { return /* binding */ createPopper; },
/* harmony export */   createPopperLite: function() { return /* reexport safe */ _popper_lite_js__WEBPACK_IMPORTED_MODULE_11__.createPopper; },
/* harmony export */   defaultModifiers: function() { return /* binding */ defaultModifiers; },
/* harmony export */   detectOverflow: function() { return /* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_10__["default"]; },
/* harmony export */   eventListeners: function() { return /* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.eventListeners; },
/* harmony export */   flip: function() { return /* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.flip; },
/* harmony export */   hide: function() { return /* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.hide; },
/* harmony export */   offset: function() { return /* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.offset; },
/* harmony export */   popperGenerator: function() { return /* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_9__.popperGenerator; },
/* harmony export */   popperOffsets: function() { return /* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.popperOffsets; },
/* harmony export */   preventOverflow: function() { return /* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.preventOverflow; }
/* harmony export */ });
/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./createPopper.js */ "./node_modules/@popperjs/core/lib/createPopper.js");
/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./createPopper.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modifiers/eventListeners.js */ "./node_modules/@popperjs/core/lib/modifiers/eventListeners.js");
/* harmony import */ var _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modifiers/popperOffsets.js */ "./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js");
/* harmony import */ var _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modifiers/computeStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/computeStyles.js");
/* harmony import */ var _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modifiers/applyStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/applyStyles.js");
/* harmony import */ var _modifiers_offset_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modifiers/offset.js */ "./node_modules/@popperjs/core/lib/modifiers/offset.js");
/* harmony import */ var _modifiers_flip_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./modifiers/flip.js */ "./node_modules/@popperjs/core/lib/modifiers/flip.js");
/* harmony import */ var _modifiers_preventOverflow_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./modifiers/preventOverflow.js */ "./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js");
/* harmony import */ var _modifiers_arrow_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./modifiers/arrow.js */ "./node_modules/@popperjs/core/lib/modifiers/arrow.js");
/* harmony import */ var _modifiers_hide_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./modifiers/hide.js */ "./node_modules/@popperjs/core/lib/modifiers/hide.js");
/* harmony import */ var _popper_lite_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./popper-lite.js */ "./node_modules/@popperjs/core/lib/popper-lite.js");
/* harmony import */ var _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./modifiers/index.js */ "./node_modules/@popperjs/core/lib/modifiers/index.js");










var defaultModifiers = [_modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_0__["default"], _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_1__["default"], _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_2__["default"], _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_3__["default"], _modifiers_offset_js__WEBPACK_IMPORTED_MODULE_4__["default"], _modifiers_flip_js__WEBPACK_IMPORTED_MODULE_5__["default"], _modifiers_preventOverflow_js__WEBPACK_IMPORTED_MODULE_6__["default"], _modifiers_arrow_js__WEBPACK_IMPORTED_MODULE_7__["default"], _modifiers_hide_js__WEBPACK_IMPORTED_MODULE_8__["default"]];
var createPopper = /*#__PURE__*/(0,_createPopper_js__WEBPACK_IMPORTED_MODULE_9__.popperGenerator)({
  defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules

 // eslint-disable-next-line import/no-unused-modules

 // eslint-disable-next-line import/no-unused-modules



/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ computeAutoPlacement; }
/* harmony export */ });
/* harmony import */ var _getVariation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getVariation.js */ "./node_modules/@popperjs/core/lib/utils/getVariation.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _detectOverflow_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./detectOverflow.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _getBasePlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");




function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      placement = _options.placement,
      boundary = _options.boundary,
      rootBoundary = _options.rootBoundary,
      padding = _options.padding,
      flipVariations = _options.flipVariations,
      _options$allowedAutoP = _options.allowedAutoPlacements,
      allowedAutoPlacements = _options$allowedAutoP === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.placements : _options$allowedAutoP;
  var variation = (0,_getVariation_js__WEBPACK_IMPORTED_MODULE_1__["default"])(placement);
  var placements = variation ? flipVariations ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.variationPlacements : _enums_js__WEBPACK_IMPORTED_MODULE_0__.variationPlacements.filter(function (placement) {
    return (0,_getVariation_js__WEBPACK_IMPORTED_MODULE_1__["default"])(placement) === variation;
  }) : _enums_js__WEBPACK_IMPORTED_MODULE_0__.basePlacements;
  var allowedPlacements = placements.filter(function (placement) {
    return allowedAutoPlacements.indexOf(placement) >= 0;
  });

  if (allowedPlacements.length === 0) {
    allowedPlacements = placements;
  } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...


  var overflows = allowedPlacements.reduce(function (acc, placement) {
    acc[placement] = (0,_detectOverflow_js__WEBPACK_IMPORTED_MODULE_2__["default"])(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding
    })[(0,_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(placement)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function (a, b) {
    return overflows[a] - overflows[b];
  });
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/computeOffsets.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/computeOffsets.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ computeOffsets; }
/* harmony export */ });
/* harmony import */ var _getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _getVariation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getVariation.js */ "./node_modules/@popperjs/core/lib/utils/getVariation.js");
/* harmony import */ var _getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getMainAxisFromPlacement.js */ "./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");




function computeOffsets(_ref) {
  var reference = _ref.reference,
      element = _ref.element,
      placement = _ref.placement;
  var basePlacement = placement ? (0,_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement) : null;
  var variation = placement ? (0,_getVariation_js__WEBPACK_IMPORTED_MODULE_1__["default"])(placement) : null;
  var commonX = reference.x + reference.width / 2 - element.width / 2;
  var commonY = reference.y + reference.height / 2 - element.height / 2;
  var offsets;

  switch (basePlacement) {
    case _enums_js__WEBPACK_IMPORTED_MODULE_2__.top:
      offsets = {
        x: commonX,
        y: reference.y - element.height
      };
      break;

    case _enums_js__WEBPACK_IMPORTED_MODULE_2__.bottom:
      offsets = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;

    case _enums_js__WEBPACK_IMPORTED_MODULE_2__.right:
      offsets = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;

    case _enums_js__WEBPACK_IMPORTED_MODULE_2__.left:
      offsets = {
        x: reference.x - element.width,
        y: commonY
      };
      break;

    default:
      offsets = {
        x: reference.x,
        y: reference.y
      };
  }

  var mainAxis = basePlacement ? (0,_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(basePlacement) : null;

  if (mainAxis != null) {
    var len = mainAxis === 'y' ? 'height' : 'width';

    switch (variation) {
      case _enums_js__WEBPACK_IMPORTED_MODULE_2__.start:
        offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
        break;

      case _enums_js__WEBPACK_IMPORTED_MODULE_2__.end:
        offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
        break;

      default:
    }
  }

  return offsets;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/debounce.js":
/*!***********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/debounce.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ debounce; }
/* harmony export */ });
function debounce(fn) {
  var pending;
  return function () {
    if (!pending) {
      pending = new Promise(function (resolve) {
        Promise.resolve().then(function () {
          pending = undefined;
          resolve(fn());
        });
      });
    }

    return pending;
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/detectOverflow.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ detectOverflow; }
/* harmony export */ });
/* harmony import */ var _dom_utils_getClippingRect_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom-utils/getClippingRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js");
/* harmony import */ var _dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../dom-utils/getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _dom_utils_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dom-utils/getBoundingClientRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");
/* harmony import */ var _computeOffsets_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./computeOffsets.js */ "./node_modules/@popperjs/core/lib/utils/computeOffsets.js");
/* harmony import */ var _rectToClientRect_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./rectToClientRect.js */ "./node_modules/@popperjs/core/lib/utils/rectToClientRect.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../dom-utils/instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mergePaddingObject.js */ "./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js");
/* harmony import */ var _expandToHashMap_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./expandToHashMap.js */ "./node_modules/@popperjs/core/lib/utils/expandToHashMap.js");








 // eslint-disable-next-line import/no-unused-modules

function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      _options$placement = _options.placement,
      placement = _options$placement === void 0 ? state.placement : _options$placement,
      _options$strategy = _options.strategy,
      strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,
      _options$boundary = _options.boundary,
      boundary = _options$boundary === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.clippingParents : _options$boundary,
      _options$rootBoundary = _options.rootBoundary,
      rootBoundary = _options$rootBoundary === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.viewport : _options$rootBoundary,
      _options$elementConte = _options.elementContext,
      elementContext = _options$elementConte === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper : _options$elementConte,
      _options$altBoundary = _options.altBoundary,
      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
      _options$padding = _options.padding,
      padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = (0,_mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_1__["default"])(typeof padding !== 'number' ? padding : (0,_expandToHashMap_js__WEBPACK_IMPORTED_MODULE_2__["default"])(padding, _enums_js__WEBPACK_IMPORTED_MODULE_0__.basePlacements));
  var altContext = elementContext === _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.reference : _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = (0,_dom_utils_getClippingRect_js__WEBPACK_IMPORTED_MODULE_3__["default"])((0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_4__.isElement)(element) ? element : element.contextElement || (0,_dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_5__["default"])(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = (0,_dom_utils_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_6__["default"])(state.elements.reference);
  var popperOffsets = (0,_computeOffsets_js__WEBPACK_IMPORTED_MODULE_7__["default"])({
    reference: referenceClientRect,
    element: popperRect,
    strategy: 'absolute',
    placement: placement
  });
  var popperClientRect = (0,_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_8__["default"])(Object.assign({}, popperRect, popperOffsets));
  var elementClientRect = elementContext === _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
  // 0 or negative = within the clipping rect

  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

  if (elementContext === _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper && offsetData) {
    var offset = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function (key) {
      var multiply = [_enums_js__WEBPACK_IMPORTED_MODULE_0__.right, _enums_js__WEBPACK_IMPORTED_MODULE_0__.bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [_enums_js__WEBPACK_IMPORTED_MODULE_0__.top, _enums_js__WEBPACK_IMPORTED_MODULE_0__.bottom].indexOf(key) >= 0 ? 'y' : 'x';
      overflowOffsets[key] += offset[axis] * multiply;
    });
  }

  return overflowOffsets;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/expandToHashMap.js":
/*!******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/expandToHashMap.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ expandToHashMap; }
/* harmony export */ });
function expandToHashMap(value, keys) {
  return keys.reduce(function (hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getAltAxis.js":
/*!*************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getAltAxis.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getAltAxis; }
/* harmony export */ });
function getAltAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getBasePlacement.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getBasePlacement; }
/* harmony export */ });

function getBasePlacement(placement) {
  return placement.split('-')[0];
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getFreshSideObject; }
/* harmony export */ });
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getMainAxisFromPlacement; }
/* harmony export */ });
function getMainAxisFromPlacement(placement) {
  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getOppositePlacement; }
/* harmony export */ });
var hash = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getOppositeVariationPlacement; }
/* harmony export */ });
var hash = {
  start: 'end',
  end: 'start'
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function (matched) {
    return hash[matched];
  });
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getVariation.js":
/*!***************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getVariation.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getVariation; }
/* harmony export */ });
function getVariation(placement) {
  return placement.split('-')[1];
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/math.js":
/*!*******************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/math.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   max: function() { return /* binding */ max; },
/* harmony export */   min: function() { return /* binding */ min; },
/* harmony export */   round: function() { return /* binding */ round; }
/* harmony export */ });
var max = Math.max;
var min = Math.min;
var round = Math.round;

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/mergeByName.js":
/*!**************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/mergeByName.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ mergeByName; }
/* harmony export */ });
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function (merged, current) {
    var existing = merged[current.name];
    merged[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged;
  }, {}); // IE11 does not support Object.values

  return Object.keys(merged).map(function (key) {
    return merged[key];
  });
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ mergePaddingObject; }
/* harmony export */ });
/* harmony import */ var _getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getFreshSideObject.js */ "./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js");

function mergePaddingObject(paddingObject) {
  return Object.assign({}, (0,_getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(), paddingObject);
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/orderModifiers.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/orderModifiers.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ orderModifiers; }
/* harmony export */ });
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
 // source: https://stackoverflow.com/questions/49875255

function order(modifiers) {
  var map = new Map();
  var visited = new Set();
  var result = [];
  modifiers.forEach(function (modifier) {
    map.set(modifier.name, modifier);
  }); // On visiting object, check for its dependencies and visit them recursively

  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function (dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);

        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }

  modifiers.forEach(function (modifier) {
    if (!visited.has(modifier.name)) {
      // check for visited object
      sort(modifier);
    }
  });
  return result;
}

function orderModifiers(modifiers) {
  // order based on dependencies
  var orderedModifiers = order(modifiers); // order based on phase

  return _enums_js__WEBPACK_IMPORTED_MODULE_0__.modifierPhases.reduce(function (acc, phase) {
    return acc.concat(orderedModifiers.filter(function (modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/rectToClientRect.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/rectToClientRect.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ rectToClientRect; }
/* harmony export */ });
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/userAgent.js":
/*!************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/userAgent.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getUAString; }
/* harmony export */ });
function getUAString() {
  var uaData = navigator.userAgentData;

  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function (item) {
      return item.brand + "/" + item.version;
    }).join(' ');
  }

  return navigator.userAgent;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/within.js":
/*!*********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/within.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   within: function() { return /* binding */ within; },
/* harmony export */   withinMaxClamp: function() { return /* binding */ withinMaxClamp; }
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");

function within(min, value, max) {
  return (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.max)(min, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(value, max));
}
function withinMaxClamp(min, value, max) {
  var v = within(min, value, max);
  return v > max ? max : v;
}

/***/ }),

/***/ "./assets/app.js":
/*!***********************!*\
  !*** ./assets/app.js ***!
  \***********************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(/*! ./sass/_app.scss */ "./assets/sass/_app.scss");

// ------ Kimai itself ------
__webpack_require__(/*! ./js/KimaiWebLoader.js */ "./assets/js/KimaiWebLoader.js");
__webpack_require__.g.KimaiPaginatedBoxWidget = (__webpack_require__(/*! ./js/widgets/KimaiPaginatedBoxWidget */ "./assets/js/widgets/KimaiPaginatedBoxWidget.js")["default"]);
__webpack_require__.g.KimaiReloadPageWidget = (__webpack_require__(/*! ./js/widgets/KimaiReloadPageWidget */ "./assets/js/widgets/KimaiReloadPageWidget.js")["default"]);
__webpack_require__.g.KimaiColor = (__webpack_require__(/*! ./js/widgets/KimaiColor */ "./assets/js/widgets/KimaiColor.js")["default"]);
__webpack_require__.g.KimaiStorage = (__webpack_require__(/*! ./js/widgets/KimaiStorage */ "./assets/js/widgets/KimaiStorage.js")["default"]);

/***/ }),

/***/ "./assets/js/KimaiConfiguration.js":
/*!*****************************************!*\
  !*** ./assets/js/KimaiConfiguration.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ KimaiConfiguration; }
/* harmony export */ });
/*
 * This file is part of the Kimai time-tracking app.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/*!
 * [KIMAI] KimaiConfiguration: handling all configuration and runtime settings
 */

class KimaiConfiguration {
  constructor(configurations) {
    this._configurations = configurations;
  }
  get(name) {
    return this._configurations[name];
  }
  has(name) {
    return name in this._configurations;
  }
  isRTL() {
    return this.get('direction') === 'rtl';
  }
  getLanguage() {
    return this.get('locale').replace('_', '-');
  }
  is24Hours() {
    return !!this.get('twentyFourHours');
  }

  /**
   * @param {boolean} iso
   * @return {number}
   */
  getFirstDayOfWeek() {
    let iso = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    if (iso === undefined) {
      iso = true;
    }
    let config = this.get('first_dow_iso');
    if (!iso) {
      config = config % 7;
    }
    return config;
  }
}

/***/ }),

/***/ "./assets/js/KimaiContainer.js":
/*!*************************************!*\
  !*** ./assets/js/KimaiContainer.js ***!
  \*************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ KimaiContainer; }
/* harmony export */ });
/* harmony import */ var _KimaiConfiguration__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./KimaiConfiguration */ "./assets/js/KimaiConfiguration.js");
/* harmony import */ var _KimaiTranslation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./KimaiTranslation */ "./assets/js/KimaiTranslation.js");
/* harmony import */ var _KimaiPlugin__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./KimaiPlugin */ "./assets/js/KimaiPlugin.js");
/*
 * This file is part of the Kimai time-tracking app.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/*!
 * [KIMAI] KimaiContainer
 *
 * ServiceContainer for Kimai
 */




class KimaiContainer {
  /**
   * Create a new Container with the given configurations and translations.
   *
   * @param {KimaiConfiguration} configuration
   * @param {KimaiTranslation} translation
   */
  constructor(configuration, translation) {
    if (!(configuration instanceof _KimaiConfiguration__WEBPACK_IMPORTED_MODULE_0__["default"])) {
      throw new Error('Configuration needs to a KimaiConfiguration instance');
    }
    this._configuration = configuration;
    if (!(translation instanceof _KimaiTranslation__WEBPACK_IMPORTED_MODULE_1__["default"])) {
      throw new Error('Configuration needs to a KimaiTranslation instance');
    }
    this._translation = translation;
    this._plugins = [];
  }

  /**
   * Register a new Plugin.
   *
   * @param {KimaiPlugin} plugin
   * @returns {KimaiPlugin}
   */
  registerPlugin(plugin) {
    if (!(plugin instanceof _KimaiPlugin__WEBPACK_IMPORTED_MODULE_2__["default"])) {
      throw new Error('Invalid plugin given, needs to be a KimaiPlugin instance');
    }
    plugin.setContainer(this);
    this._plugins.push(plugin);
    return plugin;
  }

  /**
   * @param {string} name
   * @returns {KimaiPlugin}
   */
  getPlugin(name) {
    for (let plugin of this._plugins) {
      if (plugin.getId() !== null && plugin.getId() === name) {
        return plugin;
      }
    }
    throw new Error('Unknown plugin: ' + name);
  }

  /**
   * @returns {Array<KimaiPlugin>}
   */
  getPlugins() {
    return this._plugins;
  }

  /**
   * @returns {KimaiTranslation}
   */
  getTranslation() {
    return this._translation;
  }

  /**
   * @returns {KimaiConfiguration}
   */
  getConfiguration() {
    return this._configuration;
  }

  /**
   * @returns {KimaiUser}
   */
  getUser() {
    return this.getPlugin('user');
  }
}

/***/ }),

/***/ "./assets/js/KimaiLoader.js":
/*!**********************************!*\
  !*** ./assets/js/KimaiLoader.js ***!
  \**********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ KimaiLoader; }
/* harmony export */ });
/* harmony import */ var luxon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! luxon */ "./node_modules/luxon/src/luxon.js");
/* harmony import */ var _KimaiTranslation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./KimaiTranslation */ "./assets/js/KimaiTranslation.js");
/* harmony import */ var _KimaiConfiguration__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./KimaiConfiguration */ "./assets/js/KimaiConfiguration.js");
/* harmony import */ var _KimaiContainer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./KimaiContainer */ "./assets/js/KimaiContainer.js");
/* harmony import */ var _plugins_KimaiDatatableColumnView_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./plugins/KimaiDatatableColumnView.js */ "./assets/js/plugins/KimaiDatatableColumnView.js");
/* harmony import */ var _plugins_KimaiThemeInitializer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./plugins/KimaiThemeInitializer */ "./assets/js/plugins/KimaiThemeInitializer.js");
/* harmony import */ var _forms_KimaiDateRangePicker__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./forms/KimaiDateRangePicker */ "./assets/js/forms/KimaiDateRangePicker.js");
/* harmony import */ var _plugins_KimaiDatatable__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./plugins/KimaiDatatable */ "./assets/js/plugins/KimaiDatatable.js");
/* harmony import */ var _plugins_KimaiToolbar__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./plugins/KimaiToolbar */ "./assets/js/plugins/KimaiToolbar.js");
/* harmony import */ var _plugins_KimaiAPI__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./plugins/KimaiAPI */ "./assets/js/plugins/KimaiAPI.js");
/* harmony import */ var _plugins_KimaiAlternativeLinks__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./plugins/KimaiAlternativeLinks */ "./assets/js/plugins/KimaiAlternativeLinks.js");
/* harmony import */ var _plugins_KimaiAjaxModalForm__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./plugins/KimaiAjaxModalForm */ "./assets/js/plugins/KimaiAjaxModalForm.js");
/* harmony import */ var _plugins_KimaiActiveRecords__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./plugins/KimaiActiveRecords */ "./assets/js/plugins/KimaiActiveRecords.js");
/* harmony import */ var _plugins_KimaiEvent__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./plugins/KimaiEvent */ "./assets/js/plugins/KimaiEvent.js");
/* harmony import */ var _plugins_KimaiAPILink__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./plugins/KimaiAPILink */ "./assets/js/plugins/KimaiAPILink.js");
/* harmony import */ var _plugins_KimaiAlert__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./plugins/KimaiAlert */ "./assets/js/plugins/KimaiAlert.js");
/* harmony import */ var _forms_KimaiAutocomplete__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./forms/KimaiAutocomplete */ "./assets/js/forms/KimaiAutocomplete.js");
/* harmony import */ var _forms_KimaiFormSelect__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./forms/KimaiFormSelect */ "./assets/js/forms/KimaiFormSelect.js");
/* harmony import */ var _plugins_KimaiForm__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./plugins/KimaiForm */ "./assets/js/plugins/KimaiForm.js");
/* harmony import */ var _forms_KimaiDatePicker__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./forms/KimaiDatePicker */ "./assets/js/forms/KimaiDatePicker.js");
/* harmony import */ var _plugins_KimaiConfirmationLink__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./plugins/KimaiConfirmationLink */ "./assets/js/plugins/KimaiConfirmationLink.js");
/* harmony import */ var _plugins_KimaiMultiUpdateTable__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./plugins/KimaiMultiUpdateTable */ "./assets/js/plugins/KimaiMultiUpdateTable.js");
/* harmony import */ var _plugins_KimaiDateUtils__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./plugins/KimaiDateUtils */ "./assets/js/plugins/KimaiDateUtils.js");
/* harmony import */ var _plugins_KimaiEscape__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./plugins/KimaiEscape */ "./assets/js/plugins/KimaiEscape.js");
/* harmony import */ var _plugins_KimaiFetch__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./plugins/KimaiFetch */ "./assets/js/plugins/KimaiFetch.js");
/* harmony import */ var _forms_KimaiTimesheetForm__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./forms/KimaiTimesheetForm */ "./assets/js/forms/KimaiTimesheetForm.js");
/* harmony import */ var _forms_KimaiTeamForm__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./forms/KimaiTeamForm */ "./assets/js/forms/KimaiTeamForm.js");
/* harmony import */ var _forms_KimaiCopyDataForm__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./forms/KimaiCopyDataForm */ "./assets/js/forms/KimaiCopyDataForm.js");
/* harmony import */ var _forms_KimaiDateNowForm__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./forms/KimaiDateNowForm */ "./assets/js/forms/KimaiDateNowForm.js");
/* harmony import */ var _plugins_KimaiNotification__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./plugins/KimaiNotification */ "./assets/js/plugins/KimaiNotification.js");
/* harmony import */ var _plugins_KimaiHotkeys__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./plugins/KimaiHotkeys */ "./assets/js/plugins/KimaiHotkeys.js");
/* harmony import */ var _plugins_KimaiRemoteModal__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./plugins/KimaiRemoteModal */ "./assets/js/plugins/KimaiRemoteModal.js");
/* harmony import */ var _plugins_KimaiUser__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./plugins/KimaiUser */ "./assets/js/plugins/KimaiUser.js");
/*
 * This file is part of the Kimai time-tracking app.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/*!
 * [KIMAI] KimaiLoader: bootstrap the application and all plugins
 */


































class KimaiLoader {
  constructor(configurations, translations) {
    // set the current locale for all javascript components
    luxon__WEBPACK_IMPORTED_MODULE_0__.Settings.defaultLocale = configurations['locale'].replace('_', '-').toLowerCase();
    luxon__WEBPACK_IMPORTED_MODULE_0__.Settings.defaultZone = configurations['timezone'];
    const kimai = new _KimaiContainer__WEBPACK_IMPORTED_MODULE_3__["default"](new _KimaiConfiguration__WEBPACK_IMPORTED_MODULE_2__["default"](configurations), new _KimaiTranslation__WEBPACK_IMPORTED_MODULE_1__["default"](translations));

    // GLOBAL HELPER PLUGINS
    kimai.registerPlugin(new _plugins_KimaiUser__WEBPACK_IMPORTED_MODULE_32__["default"]());
    kimai.registerPlugin(new _plugins_KimaiEscape__WEBPACK_IMPORTED_MODULE_23__["default"]());
    kimai.registerPlugin(new _plugins_KimaiEvent__WEBPACK_IMPORTED_MODULE_13__["default"]());
    kimai.registerPlugin(new _plugins_KimaiAPI__WEBPACK_IMPORTED_MODULE_9__["default"]());
    kimai.registerPlugin(new _plugins_KimaiAlert__WEBPACK_IMPORTED_MODULE_15__["default"]());
    kimai.registerPlugin(new _plugins_KimaiFetch__WEBPACK_IMPORTED_MODULE_24__["default"]());
    kimai.registerPlugin(new _plugins_KimaiDateUtils__WEBPACK_IMPORTED_MODULE_22__["default"]());
    kimai.registerPlugin(new _plugins_KimaiNotification__WEBPACK_IMPORTED_MODULE_29__["default"]());

    // FORM PLUGINS
    kimai.registerPlugin(new _forms_KimaiFormSelect__WEBPACK_IMPORTED_MODULE_17__["default"]('.selectpicker', 'select[data-related-select]'));
    kimai.registerPlugin(new _forms_KimaiDateRangePicker__WEBPACK_IMPORTED_MODULE_6__["default"]('input[data-daterangepicker="on"]'));
    kimai.registerPlugin(new _forms_KimaiDatePicker__WEBPACK_IMPORTED_MODULE_19__["default"]('input[data-datepicker="on"]'));
    kimai.registerPlugin(new _forms_KimaiAutocomplete__WEBPACK_IMPORTED_MODULE_16__["default"]());
    kimai.registerPlugin(new _forms_KimaiTimesheetForm__WEBPACK_IMPORTED_MODULE_25__["default"]());
    kimai.registerPlugin(new _forms_KimaiTeamForm__WEBPACK_IMPORTED_MODULE_26__["default"]());
    kimai.registerPlugin(new _forms_KimaiCopyDataForm__WEBPACK_IMPORTED_MODULE_27__["default"]());
    kimai.registerPlugin(new _forms_KimaiDateNowForm__WEBPACK_IMPORTED_MODULE_28__["default"]());
    kimai.registerPlugin(new _plugins_KimaiForm__WEBPACK_IMPORTED_MODULE_18__["default"]());
    kimai.registerPlugin(new _plugins_KimaiHotkeys__WEBPACK_IMPORTED_MODULE_30__["default"]());

    // SPECIAL FEATURES
    kimai.registerPlugin(new _plugins_KimaiConfirmationLink__WEBPACK_IMPORTED_MODULE_20__["default"]('confirmation-link'));
    kimai.registerPlugin(new _plugins_KimaiDatatableColumnView_js__WEBPACK_IMPORTED_MODULE_4__["default"]('data-column-visibility'));
    kimai.registerPlugin(new _plugins_KimaiDatatable__WEBPACK_IMPORTED_MODULE_7__["default"]('section.content', 'table.dataTable'));
    kimai.registerPlugin(new _plugins_KimaiToolbar__WEBPACK_IMPORTED_MODULE_8__["default"]('form.searchform', 'toolbar-action'));
    kimai.registerPlugin(new _plugins_KimaiAlternativeLinks__WEBPACK_IMPORTED_MODULE_10__["default"]('.alternative-link'));
    kimai.registerPlugin(new _plugins_KimaiAjaxModalForm__WEBPACK_IMPORTED_MODULE_11__["default"]('.modal-ajax-form'));
    kimai.registerPlugin(new _plugins_KimaiRemoteModal__WEBPACK_IMPORTED_MODULE_31__["default"]());
    kimai.registerPlugin(new _plugins_KimaiActiveRecords__WEBPACK_IMPORTED_MODULE_12__["default"]());
    kimai.registerPlugin(new _plugins_KimaiAPILink__WEBPACK_IMPORTED_MODULE_14__["default"]('api-link'));
    kimai.registerPlugin(new _plugins_KimaiMultiUpdateTable__WEBPACK_IMPORTED_MODULE_21__["default"]());
    kimai.registerPlugin(new _plugins_KimaiThemeInitializer__WEBPACK_IMPORTED_MODULE_5__["default"]());

    // notify all listeners that Kimai plugins can now be registered
    document.dispatchEvent(new CustomEvent('kimai.pluginRegister', {
      detail: {
        'kimai': kimai
      }
    }));

    // initialize all plugins
    kimai.getPlugins().map(plugin => {
      plugin.init();
    });

    // notify all listeners that Kimai is now ready to be used
    document.dispatchEvent(new CustomEvent('kimai.initialized', {
      detail: {
        'kimai': kimai
      }
    }));
    this.kimai = kimai;
  }
  getKimai() {
    return this.kimai;
  }
}

/***/ }),

/***/ "./assets/js/KimaiPlugin.js":
/*!**********************************!*\
  !*** ./assets/js/KimaiPlugin.js ***!
  \**********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ KimaiPlugin; }
/* harmony export */ });
/* harmony import */ var _KimaiContainer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./KimaiContainer */ "./assets/js/KimaiContainer.js");
/*
 * This file is part of the Kimai time-tracking app.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/*!
 * [KIMAI] KimaiPlugin: base class for all plugins
 */


class KimaiPlugin {
  /**
   * Overwrite this method to initialize your plugin.
   *
   * It is called AFTER setContainer() and AFTER DOMContentLoaded was fired.
   * You don't have access to the container before this method!
   */
  init() {}

  /**
   * If you return an ID, you indicate that your plugin can be used by other plugins.
   *
   * @returns {string|null}
   */
  getId() {
    return null;
  }

  /**
   * @param {KimaiContainer} core
   */
  setContainer(core) {
    if (!(core instanceof _KimaiContainer__WEBPACK_IMPORTED_MODULE_0__["default"])) {
      throw new Error('Plugin was given an invalid KimaiContainer');
    }
    this._core = core;
  }

  /**
   * This function returns null, if you call it BEFORE init().
   *
   * @returns {KimaiContainer}
   */
  getContainer() {
    return this._core;
  }

  /**
   * @param {string} name
   * @returns {(string|number|boolean)}
   */
  getConfiguration(name) {
    return this.getContainer().getConfiguration().get(name);
  }

  /**
   * @return {KimaiConfiguration}
   */
  getConfigurations() {
    return this.getContainer().getConfiguration();
  }

  /**
   * @returns {KimaiDateUtils}
   */
  getDateUtils() {
    return this.getPlugin('date');
  }

  /**
   * @param {string} name
   * @returns {KimaiPlugin}
   */
  getPlugin(name) {
    return this.getContainer().getPlugin(name);
  }

  /**
   * @returns {KimaiTranslation}
   */
  getTranslation() {
    return this.getContainer().getTranslation();
  }

  /**
   * @param {string} name
   * @returns {string}
   */
  translate(name) {
    return this.getTranslation().get(name);
  }

  /**
   * @param {string} title
   * @returns {string}
   */
  escape(title) {
    return this.getPlugin('escape').escapeForHtml(title);
  }

  /**
   * @param {string} name
   * @param {string|null} details
   */
  trigger(name) {
    let details = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    this.getPlugin('event').trigger(name, details);
  }

  /**
   * @param {string} url
   * @param {object} options
   * @returns {Promise<Response>}
   */
  fetch(url) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return this.getPlugin('fetch').fetch(url, options);
  }

  /**
   * @param {HTMLFormElement} form
   * @param {object} options
   * @param {string|null} url
   * @returns {Promise<Response>}
   */
  fetchForm(form) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let url = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    url = url || form.getAttribute('action');
    const method = form.getAttribute('method').toUpperCase();
    if (method === 'GET') {
      const data = this.getPlugin('form').convertFormDataToQueryString(form, {}, true);
      // TODO const data = new URLSearchParams(new FormData(form)).toString();
      url = url + (url.includes('?') ? '&' : '?') + data;
      options = {
        ...{
          method: 'GET'
        },
        ...options
      };
    } else if (method === 'POST') {
      options = {
        ...{
          method: 'POST',
          body: new FormData(form)
        },
        ...options
      };
    }
    return this.fetch(url, options);
  }

  /**
   * Check if the current device is a mobile device (targeting the bootstrip xs breakpoint size).
   *
   * @returns {boolean}
   */
  isMobile() {
    const width = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    return width < 576;
  }
}

/***/ }),

/***/ "./assets/js/KimaiTranslation.js":
/*!***************************************!*\
  !*** ./assets/js/KimaiTranslation.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ KimaiTranslation; }
/* harmony export */ });
/*
 * This file is part of the Kimai time-tracking app.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/*!
 * [KIMAI] KimaiTranslation: handling translation strings
 */

class KimaiTranslation {
  /**
   * @param {Array<string, string>} translations
   */
  constructor(translations) {
    this._translations = translations;
  }

  /**
   * @param {string} name
   * @returns {string}
   */
  get(name) {
    return this._translations[name];
  }

  /**
   * @param {string} name
   * @returns {boolean}
   */
  has(name) {
    return name in this._translations;
  }
}

/***/ }),

/***/ "./assets/js/KimaiWebLoader.js":
/*!*************************************!*\
  !*** ./assets/js/KimaiWebLoader.js ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _KimaiLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./KimaiLoader */ "./assets/js/KimaiLoader.js");
/* module decorator */ module = __webpack_require__.hmd(module);
/*
 * This file is part of the Kimai time-tracking app.
 *
 * Main JS application file for Kimai 2. This file should be included in all pages.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/*!
 * [KIMAI] Wrapper class for loading Kimai app in browser script scope
 */


(function (root, factory) {
  if (typeof define === 'function' && __webpack_require__.amdO) {
    define([], function () {
      return root.KimaiWebLoader = factory();
    });
  } else if ( true && module.exports) {
    module.exports = factory();
  } else {
    root.KimaiWebLoader = factory();
  }
})(typeof self !== 'undefined' ? self : undefined, function () {
  class KimaiWebLoader extends _KimaiLoader__WEBPACK_IMPORTED_MODULE_0__["default"] {}
  return KimaiWebLoader;
});

/***/ }),

/***/ "./assets/js/forms/KimaiAutocomplete.js":
/*!**********************************************!*\
  !*** ./assets/js/forms/KimaiAutocomplete.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ KimaiAutocomplete; }
/* harmony export */ });
/* harmony import */ var tom_select__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tom-select */ "./node_modules/tom-select/dist/js/tom-select.complete.js");
/* harmony import */ var tom_select__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(tom_select__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _KimaiFormPlugin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./KimaiFormPlugin */ "./assets/js/forms/KimaiFormPlugin.js");
/*
 * This file is part of the Kimai time-tracking app.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */




/**
 * Supporting auto-complete fields via API.
 * Used for timesheet tagging in toolbar and edit dialogs.
 */
class KimaiAutocomplete extends _KimaiFormPlugin__WEBPACK_IMPORTED_MODULE_1__["default"] {
  init() {
    this.selector = '[data-form-widget="autocomplete"]';
  }

  /**
   * @param {HTMLFormElement} form
   * @return boolean
   */
  supportsForm(form)
  // eslint-disable-line no-unused-vars
  {
    return true;
  }
  activateForm(form) {
    /** @type {KimaiAPI} API */
    const API = this.getContainer().getPlugin('api');
    [].slice.call(form.querySelectorAll(this.selector)).map(node => {
      const apiUrl = node.dataset['autocompleteUrl'];
      let minChars = 3;
      if (node.dataset['minimumCharacter'] !== undefined) {
        minChars = parseInt(node.dataset['minimumCharacter']);
      }
      new (tom_select__WEBPACK_IMPORTED_MODULE_0___default())(node, {
        // see https://github.com/orchidjs/tom-select/issues/543#issuecomment-1664342257
        onItemAdd: function () {
          // remove remaining characters from input after selecting an item
          this.setTextboxValue('');
        },
        // if there are more than 500, they need to be found by "typing"
        maxOptions: 500,
        // the autocomplete is ONLY used, when the user can create tags
        create: node.dataset['create'] !== undefined,
        onOptionAdd: value => {
          node.dispatchEvent(new CustomEvent('create', {
            detail: {
              'value': value
            }
          }));
        },
        plugins: ['remove_button'],
        shouldLoad: function (query) {
          return query.length >= minChars;
        },
        load: (query, callback) => {
          API.get(apiUrl, {
            'name': query
          }, data => {
            const results = [].slice.call(data).map(result => {
              return {
                text: result,
                value: result
              };
            });
            callback(results);
          }, () => {
            callback();
          });
        },
        render: {
          // eslint-disable-next-line
          not_loading: (data, escape) => {
            // no default content
          },
          option_create: (data, escape) => {
            const name = escape(data.input);
            if (name.length < 3) {
              return null;
            }
            const tpl = this.translate('select.search.create');
            const tplReplaced = tpl.replace('%input%', '<strong>' + name + '</strong>');
            return '<div class="create">' + tplReplaced + '</div>';
          },
          no_results: (data, escape) => {
            const tpl = this.translate('select.search.notfound');
            const tplReplaced = tpl.replace('%input%', '<strong>' + escape(data.input) + '</strong>');
            return '<div class="no-results">' + tplReplaced + '</div>';
          }
        }
      });
    });
  }
  destroyForm(form) {
    [].slice.call(form.querySelectorAll(this.selector)).map(node => {
      if (node.tomselect) {
        node.tomselect.destroy();
      }
    });
  }
}

/***/ }),

/***/ "./assets/js/forms/KimaiCopyDataForm.js":
/*!**********************************************!*\
  !*** ./assets/js/forms/KimaiCopyDataForm.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ KimaiCopyDataForm; }
/* harmony export */ });
/* harmony import */ var _KimaiFormPlugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./KimaiFormPlugin */ "./assets/js/forms/KimaiFormPlugin.js");
/*
 * This file is part of the Kimai time-tracking app.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/*!
 * [KIMAI] KimaiEditTimesheetForm: responsible for the most important form in the application
 */



/**
 * Used for simple copy from link to input action, e.g. the time and duration dropdowns
 * copy the selected values into their corresponding input.
 */
class KimaiCopyDataForm extends _KimaiFormPlugin__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {HTMLFormElement} form
   * @return boolean
   */
  supportsForm(form)
  // eslint-disable-line no-unused-vars
  {
    return true;
  }

  /**
   * @param {HTMLFormElement} form
   */
  activateForm(form)
  // eslint-disable-line no-unused-vars
  {
    if (this._eventHandler === undefined) {
      this._eventHandler = event => {
        let element = event.target;
        if (!element.matches('a[data-form-widget="copy-data"]')) {
          element = element.parentNode; // mostly for icons
        }

        if (!element.matches('a[data-form-widget="copy-data"]') || element.dataset.target === undefined) {
          return;
        }
        const target = document.querySelector(element.dataset.target);
        if (target === null) {
          return;
        }
        target.value = element.dataset.value;
        if (element.dataset.event !== undefined) {
          for (const event of element.dataset.event.split(' ')) {
            target.dispatchEvent(new Event(event));
          }
        } else if (element.dataset.eventBubbles !== undefined) {
          for (const event of element.dataset.eventBubbles.split(' ')) {
            target.dispatchEvent(new Event(event, {
              bubbles: true
            }));
          }
        }
        event.preventDefault();
      };
    }
    form.addEventListener('click', this._eventHandler);
  }

  /**
   * @param {HTMLFormElement} form
   */
  destroyForm(form)
  // eslint-disable-line no-unused-vars
  {
    form.removeEventListener('click', this._eventHandler);
  }
}

/***/ }),

/***/ "./assets/js/forms/KimaiDateNowForm.js":
/*!*********************************************!*\
  !*** ./assets/js/forms/KimaiDateNowForm.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ KimaiDateNowForm; }
/* harmony export */ });
/* harmony import */ var _KimaiFormPlugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./KimaiFormPlugin */ "./assets/js/forms/KimaiFormPlugin.js");
/*
 * This file is part of the Kimai time-tracking app.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/*!
 * [KIMAI] KimaiEditTimesheetForm: responsible for the most important form in the application
 */



/**
 */
class KimaiDateNowForm extends _KimaiFormPlugin__WEBPACK_IMPORTED_MODULE_0__["default"] {
  init() {
    this.selector = 'a[data-form-widget="date-now"]';
  }

  /**
   * @param {HTMLFormElement} form
   * @return boolean
   */
  supportsForm(form)
  // eslint-disable-line no-unused-vars
  {
    return true;
  }

  /**
   * @param {HTMLFormElement} form
   */
  activateForm(form) {
    [].slice.call(form.querySelectorAll(this.selector)).map(element => {
      if (element.dataset.format !== undefined && element.dataset.target !== undefined) {
        if (this._eventHandler === undefined) {
          this._eventHandler = event => {
            const linkTarget = event.currentTarget;
            const formElement = document.getElementById(linkTarget.dataset.target);
            if (!formElement.disabled) {
              formElement.value = this.getDateUtils().format(linkTarget.dataset.format, null);
              formElement.dispatchEvent(new Event('change', {
                bubbles: true
              }));
            }
            event.preventDefault();
          };
        }
        element.addEventListener('click', this._eventHandler);
      }
    });
  }

  /**
   * @param {HTMLFormElement} form
   */
  destroyForm(form) {
    [].slice.call(form.querySelectorAll(this.selector)).map(element => {
      if (element.dataset.format !== undefined && element.dataset.target !== undefined) {
        element.removeEventListener('click', this._eventHandler);
      }
    });
  }
}

/***/ }),

/***/ "./assets/js/forms/KimaiDatePicker.js":
/*!********************************************!*\
  !*** ./assets/js/forms/KimaiDatePicker.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ KimaiDatePicker; }
/* harmony export */ });
/* harmony import */ var litepicker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! litepicker */ "./node_modules/litepicker/dist/litepicker.umd.js");
/* harmony import */ var litepicker__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(litepicker__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var litepicker_dist_plugins_mobilefriendly__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! litepicker/dist/plugins/mobilefriendly */ "./node_modules/litepicker/dist/plugins/mobilefriendly.js");
/* harmony import */ var litepicker_dist_plugins_mobilefriendly__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(litepicker_dist_plugins_mobilefriendly__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _KimaiFormPlugin__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./KimaiFormPlugin */ "./assets/js/forms/KimaiFormPlugin.js");
/*
 * This file is part of the Kimai time-tracking app.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/*!
 * [KIMAI] KimaiDatePicker: single date selects (currently unused)
 */




class KimaiDatePicker extends _KimaiFormPlugin__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor(selector) {
    super();
    this._selector = selector;
  }
  init() {
    window.disableLitepickerStyles = true;
    this._pickers = [];
  }

  /**
   * @param {HTMLFormElement} form
   * @return boolean
   */
  supportsForm(form)
  // eslint-disable-line no-unused-vars
  {
    return true;
  }

  /**
   * @param {HTMLFormElement} form
   */
  activateForm(form) {
    const FIRST_DOW = this.getConfigurations().getFirstDayOfWeek(false);
    const LANGUAGE = this.getConfigurations().getLanguage();
    let options = {
      buttonText: {
        previousMonth: `<i class="fas fa-chevron-left"></i>`,
        nextMonth: `<i class="fas fa-chevron-right"></i>`,
        apply: this.translate('confirm'),
        cancel: this.translate('cancel')
      }
    };
    const newPickers = [].slice.call(form.querySelectorAll(this._selector)).map(element => {
      if (element.dataset.format === undefined) {
        console.log('Trying to bind litepicker to an element without data-format attribute');
      }
      options = {
        ...options,
        ...{
          format: element.dataset.format,
          showTooltip: false,
          element: element,
          lang: LANGUAGE,
          autoRefresh: true,
          firstDay: FIRST_DOW,
          // Litepicker: 0 = Sunday, 1 = Monday
          setup: picker => {
            // nasty hack, because litepicker does not trigger change event on the input and the available
            // event "selected" is triggered why to often, even when moving the cursor inside the input
            // element (not even typing is necessary) and so we have to make sure that the manual "click" event
            // (works for touch as well) happened before we actually dispatch the change event manually ...
            // what? report forms would be submitted upon cursor move without the "preselect” check
            picker.on('preselect', (date1, date2) => {
              // eslint-disable-line no-unused-vars
              picker._wasPreselected = true;
            });
            picker.on('selected', (date1, date2) => {
              // eslint-disable-line no-unused-vars
              if (picker._wasPreselected !== undefined) {
                element.dispatchEvent(new Event('change', {
                  bubbles: true
                }));
                delete picker._wasPreselected;
              }
            });

            // only if mobile.friendly plugin is activated
            if (picker.backdrop !== undefined) {
              // the node needs to be moved, so the flat form layout works properly (e.g. for date types)
              document.body.appendChild(picker.backdrop);
            }
          }
        }
      };
      return [element, new litepicker__WEBPACK_IMPORTED_MODULE_0__.Litepicker(this.prepareOptions(options))];
    });
    this._pickers = this._pickers.concat(newPickers);
  }
  prepareOptions(options) {
    return {
      ...options,
      ...{
        plugins: ['mobilefriendly']
      }
    };
  }

  /**
   * @param {HTMLFormElement} form
   */
  destroyForm(form) {
    [].slice.call(form.querySelectorAll(this._selector)).map(element => {
      for (let i = 0; i < this._pickers.length; i++) {
        if (this._pickers[i][0] === element) {
          this._pickers[i][1].destroy();
          this._pickers.splice(i, 1);
        }
      }
    });
  }
}

/***/ }),

/***/ "./assets/js/forms/KimaiDateRangePicker.js":
/*!*************************************************!*\
  !*** ./assets/js/forms/KimaiDateRangePicker.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ KimaiDateRangePicker; }
/* harmony export */ });
/* harmony import */ var _KimaiDatePicker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./KimaiDatePicker */ "./assets/js/forms/KimaiDatePicker.js");
/*
 * This file is part of the Kimai time-tracking app.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/*!
 * [KIMAI] KimaiDateRangePicker: activate the (daterange picker) compound field in toolbar
 */


class KimaiDateRangePicker extends _KimaiDatePicker__WEBPACK_IMPORTED_MODULE_0__["default"] {
  prepareOptions(options) {
    return {
      ...options,
      ...{
        plugins: ['mobilefriendly'],
        singleMode: false,
        autoRefresh: true
      }
    };
  }
}

/***/ }),

/***/ "./assets/js/forms/KimaiFormPlugin.js":
/*!********************************************!*\
  !*** ./assets/js/forms/KimaiFormPlugin.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ KimaiFormPlugin; }
/* harmony export */ });
/* harmony import */ var _KimaiPlugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../KimaiPlugin */ "./assets/js/KimaiPlugin.js");
/*
 * This file is part of the Kimai time-tracking app.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/*!
 * [KIMAI] KimaiFormPlugin: base class for all none ID plugin that handle forms
 */


class KimaiFormPlugin extends _KimaiPlugin__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {HTMLFormElement} form
   * @return boolean
   */
  supportsForm(form)
  // eslint-disable-line no-unused-vars
  {
    return false;
  }

  /**
   * @param {HTMLFormElement} form
   */
  activateForm(form)
  // eslint-disable-line no-unused-vars
  {}

  /**
   * @param {HTMLFormElement} form
   */
  destroyForm(form)
  // eslint-disable-line no-unused-vars
  {}
}

/***/ }),

/***/ "./assets/js/forms/KimaiFormSelect.js":
/*!********************************************!*\
  !*** ./assets/js/forms/KimaiFormSelect.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ KimaiFormSelect; }
/* harmony export */ });
/* harmony import */ var tom_select__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tom-select */ "./node_modules/tom-select/dist/js/tom-select.complete.js");
/* harmony import */ var tom_select__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(tom_select__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _KimaiFormPlugin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./KimaiFormPlugin */ "./assets/js/forms/KimaiFormPlugin.js");
/*
 * This file is part of the Kimai time-tracking app.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/*!
 * [KIMAI] KimaiFormSelect: enhanced functionality for HTMLSelectElement
 */



class KimaiFormSelect extends _KimaiFormPlugin__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(selector, apiSelects) {
    super();
    this._selector = selector;
    this._apiSelects = apiSelects;
  }
  getId() {
    return 'form-select';
  }
  init() {
    // selects the original value inside dropdowns, as the "reset" event (the updated option)
    // is not automatically propagated to the JS element
    document.addEventListener('reset', event => {
      if (event.target.tagName.toUpperCase() === 'FORM') {
        setTimeout(() => {
          const fields = event.target.querySelectorAll(this._selector);
          for (let field of fields) {
            if (field.tagName.toUpperCase() === 'SELECT') {
              field.dispatchEvent(new Event('data-reloaded'));
            }
          }
        }, 10);
      }
    });
  }

  /**
   * @param {HTMLFormElement} node
   */
  activateSelectPickerByElement(node) {
    let plugins = ['change_listener'];
    const isMultiple = node.multiple !== undefined && node.multiple === true;
    const isRequired = node.required !== undefined && node.required === true;
    if (isRequired) {
      plugins.push('no_backspace_delete');
    }
    if (isMultiple) {
      plugins.push('remove_button');
    }

    /*
    const isOrdering = false;
    if (isOrdering) {
        plugins.push('caret_position');
        plugins.push('drag_drop');
    }
    */

    let options = {
      // see https://github.com/orchidjs/tom-select/issues/543#issuecomment-1664342257
      onItemAdd: function () {
        // remove remaining characters from input after selecting an item
        this.setTextboxValue('');
      },
      lockOptgroupOrder: true,
      allowEmptyOption: !isRequired,
      hidePlaceholder: false,
      plugins: plugins,
      // if there are more than X entries, the other ones are hidden and can only be found
      // by typing some characters to trigger the internal option search
      maxOptions: 500
    };
    let render = {
      option_create: (data, escape) => {
        const name = escape(data.input);
        if (name.length < 3) {
          return null;
        }
        const tpl = this.translate('select.search.create');
        const tplReplaced = tpl.replace('%input%', '<strong>' + name + '</strong>');
        return '<div class="create">' + tplReplaced + '</div>';
      },
      no_results: (data, escape) => {
        const tpl = this.translate('select.search.notfound');
        const tplReplaced = tpl.replace('%input%', '<strong>' + escape(data.input) + '</strong>');
        return '<div class="no-results">' + tplReplaced + '</div>';
      },
      onOptionAdd: value => {
        node.dispatchEvent(new CustomEvent('create', {
          detail: {
            'value': value
          }
        }));
      }
    };
    if (node.dataset['create'] !== undefined) {
      options = {
        ...options,
        ...{
          persist: true,
          create: true
        }
      };
    } else {
      options = {
        ...options,
        ...{
          persist: false,
          create: false
        }
      };
    }
    if (node.dataset.disableSearch !== undefined) {
      options = {
        ...options,
        ...{
          controlInput: null
        }
      };
    }
    if (node.dataset['renderer'] !== undefined && node.dataset['renderer'] === 'color') {
      options.render = {
        ...render,
        ...{
          option: function (data, escape) {
            let item = '<div class="list-group-item border-0 p-1 ps-2 text-nowrap">';
            if (data.color !== undefined) {
              item += '<span style="background-color:' + data.color + '" class="color-choice-item">&nbsp;</span>';
            } else {
              item += '<span class="color-choice-item">&nbsp;</span>';
            }
            item += escape(data.text) + '</div>';
            return item;
          },
          item: function (data, escape) {
            let item = '<div class="text-nowrap">';
            if (data.color !== undefined) {
              item += '<span style="background-color:' + data.color + '" class="color-choice-item">&nbsp;</span>';
            } else {
              item += '<span class="color-choice-item">&nbsp;</span>';
            }
            item += escape(data.text) + '</div>';
            return item;
          }
        }
      };
    } else {
      options.render = {
        ...render,
        ...{
          // the empty entry would collapse and only show as a tiny 5px line if there is no content inside
          option: function (data, escape) {
            let text = data.text;
            if (text === null || text.trim() === '') {
              text = '&nbsp;';
            } else {
              text = escape(text);
            }
            return '<div>' + text + '</div>';
          }
        }
      };
    }
    const select = new (tom_select__WEBPACK_IMPORTED_MODULE_0___default())(node, options);
    node.addEventListener('data-reloaded', event => {
      select.clear(true);
      select.clearOptionGroups();
      select.clearOptions();
      select.sync();
      select.setValue(event.detail);
      select.refreshItems();
      select.refreshOptions(false);
    });

    // support reloading the list upon external event
    if (node.dataset['reload'] !== undefined) {
      node.addEventListener('reload', () => {
        select.disable();
        node.disabled = true;

        /** @type {KimaiAPI} API */
        const API = this.getContainer().getPlugin('api');
        API.get(node.dataset['reload'], {}, data => {
          this._updateSelect(node, data);
          select.enable();
          node.disabled = false;
        });
        node.dispatchEvent(new Event('change'));
      });
    }
  }

  /**
   * @param {HTMLFormElement} form
   * @return boolean
   */
  supportsForm(form)
  // eslint-disable-line no-unused-vars
  {
    return true;
  }

  /**
   * @param {HTMLFormElement} form
   */
  activateForm(form) {
    [].slice.call(form.querySelectorAll(this._selector)).map(node => {
      this.activateSelectPickerByElement(node);
    });
    this._activateApiSelects(this._apiSelects);
  }

  /**
   * @param {HTMLFormElement} form
   */
  destroyForm(form) {
    [].slice.call(form.querySelectorAll(this._selector)).map(node => {
      if (node.tomselect) {
        node.tomselect.destroy();
      }
    });
  }

  /**
   * @param {string|Element} selectIdentifier
   * @param {object} data
   * @private
   */
  _updateOptions(selectIdentifier, data) {
    let emptyOption = null;
    let node = null;
    if (selectIdentifier instanceof Element) {
      node = selectIdentifier;
    } else {
      node = document.querySelector(selectIdentifier);
    }
    if (node === null) {
      console.log('Missing select: ' + selectIdentifier);
      return;
    }
    const selectedValue = node.value;
    for (let i = 0; i < node.options.length; i++) {
      if (node.options[i].value === '') {
        emptyOption = node.options[i];
      }
    }
    node.options.length = 0;
    if (emptyOption !== null) {
      node.appendChild(this._createOption(emptyOption.text, ''));
    }
    let emptyOpts = [];
    let options = [];
    /** @type {string|null} titlePattern */
    let titlePattern = null;
    if (node.dataset !== undefined && node.dataset['optionPattern'] !== undefined) {
      titlePattern = node.dataset['optionPattern'];
    }
    if (titlePattern === null || titlePattern === '') {
      titlePattern = '{name}';
    }
    for (const [key, value] of Object.entries(data)) {
      if (key === '__empty__') {
        for (const entity of value) {
          emptyOpts.push(this._createOption(this._getTitleFromPattern(titlePattern, entity), entity.id));
        }
        continue;
      }
      let optGroup = this._createOptgroup(key);
      for (const entity of value) {
        optGroup.appendChild(this._createOption(this._getTitleFromPattern(titlePattern, entity), entity.id));
      }
      options.push(optGroup);
    }
    options.forEach(child => node.appendChild(child));
    emptyOpts.forEach(child => node.appendChild(child));

    // if available, re-select the previous selected option (mostly usable for global activities)
    node.value = selectedValue;

    // pre-select an option if it is the only available one
    if (node.value === '' || node.value === null) {
      const allOptions = node.options;
      const optionLength = allOptions.length;
      let selectOption = '';
      if (optionLength === 1 && node.dataset['autoselect'] === undefined) {
        selectOption = allOptions[0].value;
      } else if (optionLength === 2 && emptyOption !== null) {
        selectOption = allOptions[1].value;
      }
      if (selectOption !== '') {
        node.value = selectOption;
      }
    }

    // this will update the attached javascript component
    node.dispatchEvent(new CustomEvent('data-reloaded', {
      detail: node.value
    }));
    // if we don't trigger the change, the other selects won't reset
    node.dispatchEvent(new Event('change'));
  }

  /**
   * @param {string} pattern
   * @param {array} entity
   * @private
   */
  _getTitleFromPattern(pattern, entity) {
    const DATE_UTILS = this.getDateUtils();
    const regexp = new RegExp('{[^}]*?}', 'g');
    let title = pattern;
    let match = null;
    while ((match = regexp.exec(pattern)) !== null) {
      // cutting a string like "{name}" into "name"
      const field = match[0].slice(1, -1);
      let value = entity[field] === undefined ? null : entity[field];
      if (field === 'start' || field === 'end') {
        if (value === null) {
          value = '?';
        } else {
          value = DATE_UTILS.getFormattedDate(value);
        }
      }
      title = title.replace(new RegExp('{' + field + '}', 'g'), value ?? '');
    }
    title = title.replace(/- \?-\?/, '');
    title = title.replace(/\r\n|\r|\n/g, ' ');
    title = title.substring(0, 110);
    const chars = '- ';
    let start = 0,
      end = title.length;
    while (start < end && chars.indexOf(title[start]) >= 0) {
      ++start;
    }
    while (end > start && chars.indexOf(title[end - 1]) >= 0) {
      --end;
    }
    let result = start > 0 || end < title.length ? title.substring(start, end) : title;
    if (result === '' && entity['name'] !== undefined) {
      return entity['name'];
    }
    return result;
  }

  /**
   * @param {HTMLSelectElement} select
   * @param {string} label
   * @param {string} value
   * @param {object} dataset
   */
  addOption(select, label, value, dataset) {
    const option = this._createOption(label, value);
    for (const key in dataset) {
      option.dataset[key] = dataset[key];
    }
    select.options.add(option);
    if (select.tomselect !== undefined) {
      select.tomselect.sync();
    }
  }

  /**
   *
   * @param {HTMLSelectElement} select
   * @param {HTMLOptionElement} option
   */
  removeOption(select, option) {
    option.remove();
    if (select.tomselect !== undefined) {
      select.tomselect.removeOption(option.value, true);
      select.tomselect.clear(true);
    }
  }

  /**
   * @param {string} label
   * @param {string} value
   * @returns {HTMLElement}
   * @private
   */
  _createOption(label, value) {
    let option = document.createElement('option');
    option.innerText = label;
    option.value = value;
    return option;
  }

  /**
   * @param {string} label
   * @returns {HTMLElement}
   * @private
   */
  _createOptgroup(label) {
    let optGroup = document.createElement('optgroup');
    optGroup.label = label;
    return optGroup;
  }

  /**
   * @param {string} selector
   * @private
   */
  _activateApiSelects(selector) {
    if (this._eventHandlerApiSelects === undefined) {
      this._eventHandlerApiSelects = event => {
        if (event.target === null || !event.target.matches(selector)) {
          return;
        }
        // timesheet_edit_form_timesheet_edit_form_metaFields_rspkl_subactivity_value
        // timesheet_edit_form_metaFields_rspkl_subactivity_value
        const apiSelect = event.target;
        const targetSelectId = '#' + apiSelect.dataset['relatedSelect'];
        /** @type {HTMLSelectElement} targetSelect */
        const targetSelect = document.getElementById(apiSelect.dataset['relatedSelect']);

        // if the related target select does not exist, we do not need to load the related data
        if (targetSelect === null || targetSelect.dataset['reloading'] === '1') {
          return;
        }
        targetSelect.dataset['reloading'] = '1';
        if (targetSelect.tomselect !== undefined) {
          targetSelect.tomselect.disable();
        }
        targetSelect.disabled = true;
        let formPrefix = apiSelect.dataset['formPrefix'];
        if (formPrefix === undefined || formPrefix === null) {
          formPrefix = '';
        } else if (formPrefix.length > 0) {
          formPrefix += '_';
        }
        let newApiUrl = this._buildUrlWithFormFields(apiSelect.dataset['apiUrl'], formPrefix);
        const selectValue = apiSelect.value;
        console.log(`newApiUrl:`, newApiUrl ?? null, `\ntargetSelect:`, targetSelect ?? null, `\nselectValue: ${selectValue}\n\n`);
        // Problem: select a project with activities and then select a customer that has no project
        // results in a wrong URL, it triggers "activities?project=" instead of using the "emptyUrl"
        if (selectValue === undefined || selectValue === null || selectValue === '' || Array.isArray(selectValue) && selectValue.length === 0) {
          if (apiSelect.dataset['emptyUrl'] === undefined) {
            this._updateSelect(targetSelectId, {});
            targetSelect.dataset['reloading'] = '0';
            return;
          }
          newApiUrl = this._buildUrlWithFormFields(apiSelect.dataset['emptyUrl'], formPrefix);
        }

        /** @type {KimaiAPI} API */
        const API = this.getContainer().getPlugin('api');
        API.get(newApiUrl, {}, data => {
          this._updateSelect(targetSelectId, data);
          if (targetSelect.tomselect !== undefined) {
            targetSelect.tomselect.enable();
          }
          targetSelect.dataset['reloading'] = '0';
          targetSelect.disabled = false;
        });
      };
      document.addEventListener('change', this._eventHandlerApiSelects);
    }
  }

  /**
   * @param {string} apiUrl
   * @param {string} formPrefix
   * @return {string}
   * @private
   */
  _buildUrlWithFormFields(apiUrl, formPrefix) {
    let newApiUrl = apiUrl;
    apiUrl.split('?')[1].split('&').forEach(item => {
      const [key, value] = item.split('='); // eslint-disable-line no-unused-vars
      const decoded = decodeURIComponent(value);
      const test = decoded.match(/%(.*)%/);
      if (test !== null) {
        const originalFieldName = test[1];
        const targetFieldName = (formPrefix + originalFieldName).replace(/\[/, '').replace(/]/, '');
        const targetField = document.getElementById(targetFieldName);
        let newValue = '';
        console.log(`\n\n------------------------\n` + `newApiUrl:` + newApiUrl ?? null, `targetField:`, targetField ?? null, `\ntargetField.value: ${targetField?.value ?? null}`);
        if (targetField === null) {
          // happens for example:
          // - in duration only mode, when the end field is not found
          // console.log('ERROR: Cannot find field with name "' + test[1] + '" by selector: #' + formPrefix + test[1]);
        } else {
          if (targetField.value !== null) {
            newValue = targetField.value;
            if (targetField.tagName === 'SELECT' && targetField.multiple) {
              newValue = [...targetField.selectedOptions].map(o => o.value);
            } else if (newValue !== '') {
              if (targetField.type === 'date') {
                const timeId = targetField.id.replace('_date', '_time');
                const timeElement = document.getElementById(timeId);
                const time = timeElement === null ? '12:00:00' : timeElement.value;
                // using 12:00 as fallback, because timezone handling might change the date if we use 00:00
                const newDate = this.getDateUtils().fromHtml5Input(newValue, time);
                newValue = this.getDateUtils().formatForAPI(newDate, false);
              } else if (targetField.type === 'text' && targetField.name.includes('date')) {
                const timeId = targetField.id.replace('_date', '_time');
                const timeElement = document.getElementById(timeId);
                // using 12:00 as fallback, because timezone handling might change the date if we use 00:00
                let time = '12:00:00';
                let timeFormat = 'HH:mm';
                if (timeElement !== null) {
                  time = timeElement.value;
                  timeFormat = timeElement.dataset['format'];
                }
                const newDate = this.getDateUtils().fromFormat(newValue.trim() + ' ' + time.trim(), targetField.dataset['format'] + ' ' + timeFormat);
                newValue = this.getDateUtils().formatForAPI(newDate, false);
              } else if (targetField.dataset['format'] !== undefined) {
                // find out when this else branch is triggered and document!

                if (this.getDateUtils().isValidDateTime(newValue, targetField.dataset['format'])) {
                  newValue = this.getDateUtils().format(targetField.dataset['format'], newValue);
                }
              }
            } else {
              // happens for example:
              // - when the end date is not set on a timesheet record and the project list is loaded (as the URL contains the %end% replacer)
              // console.log('Empty value found for field with name "' + test[1] + '" by selector: #' + formPrefix + test[1]);
            }
          } else {
            // happens for example:
            // - when a customer without projects is selected
            // console.log('ERROR: Empty field with name "' + test[1] + '" by selector: #' + formPrefix + test[1]);
          }
        }
        if (Array.isArray(newValue)) {
          let urlParams = [];
          for (let tmpValue of newValue) {
            if (tmpValue === null) {
              tmpValue = '';
            }
            urlParams.push(originalFieldName + '=' + tmpValue);
          }
          newApiUrl = newApiUrl.replace(item, urlParams.join('&'));
        } else {
          if (newValue === null) {
            newValue = '';
          }
          newApiUrl = newApiUrl.replace(value, newValue);
        }
      }
    });
    return newApiUrl;
  }

  /**
   * @param {string|Element} select
   * @param {object} data
   * @private
   */
  _updateSelect(select, data) {
    const options = {};
    for (const apiData of data) {
      let title = '__empty__';
      if (apiData['parentTitle'] !== undefined && apiData['parentTitle'] !== null) {
        title = apiData['parentTitle'];
      }
      if (options[title] === undefined) {
        options[title] = [];
      }
      options[title].push(apiData);
    }
    const ordered = {};
    Object.keys(options).sort().forEach(function (key) {
      ordered[key] = options[key];
    });
    this._updateOptions(select, ordered);
  }
}

/***/ }),

/***/ "./assets/js/forms/KimaiTeamForm.js":
/*!******************************************!*\
  !*** ./assets/js/forms/KimaiTeamForm.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ KimaiTeamForm; }
/* harmony export */ });
/* harmony import */ var _KimaiFormPlugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./KimaiFormPlugin */ "./assets/js/forms/KimaiFormPlugin.js");
/* harmony import */ var _widgets_KimaiColor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../widgets/KimaiColor */ "./assets/js/widgets/KimaiColor.js");
/*
 * This file is part of the Kimai time-tracking app.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/*!
 * [KIMAI] KimaiEditTimesheetForm: responsible for the most important form in the application
 */



class KimaiTeamForm extends _KimaiFormPlugin__WEBPACK_IMPORTED_MODULE_0__["default"] {
  init() {
    this.usersId = 'team_edit_form_users';
  }

  /**
   * @param {HTMLFormElement} form
   * @return boolean
   */
  supportsForm(form) {
    return form.name === 'team_edit_form';
  }

  /**
   * @return {HTMLElement}
   * @private
   */
  _getPrototype() {
    return document.getElementById('team_edit_form_members');
  }

  /**
   * @param {HTMLFormElement} form
   */
  activateForm(form) {
    if (!this.supportsForm(form)) {
      return;
    }

    // must be attached to the form, because the button is added dynamically
    form.addEventListener('click', event => this._removeMember(event));
    document.getElementById(this.usersId).addEventListener('change', event => {
      const select = event.target;
      const option = select.options[select.selectedIndex];
      const member = this._createMember(option);
      this._getPrototype().append(member);
      this.getPlugin('form-select').removeOption(select, option);
    });
  }

  /**
   * @param {HTMLOptionElement} option
   * @returns {Element}
   * @private
   */
  _createMember(option) {
    /** @type {KimaiEscape} ESCAPER */
    const ESCAPER = this.getPlugin('escape');
    const prototype = this._getPrototype();
    let counter = prototype.dataset['widgetCounter'] || prototype.childNodes.length;
    let newWidget = prototype.dataset['prototype'];
    newWidget = newWidget.replace(/__name__/g, counter);
    newWidget = newWidget.replace(/#000000/g, _widgets_KimaiColor__WEBPACK_IMPORTED_MODULE_1__["default"].calculateContrastColor(option.dataset.color));
    newWidget = newWidget.replace(/__DISPLAY__/g, ESCAPER.escapeForHtml(option.dataset.display));
    newWidget = newWidget.replace(/__COLOR__/g, option.dataset.color);
    newWidget = newWidget.replace(/__INITIALS__/g, ESCAPER.escapeForHtml(option.dataset.initials));
    newWidget = newWidget.replace(/__TITLE__/g, ESCAPER.escapeForHtml(option.dataset.title));
    newWidget = newWidget.replace(/__USERNAME__/g, ESCAPER.escapeForHtml(option.text));
    prototype.dataset['widgetCounter'] = (++counter).toString();
    const temp = document.createElement('div');
    temp.innerHTML = newWidget;
    temp.querySelector('input[type=hidden]').value = option.value;
    const newNode = temp.firstElementChild;

    // copy over all initial settings, so we are able to rebuild the original option if the
    // member is removed from the list later on
    for (const key in option.dataset) {
      newNode.dataset[key] = option.dataset[key];
    }
    return newNode;
  }

  /**
   * @param {Event} event
   * @private
   */
  _removeMember(event) {
    let button = event.target;
    if (button.parentNode.matches('.remove-member')) {
      button = button.parentNode;
    }
    if (button.matches('.remove-member')) {
      // see blocks.html.twig => block team_member_widget
      const element = button.parentNode.parentNode.parentNode.parentNode.parentNode;

      // re-adding the option to the select makes up for form validation errors
      // because the list would have to be re-ordered and indices need to be changed ...
      /*
      this.getPlugin('form-select').addOption(
          document.getElementById(this.usersId),
          element.dataset['display'],
          element.dataset['id'],
          element.dataset
      );
      const prototype = this._getPrototype();
      prototype.dataset['widgetCounter'] = (prototype.dataset['widgetCounter'] - 1).toString();
      */

      element.remove();
      event.stopPropagation();
      event.preventDefault();
    }
  }

  /**
   * @param {HTMLFormElement} form
   */
  destroyForm(form) {
    if (!this.supportsForm(form)) {
      return;
    }
    form.removeEventListener('click', this._removeMember);
  }
}

/***/ }),

/***/ "./assets/js/forms/KimaiTimesheetForm.js":
/*!***********************************************!*\
  !*** ./assets/js/forms/KimaiTimesheetForm.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ KimaiTimesheetForm; }
/* harmony export */ });
/* harmony import */ var luxon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! luxon */ "./node_modules/luxon/src/luxon.js");
/* harmony import */ var _KimaiFormPlugin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./KimaiFormPlugin */ "./assets/js/forms/KimaiFormPlugin.js");
/*
 * This file is part of the Kimai time-tracking app.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/*!
 * [KIMAI] KimaiEditTimesheetForm: responsible for the most important form in the application
 */



class KimaiTimesheetForm extends _KimaiFormPlugin__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * @param {HTMLFormElement} form
   * @return boolean
   */
  supportsForm(form) {
    return form.name === 'timesheet_edit_form' || form.name === 'timesheet_admin_edit_form' || form.name === 'timesheet_multi_user_edit_form';
  }

  /**
   * @param {HTMLFormElement} form
   */
  destroyForm(form) {
    if (!this.supportsForm(form)) {
      return;
    }
    if (this._beginDate !== undefined) {
      this._beginDate.removeEventListener('change', this._beginListener);
      delete this._beginListener;
      delete this._beginDate;
    }
    if (this._beginTime !== undefined) {
      this._beginTime.removeEventListener('change', this._beginListener);
      delete this._beginTime;
    }
    if (this._endTime !== undefined) {
      this._endTime.removeEventListener('change', this._endListener);
      delete this._endTime;
    }
    if (this._duration !== undefined) {
      this._duration.removeEventListener('change', this._durationListener);
      delete this._durationListener;
      delete this._duration;
    }
    if (this._durationToggle !== undefined && this._durationToggle !== null) {
      this._durationToggle.removeEventListener('change', this._durationToggleListener);
      delete this._durationToggleListener;
      delete this._durationToggle;
    }
    if (this._activity !== undefined) {
      this._activity.removeEventListener('create', this._activityListener);
      delete this._activityListener;
      delete this._activity;
    }
    if (this._project !== undefined) {
      delete this._project;
    }
  }
  activateForm(form) {
    console.log('activate form');
    if (!this.supportsForm(form)) {
      return;
    }
    const formPrefix = form.name;
    this._activity = document.getElementById(formPrefix + '_activity');
    this._project = document.getElementById(formPrefix + '_project');

    /** @param {CustomEvent} event */
    this._activityListener = event => {
      const project = this._project.value;
      /** @type {KimaiAPI} API */
      const API = this.getContainer().getPlugin('api');
      API.post(this._activity.dataset['create'], {
        name: event.detail.value,
        project: project === '' ? null : project,
        visible: true
      }, () => {
        this._project.dispatchEvent(new Event('change'));
      });
    };
    this._activity.addEventListener('create', this._activityListener);
    this._beginDate = document.getElementById(formPrefix + '_begin_date');
    this._beginTime = document.getElementById(formPrefix + '_begin_time');
    this._endTime = document.getElementById(formPrefix + '_end_time');
    this._duration = document.getElementById(formPrefix + '_duration');
    this._durationToggle = document.getElementById(formPrefix + '_duration_toggle');
    if (this._beginDate === null || this._beginTime === null || this._endTime === null || this._duration === null) {
      return;
    }
    this._beginListener = () => this._changedBegin();
    this._endListener = () => this._changedEnd();
    this._durationListener = () => this._changedDuration();
    this._beginDate.addEventListener('change', this._beginListener);
    this._beginTime.addEventListener('change', this._beginListener);
    this._endTime.addEventListener('change', this._endListener);
    this._duration.addEventListener('change', this._durationListener);
    if (this._duration !== null && this._durationToggle !== null) {
      this._durationToggleListener = () => {
        this._durationToggle.classList.toggle('text-success');
      };
      this._durationToggle.addEventListener('click', this._durationToggleListener);
    }
  }
  _isDurationConnected() {
    if (this._duration === null && this._durationToggle === null) {
      return false;
    }
    if (this._durationToggle === null) {
      return true;
    }
    return this._durationToggle.classList.contains('text-success');
  }

  /**
   * @returns {DateTime|null}
   * @private
   */
  _getBegin() {
    if (this._beginDate.value === '' || this._beginTime.value === '') {
      return null;
    }
    let date = this._parseBegin(this._beginTime.dataset['format']);
    if (date.invalid) {
      date = this._parseBegin(this._fixTimeFormat(this._beginTime.dataset['format']));
      if (date.invalid) {
        return null;
      }
    }
    return date;
  }
  _parseBegin(timeFormat) {
    return this.getDateUtils().fromFormat(this._beginDate.value + ' ' + this._beginTime.value, this._beginDate.dataset['format'] + ' ' + timeFormat);
  }
  _parseEnd(endDate, timeFormat) {
    let date = this.getDateUtils().fromFormat(endDate.toFormat('yyyy-LL-dd') + ' ' + this._endTime.value, 'yyyy-LL-dd ' + timeFormat);
    if (date.invalid) {
      date = this.getDateUtils().fromFormat(endDate.toFormat('yyyy-LL-dd') + ' ' + this._endTime.value, 'yyyy-LL-dd ' + this._fixTimeFormat(timeFormat));
    }
    return date;
  }
  _fixTimeFormat(format) {
    return format.replace('HH', 'H').replace('hh', 'h');
  }

  /**
   * @returns {DateTime|null}
   * @private
   */
  _getEnd() {
    if (this._endTime.value === '') {
      return null;
    }
    let date = this._parseEnd(luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.now(), this._endTime.dataset['format']);
    const begin = this._getBegin();
    if (begin !== null) {
      date = this._parseEnd(begin, this._endTime.dataset['format']);
      if (date < begin) {
        date = date.plus({
          days: 1
        });
      }
    }
    if (date.invalid) {
      return null;
    }
    return date;
  }

  /**
   * Ruleset:
   * - invalid begin => skip
   * - empty end => set end to begin (only if duration > 0 = running record)
   * - invalid end => skip
   * - calculate duration
   */
  _changedBegin() {
    const begin = this._getBegin();
    if (begin === null) {
      return;
    }
    const duration = this._getParsedDuration();
    const hasDuration = duration.as('seconds') > 0;
    const end = this._getEnd();
    if (end === null && hasDuration) {
      this._applyDateToField(begin.plus(duration), null, this._endTime);
    } else {
      this._updateDuration();
    }
  }

  /**
   * Ruleset:
   * - invalid end => skip
   * - empty begin => set begin to end
   * - invalid begin => skip
   * - calculate duration
   */
  _changedEnd() {
    const end = this._getEnd();
    // empty or invalid date => reset duration and stop progress
    if (end === null) {
      return;
    }
    const duration = this._getParsedDuration();
    const hasDuration = duration.as('seconds') > 0;
    const begin = this._getBegin();
    if (begin === null && hasDuration) {
      this._applyDateToField(end.minus(duration), this._beginDate, this._beginTime);
    } else {
      this._updateDuration();
    }
  }

  /**
   * @private
   */
  _updateDuration() {
    const begin = this._getBegin();
    const end = this._getEnd();
    let newDuration = null;
    if (begin !== null && end !== null) {
      newDuration = end.diff(begin);
    }
    this._setDurationAsString(newDuration);
  }

  /**
   * Ruleset:
   * - invalid duration => skip
   * - if begin and end are empty: set begin to now and end to duration
   * - if begin is empty and end is not empty: set begin to end minus duration
   * - if begin is not empty and end is empty and duration is > 0 (running records = 0): set end to begin plus duration
   */
  _changedDuration() {
    if (!this._isDurationConnected()) {
      return;
    }
    const duration = this._getParsedDuration();
    if (!duration.isValid) {
      this._setDurationAsString(null);
      return;
    }
    const begin = this._getBegin();
    let end = this._getEnd();
    const seconds = duration.as('seconds');
    if (seconds < 0) {
      end = null;
    }
    if (begin === null && end === null) {
      const newBegin = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.now();
      this._applyDateToField(newBegin, this._beginDate, this._beginTime);
      this._applyDateToField(newBegin.plus({
        seconds: seconds
      }), null, this._endTime);
    } else if (begin === null && end !== null) {
      this._applyDateToField(end.minus({
        seconds: seconds
      }), this._beginDate, this._beginTime);
    } else if (begin !== null && seconds >= 0) {
      this._applyDateToField(begin.plus({
        seconds: seconds
      }), null, this._endTime);
    }
  }

  /**
   * Writes the value of a duration object as human-readable string into the duration field
   *
   * @param {Duration|null} duration
   */
  _setDurationAsString(duration) {
    if (!this._isDurationConnected()) {
      return;
    }
    if (duration === null) {
      this._duration.value = '';
      return;
    }
    if (!duration.isValid) {
      return;
    }
    const seconds = duration.as('seconds');
    if (seconds < 0) {
      this._duration.value = '';
      return;
    }
    const hours = Math.floor(seconds / 3600);
    let minutes = Math.floor((seconds - hours * 3600) / 60);
    if (minutes < 10) {
      minutes = '0' + minutes;
    }
    this._duration.value = hours + ':' + minutes;
  }

  /**
   * Returns a duration object from the duration input field.
   *
   * @private
   * @return {Duration}
   */
  _getParsedDuration() {
    return this.getDateUtils().parseDuration(this._duration.value.toUpperCase());
  }

  /**
   * @param {DateTime|null} dateTime
   * @param {HTMLElement|null} dateField
   * @param {HTMLElement} timeField
   * @private
   */
  _applyDateToField(dateTime, dateField, timeField) {
    if (dateTime === null || dateTime.invalid) {
      dateField.value = '';
      timeField.value = '';
      return;
    }
    if (dateField !== null) {
      dateField.value = this.getDateUtils().format(dateField.dataset['format'], dateTime);
    }
    timeField.value = this.getDateUtils().format(timeField.dataset['format'], dateTime);
  }
}

/***/ }),

/***/ "./assets/js/plugins/KimaiAPI.js":
/*!***************************************!*\
  !*** ./assets/js/plugins/KimaiAPI.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ KimaiAPI; }
/* harmony export */ });
/* harmony import */ var _KimaiPlugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../KimaiPlugin */ "./assets/js/KimaiPlugin.js");
/*
 * This file is part of the Kimai time-tracking app.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/*!
 * [KIMAI] KimaiAPI: easy access to API methods
 */


class KimaiAPI extends _KimaiPlugin__WEBPACK_IMPORTED_MODULE_0__["default"] {
  getId() {
    return 'api';
  }
  _headers() {
    const headers = new Headers();
    headers.append('X-AUTH-SESSION', '1');
    headers.append('Content-Type', 'application/json');
    return headers;
  }
  get(url, data, callbackSuccess, callbackError) {
    if (data !== undefined) {
      const params = new URLSearchParams(data).toString();
      if (params !== '') {
        url = url + (url.includes('?') ? '&' : '?') + params;
      }
    }
    if (callbackError === undefined) {
      callbackError = error => {
        this.handleError('An error occurred', error);
      };
    }
    this.fetch(url, {
      method: 'GET',
      headers: this._headers()
    }).then(response => {
      response.json().then(json => {
        callbackSuccess(json);
      });
    }).catch(error => {
      callbackError(error);
    });
  }
  post(url, data, callbackSuccess, callbackError) {
    if (callbackError === undefined) {
      callbackError = error => {
        this.handleError('action.update.error', error);
      };
    }
    this.fetch(url, {
      method: 'POST',
      body: this._parseData(data),
      headers: this._headers()
    }).then(response => {
      response.json().then(json => {
        callbackSuccess(json);
      });
    }).catch(error => {
      callbackError(error);
    });
  }
  patch(url, data, callbackSuccess, callbackError) {
    if (callbackError === undefined) {
      callbackError = error => {
        this.handleError('action.update.error', error);
      };
    }
    this.fetch(url, {
      method: 'PATCH',
      body: this._parseData(data),
      headers: this._headers()
    }).then(response => {
      if (response.statusCode === 204) {
        callbackSuccess();
      } else {
        response.json().then(json => {
          callbackSuccess(json);
        });
      }
    }).catch(error => {
      callbackError(error);
    });
  }
  delete(url, callbackSuccess, callbackError) {
    if (callbackError === undefined) {
      callbackError = error => {
        this.handleError('action.delete.error', error);
      };
    }
    this.fetch(url, {
      method: 'DELETE',
      headers: this._headers()
    }).then(() => {
      callbackSuccess();
    }).catch(error => {
      callbackError(error);
    });
  }

  /**
   * @param {string|object} data
   * @returns {string}
   * @private
   */
  _parseData(data) {
    if (typeof data === 'object') {
      return JSON.stringify(data);
    }
    return data;
  }

  /**
   * @param {string} message
   * @param {Response} response
   */
  handleError(message, response) {
    if (response.headers === undefined) {
      // this can happen if someone clicks to fast and auto running
      // requests (e.g. active records) are aborted
      return;
    }
    const contentType = response.headers.get("content-type");
    if (contentType && contentType.indexOf("application/json") !== -1) {
      response.json().then(data => {
        let resultError = data.message;
        // find validation errors
        if (response.status === 400 && data.errors) {
          let collected = ['<u>' + resultError + '</u>'];
          // form errors that are not attached to a field (like extra fields)
          if (data.errors.errors) {
            for (let error of data.errors.errors) {
              collected.push(error);
            }
          }
          if (data.errors.children) {
            for (let field in data.errors.children) {
              let tmpField = data.errors.children[field];
              if (tmpField.errors !== undefined && tmpField.errors.length > 0) {
                for (let error of tmpField.errors) {
                  collected.push(error);
                }
              }
            }
          }
          if (collected.length > 0) {
            resultError = collected;
          }
        }
        this.getPlugin('alert').error(message, resultError);
      });
    } else {
      response.text().then(() => {
        const resultError = '[' + response.statusCode + '] ' + response.statusText;
        this.getPlugin('alert').error(message, resultError);
      });
    }
  }
}

/***/ }),

/***/ "./assets/js/plugins/KimaiAPILink.js":
/*!*******************************************!*\
  !*** ./assets/js/plugins/KimaiAPILink.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ KimaiAPILink; }
/* harmony export */ });
/* harmony import */ var _KimaiPlugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../KimaiPlugin */ "./assets/js/KimaiPlugin.js");
/*
 * This file is part of the Kimai time-tracking app.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */



/**
 * Needs to be initialized with a class name.
 *
 * A link like <a href=# class=remoteLink> can be activated with:
 * new KimaiAPILink('remoteLink')
 *
 * Allows to assign the given selector to any element, which then is used as click-handler
 * calling an API method and trigger the event from data-event attribute afterwards.
 *
 * @param selector
 */
class KimaiAPILink extends _KimaiPlugin__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(selector) {
    super();
    this._selector = selector;
  }
  init() {
    document.addEventListener('click', event => {
      let target = event.target;
      while (target !== null && typeof target.matches === "function" && !target.matches('body')) {
        if (target.classList.contains(this._selector)) {
          const attributes = target.dataset;
          let url = attributes['href'];
          if (!url) {
            url = target.getAttribute('href');
          }
          if (attributes.question !== undefined) {
            this.getContainer().getPlugin('alert').question(attributes.question, value => {
              if (value) {
                this._callApi(url, attributes);
              }
            });
          } else {
            this._callApi(url, attributes);
          }
          event.preventDefault();
          event.stopPropagation();
        }
        target = target.parentNode;
      }
    });
  }

  /**
   * @param {string} url
   * @param {DOMStringMap} attributes
   * @private
   */
  _callApi(url, attributes) {
    const method = attributes['method'];
    const eventName = attributes['event'];
    /** @type {KimaiAPI} API */
    const API = this.getContainer().getPlugin('api');
    /** @type {KimaiEvent} EVENTS */
    const EVENTS = this.getContainer().getPlugin('event');
    /** @type {KimaiAlert} ALERT */
    const ALERT = this.getContainer().getPlugin('alert');
    const successHandle = () => {
      EVENTS.trigger(eventName);
      if (attributes['msgSuccess'] !== undefined) {
        ALERT.success(attributes['msgSuccess']);
      }
    };
    const errorHandle = error => {
      let message = 'action.update.error';
      if (attributes['msgError'] !== undefined) {
        message = attributes['msgError'];
      }
      API.handleError(message, error);
    };
    let data = {};
    if (attributes['payload'] !== undefined) {
      data = attributes['payload'];
    }
    if (method === 'PATCH') {
      API.patch(url, data, successHandle, errorHandle);
    } else if (method === 'POST') {
      let data = {};
      API.post(url, data, successHandle, errorHandle);
    } else if (method === 'DELETE') {
      API.delete(url, successHandle, errorHandle);
    } else if (method === 'GET') {
      API.get(url, data, successHandle, errorHandle);
    }
  }
}

/***/ }),

/***/ "./assets/js/plugins/KimaiActiveRecords.js":
/*!*************************************************!*\
  !*** ./assets/js/plugins/KimaiActiveRecords.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ KimaiActiveRecords; }
/* harmony export */ });
/* harmony import */ var _KimaiPlugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../KimaiPlugin */ "./assets/js/KimaiPlugin.js");
/*
 * This file is part of the Kimai time-tracking app.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/*!
 * [KIMAI] KimaiActiveRecords: responsible to display the users active records
 */


class KimaiActiveRecords extends _KimaiPlugin__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor() {
    super();
    this._selector = '.ticktac-menu';
    this._selectorEmpty = '.ticktac-menu-empty';
    this._favIconUrl = null;
  }

  /**
   * @returns {string}
   */
  getId() {
    return 'active-records';
  }
  init() {
    // the menu can be hidden if user has no permissions to see it
    if (document.querySelector(this._selector) === null) {
      return;
    }
    const handleUpdate = () => {
      this.reloadActiveRecords();
    };
    document.addEventListener('kimai.timesheetUpdate', handleUpdate);
    document.addEventListener('kimai.timesheetDelete', handleUpdate);
    document.addEventListener('kimai.activityUpdate', handleUpdate);
    document.addEventListener('kimai.activityDelete', handleUpdate);
    document.addEventListener('kimai.projectUpdate', handleUpdate);
    document.addEventListener('kimai.projectDelete', handleUpdate);
    document.addEventListener('kimai.customerUpdate', handleUpdate);
    document.addEventListener('kimai.customerDelete', handleUpdate);

    // -----------------------------------------------------------------------
    // handle duration in the visible UI
    this._updateBrowserTitle = !!this.getConfiguration('updateBrowserTitle');
    const handle = () => {
      this._updateDuration();
    };
    this._updatesHandler = setInterval(handle, 10000);
    document.addEventListener('kimai.timesheetUpdate', handle);
    document.addEventListener('kimai.reloadedContent', handle);
  }

  // TODO we could unregister all handler and listener
  // _unregisterHandler() {
  //     clearInterval(this._updatesHandler);
  // }

  /**
   * Updates the duration of all running entries, both in the ticktac menus and in the listing pages.
   *
   * @private
   */
  _updateDuration() {
    // needs to search in document, to find all running entries, both in "ticktac" and listing pages
    const activeRecords = document.querySelectorAll('[data-since]:not([data-since=""])');
    if (this._updateBrowserTitle) {
      this._changeFavicon(activeRecords.length > 0);
    }
    if (activeRecords.length === 0) {
      if (this._updateBrowserTitle) {
        if (document.body.dataset['title'] === undefined) {
          this._updateBrowserTitle = false;
        } else {
          document.title = document.body.dataset['title'];
        }
      }
      return;
    }
    const DATE = this.getDateUtils();
    let durations = [];
    for (const record of activeRecords) {
      const duration = DATE.formatDuration(record.dataset['since']);
      // only use the ones from the menu for the title
      if (record.dataset['replacer'] !== undefined && record.dataset['title'] !== null && duration !== '?') {
        durations.push(duration);
      }
      // but update all on the page (running entries in list pages)
      record.textContent = duration;
    }
    if (durations.length === 0) {
      return;
    }
    if (this._updateBrowserTitle) {
      // only show the first found record, even if we have more
      document.title = durations.shift();
    }
  }

  /**
   * Adapts the ticktac menus according to the given entries (amount and duration).
   * Does not influence listing pages, as those refresh themselves.
   *
   * @param {array} entries
   * @private
   */
  _setEntries(entries) {
    const hasEntries = entries.length > 0;

    // these contain the "start" button
    for (let menuEmpty of document.querySelectorAll(this._selectorEmpty)) {
      menuEmpty.style.display = !hasEntries ? 'inline-block' : 'none';
    }

    // and they contain the "stop" button
    for (let menu of document.querySelectorAll(this._selector)) {
      menu.style.display = hasEntries ? 'inline-block' : 'none';
      if (!hasEntries) {
        // make sure that template entries in the menu are removed, otherwise they
        // might still be shown in the browsers title
        for (let record of menu.querySelectorAll('[data-since]')) {
          record.dataset['since'] = '';
        }
      }
      const stop = menu.querySelector('.ticktac-stop');
      if (!hasEntries) {
        if (stop) {
          stop.accesskey = null;
        }
        continue;
      }
      if (stop) {
        stop.accesskey = 's';
      }
      this._replaceInNode(menu, entries[0]);
    }
    this._updateDuration();
  }

  /**
   * @param {HTMLElement} node
   * @param {object} timesheet
   * @private
   */
  _replaceInNode(node, timesheet) {
    const date = this.getDateUtils();
    const allReplacer = node.querySelectorAll('[data-replacer]');
    for (let link of allReplacer) {
      const replacerName = link.dataset['replacer'];
      console.log(`replacerName: ${replacerName}`);
      if (replacerName === 'url') {
        link.dataset['href'] = node.dataset['href'].replace('000', timesheet.id);
      } else if (replacerName === 'activity') {
        link.innerText = timesheet.activity.name;
      } else if (replacerName === 'project') {
        link.innerText = timesheet.project.name;
      } else if (replacerName === 'customer') {
        link.innerText = timesheet.project.customer.name;
      } else if (replacerName === 'duration') {
        link.dataset['since'] = timesheet.begin;
        link.innerText = date.formatDuration(timesheet.duration);
      }
    }
  }
  reloadActiveRecords() {
    /** @type {KimaiAPI} API */
    const API = this.getContainer().getPlugin('api');

    // TODO using the first found "ticktac" menu is working, but can be done better
    const apiUrl = document.querySelector(this._selector).dataset['api'];
    API.get(apiUrl, {}, result => {
      this._setEntries(result);
    });
  }

  /**
   * @param {boolean} running
   * @private
   */
  _changeFavicon(running) {
    const canvas = document.createElement('canvas');
    const orig = document.getElementById('favicon');
    if (this._favIconUrl === null) {
      this._favIconUrl = orig.href;
    }
    const link = orig.cloneNode(true);
    if (canvas.getContext && link) {
      const ratio = window.devicePixelRatio;
      const img = document.createElement('img');
      canvas.height = canvas.width = 16 * ratio;
      img.onload = function () {
        const ctx = canvas.getContext('2d');
        ctx.drawImage(this, 0, 0, canvas.width, canvas.height);
        if (running) {
          const width = 5.5 * ratio;
          ctx.fillStyle = 'rgb(182,57,57)';
          ctx.fillRect(canvas.width / 2 - width / 2, canvas.height / 2 - width / 2, width, width);
        }
        link.href = canvas.toDataURL('image/png');
        orig.remove();
        document.head.appendChild(link);
      };
      img.src = this._favIconUrl;
    }
  }
}

/***/ }),

/***/ "./assets/js/plugins/KimaiAjaxModalForm.js":
/*!*************************************************!*\
  !*** ./assets/js/plugins/KimaiAjaxModalForm.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ KimaiAjaxModalForm; }
/* harmony export */ });
/* harmony import */ var _KimaiReducedClickHandler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./KimaiReducedClickHandler */ "./assets/js/plugins/KimaiReducedClickHandler.js");
/* harmony import */ var bootstrap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bootstrap */ "./node_modules/bootstrap/dist/js/bootstrap.esm.js");
/*
 * This file is part of the Kimai time-tracking app.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/*!
 * [KIMAI] KimaiAjaxModalForm
 *
 * allows to assign the given selector to any element, which then is used as click-handler:
 * opening a modal with the content from the URL given in the elements 'data-href' or 'href' attribute
 */



class KimaiAjaxModalForm extends _KimaiReducedClickHandler__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(selector) {
    super();
    this._selector = selector;
  }
  getId() {
    return 'modal';
  }
  init() {
    this._isDirty = false;
    const modalElement = this._getModalElement();
    if (modalElement === null) {
      return;
    }
    modalElement.addEventListener('hide.bs.modal', event => {
      if (this._isDirty) {
        if (modalElement.querySelector('.modal-body .remote_modal_is_dirty_warning') === null) {
          const msg = this.translate('modal.dirty');
          const temp = document.createElement('div');
          temp.innerHTML = '<p class="text-danger small remote_modal_is_dirty_warning">' + msg + '</p>';
          modalElement.querySelector('.modal-body').prepend(temp.firstElementChild);
        }
        event.preventDefault();
        return;
      }
      this._isDirty = false;
      document.dispatchEvent(new Event('modal-hide'));
    });
    modalElement.addEventListener('hidden.bs.modal', () => {
      // kill all references, so GC can kick in
      this.getContainer().getPlugin('form').destroyForm(this._getFormIdentifier());
      modalElement.querySelector('.modal-body').replaceWith('');
    });
    modalElement.addEventListener('show.bs.modal', () => {
      document.dispatchEvent(new Event('modal-show'));
    });
    this.addClickHandler(this._selector, href => {
      this.openUrlInModal(href);
    });
  }
  _getModal() {
    return bootstrap__WEBPACK_IMPORTED_MODULE_1__.Modal.getOrCreateInstance(this._getModalElement());
  }

  /**
   * @param {string} url
   * @param {function(Response)} error the callback to execute if the fetch failed
   */
  openUrlInModal(url, error) {
    const headers = new Headers();
    headers.append('X-Requested-With', 'Kimai-Modal');
    this.fetch(url, {
      method: 'GET',
      redirect: 'follow',
      headers: headers
    }).then(response => {
      if (!response.ok) {
        window.location = url;
        return;
      }
      return response.text().then(html => {
        this._openFormInModal(html);
      });
    }).catch(reason => {
      if (error === undefined || error === null) {
        window.location = url;
      } else {
        error(reason);
      }
    });
  }

  /**
   * Returns the CSS selector for the modal form.
   * 
   * @returns {string}
   * @private
   */
  _getFormIdentifier() {
    return '#remote_form_modal .modal-content form';
  }

  /**
   * @returns {HTMLElement|null}
   * @private
   */
  _getModalElement() {
    return document.getElementById('remote_form_modal');
  }

  /**
   * @param {Element|ChildNode} node
   * @returns {Element}
   * @private
   */
  _makeScriptExecutable(node) {
    if (node.tagName !== undefined && node.tagName === 'SCRIPT') {
      const script = document.createElement('script');
      script.text = node.innerHTML;
      node.parentNode.replaceChild(script, node);
    } else {
      for (const child of node.childNodes) {
        this._makeScriptExecutable(child);
      }
    }
    return node;
  }
  _openFormInModal(html) {
    const formIdentifier = this._getFormIdentifier();
    let remoteModal = this._getModalElement();
    const newFormHtml = document.createElement('div');
    newFormHtml.innerHTML = html;
    const newModalContent = this._makeScriptExecutable(newFormHtml.querySelector('#form_modal .modal-content'));

    // load new form from given content
    if (newModalContent !== null) {
      // Support changing modal sizes
      let modalDialog = remoteModal.querySelector('.modal-dialog');
      let largeModal = newFormHtml.querySelector('.modal-dialog').classList.contains('modal-lg');
      if (largeModal && !modalDialog.classList.contains('modal-lg')) {
        modalDialog.classList.toggle('modal-lg');
      }
      if (!largeModal && modalDialog.classList.contains('modal-lg')) {
        modalDialog.classList.toggle('modal-lg');
      }
      remoteModal.querySelector('.modal-content').replaceWith(newModalContent);
      [].slice.call(remoteModal.querySelectorAll('[data-bs-dismiss="modal"]')).map(element => {
        element.addEventListener('click', () => {
          this._isDirty = false;
          this._getModal().hide();
        });
      });

      // activate new loaded widgets
      this.getContainer().getPlugin('form').activateForm(formIdentifier);
    }

    // show error flash messages
    let flashMessages = newFormHtml.querySelector('div.alert');
    if (flashMessages !== null) {
      remoteModal.querySelector('.modal-body').prepend(flashMessages);
    }

    // the new form that was loaded via ajax
    const form = document.querySelector(formIdentifier);
    form.addEventListener('change', () => {
      this._isDirty = true;
    });

    // click handler for modal save button, to send forms via ajax
    form.addEventListener('submit', this._getEventHandler());
    this._getModal().show();
  }
  _getEventHandler() {
    if (this.eventHandler === undefined) {
      this.eventHandler = event => {
        const form = event.target;

        // if the form has a target, we let the normal HTML flow happen
        if (form.target !== undefined && form.target !== '') {
          return true;
        }

        // otherwise we do some AJAX magic to process the form in the background
        /** @type {HTMLButtonElement} btn */
        const btn = document.querySelector(this._getFormIdentifier() + ' button[type=submit]');
        btn.textContent = btn.textContent + ' …';
        btn.disabled = true;
        const eventName = form.dataset['formEvent'];
        /** @type {KimaiEvent} alert */
        const events = this.getContainer().getPlugin('event');
        /** @type {KimaiAlert} alert */
        const alert = this.getContainer().getPlugin('alert');
        event.preventDefault();
        event.stopPropagation();
        const headers = new Headers();
        headers.append('X-Requested-With', 'Kimai-Modal');
        const options = {
          headers: headers
        };
        this.fetchForm(form, options).then(response => {
          response.text().then(html => {
            /** @type {HTMLDivElement} responseHtml */
            const responseHtml = document.createElement('div');
            responseHtml.innerHTML = html;
            let hasFieldError = false;
            let hasFormError = false;
            let hasFlashError = false;

            // button must be re-enabled anyway
            btn.textContent = btn.textContent.replace(' …', '');
            btn.disabled = false;

            // if the request was successful, there will be no form
            /** @type {Element} modalContent */
            const modalContent = responseHtml.querySelector('#form_modal .modal-content');
            if (modalContent !== null) {
              hasFieldError = modalContent.querySelector('.is-invalid') !== null;
              if (!hasFieldError) {
                // happens when an error occurs for a "hidden or non-classical" form element e.g. creating team without users
                hasFieldError = modalContent.querySelector('.invalid-feedback') !== null;
              }
              hasFormError = modalContent.querySelector('ul.list-unstyled li.text-danger') !== null;
              hasFlashError = responseHtml.querySelector('div.alert-danger') !== null;
            }
            if (hasFieldError || hasFormError || hasFlashError) {
              this._openFormInModal(html);
            } else {
              events.trigger(eventName);

              // try to find form defined message first, but
              let msg = form.dataset['msgSuccess'];
              // if that is not available: use a generic fallback message
              if (msg === null || msg === undefined || msg === '') {
                msg = 'action.update.success';
              }
              this._isDirty = false;
              this._getModal().hide();
              alert.success(msg);
            }
          });
        }).catch(error => {
          let message = form.dataset['msgError'];
          if (message === null || message === undefined || message === '') {
            message = 'action.update.error';
          }
          alert.error(message, error.message);

          // this is useful for changing form fields and retrying to save (and in development to test form changes)
          setTimeout(() => {
            // critical error, allow to re-submit?
            btn.textContent = btn.textContent.replace(' …', '');
            btn.disabled = false;
          }, 1500);
        });
      };
    }
    return this.eventHandler;
  }
}

/***/ }),

/***/ "./assets/js/plugins/KimaiAlert.js":
/*!*****************************************!*\
  !*** ./assets/js/plugins/KimaiAlert.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ KimaiAlert; }
/* harmony export */ });
/* harmony import */ var _KimaiPlugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../KimaiPlugin */ "./assets/js/KimaiPlugin.js");
/* harmony import */ var bootstrap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bootstrap */ "./node_modules/bootstrap/dist/js/bootstrap.esm.js");
/*
 * This file is part of the Kimai time-tracking app.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/*!
 * [KIMAI] KimaiAlert: notifications for Kimai
 */



class KimaiAlert extends _KimaiPlugin__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @return {string}
   */
  getId() {
    return 'alert';
  }

  /**
   * @param {string} title
   * @param {string|array|undefined} message
   */
  error(title, message) {
    const translation = this.getTranslation();
    if (translation.has(title)) {
      title = translation.get(title);
    }
    title = title.replace('%reason%', '');
    if (message === undefined) {
      message = null;
    }
    if (message !== null) {
      if (translation.has(message)) {
        message = translation.get(message);
      }
      if (Array.isArray(message)) {
        message = message.join('<br>');
      }
    }
    const id = 'alert_global_error';
    const oldModalElement = document.getElementById(id);
    if (oldModalElement !== null) {
      bootstrap__WEBPACK_IMPORTED_MODULE_1__.Modal.getOrCreateInstance(oldModalElement).hide();
    }
    const html = `
            <div class="modal modal-blur fade" id="` + id + `" tabindex="-1" role="dialog">
                <div class="modal-dialog modal-sm modal-dialog-centered" role="document">
                    <div class="modal-content">
                        <div class="modal-status bg-` + this._mapClass('danger') + `"></div>
                        <div class="modal-body text-center py-4">
                            <i class="fas fa-exclamation-circle fa-3x mb-3 text-danger"></i>
                            <h2>` + title + `</h2>
                            ` + (message !== null ? '<div class="text-muted">' + message + '</div>' : '') + `
                        </div>
                        <div class="modal-footer">
                            <div class="w-100">
                                <div class="row">
                                    <div class="col text-center"><a href="#" class="btn btn-primary" data-bs-dismiss="modal">` + translation.get('close') + `</a></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        `;
    this._showModal(html);
  }

  /**
   * @param {string} message
   */
  warning(message) {
    this._show('warning', message);
  }

  /**
   * @param {string} message
   */
  success(message) {
    this._toast('success', message);
  }

  /**
   * @param {string} message
   */
  info(message) {
    this._show('info', message);
  }

  /**
   * @param {string} html
   * @private
   */
  _showModal(html) {
    const container = document.body;
    const template = document.createElement('template');
    template.innerHTML = html.trim();
    const element = template.content.firstChild;
    container.appendChild(element);
    const modal = new bootstrap__WEBPACK_IMPORTED_MODULE_1__.Modal(element);
    element.addEventListener('hidden.bs.modal', function () {
      container.removeChild(element);
    });
    modal.show();
  }

  /**
   * @param {string} type
   * @param {string} message
   * @private
   */
  _show(type, message) {
    const translation = this.getTranslation();
    if (translation.has(message)) {
      message = translation.get(message);
    }
    const html = `
            <div class="modal modal-blur fade" tabindex="-1" role="dialog">
                <div class="modal-dialog modal-sm modal-dialog-centered" role="document">
                    <div class="modal-content">
                        <div class="modal-status bg-` + this._mapClass(type) + `"></div>
                        <div class="modal-body text-center py-4">
                            <i class="fas fa-exclamation-circle fa-3x mb-3 text-` + this._mapClass(type) + `"></i>
                            <h2>` + message + `</h2>
                        </div>
                        <div class="modal-footer">
                            <div class="w-100">
                                <div class="row">
                                    <div class="col text-center"><a href="#" class="btn btn-primary" data-bs-dismiss="modal">` + translation.get('close') + `</a></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        `;
    this._showModal(html);
  }

  /**
   * @param {string} type
   * @return {string}
   * @private
   */
  _mapClass(type) {
    if (type === 'info' || type === 'success' || type === 'warning' || type === 'danger') {
      return type;
    } else if (type === 'error') {
      return 'danger';
    }
    return 'primary';
  }

  /**
   * @param type
   * @param message
   * @private
   */
  _toast(type, message) {
    const translation = this.getTranslation();
    if (translation.has(message)) {
      message = translation.get(message);
    }
    let icon = '<i class="fas fa-info me-2"></i>';
    if (type === 'success') {
      icon = '<i class="fas fa-check me-2"></i>';
    } else if (type === 'warning') {
      icon = '<i class="fas fa-exclamation me-2"></i>';
    } else if (type === 'danger' || type === 'error') {
      icon = '<i class="fas fa-exclamation-circle me-2"></i>';
    }
    const html = `<div class="toast align-items-center text-white bg-` + this._mapClass(type) + ` border-0" data-bs-delay="2000" role="alert" aria-live="assertive" aria-atomic="true">
            <div class="d-flex">
                <div class="toast-body">
                    ` + icon + ' ' + message + `
                </div>
                <button type="button" class="btn-close me-2 m-auto" data-bs-dismiss="toast" aria-label="` + translation.get('close') + `"></button>
            </div>
        </div>`;
    const container = document.getElementById('toast-container');
    const template = document.createElement('template');
    template.innerHTML = html.trim();
    const element = template.content.firstChild;
    container.appendChild(element);
    const toast = new bootstrap__WEBPACK_IMPORTED_MODULE_1__.Toast(element);
    element.addEventListener('hidden.bs.toast', function () {
      container.removeChild(element);
    });
    toast.show();
  }

  /**
   * Callback receives a bool value (true = confirm, false = cancel / close without action).
   *
   * @param message
   * @param callback
   */
  question(message, callback) {
    const translation = this.getTranslation();
    if (translation.has(message)) {
      message = translation.get(message);
    }
    const css = this._mapClass('info');
    const html = `
            <div class="modal modal-blur fade" tabindex="-1" role="dialog" data-bs-backdrop="static">
                <div class="modal-dialog modal-sm modal-dialog-centered" role="document">
                    <div class="modal-content">
                        <div class="modal-status bg-` + css + `"></div>
                        <div class="modal-body text-center py-4">
                            <i class="fas fa-question fa-3x mb-3 text-` + css + `"></i>
                            <h2>` + message + `</h2>
                        </div>
                        <div class="modal-footer">
                            <div class="w-100">
                                <div class="row">
                                    <div class="col"><a href="#" class="question-confirm btn btn-primary w-100" data-bs-dismiss="modal">` + translation.get('confirm') + `</a></div>
                                    <div class="col"><a href="#" class="question-cancel btn w-100" data-bs-dismiss="modal">` + translation.get('cancel') + `</a></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        `;
    const container = document.body;
    const template = document.createElement('template');
    template.innerHTML = html.trim();
    const element = template.content.firstChild;
    container.appendChild(element);
    element.querySelector('.question-confirm').addEventListener('click', () => {
      callback(true);
    });
    element.querySelector('.question-cancel').addEventListener('click', () => {
      callback(false);
    });
    const modal = new bootstrap__WEBPACK_IMPORTED_MODULE_1__.Modal(element);
    element.addEventListener('hidden.bs.modal', () => {
      container.removeChild(element);
    });
    modal.show();
  }
}

/***/ }),

/***/ "./assets/js/plugins/KimaiAlternativeLinks.js":
/*!****************************************************!*\
  !*** ./assets/js/plugins/KimaiAlternativeLinks.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ KimaiAlternativeLinks; }
/* harmony export */ });
/* harmony import */ var _KimaiReducedClickHandler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./KimaiReducedClickHandler */ "./assets/js/plugins/KimaiReducedClickHandler.js");
/*
 * This file is part of the Kimai time-tracking app.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/*!
 * [KIMAI] KimaiAlternativeLinks
 *
 * allows to assign the given selector to any element, which then is used as click-handler
 * redirecting to the URL given in the elements 'data-href' or 'href' attribute
 */


class KimaiAlternativeLinks extends _KimaiReducedClickHandler__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(selector) {
    super();
    this._selector = selector;
  }
  init() {
    this.addClickHandler(this._selector, function (href) {
      window.location = href;
    });
  }
}

/***/ }),

/***/ "./assets/js/plugins/KimaiConfirmationLink.js":
/*!****************************************************!*\
  !*** ./assets/js/plugins/KimaiConfirmationLink.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ KimaiConfirmationLink; }
/* harmony export */ });
/* harmony import */ var _KimaiPlugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../KimaiPlugin */ "./assets/js/KimaiPlugin.js");
/*
 * This file is part of the Kimai time-tracking app.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */



/**
 * Needs to be initialized with a class name.
 *
 * Allows to assign the given selector to any element, which then is used as click-handler
 * calling an API method and trigger the event from data-event attribute afterwards.
 *
 * @param selector
 */
class KimaiConfirmationLink extends _KimaiPlugin__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(selector) {
    super();
    this._selector = selector;
  }
  init() {
    document.addEventListener('click', event => {
      let target = event.target;
      while (target !== null && typeof target.matches === "function" && !target.matches('body')) {
        if (target.classList.contains(this._selector)) {
          const attributes = target.dataset;

          // is this a link? 
          let url = attributes['href'];
          // or another HTML element with a custom href 
          if (!url) {
            url = target.getAttribute('href');
          }

          // or is this a button?
          let form = null;
          if (target.type === 'submit' && target.form !== undefined) {
            form = target.form;
          }
          if (attributes.question !== undefined) {
            this.getContainer().getPlugin('alert').question(attributes.question, function (value) {
              if (value) {
                if (form === null) {
                  document.location = url;
                } else {
                  if (url !== null) {
                    form.action = url;
                  }
                  form.submit();
                }
              }
            });
          }
          event.preventDefault();
          event.stopPropagation();
        }
        target = target.parentNode;
      }
    });
  }
}

/***/ }),

/***/ "./assets/js/plugins/KimaiDatatable.js":
/*!*********************************************!*\
  !*** ./assets/js/plugins/KimaiDatatable.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ KimaiDatatable; }
/* harmony export */ });
/* harmony import */ var _KimaiPlugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../KimaiPlugin */ "./assets/js/KimaiPlugin.js");
/* harmony import */ var _widgets_KimaiContextMenu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../widgets/KimaiContextMenu */ "./assets/js/widgets/KimaiContextMenu.js");
/*
 * This file is part of the Kimai time-tracking app.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/*!
 * [KIMAI] KimaiDatatable: handles functionality for the datatable
 */



class KimaiDatatable extends _KimaiPlugin__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(contentAreaSelector, tableSelector) {
    super();
    this._contentArea = contentAreaSelector;
    this._selector = tableSelector;
  }
  getId() {
    return 'datatable';
  }
  init() {
    const dataTable = document.querySelector(this._selector);

    // not every page contains a dataTable
    if (dataTable === null) {
      return;
    }
    this.registerContextMenu(this._selector);
    const events = dataTable.dataset['reloadEvent'];
    if (events === undefined) {
      return;
    }
    const handle = () => {
      this.reloadDatatable();
    };
    for (let eventName of events.split(' ')) {
      document.addEventListener(eventName, handle);
    }
    document.addEventListener('pagination-change', handle);
    document.addEventListener('filter-change', handle);
  }

  /**
   * @param {string} selector
   * @private
   */
  registerContextMenu(selector) {
    _widgets_KimaiContextMenu__WEBPACK_IMPORTED_MODULE_1__["default"].createForDataTable(selector);
  }
  reloadDatatable() {
    const toolbarSelector = this.getContainer().getPlugin('toolbar').getSelector();

    /** @type {HTMLFormElement} form */
    const form = document.querySelector(toolbarSelector);
    const callback = text => {
      const temp = document.createElement('div');
      temp.innerHTML = text;
      const newContent = temp.querySelector(this._contentArea);
      document.querySelector(this._contentArea).replaceWith(newContent);
      this.registerContextMenu(this._selector);
      document.dispatchEvent(new Event('kimai.reloadedContent'));
    };
    document.dispatchEvent(new CustomEvent('kimai.reloadContent', {
      detail: this._contentArea
    }));
    if (form === null) {
      this.fetch(document.location).then(response => {
        response.text().then(callback);
      }).catch(() => {
        document.location.reload();
      });
      return;
    }
    this.fetchForm(form).then(response => {
      response.text().then(callback);
    }).catch(() => {
      form.submit();
    });
  }
}

/***/ }),

/***/ "./assets/js/plugins/KimaiDatatableColumnView.js":
/*!*******************************************************!*\
  !*** ./assets/js/plugins/KimaiDatatableColumnView.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ KimaiDatatableColumnView; }
/* harmony export */ });
/* harmony import */ var _KimaiPlugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../KimaiPlugin */ "./assets/js/KimaiPlugin.js");
/*
 * This file is part of the Kimai time-tracking app.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/*!
 * [KIMAI] KimaiDatatableColumnView: manages the visibility of data-table columns in cookies
 */


class KimaiDatatableColumnView extends _KimaiPlugin__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(dataAttribute) {
    super();
    this.dataAttribute = dataAttribute;
  }
  getId() {
    return 'datatable-column-visibility';
  }
  init() {
    let dataTable = document.querySelector('[' + this.dataAttribute + ']');
    if (dataTable === null) {
      return;
    }
    this._id = dataTable.getAttribute(this.dataAttribute);
    this._modal = document.getElementById('modal_' + this._id);
    this._modal.addEventListener('show.bs.modal', () => {
      this._evaluateCheckboxes();
    });
    this._modal.querySelector('button[data-type=save]').addEventListener('click', () => {
      this._saveVisibility();
    });
    this._modal.querySelector('button[data-type=reset]').addEventListener('click', event => {
      this._resetVisibility(event.currentTarget);
    });
    this._modal.querySelectorAll('input[name=datatable_profile]').forEach(element => {
      element.addEventListener('change', () => {
        const form = this._modal.getElementsByTagName('form')[0];
        this.fetchForm(form, {}, element.getAttribute('data-href')).then(() => {
          // the local storage is read in the login screen to set a cookie,
          // which triggers the session switch in ProfileSubscriber
          localStorage.setItem('kimai_profile', element.getAttribute('value'));
          document.location.reload();
        }).catch(() => {
          form.setAttribute('action', element.getAttribute('data-href'));
          form.submit();
        });
      });
    });
    for (let checkbox of this._modal.querySelectorAll('form input[type=checkbox]')) {
      checkbox.addEventListener('change', () => {
        this._changeVisibility(checkbox.getAttribute('name'), checkbox.checked);
      });
    }
  }
  _evaluateCheckboxes() {
    const form = this._modal.getElementsByTagName('form')[0];
    const table = document.getElementsByClassName('datatable_' + this._id)[0];
    for (let columnElement of table.getElementsByTagName('th')) {
      const fieldName = columnElement.getAttribute('data-field');
      if (fieldName === null) {
        continue;
      }
      const checkbox = form.querySelector('input[name=' + fieldName + ']');
      if (checkbox === null) {
        continue;
      }
      checkbox.checked = window.getComputedStyle(columnElement).display !== 'none';
    }
  }
  _saveVisibility() {
    const form = this._modal.getElementsByTagName('form')[0];
    this.fetchForm(form).then(() => {
      document.location.reload();
    }).catch(() => {
      form.submit();
    });
  }
  _resetVisibility(button) {
    const form = this._modal.getElementsByTagName('form')[0];
    this.fetchForm(form, {}, button.getAttribute('formaction')).then(() => {
      document.location.reload();
    }).catch(() => {
      form.setAttribute('action', button.getAttribute('formaction'));
      form.submit();
    });
  }
  _changeVisibility(columnName, checked) {
    for (const tableBox of document.getElementsByClassName('datatable_' + this._id)) {
      let targetClasses = null;
      for (let element of tableBox.getElementsByClassName('col_' + columnName)) {
        // only calculate that once and re-use the cached class list
        if (targetClasses === null) {
          let removeClass = '-none';
          let addClass = 'd-table-cell';
          if (!checked) {
            removeClass = '-table-cell';
            addClass = 'd-none';
          }
          targetClasses = '';
          element.classList.forEach(function (name, index, listObj) {
            // eslint-disable-line no-unused-vars
            if (name.indexOf(removeClass) === -1) {
              targetClasses += ' ' + name;
            }
          });
          if (targetClasses.indexOf(addClass) === -1) {
            targetClasses += ' ' + addClass;
          }
        }
        element.className = targetClasses;
      }
    }
  }
}

/***/ }),

/***/ "./assets/js/plugins/KimaiDateUtils.js":
/*!*********************************************!*\
  !*** ./assets/js/plugins/KimaiDateUtils.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ KimaiDateUtils; }
/* harmony export */ });
/* harmony import */ var _KimaiPlugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../KimaiPlugin */ "./assets/js/KimaiPlugin.js");
/* harmony import */ var luxon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! luxon */ "./node_modules/luxon/src/luxon.js");
/*
 * This file is part of the Kimai time-tracking app.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/*!
 * [KIMAI] KimaiDateUtils: responsible for handling date specific tasks
 */



class KimaiDateUtils extends _KimaiPlugin__WEBPACK_IMPORTED_MODULE_0__["default"] {
  getId() {
    return 'date';
  }
  init() {
    if (this.getConfigurations().is24Hours()) {
      this.timeFormat = 'HH:mm';
    } else {
      this.timeFormat = 'hh:mm a';
    }
    this.durationFormat = this.getConfiguration('formatDuration');
    this.dateFormat = this.getConfiguration('formatDate');
  }

  /**
   * @see https://moment.github.io/luxon/#/formatting?id=table-of-tokens
   * @param {string} format
   * @returns {string}
   * @private
   */
  _parseFormat(format) {
    format = format.replace('DD', 'dd');
    format = format.replace('D', 'd');
    format = format.replace('MM', 'LL');
    format = format.replace('M', 'L');
    format = format.replace('YYYY', 'yyyy');
    format = format.replace('YY', 'yy');
    format = format.replace('A', 'a');
    return format;
  }

  /**
   * @param {string} format
   * @param {string|Date|null|undefined} dateTime
   * @returns {string}
   */
  format(format, dateTime) {
    let newDate = null;
    if (dateTime === null || dateTime === undefined) {
      newDate = luxon__WEBPACK_IMPORTED_MODULE_1__.DateTime.now();
    } else if (dateTime instanceof Date) {
      newDate = luxon__WEBPACK_IMPORTED_MODULE_1__.DateTime.fromJSDate(dateTime);
    } else {
      newDate = luxon__WEBPACK_IMPORTED_MODULE_1__.DateTime.fromISO(dateTime);
    }

    // using locale english here prevents that that AM/PM is translated to the
    // locale variant: e.g. "ko" translates it to 오후 / 오전
    return newDate.toFormat(this._parseFormat(format), {
      locale: 'en-us'
    });
  }

  /**
   * @param {string|Date} dateTime
   * @returns {string}
   */
  getFormattedDate(dateTime) {
    return this.format(this._parseFormat(this.dateFormat), dateTime);
  }

  /**
   * Returns a "YYYY-MM-DDTHH:mm:ss" formatted string in local time.
   * This can take Date objects (e.g. from FullCalendar) and turn them into the correct format.
   *
   * @param {Date|DateTime} date
   * @param {boolean|undefined} isUtc
   * @return {string}
   */
  formatForAPI(date) {
    let isUtc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    if (date instanceof Date) {
      date = luxon__WEBPACK_IMPORTED_MODULE_1__.DateTime.fromJSDate(date);
    }
    if (isUtc === undefined || !isUtc) {
      date = date.toUTC();
    }
    return date.toISO({
      includeOffset: false,
      suppressMilliseconds: true
    });
  }

  /**
   * @param {string} date
   * @param {string} format
   * @return {DateTime}
   */
  fromFormat(date, format) {
    // using locale en-us here prevents that Luxon expects the localized
    // version of AM/PM (e.g. 오후 / 오전 for locale "ko")
    return luxon__WEBPACK_IMPORTED_MODULE_1__.DateTime.fromFormat(date, this._parseFormat(format), {
      locale: 'en-us'
    });
  }

  /**
   * @param {string|null} date
   * @param {string|null} time
   * @return {DateTime}
   */
  fromHtml5Input(date, time) {
    date = date ?? '';
    time = time ?? '';
    if (date === '' && time === '') {
      return luxon__WEBPACK_IMPORTED_MODULE_1__.DateTime.invalid('Empty date and time given');
    }
    if (date !== '' && time !== '') {
      date = date + 'T' + time;
    }
    return luxon__WEBPACK_IMPORTED_MODULE_1__.DateTime.fromISO(date);
  }

  /**
   * @param {string} date
   * @param {string} format
   * @return {boolean}
   */
  isValidDateTime(date, format) {
    return this.fromFormat(date, format).isValid;
  }

  /**
   * Adds a string like "00:30:00" or "01:15" to a given date.
   *
   * @param {Date} date
   * @param {string} duration
   * @return {Date}
   */
  addHumanDuration(date, duration) {
    /** @type {DateTime} newDate */
    let newDate = null;
    if (date instanceof Date) {
      newDate = luxon__WEBPACK_IMPORTED_MODULE_1__.DateTime.fromJSDate(date);
    } else if (date instanceof luxon__WEBPACK_IMPORTED_MODULE_1__.DateTime) {
      newDate = date;
    } else {
      throw 'addHumanDuration() needs a JS Date';
    }
    const parsed = luxon__WEBPACK_IMPORTED_MODULE_1__.DateTime.fromISO(duration);
    const today = luxon__WEBPACK_IMPORTED_MODULE_1__.DateTime.now().startOf('day');
    const timeOfDay = parsed.diff(today);
    return newDate.plus(timeOfDay).toJSDate();
  }

  /**
   * @param {string|integer|null} since
   * @return {string}
   */
  formatDuration(since) {
    let duration = null;
    if (typeof since === 'string') {
      duration = luxon__WEBPACK_IMPORTED_MODULE_1__.DateTime.now().diff(luxon__WEBPACK_IMPORTED_MODULE_1__.DateTime.fromISO(since));
    } else {
      duration = luxon__WEBPACK_IMPORTED_MODULE_1__.Duration.fromISO('PT' + (since === null ? 0 : since) + 'S');
    }
    return this.formatLuxonDuration(duration);
  }

  /**
   * @param {integer} seconds
   * @return {string}
   */
  formatSeconds(seconds) {
    return this.formatLuxonDuration(luxon__WEBPACK_IMPORTED_MODULE_1__.Duration.fromObject({
      seconds: seconds
    }));
  }

  /**
   * @param {Duration} duration
   * @returns {string}
   * @private
   */
  formatLuxonDuration(duration) {
    duration = duration.shiftTo('hours', 'minutes', 'seconds');
    return this.formatAsDuration(duration.hours, duration.minutes);
  }

  /**
   * @param {Date} date
   * @param {boolean|undefined} isUtc
   * @return {string}
   */
  formatTime(date) {
    let isUtc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    let newDate = luxon__WEBPACK_IMPORTED_MODULE_1__.DateTime.fromJSDate(date);
    if (isUtc === undefined || !isUtc) {
      newDate = newDate.toUTC();
    }

    // .utc() is required for calendar
    return newDate.toFormat(this.timeFormat);
  }

  /**
   * @param {int} hours
   * @param {int} minutes
   * @return {string}
   */
  formatAsDuration(hours, minutes) {
    let format = this.durationFormat;
    if (hours < 0 || minutes < 0) {
      hours = Math.abs(hours);
      minutes = Math.abs(minutes);
      format = '-' + format;
    }
    return format.replace('%h', hours.toString()).replace('%m', ('0' + minutes).slice(-2));
  }

  /**
   * @param {string} duration
   * @returns {int}
   */
  getSecondsFromDurationString(duration) {
    const luxonDuration = this.parseDuration(duration);
    if (luxonDuration === null || !luxonDuration.isValid) {
      return 0;
    }
    return luxonDuration.as('seconds');
  }

  /**
   * @param {string} duration
   * @returns {Duration}
   */
  parseDuration(duration) {
    if (duration === undefined || duration === null || duration === '') {
      return new luxon__WEBPACK_IMPORTED_MODULE_1__.Duration({
        seconds: 0
      });
    }
    duration = duration.trim().toUpperCase();
    let luxonDuration = null;
    if (duration.indexOf(':') !== -1) {
      const [, hours, minutes, seconds] = duration.match(/(\d+):(\d+)(?::(\d+))*/);
      luxonDuration = luxon__WEBPACK_IMPORTED_MODULE_1__.Duration.fromObject({
        hours: hours,
        minutes: minutes,
        seconds: seconds
      });
    } else if (duration.indexOf('.') !== -1 || duration.indexOf(',') !== -1) {
      duration = duration.replace(/,/, '.');
      duration = (parseFloat(duration) * 3600).toString();
      luxonDuration = luxon__WEBPACK_IMPORTED_MODULE_1__.Duration.fromISO('PT' + duration + 'S');
    } else if (duration.indexOf('H') !== -1 || duration.indexOf('M') !== -1 || duration.indexOf('S') !== -1) {
      /* D for days does not work, because 'PT1H' but with days 'P1D' is used */
      luxonDuration = luxon__WEBPACK_IMPORTED_MODULE_1__.Duration.fromISO('PT' + duration);
    } else {
      let c = parseInt(duration);
      const d = parseInt(duration).toFixed();
      if (!isNaN(c) && duration === d) {
        duration = (c * 3600).toString();
        luxonDuration = luxon__WEBPACK_IMPORTED_MODULE_1__.Duration.fromISO('PT' + duration + 'S');
      }
    }
    if (luxonDuration === null || !luxonDuration.isValid) {
      return new luxon__WEBPACK_IMPORTED_MODULE_1__.Duration({
        seconds: 0
      });
    }

    // actually, the parsing above should be improved, but that works as well
    if (duration[0] === '-' && luxonDuration.valueOf() > 0) {
      return luxonDuration.negate();
    }
    return luxonDuration;
  }
}

/***/ }),

/***/ "./assets/js/plugins/KimaiEscape.js":
/*!******************************************!*\
  !*** ./assets/js/plugins/KimaiEscape.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ KimaiEscape; }
/* harmony export */ });
/* harmony import */ var _KimaiPlugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../KimaiPlugin */ "./assets/js/KimaiPlugin.js");
/*
 * This file is part of the Kimai time-tracking app.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/*!
 * [KIMAI] KimaiEscape: sanitize strings
 */


class KimaiEscape extends _KimaiPlugin__WEBPACK_IMPORTED_MODULE_0__["default"] {
  getId() {
    return 'escape';
  }

  /**
   * @param {string} title
   * @returns {string}
   */
  escapeForHtml(title) {
    if (title === undefined || title === null) {
      return '';
    }
    const tagsToReplace = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;'
    };
    return title.replace(/[&<>]/g, function (tag) {
      return tagsToReplace[tag] || tag;
    });
  }
}

/***/ }),

/***/ "./assets/js/plugins/KimaiEvent.js":
/*!*****************************************!*\
  !*** ./assets/js/plugins/KimaiEvent.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ KimaiEvent; }
/* harmony export */ });
/* harmony import */ var _KimaiPlugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../KimaiPlugin */ "./assets/js/KimaiPlugin.js");
/*
 * This file is part of the Kimai time-tracking app.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/*!
 * [KIMAI] KimaiEvent: helper to trigger events
 */


class KimaiEvent extends _KimaiPlugin__WEBPACK_IMPORTED_MODULE_0__["default"] {
  getId() {
    return 'event';
  }

  /**
   * @param {string} name
   * @param {string|array|object|null} details
   */
  trigger(name) {
    let details = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    if (name === '') {
      return;
    }
    for (const event of name.split(' ')) {
      let triggerEvent = new Event(event);
      if (details !== null) {
        triggerEvent = new CustomEvent(event, {
          detail: details
        });
      }
      document.dispatchEvent(triggerEvent);
    }
  }
}

/***/ }),

/***/ "./assets/js/plugins/KimaiFetch.js":
/*!*****************************************!*\
  !*** ./assets/js/plugins/KimaiFetch.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ KimaiFetch; }
/* harmony export */ });
/* harmony import */ var _KimaiPlugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../KimaiPlugin */ "./assets/js/KimaiPlugin.js");
/*
 * This file is part of the Kimai time-tracking app.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/*!
 * [KIMAI] KimaiEscape: sanitize strings
 */


class KimaiFetch extends _KimaiPlugin__WEBPACK_IMPORTED_MODULE_0__["default"] {
  getId() {
    return 'fetch';
  }

  /**
   * @param {string} url
   * @param {object} options
   * @returns {Promise<Response>}
   */
  fetch(url) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (options.headers === undefined) {
      options.headers = new Headers();
    }
    options.headers.append('X-Requested-With', 'Kimai');
    options = {
      ...{
        redirect: 'follow'
      },
      ...options
    };
    return new Promise((resolve, reject) => {
      fetch(url, options).then(response => {
        if (response.ok) {
          if (response.status === 201 && response.headers.has('x-modal-redirect')) {
            window.location = response.headers.get('x-modal-redirect');
            return;
          }

          // "ok" is only in status code range of 2xx
          resolve(response);
          return;
        }
        let stopPropagation = false;
        switch (response.status) {
          case 403:
            {
              if (response.headers.has('login-required')) {
                const loginUrl = this.getConfiguration('login').toString();
                /** @type {KimaiAlert} alert */
                const alert = this.getContainer().getPlugin('alert');
                alert.question(this.translate('login.required'), result => {
                  if (result === true) {
                    window.location.replace(loginUrl);
                  }
                });
                stopPropagation = true;
              }
              break;
            }
          default:
            {
              console.log('Some error occurred');
              break;
            }
        }
        if (!stopPropagation) {
          reject(response);
        }
      }).catch(error => {
        console.log('Error occurred while talking to Kimai backend', error);
        reject(error);
      });
    });
  }
}

/***/ }),

/***/ "./assets/js/plugins/KimaiForm.js":
/*!****************************************!*\
  !*** ./assets/js/plugins/KimaiForm.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ KimaiForm; }
/* harmony export */ });
/* harmony import */ var _KimaiPlugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../KimaiPlugin */ "./assets/js/KimaiPlugin.js");
/* harmony import */ var _forms_KimaiFormPlugin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../forms/KimaiFormPlugin */ "./assets/js/forms/KimaiFormPlugin.js");
/*
 * This file is part of the Kimai time-tracking app.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/*!
 * [KIMAI] KimaiForm: basic functions for all forms
 */



class KimaiForm extends _KimaiPlugin__WEBPACK_IMPORTED_MODULE_0__["default"] {
  getId() {
    return 'form';
  }
  activateForm(formSelector) {
    [].slice.call(document.querySelectorAll(formSelector)).map(form => {
      for (const plugin of this.getContainer().getPlugins()) {
        if (plugin instanceof _forms_KimaiFormPlugin__WEBPACK_IMPORTED_MODULE_1__["default"] && plugin.supportsForm(form)) {
          plugin.activateForm(form);
        }
      }
    });
  }
  destroyForm(formSelector) {
    [].slice.call(document.querySelectorAll(formSelector)).map(form => {
      for (const plugin of this.getContainer().getPlugins()) {
        if (plugin instanceof _forms_KimaiFormPlugin__WEBPACK_IMPORTED_MODULE_1__["default"] && plugin.supportsForm(form)) {
          plugin.destroyForm(form);
        }
      }
    });
  }

  /**
   * @param {HTMLFormElement} form
   * @param {Object} overwrites
   * @param {boolean} removeEmpty
   * @returns {string}
   */
  convertFormDataToQueryString(form) {
    let overwrites = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let removeEmpty = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    let serialized = [];
    let data = new FormData(form);
    for (const key in overwrites) {
      data.set(key, overwrites[key]);
    }
    for (let row of data) {
      if (!removeEmpty || row[1] !== '') {
        serialized.push(encodeURIComponent(row[0]) + "=" + encodeURIComponent(row[1]));
      }
    }
    return serialized.join('&');
  }
}

/***/ }),

/***/ "./assets/js/plugins/KimaiHotkeys.js":
/*!*******************************************!*\
  !*** ./assets/js/plugins/KimaiHotkeys.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ KimaiHotkeys; }
/* harmony export */ });
/* harmony import */ var _KimaiPlugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../KimaiPlugin */ "./assets/js/KimaiPlugin.js");
/*
 * This file is part of the Kimai time-tracking app.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */


class KimaiHotkeys extends _KimaiPlugin__WEBPACK_IMPORTED_MODULE_0__["default"] {
  getId() {
    return 'hotkeys';
  }
  init() {
    // https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent
    // https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key

    const selector = '[data-hotkey="ctrl+Enter"]';
    window.addEventListener('keyup', ev => {
      if (ev.ctrlKey && ev.key === 'Enter') {
        const elements = [...document.querySelectorAll(selector)].filter(element => this.isVisible(element));
        if (elements.length > 1) {
          console.warn('KimaiHotkeys: More than one visible element matches ${selector}. No action triggered.');
        }
        if (elements.length === 1) {
          ev.stopPropagation();
          ev.preventDefault();
          elements[0].click();
        }
      }
    });
  }

  // adopted from Bootstrap 5.1.1, MIT
  isVisible(element) {
    if (!element || element.getClientRects().length === 0) {
      return false;
    }
    return getComputedStyle(element).getPropertyValue('visibility') === 'visible';
  }
}

/***/ }),

/***/ "./assets/js/plugins/KimaiMultiUpdateTable.js":
/*!****************************************************!*\
  !*** ./assets/js/plugins/KimaiMultiUpdateTable.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ KimaiMultiUpdateTable; }
/* harmony export */ });
/* harmony import */ var _KimaiPlugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../KimaiPlugin */ "./assets/js/KimaiPlugin.js");
/*
 * This file is part of the Kimai time-tracking app.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/*!
 * [KIMAI] KimaiMultiUpdateForm: handle the multi update checkbox list and form
 */


class KimaiMultiUpdateTable extends _KimaiPlugin__WEBPACK_IMPORTED_MODULE_0__["default"] {
  init() {
    if (document.getElementById('multi_update_all') === null) {
      return;
    }

    // we have to attach it to the "page-body" div, because section.content can be replaced
    // via KimaiDatable and everything inside will be removed, including event listeners
    const element = document.querySelector('div.page-body');
    element.addEventListener('change', event => {
      if (event.target.matches('#multi_update_all')) {
        // the "check all" checkbox in the upper start corner of the table
        const checked = event.target.checked;
        for (const element of document.querySelectorAll('.multi_update_single')) {
          element.checked = checked;
        }
        this._toggleForm();
        event.stopPropagation();
      } else if (event.target.matches('.multi_update_single')) {
        // single checkboxes in front of each row
        this._toggleForm();
        event.stopPropagation();
      }
    });
    element.addEventListener('click', event => {
      if (event.target.matches('.multi_update_table_action')) {
        const selectedItem = event.target;
        const ids = this._getSelectedIds();
        const form = document.getElementById('multi_update_form');
        const question = form.dataset['question'].replace(/%action%/, selectedItem.textContent).replace(/%count%/, ids.length.toString());

        /** @type {KimaiAlert} ALERT */
        const ALERT = this.getPlugin('alert');
        ALERT.question(question, function (value) {
          if (value) {
            const form = document.getElementById('multi_update_form');
            form.action = selectedItem.dataset['href'];
            form.submit();
          }
        });
      }
    });
  }
  _getSelectedIds() {
    let ids = [];
    for (const box of document.querySelectorAll('input.multi_update_single:checked')) {
      ids.push(box.value);
    }
    return ids;
  }
  _toggleForm() {
    const ids = this._getSelectedIds();
    document.getElementById('multi_update_table_entities').value = ids.join(',');
    if (ids.length > 0) {
      for (const element of document.getElementsByClassName('multi_update_form_hide')) {
        element.style.setProperty('display', 'none', 'important');
      }
      document.getElementById('multi_update_form').style.display = null; //'block';
    } else {
      document.getElementById('multi_update_form').style.setProperty('display', 'none', 'important');
      for (const element of document.getElementsByClassName('multi_update_form_hide')) {
        element.style.display = null;
      }
    }
  }
}

/***/ }),

/***/ "./assets/js/plugins/KimaiNotification.js":
/*!************************************************!*\
  !*** ./assets/js/plugins/KimaiNotification.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ KimaiNotification; }
/* harmony export */ });
/* harmony import */ var _KimaiPlugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../KimaiPlugin */ "./assets/js/KimaiPlugin.js");
/*
 * This file is part of the Kimai time-tracking app.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/*!
 * [KIMAI] Notification: notifications for Kimai
 */


class KimaiNotification extends _KimaiPlugin__WEBPACK_IMPORTED_MODULE_0__["default"] {
  getId() {
    return 'notification';
  }
  isSupported() {
    if (!window.Notification) {
      return false;
    }
    if (Notification.permission === 'denied') {
      return false;
    }
    return Notification.permission === "granted";
  }
  request(callback) {
    try {
      Notification.requestPermission().then(permission => {
        if (permission === "granted") {
          callback(true);
        } else if (permission === "default") {
          callback(null);
        } else {
          callback(false);
        }
      });
    } catch (e) {
      Notification.requestPermission(permission => {
        if (permission === "granted") {
          callback(true);
        } else if (permission === "default") {
          callback(null);
        } else {
          callback(false);
        }
      });
    }
  }
  notify(title, message, icon, options) {
    this.request(permission => {
      if (permission !== true) {
        /** @type KimaiAlert */
        const ALERT = this.getPlugin('alert');
        ALERT.info(message);
      }
      let opts = {
        body: message,
        dir: this.getConfigurations().isRTL() ? 'rtl' : 'ltr'
      };
      //opts.requireInteraction = true;
      //opts.renotify = true;
      /*
      if (options.tag === undefined) {
          opts.tag = 'kimai';
      }
      */
      if (icon !== undefined && icon !== null) {
        opts.icon = icon;
      }
      let nTitle = 'Kimai';
      if (title !== null) {
        nTitle = nTitle + ': ' + title;
      }
      if (options !== undefined && options !== null) {
        opts = {
          ...opts,
          ...options
        };
      }
      const notification = new window.Notification(nTitle, opts);
      notification.onclick = function () {
        window.focus();
        notification.close();
      };
    });
  }
}

/***/ }),

/***/ "./assets/js/plugins/KimaiReducedClickHandler.js":
/*!*******************************************************!*\
  !*** ./assets/js/plugins/KimaiReducedClickHandler.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ KimaiReducedClickHandler; }
/* harmony export */ });
/* harmony import */ var _KimaiPlugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../KimaiPlugin */ "./assets/js/KimaiPlugin.js");
/*
 * This file is part of the Kimai time-tracking app.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/*!
 * [KIMAI] KimaiReducedClickHandler: abstract class
 */


class KimaiReducedClickHandler extends _KimaiPlugin__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * No _underscore naming for now, as it would be mangled otherwise
   * @param selector
   * @param callback
   */
  addClickHandler(selector, callback) {
    document.body.addEventListener('click', event => {
      // event.currentTarget is ALWAYS the body

      let target = event.target;
      while (target !== null) {
        const tagName = target.tagName.toUpperCase();
        if (tagName === 'BODY') {
          return;
        }
        if (target.matches(selector)) {
          break;
        }

        // when an element is clicked, which can trigger stuff itself, we don't want the event to be processed
        if (tagName === 'A' || tagName === 'BUTTON' || tagName === 'INPUT' || tagName === 'LABEL') {
          return;
        }
        target = target.parentNode;
      }
      if (target === null) {
        return;
      }

      // just in case an inner element is editable, then this should not be triggered
      if (target.isContentEditable || target.parentNode.isContentEditable) {
        return;
      }
      if (!target.matches(selector)) {
        return;
      }
      event.preventDefault();
      event.stopPropagation();
      let href = target.dataset['href'];
      if (href === undefined || href === null) {
        href = target.href;
      }
      if (href === undefined || href === null || href === '') {
        return;
      }
      callback(href);
    });
  }
}

/***/ }),

/***/ "./assets/js/plugins/KimaiRemoteModal.js":
/*!***********************************************!*\
  !*** ./assets/js/plugins/KimaiRemoteModal.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ KimaiRemoteModal; }
/* harmony export */ });
/* harmony import */ var _KimaiPlugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../KimaiPlugin */ "./assets/js/KimaiPlugin.js");
/* harmony import */ var bootstrap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bootstrap */ "./node_modules/bootstrap/dist/js/bootstrap.esm.js");
/*
 * This file is part of the Kimai time-tracking app.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/*!
 * [KIMAI] KimaiRecentActivities: responsible to reload the users recent activities
 */



class KimaiRemoteModal extends _KimaiPlugin__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor() {
    super();
    this._selector = 'a.remote-modal-load';
  }

  /**
   * @returns {string}
   */
  getId() {
    return 'remote-modal';
  }
  init() {
    this.handle = event => {
      this._showModal(event.currentTarget);
      event.stopPropagation();
      event.preventDefault();
    };
    for (let link of document.querySelectorAll(this._selector)) {
      link.addEventListener('click', this.handle);
    }
    document.addEventListener('kimai.closeRemoteModal', () => {
      this._hide();
    });
  }

  /**
   * @param {HTMLElement} element
   * @private
   */
  _initElement(element) {
    for (let link of element.querySelectorAll('a.remote-modal-reload')) {
      link.addEventListener('click', this.handle);
    }
  }
  _hide() {
    this._getModal().hide();
  }
  _getModalElement() {
    return document.getElementById('remote_modal');
  }

  /**
   * @returns {Modal}
   * @private
   */
  _getModal() {
    return bootstrap__WEBPACK_IMPORTED_MODULE_1__.Modal.getOrCreateInstance(this._getModalElement());
  }

  /**
   * @param {HTMLLinkElement} element
   * @private
   */
  _showModal(element) {
    this.fetch(element.href, {
      method: 'GET'
    }).then(response => {
      if (!response.ok) {
        return;
      }
      return response.text().then(html => {
        const newFormHtml = document.createElement('div');
        newFormHtml.classList.add('modal-body');
        newFormHtml.classList.add('p-0');
        newFormHtml.innerHTML = html;
        this._initElement(newFormHtml);
        const modal = this._getModalElement();
        modal.querySelector('.modal-body').replaceWith(newFormHtml);
        if (element.dataset['modalTitle'] !== undefined) {
          modal.querySelector('.modal-title').textContent = element.dataset['modalTitle'];
        }
        this._getModal().show();
      });
    }).catch(reason => {
      console.log('Failed to load remote modal', reason);
    });
  }
}

/***/ }),

/***/ "./assets/js/plugins/KimaiThemeInitializer.js":
/*!****************************************************!*\
  !*** ./assets/js/plugins/KimaiThemeInitializer.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ KimaiThemeInitializer; }
/* harmony export */ });
/* harmony import */ var bootstrap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bootstrap */ "./node_modules/bootstrap/dist/js/bootstrap.esm.js");
/* harmony import */ var _KimaiPlugin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../KimaiPlugin */ "./assets/js/KimaiPlugin.js");
/*
 * This file is part of the Kimai time-tracking app.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/*!
 * [KIMAI] KimaiThemeInitializer: initialize theme functionality
 */



class KimaiThemeInitializer extends _KimaiPlugin__WEBPACK_IMPORTED_MODULE_1__["default"] {
  init() {
    // the tooltip do not use data-bs-toggle="tooltip" so they can be mixed with data-toggle="modal"
    [].slice.call(document.querySelectorAll('[data-toggle="tooltip"]')).map(function (tooltipTriggerEl) {
      return new bootstrap__WEBPACK_IMPORTED_MODULE_0__.Tooltip(tooltipTriggerEl);
    });

    // activate all form plugins
    /** @type {KimaiForm} FORMS */
    const FORMS = this.getContainer().getPlugin('form');
    FORMS.activateForm('div.page-wrapper form');
    this._registerModalAutofocus('#remote_form_modal');
    this.overlay = null;

    // register a global event listener, which displays an overlays upon notification
    document.addEventListener('kimai.reloadContent', event => {
      // do not allow more than one loading screen at a time
      if (this.overlay !== null) {
        return;
      }

      // at which element we append the loading screen
      let container = 'body';
      if (event.detail !== undefined && event.detail !== null) {
        container = event.detail;
      }
      const temp = document.createElement('div');
      temp.innerHTML = '<div class="overlay"><div class="fas fa-sync fa-spin"></div></div>';
      this.overlay = temp.firstElementChild;
      document.querySelector(container).append(this.overlay);
    });

    // register a global event listener, which hides an overlay upon notification
    document.addEventListener('kimai.reloadedContent', () => {
      if (this.overlay !== null) {
        this.overlay.remove();
        this.overlay = null;
      }
    });
  }

  /**
   * Helps to set the autofocus on modals.
   *
   * @param {string} selector
   */
  _registerModalAutofocus(selector) {
    // on mobile you do not want to trigger the virtual keyboard upon modal open
    if (this.isMobile()) {
      return;
    }
    const modal = document.querySelector(selector);
    if (modal === null) {
      return;
    }
    modal.addEventListener('shown.bs.modal', () => {
      const form = modal.querySelector('form');
      let formAutofocus = form.querySelectorAll('[autofocus]');
      if (formAutofocus.length < 1) {
        formAutofocus = form.querySelectorAll('input[type=text],input[type=date],textarea,select');
      }
      if (formAutofocus.length > 0) {
        formAutofocus[0].focus();
      }
    });
  }
}

/***/ }),

/***/ "./assets/js/plugins/KimaiToolbar.js":
/*!*******************************************!*\
  !*** ./assets/js/plugins/KimaiToolbar.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ KimaiToolbar; }
/* harmony export */ });
/* harmony import */ var _KimaiPlugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../KimaiPlugin */ "./assets/js/KimaiPlugin.js");
/*
 * This file is part of the Kimai time-tracking app.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/*!
 * [KIMAI] KimaiToolbar: some event listener to handle the toolbar/data-table filter, toolbar and navigation
 */


class KimaiToolbar extends _KimaiPlugin__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(formSelector, formSubmitActionClass) {
    super();
    this._formSelector = formSelector;
    this._actionClass = formSubmitActionClass;
  }
  getId() {
    return 'toolbar';
  }
  init() {
    const formSelector = this.getSelector();
    this._registerPagination(formSelector);
    this._registerSortableTables(formSelector);
    this._registerAlternativeSubmitActions(formSelector, this._actionClass);

    // Reset the page if filter values are changed, otherwise we might end up with a limited set of data,
    // which does not support the given page - and it would be just wrong to stay in the same page
    [].slice.call(document.querySelectorAll(formSelector + ' input')).map(element => {
      element.addEventListener('change', event => {
        switch (event.target.id) {
          case 'order':
          case 'orderBy':
          case 'page':
            break;
          default:
            document.querySelector(formSelector + ' input#page').value = 1;
            break;
        }
      });
      this.triggerChange();
    });

    // when user selected a new customer or project, reset the pagination back to 1
    // and then find out if the results should be reloaded
    [].slice.call(document.querySelectorAll(formSelector + ' select')).map(element => {
      element.addEventListener('change', event => {
        let reload = true;
        switch (event.target.id) {
          case 'customer':
            if (document.querySelector(formSelector + ' select#project') !== null) {
              reload = false;
            }
            break;
          case 'project':
            if (document.querySelector(formSelector + ' select#activity') !== null) {
              reload = false;
            }
            break;
        }
        document.querySelector(formSelector + ' input#page').value = 1;
        if (reload) {
          this.triggerChange();
        }
      });
    });
  }

  /**
   * Some actions utilize the filter from the search form and submit it to another URL.
   * @private
   */
  _registerAlternativeSubmitActions(toolbarSelector, actionBtnClass) {
    document.addEventListener('click', function (event) {
      let target = event.target;
      while (target !== null && typeof target.matches === "function" && !target.matches('body')) {
        if (target.classList.contains(actionBtnClass)) {
          const form = document.querySelector(toolbarSelector);
          if (form === null) {
            return;
          }
          const prevAction = form.getAttribute('action');
          const prevMethod = form.getAttribute('method');
          if (target.dataset.target !== undefined) {
            form.target = target.dataset.target;
          }
          form.action = target.href;
          if (target.dataset.method !== undefined) {
            form.method = target.dataset.method;
          }
          form.submit();
          form.target = '';
          form.action = prevAction;
          form.method = prevMethod;
          event.preventDefault();
          event.stopPropagation();
        }
        target = target.parentNode;
      }
    });
  }

  /**
   * Sortable datatables use hidden fields in the toolbar filter/search form
   * @private
   */
  _registerSortableTables(formSelector) {
    document.body.addEventListener('click', event => {
      if (!event.target.matches('th.sortable')) {
        return;
      }
      let order = 'DESC';
      let orderBy = event.target.dataset['order'];
      if (event.target.classList.contains('sorting_desc')) {
        order = 'ASC';
      }
      document.querySelector(formSelector + ' #orderBy').value = orderBy;
      document.querySelector(formSelector + ' #order').value = order;

      // re-render the selectbox
      document.querySelector(formSelector + ' #orderBy').dispatchEvent(new Event('change'));
      document.querySelector(formSelector + ' #order').dispatchEvent(new Event('change'));

      // triggers the datatable reload - search for the event name
      document.dispatchEvent(new Event('filter-change'));
    });
  }

  /**
   * This catches all clicks on the pagination and prevents the default action,
   * as we want to reload the page via JS.
   *
   * @private
   */
  _registerPagination(formSelector) {
    document.body.addEventListener('click', event => {
      if (!event.target.matches('ul.pagination li a') && (event.target.parentNode === null || !event.target.parentNode.matches('ul.pagination li a'))) {
        return;
      }
      let pager = document.querySelector(formSelector + " input#page");
      if (pager === null) {
        return;
      }
      let target = event.target;

      // this happens for the arrows, which can be an icon <i> element
      if (!target.matches('a')) {
        target = target.parentNode;
      }
      event.preventDefault();
      event.stopPropagation();
      let urlParts = target.href.split('/');
      let pageNumber = urlParts[urlParts.length - 1];
      // page number usually is the default value and is therefor missing from the URL
      if (!/\d/.test(pageNumber)) {
        pageNumber = 1;
      }
      pager.value = pageNumber;
      pager.dispatchEvent(new Event('change'));
      document.dispatchEvent(new Event('pagination-change'));
      return false;
    });
  }

  /**
   * Triggers an event, that everyone can listen for.
   */
  triggerChange() {
    document.dispatchEvent(new Event('toolbar-change'));
  }

  /**
   * Returns the CSS selector to target the toolbar form.
   * 
   * @returns {string}
   */
  getSelector() {
    return this._formSelector;
  }
}

/***/ }),

/***/ "./assets/js/plugins/KimaiUser.js":
/*!****************************************!*\
  !*** ./assets/js/plugins/KimaiUser.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ KimaiUser; }
/* harmony export */ });
/* harmony import */ var _KimaiPlugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../KimaiPlugin */ "./assets/js/KimaiPlugin.js");
/*
 * This file is part of the Kimai time-tracking app.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/*!
 * [KIMAI] KimaiUser: information about the current user
 */


class KimaiUser extends _KimaiPlugin__WEBPACK_IMPORTED_MODULE_0__["default"] {
  getId() {
    return 'user';
  }
  init() {
    this.user = this.getConfigurations().get('user');
  }

  /**
   * @returns {string}
   */
  getUserId() {
    return this.user.id;
  }

  /**
   * @returns {string}
   */
  getName() {
    return this.user.name;
  }

  /**
   * @returns {boolean}
   */
  isAdmin() {
    return this.user.admin;
  }

  /**
   * @returns {boolean}
   */
  isSuperAdmin() {
    return this.user.superAdmin;
  }
}

/***/ }),

/***/ "./assets/js/widgets/KimaiColor.js":
/*!*****************************************!*\
  !*** ./assets/js/widgets/KimaiColor.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ KimaiColor; }
/* harmony export */ });
/*
 * This file is part of the Kimai time-tracking app.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/*!
 * [KIMAI] KimaiColor: handle colors
 */

class KimaiColor {
  /**
   * @param {string} hexcolor
   * @return {string}
   */
  static calculateContrastColor(hexcolor) {
    if (hexcolor.slice(0, 1) === '#') {
      hexcolor = hexcolor.slice(1);
    }
    if (hexcolor.length === 3) {
      hexcolor = hexcolor.split('').map(function (hex) {
        return hex + hex;
      }).join('');
    }
    const r = parseInt(hexcolor.substring(0, 2), 16);
    const g = parseInt(hexcolor.substring(2, 4), 16);
    const b = parseInt(hexcolor.substring(4, 6), 16);

    // https://gomakethings.com/dynamically-changing-the-text-color-based-on-background-color-contrast-with-vanilla-js/
    const yiq = (r * 299 + g * 587 + b * 114) / 1000;
    return yiq >= 128 ? '#000000' : '#ffffff';
  }
}

/***/ }),

/***/ "./assets/js/widgets/KimaiContextMenu.js":
/*!***********************************************!*\
  !*** ./assets/js/widgets/KimaiContextMenu.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ KimaiContextMenu; }
/* harmony export */ });
/*
 * This file is part of the Kimai time-tracking app.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/*!
 * [KIMAI] KimaiContextMenu: help to create, position and display context menus
 */

class KimaiContextMenu {
  /**
   * @param {string} id
   */
  constructor(id) {
    this.id = id;
  }

  /**
   * @returns {HTMLElement}
   */
  getContextMenuElement() {
    if (document.getElementById(this.id) === null) {
      const temp = document.createElement('div');
      temp.id = this.id;
      temp.classList.add('dropdown-menu', 'd-none');
      document.body.appendChild(temp);
    }
    return document.getElementById(this.id);
  }

  /**
   * @param {MouseEvent} event
   * @param {object} json
   */
  createFromApi(event, json) {
    let html = '';
    for (const options of json) {
      if (options['divider'] === true) {
        html += '<div class="dropdown-divider"></div>';
      }
      if (options['url'] !== null) {
        html += '<a class="dropdown-item ' + (options['class'] !== null ? options['class'] : '') + '" href="' + options['url'] + '"';
        if (options['attr'] !== undefined) {
          for (const attrName in options['attr']) {
            html += ' ' + attrName + '="' + options['attr'][attrName].replaceAll('"', '&quot;') + '"';
          }
        }
        html += '>' + options['title'] + '</a>';
      }
    }
    this.createFromClickEvent(event, html);
  }

  /**
   * @param {MouseEvent} event
   * @param {string} html
   */
  createFromClickEvent(event, html) {
    const dropdownElement = this.getContextMenuElement();
    dropdownElement.style.zIndex = '1021'; // stay on top of sticky elements (like table header)
    dropdownElement.innerHTML = html;
    dropdownElement.style.position = 'fixed';
    dropdownElement.style.top = event.clientY + 'px';
    dropdownElement.style.left = event.clientX + 'px';
    const dropdownListener = event => {
      if (event.target.classList.contains('dropdown-toggle') || event.target.classList.contains('dropdown-divider')) {
        return;
      }
      dropdownElement.classList.remove('d-block');
      if (!dropdownElement.classList.contains('d-none')) {
        dropdownElement.classList.add('d-none');
      }
      dropdownElement.removeEventListener('click', dropdownListener);
      document.removeEventListener('click', dropdownListener);
    };
    dropdownElement.addEventListener('click', dropdownListener);
    document.addEventListener('click', dropdownListener);
    dropdownElement.classList.remove('d-none');
    if (!dropdownElement.classList.contains('d-block')) {
      dropdownElement.classList.add('d-block');
    }
  }

  /**
   * @param {string} selector
   */
  static createForDataTable(selector) {
    [].slice.call(document.querySelectorAll(selector)).map(dataTable => {
      const actions = dataTable.querySelector('td.actions div.dropdown-menu');
      if (actions === null) {
        return;
      }
      dataTable.addEventListener('contextmenu', jsEvent => {
        let target = jsEvent.target;
        while (target !== null) {
          const tagName = target.tagName.toUpperCase();
          if (tagName === 'TH' || tagName === 'TABLE' || tagName === 'BODY') {
            return;
          }
          if (tagName === 'TR') {
            break;
          }
          target = target.parentNode;
        }
        if (target === null || !target.matches('table.dataTable tbody tr')) {
          return;
        }
        const actions = target.querySelector('td.actions div.dropdown-menu');
        if (actions === null) {
          return;
        }
        jsEvent.preventDefault();
        const contextMenu = new KimaiContextMenu(dataTable.dataset['contextMenu']);
        contextMenu.createFromClickEvent(jsEvent, actions.innerHTML);
      });
    });
  }
}

/***/ }),

/***/ "./assets/js/widgets/KimaiPaginatedBoxWidget.js":
/*!******************************************************!*\
  !*** ./assets/js/widgets/KimaiPaginatedBoxWidget.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ KimaiPaginatedBoxWidget; }
/* harmony export */ });
/* harmony import */ var _KimaiContextMenu__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./KimaiContextMenu */ "./assets/js/widgets/KimaiContextMenu.js");
/*
 * This file is part of the Kimai time-tracking app.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/*!
 * [KIMAI] KimaiPaginatedBoxWidget: handles box widgets that have a pagination
 */


class KimaiPaginatedBoxWidget {
  constructor(boxId) {
    this.selector = boxId;
    const widget = document.querySelector(this.selector);
    this.href = widget.dataset['href'];
    if (widget.dataset['reload'] !== undefined) {
      this.events = widget.dataset['reload'].split(' ');
      const reloadPage = () => {
        let url = null;
        if (document.querySelector(this.selector).dataset['reloadHref'] !== undefined) {
          url = document.querySelector(this.selector).dataset['reloadHref'];
        } else {
          url = document.querySelector(this.selector + ' ul.pagination li.active a').href;
        }
        this.loadPage(url);
      };
      for (const eventName of this.events) {
        document.addEventListener(eventName, reloadPage);
      }
    }
    document.body.addEventListener('click', event => {
      let link = event.target;
      // could be an icon
      if (!link.matches(this.selector + ' a.pagination-link')) {
        link = link.parentNode;
      }
      if (link.matches(this.selector + ' a.pagination-link')) {
        event.preventDefault();
        this.loadPage(link.href);
      }
    });
  }
  static create(elementId) {
    return new KimaiPaginatedBoxWidget(elementId);
  }
  loadPage(url) {
    const selector = this.selector;

    // this event will render a spinning loader
    document.dispatchEvent(new CustomEvent('kimai.reloadContent', {
      detail: this.selector
    }));

    // and this event will hide it afterwards
    const hideOverlay = () => {
      document.dispatchEvent(new Event('kimai.reloadedContent'));
    };
    window.kimai.getPlugin('fetch').fetch(url).then(response => {
      response.text().then(text => {
        const temp = document.createElement('div');
        temp.innerHTML = text;
        // previously the parts .card-header .card-body .card-title .card-footer were replaced
        // but the layout allows eg. ".list-group .list-group-flush" instead of .card-body
        // so we directly replace the entire HTML
        // the HTML needs to be parsed for script tags, which can be included (e.g. paginated chart widget)
        document.querySelector(selector).replaceWith(this._makeScriptExecutable(temp.firstElementChild));
        _KimaiContextMenu__WEBPACK_IMPORTED_MODULE_0__["default"].createForDataTable(selector + ' table.dataTable');
        hideOverlay();
      });
    }).catch(() => {
      // this is not yet a plugin, so the alert is not available here
      window.kimai.getPlugin('alert').error('Failed loading selected page');
      hideOverlay();
    });
  }

  /**
   * @param {Element|ChildNode} node
   * @returns {Element}
   * @private
   */
  _makeScriptExecutable(node) {
    if (node.tagName !== undefined && node.tagName === 'SCRIPT') {
      const script = document.createElement('script');
      script.text = node.innerHTML;
      node.parentNode.replaceChild(script, node);
    } else {
      for (const child of node.childNodes) {
        this._makeScriptExecutable(child);
      }
    }
    return node;
  }
}

/***/ }),

/***/ "./assets/js/widgets/KimaiReloadPageWidget.js":
/*!****************************************************!*\
  !*** ./assets/js/widgets/KimaiReloadPageWidget.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ KimaiReloadPageWidget; }
/* harmony export */ });
/*
 * This file is part of the Kimai time-tracking app.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/*!
 * [KIMAI] KimaiReloadPageWidget: a simple helper to reload the page on events
 */

class KimaiReloadPageWidget {
  constructor(events, fullReload) {
    const reloadPage = () => {
      if (fullReload) {
        document.location.reload();
      } else {
        this._loadPage(document.location);
      }
    };
    for (const eventName of events.split(' ')) {
      document.addEventListener(eventName, reloadPage);
    }
  }
  static create(events, fullReload) {
    if (fullReload === undefined || fullReload === null) {
      fullReload = false;
    }
    return new KimaiReloadPageWidget(events, fullReload);
  }
  _showOverlay() {
    document.dispatchEvent(new CustomEvent('kimai.reloadContent', {
      detail: 'div.page-wrapper'
    }));
  }
  _hideOverlay() {
    document.dispatchEvent(new Event('kimai.reloadedContent'));
  }
  _loadPage(url) {
    this._showOverlay();
    window.kimai.getPlugin('fetch').fetch(url).then(response => {
      response.text().then(text => {
        const temp = document.createElement('div');
        temp.innerHTML = text;
        const newContent = temp.querySelector('section.content');
        document.querySelector('section.content').replaceWith(newContent);
        document.dispatchEvent(new Event('kimai.reloadPage'));
        this._hideOverlay();
      });
    }).catch(() => {
      this._hideOverlay();
      document.location = url;
    });
  }
}

/***/ }),

/***/ "./assets/js/widgets/KimaiStorage.js":
/*!*******************************************!*\
  !*** ./assets/js/widgets/KimaiStorage.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ KimaiStorage; }
/* harmony export */ });
/*
 * This file is part of the Kimai time-tracking app.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/*!
 * [KIMAI] KimaiStorage: simple wrapper to handle localStorage access
 */

class KimaiStorage {
  static set(name, values) {
    window.localStorage.setItem(name, JSON.stringify(values));
  }
  static get(name) {
    let value = window.localStorage.getItem(name);
    if (value === undefined || value === null) {
      return null;
    }
    return JSON.parse(value);
  }
  static remove(name) {
    window.localStorage.removeItem(name);
  }
}

/***/ }),

/***/ "./node_modules/bootstrap/dist/js/bootstrap.esm.js":
/*!*********************************************************!*\
  !*** ./node_modules/bootstrap/dist/js/bootstrap.esm.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Alert: function() { return /* binding */ Alert; },
/* harmony export */   Button: function() { return /* binding */ Button; },
/* harmony export */   Carousel: function() { return /* binding */ Carousel; },
/* harmony export */   Collapse: function() { return /* binding */ Collapse; },
/* harmony export */   Dropdown: function() { return /* binding */ Dropdown; },
/* harmony export */   Modal: function() { return /* binding */ Modal; },
/* harmony export */   Offcanvas: function() { return /* binding */ Offcanvas; },
/* harmony export */   Popover: function() { return /* binding */ Popover; },
/* harmony export */   ScrollSpy: function() { return /* binding */ ScrollSpy; },
/* harmony export */   Tab: function() { return /* binding */ Tab; },
/* harmony export */   Toast: function() { return /* binding */ Toast; },
/* harmony export */   Tooltip: function() { return /* binding */ Tooltip; }
/* harmony export */ });
/* harmony import */ var _popperjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @popperjs/core */ "./node_modules/@popperjs/core/lib/index.js");
/* harmony import */ var _popperjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @popperjs/core */ "./node_modules/@popperjs/core/lib/popper.js");
/*!
  * Bootstrap v5.3.0-alpha3 (https://getbootstrap.com/)
  * Copyright 2011-2023 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */


/**
 * --------------------------------------------------------------------------
 * Bootstrap dom/data.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */

const elementMap = new Map();
const Data = {
  set(element, key, instance) {
    if (!elementMap.has(element)) {
      elementMap.set(element, new Map());
    }
    const instanceMap = elementMap.get(element);

    // make it clear we only want one instance per element
    // can be removed later when multiple key/instances are fine to be used
    if (!instanceMap.has(key) && instanceMap.size !== 0) {
      // eslint-disable-next-line no-console
      console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(instanceMap.keys())[0]}.`);
      return;
    }
    instanceMap.set(key, instance);
  },
  get(element, key) {
    if (elementMap.has(element)) {
      return elementMap.get(element).get(key) || null;
    }
    return null;
  },
  remove(element, key) {
    if (!elementMap.has(element)) {
      return;
    }
    const instanceMap = elementMap.get(element);
    instanceMap.delete(key);

    // free up element references if there are no instances left for an element
    if (instanceMap.size === 0) {
      elementMap.delete(element);
    }
  }
};

/**
 * --------------------------------------------------------------------------
 * Bootstrap util/index.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

const MAX_UID = 1000000;
const MILLISECONDS_MULTIPLIER = 1000;
const TRANSITION_END = 'transitionend';

/**
 * Properly escape IDs selectors to handle weird IDs
 * @param {string} selector
 * @returns {string}
 */
const parseSelector = selector => {
  if (selector && window.CSS && window.CSS.escape) {
    // document.querySelector needs escaping to handle IDs (html5+) containing for instance /
    selector = selector.replace(/#([^\s"#']+)/g, (match, id) => `#${CSS.escape(id)}`);
  }
  return selector;
};

// Shout-out Angus Croll (https://goo.gl/pxwQGp)
const toType = object => {
  if (object === null || object === undefined) {
    return `${object}`;
  }
  return Object.prototype.toString.call(object).match(/\s([a-z]+)/i)[1].toLowerCase();
};

/**
 * Public Util API
 */

const getUID = prefix => {
  do {
    prefix += Math.floor(Math.random() * MAX_UID);
  } while (document.getElementById(prefix));
  return prefix;
};
const getTransitionDurationFromElement = element => {
  if (!element) {
    return 0;
  }

  // Get transition-duration of the element
  let {
    transitionDuration,
    transitionDelay
  } = window.getComputedStyle(element);
  const floatTransitionDuration = Number.parseFloat(transitionDuration);
  const floatTransitionDelay = Number.parseFloat(transitionDelay);

  // Return 0 if element or transition duration is not found
  if (!floatTransitionDuration && !floatTransitionDelay) {
    return 0;
  }

  // If multiple durations are defined, take the first
  transitionDuration = transitionDuration.split(',')[0];
  transitionDelay = transitionDelay.split(',')[0];
  return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
};
const triggerTransitionEnd = element => {
  element.dispatchEvent(new Event(TRANSITION_END));
};
const isElement = object => {
  if (!object || typeof object !== 'object') {
    return false;
  }
  if (typeof object.jquery !== 'undefined') {
    object = object[0];
  }
  return typeof object.nodeType !== 'undefined';
};
const getElement = object => {
  // it's a jQuery object or a node element
  if (isElement(object)) {
    return object.jquery ? object[0] : object;
  }
  if (typeof object === 'string' && object.length > 0) {
    return document.querySelector(parseSelector(object));
  }
  return null;
};
const isVisible = element => {
  if (!isElement(element) || element.getClientRects().length === 0) {
    return false;
  }
  const elementIsVisible = getComputedStyle(element).getPropertyValue('visibility') === 'visible';
  // Handle `details` element as its content may falsie appear visible when it is closed
  const closedDetails = element.closest('details:not([open])');
  if (!closedDetails) {
    return elementIsVisible;
  }
  if (closedDetails !== element) {
    const summary = element.closest('summary');
    if (summary && summary.parentNode !== closedDetails) {
      return false;
    }
    if (summary === null) {
      return false;
    }
  }
  return elementIsVisible;
};
const isDisabled = element => {
  if (!element || element.nodeType !== Node.ELEMENT_NODE) {
    return true;
  }
  if (element.classList.contains('disabled')) {
    return true;
  }
  if (typeof element.disabled !== 'undefined') {
    return element.disabled;
  }
  return element.hasAttribute('disabled') && element.getAttribute('disabled') !== 'false';
};
const findShadowRoot = element => {
  if (!document.documentElement.attachShadow) {
    return null;
  }

  // Can find the shadow root otherwise it'll return the document
  if (typeof element.getRootNode === 'function') {
    const root = element.getRootNode();
    return root instanceof ShadowRoot ? root : null;
  }
  if (element instanceof ShadowRoot) {
    return element;
  }

  // when we don't find a shadow root
  if (!element.parentNode) {
    return null;
  }
  return findShadowRoot(element.parentNode);
};
const noop = () => {};

/**
 * Trick to restart an element's animation
 *
 * @param {HTMLElement} element
 * @return void
 *
 * @see https://www.charistheo.io/blog/2021/02/restart-a-css-animation-with-javascript/#restarting-a-css-animation
 */
const reflow = element => {
  element.offsetHeight; // eslint-disable-line no-unused-expressions
};

const getjQuery = () => {
  if (window.jQuery && !document.body.hasAttribute('data-bs-no-jquery')) {
    return window.jQuery;
  }
  return null;
};
const DOMContentLoadedCallbacks = [];
const onDOMContentLoaded = callback => {
  if (document.readyState === 'loading') {
    // add listener on the first call when the document is in loading state
    if (!DOMContentLoadedCallbacks.length) {
      document.addEventListener('DOMContentLoaded', () => {
        for (const callback of DOMContentLoadedCallbacks) {
          callback();
        }
      });
    }
    DOMContentLoadedCallbacks.push(callback);
  } else {
    callback();
  }
};
const isRTL = () => document.documentElement.dir === 'rtl';
const defineJQueryPlugin = plugin => {
  onDOMContentLoaded(() => {
    const $ = getjQuery();
    /* istanbul ignore if */
    if ($) {
      const name = plugin.NAME;
      const JQUERY_NO_CONFLICT = $.fn[name];
      $.fn[name] = plugin.jQueryInterface;
      $.fn[name].Constructor = plugin;
      $.fn[name].noConflict = () => {
        $.fn[name] = JQUERY_NO_CONFLICT;
        return plugin.jQueryInterface;
      };
    }
  });
};
const execute = (possibleCallback, args = [], defaultValue = possibleCallback) => {
  return typeof possibleCallback === 'function' ? possibleCallback(...args) : defaultValue;
};
const executeAfterTransition = (callback, transitionElement, waitForTransition = true) => {
  if (!waitForTransition) {
    execute(callback);
    return;
  }
  const durationPadding = 5;
  const emulatedDuration = getTransitionDurationFromElement(transitionElement) + durationPadding;
  let called = false;
  const handler = ({
    target
  }) => {
    if (target !== transitionElement) {
      return;
    }
    called = true;
    transitionElement.removeEventListener(TRANSITION_END, handler);
    execute(callback);
  };
  transitionElement.addEventListener(TRANSITION_END, handler);
  setTimeout(() => {
    if (!called) {
      triggerTransitionEnd(transitionElement);
    }
  }, emulatedDuration);
};

/**
 * Return the previous/next element of a list.
 *
 * @param {array} list    The list of elements
 * @param activeElement   The active element
 * @param shouldGetNext   Choose to get next or previous element
 * @param isCycleAllowed
 * @return {Element|elem} The proper element
 */
const getNextActiveElement = (list, activeElement, shouldGetNext, isCycleAllowed) => {
  const listLength = list.length;
  let index = list.indexOf(activeElement);

  // if the element does not exist in the list return an element
  // depending on the direction and if cycle is allowed
  if (index === -1) {
    return !shouldGetNext && isCycleAllowed ? list[listLength - 1] : list[0];
  }
  index += shouldGetNext ? 1 : -1;
  if (isCycleAllowed) {
    index = (index + listLength) % listLength;
  }
  return list[Math.max(0, Math.min(index, listLength - 1))];
};

/**
 * --------------------------------------------------------------------------
 * Bootstrap dom/event-handler.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */

const namespaceRegex = /[^.]*(?=\..*)\.|.*/;
const stripNameRegex = /\..*/;
const stripUidRegex = /::\d+$/;
const eventRegistry = {}; // Events storage
let uidEvent = 1;
const customEvents = {
  mouseenter: 'mouseover',
  mouseleave: 'mouseout'
};
const nativeEvents = new Set(['click', 'dblclick', 'mouseup', 'mousedown', 'contextmenu', 'mousewheel', 'DOMMouseScroll', 'mouseover', 'mouseout', 'mousemove', 'selectstart', 'selectend', 'keydown', 'keypress', 'keyup', 'orientationchange', 'touchstart', 'touchmove', 'touchend', 'touchcancel', 'pointerdown', 'pointermove', 'pointerup', 'pointerleave', 'pointercancel', 'gesturestart', 'gesturechange', 'gestureend', 'focus', 'blur', 'change', 'reset', 'select', 'submit', 'focusin', 'focusout', 'load', 'unload', 'beforeunload', 'resize', 'move', 'DOMContentLoaded', 'readystatechange', 'error', 'abort', 'scroll']);

/**
 * Private methods
 */

function makeEventUid(element, uid) {
  return uid && `${uid}::${uidEvent++}` || element.uidEvent || uidEvent++;
}
function getElementEvents(element) {
  const uid = makeEventUid(element);
  element.uidEvent = uid;
  eventRegistry[uid] = eventRegistry[uid] || {};
  return eventRegistry[uid];
}
function bootstrapHandler(element, fn) {
  return function handler(event) {
    hydrateObj(event, {
      delegateTarget: element
    });
    if (handler.oneOff) {
      EventHandler.off(element, event.type, fn);
    }
    return fn.apply(element, [event]);
  };
}
function bootstrapDelegationHandler(element, selector, fn) {
  return function handler(event) {
    const domElements = element.querySelectorAll(selector);
    for (let {
      target
    } = event; target && target !== this; target = target.parentNode) {
      for (const domElement of domElements) {
        if (domElement !== target) {
          continue;
        }
        hydrateObj(event, {
          delegateTarget: target
        });
        if (handler.oneOff) {
          EventHandler.off(element, event.type, selector, fn);
        }
        return fn.apply(target, [event]);
      }
    }
  };
}
function findHandler(events, callable, delegationSelector = null) {
  return Object.values(events).find(event => event.callable === callable && event.delegationSelector === delegationSelector);
}
function normalizeParameters(originalTypeEvent, handler, delegationFunction) {
  const isDelegated = typeof handler === 'string';
  // TODO: tooltip passes `false` instead of selector, so we need to check
  const callable = isDelegated ? delegationFunction : handler || delegationFunction;
  let typeEvent = getTypeEvent(originalTypeEvent);
  if (!nativeEvents.has(typeEvent)) {
    typeEvent = originalTypeEvent;
  }
  return [isDelegated, callable, typeEvent];
}
function addHandler(element, originalTypeEvent, handler, delegationFunction, oneOff) {
  if (typeof originalTypeEvent !== 'string' || !element) {
    return;
  }
  let [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);

  // in case of mouseenter or mouseleave wrap the handler within a function that checks for its DOM position
  // this prevents the handler from being dispatched the same way as mouseover or mouseout does
  if (originalTypeEvent in customEvents) {
    const wrapFunction = fn => {
      return function (event) {
        if (!event.relatedTarget || event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget)) {
          return fn.call(this, event);
        }
      };
    };
    callable = wrapFunction(callable);
  }
  const events = getElementEvents(element);
  const handlers = events[typeEvent] || (events[typeEvent] = {});
  const previousFunction = findHandler(handlers, callable, isDelegated ? handler : null);
  if (previousFunction) {
    previousFunction.oneOff = previousFunction.oneOff && oneOff;
    return;
  }
  const uid = makeEventUid(callable, originalTypeEvent.replace(namespaceRegex, ''));
  const fn = isDelegated ? bootstrapDelegationHandler(element, handler, callable) : bootstrapHandler(element, callable);
  fn.delegationSelector = isDelegated ? handler : null;
  fn.callable = callable;
  fn.oneOff = oneOff;
  fn.uidEvent = uid;
  handlers[uid] = fn;
  element.addEventListener(typeEvent, fn, isDelegated);
}
function removeHandler(element, events, typeEvent, handler, delegationSelector) {
  const fn = findHandler(events[typeEvent], handler, delegationSelector);
  if (!fn) {
    return;
  }
  element.removeEventListener(typeEvent, fn, Boolean(delegationSelector));
  delete events[typeEvent][fn.uidEvent];
}
function removeNamespacedHandlers(element, events, typeEvent, namespace) {
  const storeElementEvent = events[typeEvent] || {};
  for (const [handlerKey, event] of Object.entries(storeElementEvent)) {
    if (handlerKey.includes(namespace)) {
      removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);
    }
  }
}
function getTypeEvent(event) {
  // allow to get the native events from namespaced events ('click.bs.button' --> 'click')
  event = event.replace(stripNameRegex, '');
  return customEvents[event] || event;
}
const EventHandler = {
  on(element, event, handler, delegationFunction) {
    addHandler(element, event, handler, delegationFunction, false);
  },
  one(element, event, handler, delegationFunction) {
    addHandler(element, event, handler, delegationFunction, true);
  },
  off(element, originalTypeEvent, handler, delegationFunction) {
    if (typeof originalTypeEvent !== 'string' || !element) {
      return;
    }
    const [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);
    const inNamespace = typeEvent !== originalTypeEvent;
    const events = getElementEvents(element);
    const storeElementEvent = events[typeEvent] || {};
    const isNamespace = originalTypeEvent.startsWith('.');
    if (typeof callable !== 'undefined') {
      // Simplest case: handler is passed, remove that listener ONLY.
      if (!Object.keys(storeElementEvent).length) {
        return;
      }
      removeHandler(element, events, typeEvent, callable, isDelegated ? handler : null);
      return;
    }
    if (isNamespace) {
      for (const elementEvent of Object.keys(events)) {
        removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1));
      }
    }
    for (const [keyHandlers, event] of Object.entries(storeElementEvent)) {
      const handlerKey = keyHandlers.replace(stripUidRegex, '');
      if (!inNamespace || originalTypeEvent.includes(handlerKey)) {
        removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);
      }
    }
  },
  trigger(element, event, args) {
    if (typeof event !== 'string' || !element) {
      return null;
    }
    const $ = getjQuery();
    const typeEvent = getTypeEvent(event);
    const inNamespace = event !== typeEvent;
    let jQueryEvent = null;
    let bubbles = true;
    let nativeDispatch = true;
    let defaultPrevented = false;
    if (inNamespace && $) {
      jQueryEvent = $.Event(event, args);
      $(element).trigger(jQueryEvent);
      bubbles = !jQueryEvent.isPropagationStopped();
      nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();
      defaultPrevented = jQueryEvent.isDefaultPrevented();
    }
    const evt = hydrateObj(new Event(event, {
      bubbles,
      cancelable: true
    }), args);
    if (defaultPrevented) {
      evt.preventDefault();
    }
    if (nativeDispatch) {
      element.dispatchEvent(evt);
    }
    if (evt.defaultPrevented && jQueryEvent) {
      jQueryEvent.preventDefault();
    }
    return evt;
  }
};
function hydrateObj(obj, meta = {}) {
  for (const [key, value] of Object.entries(meta)) {
    try {
      obj[key] = value;
    } catch (_unused) {
      Object.defineProperty(obj, key, {
        configurable: true,
        get() {
          return value;
        }
      });
    }
  }
  return obj;
}

/**
 * --------------------------------------------------------------------------
 * Bootstrap dom/manipulator.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

function normalizeData(value) {
  if (value === 'true') {
    return true;
  }
  if (value === 'false') {
    return false;
  }
  if (value === Number(value).toString()) {
    return Number(value);
  }
  if (value === '' || value === 'null') {
    return null;
  }
  if (typeof value !== 'string') {
    return value;
  }
  try {
    return JSON.parse(decodeURIComponent(value));
  } catch (_unused) {
    return value;
  }
}
function normalizeDataKey(key) {
  return key.replace(/[A-Z]/g, chr => `-${chr.toLowerCase()}`);
}
const Manipulator = {
  setDataAttribute(element, key, value) {
    element.setAttribute(`data-bs-${normalizeDataKey(key)}`, value);
  },
  removeDataAttribute(element, key) {
    element.removeAttribute(`data-bs-${normalizeDataKey(key)}`);
  },
  getDataAttributes(element) {
    if (!element) {
      return {};
    }
    const attributes = {};
    const bsKeys = Object.keys(element.dataset).filter(key => key.startsWith('bs') && !key.startsWith('bsConfig'));
    for (const key of bsKeys) {
      let pureKey = key.replace(/^bs/, '');
      pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1, pureKey.length);
      attributes[pureKey] = normalizeData(element.dataset[key]);
    }
    return attributes;
  },
  getDataAttribute(element, key) {
    return normalizeData(element.getAttribute(`data-bs-${normalizeDataKey(key)}`));
  }
};

/**
 * --------------------------------------------------------------------------
 * Bootstrap util/config.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Class definition
 */

class Config {
  // Getters
  static get Default() {
    return {};
  }
  static get DefaultType() {
    return {};
  }
  static get NAME() {
    throw new Error('You have to implement the static method "NAME", for each component!');
  }
  _getConfig(config) {
    config = this._mergeConfigObj(config);
    config = this._configAfterMerge(config);
    this._typeCheckConfig(config);
    return config;
  }
  _configAfterMerge(config) {
    return config;
  }
  _mergeConfigObj(config, element) {
    const jsonConfig = isElement(element) ? Manipulator.getDataAttribute(element, 'config') : {}; // try to parse

    return {
      ...this.constructor.Default,
      ...(typeof jsonConfig === 'object' ? jsonConfig : {}),
      ...(isElement(element) ? Manipulator.getDataAttributes(element) : {}),
      ...(typeof config === 'object' ? config : {})
    };
  }
  _typeCheckConfig(config, configTypes = this.constructor.DefaultType) {
    for (const [property, expectedTypes] of Object.entries(configTypes)) {
      const value = config[property];
      const valueType = isElement(value) ? 'element' : toType(value);
      if (!new RegExp(expectedTypes).test(valueType)) {
        throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${property}" provided type "${valueType}" but expected type "${expectedTypes}".`);
      }
    }
  }
}

/**
 * --------------------------------------------------------------------------
 * Bootstrap base-component.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */

const VERSION = '5.3.0-alpha2';

/**
 * Class definition
 */

class BaseComponent extends Config {
  constructor(element, config) {
    super();
    element = getElement(element);
    if (!element) {
      return;
    }
    this._element = element;
    this._config = this._getConfig(config);
    Data.set(this._element, this.constructor.DATA_KEY, this);
  }

  // Public
  dispose() {
    Data.remove(this._element, this.constructor.DATA_KEY);
    EventHandler.off(this._element, this.constructor.EVENT_KEY);
    for (const propertyName of Object.getOwnPropertyNames(this)) {
      this[propertyName] = null;
    }
  }
  _queueCallback(callback, element, isAnimated = true) {
    executeAfterTransition(callback, element, isAnimated);
  }
  _getConfig(config) {
    config = this._mergeConfigObj(config, this._element);
    config = this._configAfterMerge(config);
    this._typeCheckConfig(config);
    return config;
  }

  // Static
  static getInstance(element) {
    return Data.get(getElement(element), this.DATA_KEY);
  }
  static getOrCreateInstance(element, config = {}) {
    return this.getInstance(element) || new this(element, typeof config === 'object' ? config : null);
  }
  static get VERSION() {
    return VERSION;
  }
  static get DATA_KEY() {
    return `bs.${this.NAME}`;
  }
  static get EVENT_KEY() {
    return `.${this.DATA_KEY}`;
  }
  static eventName(name) {
    return `${name}${this.EVENT_KEY}`;
  }
}

/**
 * --------------------------------------------------------------------------
 * Bootstrap dom/selector-engine.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */
const getSelector = element => {
  let selector = element.getAttribute('data-bs-target');
  if (!selector || selector === '#') {
    let hrefAttribute = element.getAttribute('href');

    // The only valid content that could double as a selector are IDs or classes,
    // so everything starting with `#` or `.`. If a "real" URL is used as the selector,
    // `document.querySelector` will rightfully complain it is invalid.
    // See https://github.com/twbs/bootstrap/issues/32273
    if (!hrefAttribute || !hrefAttribute.includes('#') && !hrefAttribute.startsWith('.')) {
      return null;
    }

    // Just in case some CMS puts out a full URL with the anchor appended
    if (hrefAttribute.includes('#') && !hrefAttribute.startsWith('#')) {
      hrefAttribute = `#${hrefAttribute.split('#')[1]}`;
    }
    selector = hrefAttribute && hrefAttribute !== '#' ? hrefAttribute.trim() : null;
  }
  return parseSelector(selector);
};
const SelectorEngine = {
  find(selector, element = document.documentElement) {
    return [].concat(...Element.prototype.querySelectorAll.call(element, selector));
  },
  findOne(selector, element = document.documentElement) {
    return Element.prototype.querySelector.call(element, selector);
  },
  children(element, selector) {
    return [].concat(...element.children).filter(child => child.matches(selector));
  },
  parents(element, selector) {
    const parents = [];
    let ancestor = element.parentNode.closest(selector);
    while (ancestor) {
      parents.push(ancestor);
      ancestor = ancestor.parentNode.closest(selector);
    }
    return parents;
  },
  prev(element, selector) {
    let previous = element.previousElementSibling;
    while (previous) {
      if (previous.matches(selector)) {
        return [previous];
      }
      previous = previous.previousElementSibling;
    }
    return [];
  },
  // TODO: this is now unused; remove later along with prev()
  next(element, selector) {
    let next = element.nextElementSibling;
    while (next) {
      if (next.matches(selector)) {
        return [next];
      }
      next = next.nextElementSibling;
    }
    return [];
  },
  focusableChildren(element) {
    const focusables = ['a', 'button', 'input', 'textarea', 'select', 'details', '[tabindex]', '[contenteditable="true"]'].map(selector => `${selector}:not([tabindex^="-"])`).join(',');
    return this.find(focusables, element).filter(el => !isDisabled(el) && isVisible(el));
  },
  getSelectorFromElement(element) {
    const selector = getSelector(element);
    if (selector) {
      return SelectorEngine.findOne(selector) ? selector : null;
    }
    return null;
  },
  getElementFromSelector(element) {
    const selector = getSelector(element);
    return selector ? SelectorEngine.findOne(selector) : null;
  },
  getMultipleElementsFromSelector(element) {
    const selector = getSelector(element);
    return selector ? SelectorEngine.find(selector) : [];
  }
};

/**
 * --------------------------------------------------------------------------
 * Bootstrap util/component-functions.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */
const enableDismissTrigger = (component, method = 'hide') => {
  const clickEvent = `click.dismiss${component.EVENT_KEY}`;
  const name = component.NAME;
  EventHandler.on(document, clickEvent, `[data-bs-dismiss="${name}"]`, function (event) {
    if (['A', 'AREA'].includes(this.tagName)) {
      event.preventDefault();
    }
    if (isDisabled(this)) {
      return;
    }
    const target = SelectorEngine.getElementFromSelector(this) || this.closest(`.${name}`);
    const instance = component.getOrCreateInstance(target);

    // Method argument is left, for Alert and only, as it doesn't implement the 'hide' method
    instance[method]();
  });
};

/**
 * --------------------------------------------------------------------------
 * Bootstrap alert.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */

const NAME$f = 'alert';
const DATA_KEY$a = 'bs.alert';
const EVENT_KEY$b = `.${DATA_KEY$a}`;
const EVENT_CLOSE = `close${EVENT_KEY$b}`;
const EVENT_CLOSED = `closed${EVENT_KEY$b}`;
const CLASS_NAME_FADE$5 = 'fade';
const CLASS_NAME_SHOW$8 = 'show';

/**
 * Class definition
 */

class Alert extends BaseComponent {
  // Getters
  static get NAME() {
    return NAME$f;
  }

  // Public
  close() {
    const closeEvent = EventHandler.trigger(this._element, EVENT_CLOSE);
    if (closeEvent.defaultPrevented) {
      return;
    }
    this._element.classList.remove(CLASS_NAME_SHOW$8);
    const isAnimated = this._element.classList.contains(CLASS_NAME_FADE$5);
    this._queueCallback(() => this._destroyElement(), this._element, isAnimated);
  }

  // Private
  _destroyElement() {
    this._element.remove();
    EventHandler.trigger(this._element, EVENT_CLOSED);
    this.dispose();
  }

  // Static
  static jQueryInterface(config) {
    return this.each(function () {
      const data = Alert.getOrCreateInstance(this);
      if (typeof config !== 'string') {
        return;
      }
      if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {
        throw new TypeError(`No method named "${config}"`);
      }
      data[config](this);
    });
  }
}

/**
 * Data API implementation
 */

enableDismissTrigger(Alert, 'close');

/**
 * jQuery
 */

defineJQueryPlugin(Alert);

/**
 * --------------------------------------------------------------------------
 * Bootstrap button.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */

const NAME$e = 'button';
const DATA_KEY$9 = 'bs.button';
const EVENT_KEY$a = `.${DATA_KEY$9}`;
const DATA_API_KEY$6 = '.data-api';
const CLASS_NAME_ACTIVE$3 = 'active';
const SELECTOR_DATA_TOGGLE$5 = '[data-bs-toggle="button"]';
const EVENT_CLICK_DATA_API$6 = `click${EVENT_KEY$a}${DATA_API_KEY$6}`;

/**
 * Class definition
 */

class Button extends BaseComponent {
  // Getters
  static get NAME() {
    return NAME$e;
  }

  // Public
  toggle() {
    // Toggle class and sync the `aria-pressed` attribute with the return value of the `.toggle()` method
    this._element.setAttribute('aria-pressed', this._element.classList.toggle(CLASS_NAME_ACTIVE$3));
  }

  // Static
  static jQueryInterface(config) {
    return this.each(function () {
      const data = Button.getOrCreateInstance(this);
      if (config === 'toggle') {
        data[config]();
      }
    });
  }
}

/**
 * Data API implementation
 */

EventHandler.on(document, EVENT_CLICK_DATA_API$6, SELECTOR_DATA_TOGGLE$5, event => {
  event.preventDefault();
  const button = event.target.closest(SELECTOR_DATA_TOGGLE$5);
  const data = Button.getOrCreateInstance(button);
  data.toggle();
});

/**
 * jQuery
 */

defineJQueryPlugin(Button);

/**
 * --------------------------------------------------------------------------
 * Bootstrap util/swipe.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */

const NAME$d = 'swipe';
const EVENT_KEY$9 = '.bs.swipe';
const EVENT_TOUCHSTART = `touchstart${EVENT_KEY$9}`;
const EVENT_TOUCHMOVE = `touchmove${EVENT_KEY$9}`;
const EVENT_TOUCHEND = `touchend${EVENT_KEY$9}`;
const EVENT_POINTERDOWN = `pointerdown${EVENT_KEY$9}`;
const EVENT_POINTERUP = `pointerup${EVENT_KEY$9}`;
const POINTER_TYPE_TOUCH = 'touch';
const POINTER_TYPE_PEN = 'pen';
const CLASS_NAME_POINTER_EVENT = 'pointer-event';
const SWIPE_THRESHOLD = 40;
const Default$c = {
  endCallback: null,
  leftCallback: null,
  rightCallback: null
};
const DefaultType$c = {
  endCallback: '(function|null)',
  leftCallback: '(function|null)',
  rightCallback: '(function|null)'
};

/**
 * Class definition
 */

class Swipe extends Config {
  constructor(element, config) {
    super();
    this._element = element;
    if (!element || !Swipe.isSupported()) {
      return;
    }
    this._config = this._getConfig(config);
    this._deltaX = 0;
    this._supportPointerEvents = Boolean(window.PointerEvent);
    this._initEvents();
  }

  // Getters
  static get Default() {
    return Default$c;
  }
  static get DefaultType() {
    return DefaultType$c;
  }
  static get NAME() {
    return NAME$d;
  }

  // Public
  dispose() {
    EventHandler.off(this._element, EVENT_KEY$9);
  }

  // Private
  _start(event) {
    if (!this._supportPointerEvents) {
      this._deltaX = event.touches[0].clientX;
      return;
    }
    if (this._eventIsPointerPenTouch(event)) {
      this._deltaX = event.clientX;
    }
  }
  _end(event) {
    if (this._eventIsPointerPenTouch(event)) {
      this._deltaX = event.clientX - this._deltaX;
    }
    this._handleSwipe();
    execute(this._config.endCallback);
  }
  _move(event) {
    this._deltaX = event.touches && event.touches.length > 1 ? 0 : event.touches[0].clientX - this._deltaX;
  }
  _handleSwipe() {
    const absDeltaX = Math.abs(this._deltaX);
    if (absDeltaX <= SWIPE_THRESHOLD) {
      return;
    }
    const direction = absDeltaX / this._deltaX;
    this._deltaX = 0;
    if (!direction) {
      return;
    }
    execute(direction > 0 ? this._config.rightCallback : this._config.leftCallback);
  }
  _initEvents() {
    if (this._supportPointerEvents) {
      EventHandler.on(this._element, EVENT_POINTERDOWN, event => this._start(event));
      EventHandler.on(this._element, EVENT_POINTERUP, event => this._end(event));
      this._element.classList.add(CLASS_NAME_POINTER_EVENT);
    } else {
      EventHandler.on(this._element, EVENT_TOUCHSTART, event => this._start(event));
      EventHandler.on(this._element, EVENT_TOUCHMOVE, event => this._move(event));
      EventHandler.on(this._element, EVENT_TOUCHEND, event => this._end(event));
    }
  }
  _eventIsPointerPenTouch(event) {
    return this._supportPointerEvents && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH);
  }

  // Static
  static isSupported() {
    return 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0;
  }
}

/**
 * --------------------------------------------------------------------------
 * Bootstrap carousel.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */

const NAME$c = 'carousel';
const DATA_KEY$8 = 'bs.carousel';
const EVENT_KEY$8 = `.${DATA_KEY$8}`;
const DATA_API_KEY$5 = '.data-api';
const ARROW_LEFT_KEY$1 = 'ArrowLeft';
const ARROW_RIGHT_KEY$1 = 'ArrowRight';
const TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch

const ORDER_NEXT = 'next';
const ORDER_PREV = 'prev';
const DIRECTION_LEFT = 'left';
const DIRECTION_RIGHT = 'right';
const EVENT_SLIDE = `slide${EVENT_KEY$8}`;
const EVENT_SLID = `slid${EVENT_KEY$8}`;
const EVENT_KEYDOWN$1 = `keydown${EVENT_KEY$8}`;
const EVENT_MOUSEENTER$1 = `mouseenter${EVENT_KEY$8}`;
const EVENT_MOUSELEAVE$1 = `mouseleave${EVENT_KEY$8}`;
const EVENT_DRAG_START = `dragstart${EVENT_KEY$8}`;
const EVENT_LOAD_DATA_API$3 = `load${EVENT_KEY$8}${DATA_API_KEY$5}`;
const EVENT_CLICK_DATA_API$5 = `click${EVENT_KEY$8}${DATA_API_KEY$5}`;
const CLASS_NAME_CAROUSEL = 'carousel';
const CLASS_NAME_ACTIVE$2 = 'active';
const CLASS_NAME_SLIDE = 'slide';
const CLASS_NAME_END = 'carousel-item-end';
const CLASS_NAME_START = 'carousel-item-start';
const CLASS_NAME_NEXT = 'carousel-item-next';
const CLASS_NAME_PREV = 'carousel-item-prev';
const SELECTOR_ACTIVE = '.active';
const SELECTOR_ITEM = '.carousel-item';
const SELECTOR_ACTIVE_ITEM = SELECTOR_ACTIVE + SELECTOR_ITEM;
const SELECTOR_ITEM_IMG = '.carousel-item img';
const SELECTOR_INDICATORS = '.carousel-indicators';
const SELECTOR_DATA_SLIDE = '[data-bs-slide], [data-bs-slide-to]';
const SELECTOR_DATA_RIDE = '[data-bs-ride="carousel"]';
const KEY_TO_DIRECTION = {
  [ARROW_LEFT_KEY$1]: DIRECTION_RIGHT,
  [ARROW_RIGHT_KEY$1]: DIRECTION_LEFT
};
const Default$b = {
  interval: 5000,
  keyboard: true,
  pause: 'hover',
  ride: false,
  touch: true,
  wrap: true
};
const DefaultType$b = {
  interval: '(number|boolean)',
  // TODO:v6 remove boolean support
  keyboard: 'boolean',
  pause: '(string|boolean)',
  ride: '(boolean|string)',
  touch: 'boolean',
  wrap: 'boolean'
};

/**
 * Class definition
 */

class Carousel extends BaseComponent {
  constructor(element, config) {
    super(element, config);
    this._interval = null;
    this._activeElement = null;
    this._isSliding = false;
    this.touchTimeout = null;
    this._swipeHelper = null;
    this._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, this._element);
    this._addEventListeners();
    if (this._config.ride === CLASS_NAME_CAROUSEL) {
      this.cycle();
    }
  }

  // Getters
  static get Default() {
    return Default$b;
  }
  static get DefaultType() {
    return DefaultType$b;
  }
  static get NAME() {
    return NAME$c;
  }

  // Public
  next() {
    this._slide(ORDER_NEXT);
  }
  nextWhenVisible() {
    // FIXME TODO use `document.visibilityState`
    // Don't call next when the page isn't visible
    // or the carousel or its parent isn't visible
    if (!document.hidden && isVisible(this._element)) {
      this.next();
    }
  }
  prev() {
    this._slide(ORDER_PREV);
  }
  pause() {
    if (this._isSliding) {
      triggerTransitionEnd(this._element);
    }
    this._clearInterval();
  }
  cycle() {
    this._clearInterval();
    this._updateInterval();
    this._interval = setInterval(() => this.nextWhenVisible(), this._config.interval);
  }
  _maybeEnableCycle() {
    if (!this._config.ride) {
      return;
    }
    if (this._isSliding) {
      EventHandler.one(this._element, EVENT_SLID, () => this.cycle());
      return;
    }
    this.cycle();
  }
  to(index) {
    const items = this._getItems();
    if (index > items.length - 1 || index < 0) {
      return;
    }
    if (this._isSliding) {
      EventHandler.one(this._element, EVENT_SLID, () => this.to(index));
      return;
    }
    const activeIndex = this._getItemIndex(this._getActive());
    if (activeIndex === index) {
      return;
    }
    const order = index > activeIndex ? ORDER_NEXT : ORDER_PREV;
    this._slide(order, items[index]);
  }
  dispose() {
    if (this._swipeHelper) {
      this._swipeHelper.dispose();
    }
    super.dispose();
  }

  // Private
  _configAfterMerge(config) {
    config.defaultInterval = config.interval;
    return config;
  }
  _addEventListeners() {
    if (this._config.keyboard) {
      EventHandler.on(this._element, EVENT_KEYDOWN$1, event => this._keydown(event));
    }
    if (this._config.pause === 'hover') {
      EventHandler.on(this._element, EVENT_MOUSEENTER$1, () => this.pause());
      EventHandler.on(this._element, EVENT_MOUSELEAVE$1, () => this._maybeEnableCycle());
    }
    if (this._config.touch && Swipe.isSupported()) {
      this._addTouchEventListeners();
    }
  }
  _addTouchEventListeners() {
    for (const img of SelectorEngine.find(SELECTOR_ITEM_IMG, this._element)) {
      EventHandler.on(img, EVENT_DRAG_START, event => event.preventDefault());
    }
    const endCallBack = () => {
      if (this._config.pause !== 'hover') {
        return;
      }

      // If it's a touch-enabled device, mouseenter/leave are fired as
      // part of the mouse compatibility events on first tap - the carousel
      // would stop cycling until user tapped out of it;
      // here, we listen for touchend, explicitly pause the carousel
      // (as if it's the second time we tap on it, mouseenter compat event
      // is NOT fired) and after a timeout (to allow for mouse compatibility
      // events to fire) we explicitly restart cycling

      this.pause();
      if (this.touchTimeout) {
        clearTimeout(this.touchTimeout);
      }
      this.touchTimeout = setTimeout(() => this._maybeEnableCycle(), TOUCHEVENT_COMPAT_WAIT + this._config.interval);
    };
    const swipeConfig = {
      leftCallback: () => this._slide(this._directionToOrder(DIRECTION_LEFT)),
      rightCallback: () => this._slide(this._directionToOrder(DIRECTION_RIGHT)),
      endCallback: endCallBack
    };
    this._swipeHelper = new Swipe(this._element, swipeConfig);
  }
  _keydown(event) {
    if (/input|textarea/i.test(event.target.tagName)) {
      return;
    }
    const direction = KEY_TO_DIRECTION[event.key];
    if (direction) {
      event.preventDefault();
      this._slide(this._directionToOrder(direction));
    }
  }
  _getItemIndex(element) {
    return this._getItems().indexOf(element);
  }
  _setActiveIndicatorElement(index) {
    if (!this._indicatorsElement) {
      return;
    }
    const activeIndicator = SelectorEngine.findOne(SELECTOR_ACTIVE, this._indicatorsElement);
    activeIndicator.classList.remove(CLASS_NAME_ACTIVE$2);
    activeIndicator.removeAttribute('aria-current');
    const newActiveIndicator = SelectorEngine.findOne(`[data-bs-slide-to="${index}"]`, this._indicatorsElement);
    if (newActiveIndicator) {
      newActiveIndicator.classList.add(CLASS_NAME_ACTIVE$2);
      newActiveIndicator.setAttribute('aria-current', 'true');
    }
  }
  _updateInterval() {
    const element = this._activeElement || this._getActive();
    if (!element) {
      return;
    }
    const elementInterval = Number.parseInt(element.getAttribute('data-bs-interval'), 10);
    this._config.interval = elementInterval || this._config.defaultInterval;
  }
  _slide(order, element = null) {
    if (this._isSliding) {
      return;
    }
    const activeElement = this._getActive();
    const isNext = order === ORDER_NEXT;
    const nextElement = element || getNextActiveElement(this._getItems(), activeElement, isNext, this._config.wrap);
    if (nextElement === activeElement) {
      return;
    }
    const nextElementIndex = this._getItemIndex(nextElement);
    const triggerEvent = eventName => {
      return EventHandler.trigger(this._element, eventName, {
        relatedTarget: nextElement,
        direction: this._orderToDirection(order),
        from: this._getItemIndex(activeElement),
        to: nextElementIndex
      });
    };
    const slideEvent = triggerEvent(EVENT_SLIDE);
    if (slideEvent.defaultPrevented) {
      return;
    }
    if (!activeElement || !nextElement) {
      // Some weirdness is happening, so we bail
      // TODO: change tests that use empty divs to avoid this check
      return;
    }
    const isCycling = Boolean(this._interval);
    this.pause();
    this._isSliding = true;
    this._setActiveIndicatorElement(nextElementIndex);
    this._activeElement = nextElement;
    const directionalClassName = isNext ? CLASS_NAME_START : CLASS_NAME_END;
    const orderClassName = isNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV;
    nextElement.classList.add(orderClassName);
    reflow(nextElement);
    activeElement.classList.add(directionalClassName);
    nextElement.classList.add(directionalClassName);
    const completeCallBack = () => {
      nextElement.classList.remove(directionalClassName, orderClassName);
      nextElement.classList.add(CLASS_NAME_ACTIVE$2);
      activeElement.classList.remove(CLASS_NAME_ACTIVE$2, orderClassName, directionalClassName);
      this._isSliding = false;
      triggerEvent(EVENT_SLID);
    };
    this._queueCallback(completeCallBack, activeElement, this._isAnimated());
    if (isCycling) {
      this.cycle();
    }
  }
  _isAnimated() {
    return this._element.classList.contains(CLASS_NAME_SLIDE);
  }
  _getActive() {
    return SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);
  }
  _getItems() {
    return SelectorEngine.find(SELECTOR_ITEM, this._element);
  }
  _clearInterval() {
    if (this._interval) {
      clearInterval(this._interval);
      this._interval = null;
    }
  }
  _directionToOrder(direction) {
    if (isRTL()) {
      return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT;
    }
    return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV;
  }
  _orderToDirection(order) {
    if (isRTL()) {
      return order === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return order === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT;
  }

  // Static
  static jQueryInterface(config) {
    return this.each(function () {
      const data = Carousel.getOrCreateInstance(this, config);
      if (typeof config === 'number') {
        data.to(config);
        return;
      }
      if (typeof config === 'string') {
        if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config]();
      }
    });
  }
}

/**
 * Data API implementation
 */

EventHandler.on(document, EVENT_CLICK_DATA_API$5, SELECTOR_DATA_SLIDE, function (event) {
  const target = SelectorEngine.getElementFromSelector(this);
  if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) {
    return;
  }
  event.preventDefault();
  const carousel = Carousel.getOrCreateInstance(target);
  const slideIndex = this.getAttribute('data-bs-slide-to');
  if (slideIndex) {
    carousel.to(slideIndex);
    carousel._maybeEnableCycle();
    return;
  }
  if (Manipulator.getDataAttribute(this, 'slide') === 'next') {
    carousel.next();
    carousel._maybeEnableCycle();
    return;
  }
  carousel.prev();
  carousel._maybeEnableCycle();
});
EventHandler.on(window, EVENT_LOAD_DATA_API$3, () => {
  const carousels = SelectorEngine.find(SELECTOR_DATA_RIDE);
  for (const carousel of carousels) {
    Carousel.getOrCreateInstance(carousel);
  }
});

/**
 * jQuery
 */

defineJQueryPlugin(Carousel);

/**
 * --------------------------------------------------------------------------
 * Bootstrap collapse.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */

const NAME$b = 'collapse';
const DATA_KEY$7 = 'bs.collapse';
const EVENT_KEY$7 = `.${DATA_KEY$7}`;
const DATA_API_KEY$4 = '.data-api';
const EVENT_SHOW$6 = `show${EVENT_KEY$7}`;
const EVENT_SHOWN$6 = `shown${EVENT_KEY$7}`;
const EVENT_HIDE$6 = `hide${EVENT_KEY$7}`;
const EVENT_HIDDEN$6 = `hidden${EVENT_KEY$7}`;
const EVENT_CLICK_DATA_API$4 = `click${EVENT_KEY$7}${DATA_API_KEY$4}`;
const CLASS_NAME_SHOW$7 = 'show';
const CLASS_NAME_COLLAPSE = 'collapse';
const CLASS_NAME_COLLAPSING = 'collapsing';
const CLASS_NAME_COLLAPSED = 'collapsed';
const CLASS_NAME_DEEPER_CHILDREN = `:scope .${CLASS_NAME_COLLAPSE} .${CLASS_NAME_COLLAPSE}`;
const CLASS_NAME_HORIZONTAL = 'collapse-horizontal';
const WIDTH = 'width';
const HEIGHT = 'height';
const SELECTOR_ACTIVES = '.collapse.show, .collapse.collapsing';
const SELECTOR_DATA_TOGGLE$4 = '[data-bs-toggle="collapse"]';
const Default$a = {
  parent: null,
  toggle: true
};
const DefaultType$a = {
  parent: '(null|element)',
  toggle: 'boolean'
};

/**
 * Class definition
 */

class Collapse extends BaseComponent {
  constructor(element, config) {
    super(element, config);
    this._isTransitioning = false;
    this._triggerArray = [];
    const toggleList = SelectorEngine.find(SELECTOR_DATA_TOGGLE$4);
    for (const elem of toggleList) {
      const selector = SelectorEngine.getSelectorFromElement(elem);
      const filterElement = SelectorEngine.find(selector).filter(foundElement => foundElement === this._element);
      if (selector !== null && filterElement.length) {
        this._triggerArray.push(elem);
      }
    }
    this._initializeChildren();
    if (!this._config.parent) {
      this._addAriaAndCollapsedClass(this._triggerArray, this._isShown());
    }
    if (this._config.toggle) {
      this.toggle();
    }
  }

  // Getters
  static get Default() {
    return Default$a;
  }
  static get DefaultType() {
    return DefaultType$a;
  }
  static get NAME() {
    return NAME$b;
  }

  // Public
  toggle() {
    if (this._isShown()) {
      this.hide();
    } else {
      this.show();
    }
  }
  show() {
    if (this._isTransitioning || this._isShown()) {
      return;
    }
    let activeChildren = [];

    // find active children
    if (this._config.parent) {
      activeChildren = this._getFirstLevelChildren(SELECTOR_ACTIVES).filter(element => element !== this._element).map(element => Collapse.getOrCreateInstance(element, {
        toggle: false
      }));
    }
    if (activeChildren.length && activeChildren[0]._isTransitioning) {
      return;
    }
    const startEvent = EventHandler.trigger(this._element, EVENT_SHOW$6);
    if (startEvent.defaultPrevented) {
      return;
    }
    for (const activeInstance of activeChildren) {
      activeInstance.hide();
    }
    const dimension = this._getDimension();
    this._element.classList.remove(CLASS_NAME_COLLAPSE);
    this._element.classList.add(CLASS_NAME_COLLAPSING);
    this._element.style[dimension] = 0;
    this._addAriaAndCollapsedClass(this._triggerArray, true);
    this._isTransitioning = true;
    const complete = () => {
      this._isTransitioning = false;
      this._element.classList.remove(CLASS_NAME_COLLAPSING);
      this._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);
      this._element.style[dimension] = '';
      EventHandler.trigger(this._element, EVENT_SHOWN$6);
    };
    const capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
    const scrollSize = `scroll${capitalizedDimension}`;
    this._queueCallback(complete, this._element, true);
    this._element.style[dimension] = `${this._element[scrollSize]}px`;
  }
  hide() {
    if (this._isTransitioning || !this._isShown()) {
      return;
    }
    const startEvent = EventHandler.trigger(this._element, EVENT_HIDE$6);
    if (startEvent.defaultPrevented) {
      return;
    }
    const dimension = this._getDimension();
    this._element.style[dimension] = `${this._element.getBoundingClientRect()[dimension]}px`;
    reflow(this._element);
    this._element.classList.add(CLASS_NAME_COLLAPSING);
    this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);
    for (const trigger of this._triggerArray) {
      const element = SelectorEngine.getElementFromSelector(trigger);
      if (element && !this._isShown(element)) {
        this._addAriaAndCollapsedClass([trigger], false);
      }
    }
    this._isTransitioning = true;
    const complete = () => {
      this._isTransitioning = false;
      this._element.classList.remove(CLASS_NAME_COLLAPSING);
      this._element.classList.add(CLASS_NAME_COLLAPSE);
      EventHandler.trigger(this._element, EVENT_HIDDEN$6);
    };
    this._element.style[dimension] = '';
    this._queueCallback(complete, this._element, true);
  }
  _isShown(element = this._element) {
    return element.classList.contains(CLASS_NAME_SHOW$7);
  }

  // Private
  _configAfterMerge(config) {
    config.toggle = Boolean(config.toggle); // Coerce string values
    config.parent = getElement(config.parent);
    return config;
  }
  _getDimension() {
    return this._element.classList.contains(CLASS_NAME_HORIZONTAL) ? WIDTH : HEIGHT;
  }
  _initializeChildren() {
    if (!this._config.parent) {
      return;
    }
    const children = this._getFirstLevelChildren(SELECTOR_DATA_TOGGLE$4);
    for (const element of children) {
      const selected = SelectorEngine.getElementFromSelector(element);
      if (selected) {
        this._addAriaAndCollapsedClass([element], this._isShown(selected));
      }
    }
  }
  _getFirstLevelChildren(selector) {
    const children = SelectorEngine.find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent);
    // remove children if greater depth
    return SelectorEngine.find(selector, this._config.parent).filter(element => !children.includes(element));
  }
  _addAriaAndCollapsedClass(triggerArray, isOpen) {
    if (!triggerArray.length) {
      return;
    }
    for (const element of triggerArray) {
      element.classList.toggle(CLASS_NAME_COLLAPSED, !isOpen);
      element.setAttribute('aria-expanded', isOpen);
    }
  }

  // Static
  static jQueryInterface(config) {
    const _config = {};
    if (typeof config === 'string' && /show|hide/.test(config)) {
      _config.toggle = false;
    }
    return this.each(function () {
      const data = Collapse.getOrCreateInstance(this, _config);
      if (typeof config === 'string') {
        if (typeof data[config] === 'undefined') {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config]();
      }
    });
  }
}

/**
 * Data API implementation
 */

EventHandler.on(document, EVENT_CLICK_DATA_API$4, SELECTOR_DATA_TOGGLE$4, function (event) {
  // preventDefault only for <a> elements (which change the URL) not inside the collapsible element
  if (event.target.tagName === 'A' || event.delegateTarget && event.delegateTarget.tagName === 'A') {
    event.preventDefault();
  }
  for (const element of SelectorEngine.getMultipleElementsFromSelector(this)) {
    Collapse.getOrCreateInstance(element, {
      toggle: false
    }).toggle();
  }
});

/**
 * jQuery
 */

defineJQueryPlugin(Collapse);

/**
 * --------------------------------------------------------------------------
 * Bootstrap dropdown.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */

const NAME$a = 'dropdown';
const DATA_KEY$6 = 'bs.dropdown';
const EVENT_KEY$6 = `.${DATA_KEY$6}`;
const DATA_API_KEY$3 = '.data-api';
const ESCAPE_KEY$2 = 'Escape';
const TAB_KEY$1 = 'Tab';
const ARROW_UP_KEY$1 = 'ArrowUp';
const ARROW_DOWN_KEY$1 = 'ArrowDown';
const RIGHT_MOUSE_BUTTON = 2; // MouseEvent.button value for the secondary button, usually the right button

const EVENT_HIDE$5 = `hide${EVENT_KEY$6}`;
const EVENT_HIDDEN$5 = `hidden${EVENT_KEY$6}`;
const EVENT_SHOW$5 = `show${EVENT_KEY$6}`;
const EVENT_SHOWN$5 = `shown${EVENT_KEY$6}`;
const EVENT_CLICK_DATA_API$3 = `click${EVENT_KEY$6}${DATA_API_KEY$3}`;
const EVENT_KEYDOWN_DATA_API = `keydown${EVENT_KEY$6}${DATA_API_KEY$3}`;
const EVENT_KEYUP_DATA_API = `keyup${EVENT_KEY$6}${DATA_API_KEY$3}`;
const CLASS_NAME_SHOW$6 = 'show';
const CLASS_NAME_DROPUP = 'dropup';
const CLASS_NAME_DROPEND = 'dropend';
const CLASS_NAME_DROPSTART = 'dropstart';
const CLASS_NAME_DROPUP_CENTER = 'dropup-center';
const CLASS_NAME_DROPDOWN_CENTER = 'dropdown-center';
const SELECTOR_DATA_TOGGLE$3 = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)';
const SELECTOR_DATA_TOGGLE_SHOWN = `${SELECTOR_DATA_TOGGLE$3}.${CLASS_NAME_SHOW$6}`;
const SELECTOR_MENU = '.dropdown-menu';
const SELECTOR_NAVBAR = '.navbar';
const SELECTOR_NAVBAR_NAV = '.navbar-nav';
const SELECTOR_VISIBLE_ITEMS = '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)';
const PLACEMENT_TOP = isRTL() ? 'top-end' : 'top-start';
const PLACEMENT_TOPEND = isRTL() ? 'top-start' : 'top-end';
const PLACEMENT_BOTTOM = isRTL() ? 'bottom-end' : 'bottom-start';
const PLACEMENT_BOTTOMEND = isRTL() ? 'bottom-start' : 'bottom-end';
const PLACEMENT_RIGHT = isRTL() ? 'left-start' : 'right-start';
const PLACEMENT_LEFT = isRTL() ? 'right-start' : 'left-start';
const PLACEMENT_TOPCENTER = 'top';
const PLACEMENT_BOTTOMCENTER = 'bottom';
const Default$9 = {
  autoClose: true,
  boundary: 'clippingParents',
  display: 'dynamic',
  offset: [0, 2],
  popperConfig: null,
  reference: 'toggle'
};
const DefaultType$9 = {
  autoClose: '(boolean|string)',
  boundary: '(string|element)',
  display: 'string',
  offset: '(array|string|function)',
  popperConfig: '(null|object|function)',
  reference: '(string|element|object)'
};

/**
 * Class definition
 */

class Dropdown extends BaseComponent {
  constructor(element, config) {
    super(element, config);
    this._popper = null;
    this._parent = this._element.parentNode; // dropdown wrapper
    // TODO: v6 revert #37011 & change markup https://getbootstrap.com/docs/5.3/forms/input-group/
    this._menu = SelectorEngine.next(this._element, SELECTOR_MENU)[0] || SelectorEngine.prev(this._element, SELECTOR_MENU)[0] || SelectorEngine.findOne(SELECTOR_MENU, this._parent);
    this._inNavbar = this._detectNavbar();
  }

  // Getters
  static get Default() {
    return Default$9;
  }
  static get DefaultType() {
    return DefaultType$9;
  }
  static get NAME() {
    return NAME$a;
  }

  // Public
  toggle() {
    return this._isShown() ? this.hide() : this.show();
  }
  show() {
    if (isDisabled(this._element) || this._isShown()) {
      return;
    }
    const relatedTarget = {
      relatedTarget: this._element
    };
    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$5, relatedTarget);
    if (showEvent.defaultPrevented) {
      return;
    }
    this._createPopper();

    // If this is a touch-enabled device we add extra
    // empty mouseover listeners to the body's immediate children;
    // only needed because of broken event delegation on iOS
    // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html
    if ('ontouchstart' in document.documentElement && !this._parent.closest(SELECTOR_NAVBAR_NAV)) {
      for (const element of [].concat(...document.body.children)) {
        EventHandler.on(element, 'mouseover', noop);
      }
    }
    this._element.focus();
    this._element.setAttribute('aria-expanded', true);
    this._menu.classList.add(CLASS_NAME_SHOW$6);
    this._element.classList.add(CLASS_NAME_SHOW$6);
    EventHandler.trigger(this._element, EVENT_SHOWN$5, relatedTarget);
  }
  hide() {
    if (isDisabled(this._element) || !this._isShown()) {
      return;
    }
    const relatedTarget = {
      relatedTarget: this._element
    };
    this._completeHide(relatedTarget);
  }
  dispose() {
    if (this._popper) {
      this._popper.destroy();
    }
    super.dispose();
  }
  update() {
    this._inNavbar = this._detectNavbar();
    if (this._popper) {
      this._popper.update();
    }
  }

  // Private
  _completeHide(relatedTarget) {
    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$5, relatedTarget);
    if (hideEvent.defaultPrevented) {
      return;
    }

    // If this is a touch-enabled device we remove the extra
    // empty mouseover listeners we added for iOS support
    if ('ontouchstart' in document.documentElement) {
      for (const element of [].concat(...document.body.children)) {
        EventHandler.off(element, 'mouseover', noop);
      }
    }
    if (this._popper) {
      this._popper.destroy();
    }
    this._menu.classList.remove(CLASS_NAME_SHOW$6);
    this._element.classList.remove(CLASS_NAME_SHOW$6);
    this._element.setAttribute('aria-expanded', 'false');
    Manipulator.removeDataAttribute(this._menu, 'popper');
    EventHandler.trigger(this._element, EVENT_HIDDEN$5, relatedTarget);
  }
  _getConfig(config) {
    config = super._getConfig(config);
    if (typeof config.reference === 'object' && !isElement(config.reference) && typeof config.reference.getBoundingClientRect !== 'function') {
      // Popper virtual elements require a getBoundingClientRect method
      throw new TypeError(`${NAME$a.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
    }
    return config;
  }
  _createPopper() {
    if (typeof _popperjs_core__WEBPACK_IMPORTED_MODULE_0__ === 'undefined') {
      throw new TypeError('Bootstrap\'s dropdowns require Popper (https://popper.js.org)');
    }
    let referenceElement = this._element;
    if (this._config.reference === 'parent') {
      referenceElement = this._parent;
    } else if (isElement(this._config.reference)) {
      referenceElement = getElement(this._config.reference);
    } else if (typeof this._config.reference === 'object') {
      referenceElement = this._config.reference;
    }
    const popperConfig = this._getPopperConfig();
    this._popper = _popperjs_core__WEBPACK_IMPORTED_MODULE_1__.createPopper(referenceElement, this._menu, popperConfig);
  }
  _isShown() {
    return this._menu.classList.contains(CLASS_NAME_SHOW$6);
  }
  _getPlacement() {
    const parentDropdown = this._parent;
    if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) {
      return PLACEMENT_RIGHT;
    }
    if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) {
      return PLACEMENT_LEFT;
    }
    if (parentDropdown.classList.contains(CLASS_NAME_DROPUP_CENTER)) {
      return PLACEMENT_TOPCENTER;
    }
    if (parentDropdown.classList.contains(CLASS_NAME_DROPDOWN_CENTER)) {
      return PLACEMENT_BOTTOMCENTER;
    }

    // We need to trim the value because custom properties can also include spaces
    const isEnd = getComputedStyle(this._menu).getPropertyValue('--bs-position').trim() === 'end';
    if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) {
      return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;
    }
    return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;
  }
  _detectNavbar() {
    return this._element.closest(SELECTOR_NAVBAR) !== null;
  }
  _getOffset() {
    const {
      offset
    } = this._config;
    if (typeof offset === 'string') {
      return offset.split(',').map(value => Number.parseInt(value, 10));
    }
    if (typeof offset === 'function') {
      return popperData => offset(popperData, this._element);
    }
    return offset;
  }
  _getPopperConfig() {
    const defaultBsPopperConfig = {
      placement: this._getPlacement(),
      modifiers: [{
        name: 'preventOverflow',
        options: {
          boundary: this._config.boundary
        }
      }, {
        name: 'offset',
        options: {
          offset: this._getOffset()
        }
      }]
    };

    // Disable Popper if we have a static display or Dropdown is in Navbar
    if (this._inNavbar || this._config.display === 'static') {
      Manipulator.setDataAttribute(this._menu, 'popper', 'static'); // TODO: v6 remove
      defaultBsPopperConfig.modifiers = [{
        name: 'applyStyles',
        enabled: false
      }];
    }
    return {
      ...defaultBsPopperConfig,
      ...execute(this._config.popperConfig, [defaultBsPopperConfig])
    };
  }
  _selectMenuItem({
    key,
    target
  }) {
    const items = SelectorEngine.find(SELECTOR_VISIBLE_ITEMS, this._menu).filter(element => isVisible(element));
    if (!items.length) {
      return;
    }

    // if target isn't included in items (e.g. when expanding the dropdown)
    // allow cycling to get the last item in case key equals ARROW_UP_KEY
    getNextActiveElement(items, target, key === ARROW_DOWN_KEY$1, !items.includes(target)).focus();
  }

  // Static
  static jQueryInterface(config) {
    return this.each(function () {
      const data = Dropdown.getOrCreateInstance(this, config);
      if (typeof config !== 'string') {
        return;
      }
      if (typeof data[config] === 'undefined') {
        throw new TypeError(`No method named "${config}"`);
      }
      data[config]();
    });
  }
  static clearMenus(event) {
    if (event.button === RIGHT_MOUSE_BUTTON || event.type === 'keyup' && event.key !== TAB_KEY$1) {
      return;
    }
    const openToggles = SelectorEngine.find(SELECTOR_DATA_TOGGLE_SHOWN);
    for (const toggle of openToggles) {
      const context = Dropdown.getInstance(toggle);
      if (!context || context._config.autoClose === false) {
        continue;
      }
      const composedPath = event.composedPath();
      const isMenuTarget = composedPath.includes(context._menu);
      if (composedPath.includes(context._element) || context._config.autoClose === 'inside' && !isMenuTarget || context._config.autoClose === 'outside' && isMenuTarget) {
        continue;
      }

      // Tab navigation through the dropdown menu or events from contained inputs shouldn't close the menu
      if (context._menu.contains(event.target) && (event.type === 'keyup' && event.key === TAB_KEY$1 || /input|select|option|textarea|form/i.test(event.target.tagName))) {
        continue;
      }
      const relatedTarget = {
        relatedTarget: context._element
      };
      if (event.type === 'click') {
        relatedTarget.clickEvent = event;
      }
      context._completeHide(relatedTarget);
    }
  }
  static dataApiKeydownHandler(event) {
    // If not an UP | DOWN | ESCAPE key => not a dropdown command
    // If input/textarea && if key is other than ESCAPE => not a dropdown command

    const isInput = /input|textarea/i.test(event.target.tagName);
    const isEscapeEvent = event.key === ESCAPE_KEY$2;
    const isUpOrDownEvent = [ARROW_UP_KEY$1, ARROW_DOWN_KEY$1].includes(event.key);
    if (!isUpOrDownEvent && !isEscapeEvent) {
      return;
    }
    if (isInput && !isEscapeEvent) {
      return;
    }
    event.preventDefault();

    // TODO: v6 revert #37011 & change markup https://getbootstrap.com/docs/5.3/forms/input-group/
    const getToggleButton = this.matches(SELECTOR_DATA_TOGGLE$3) ? this : SelectorEngine.prev(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.next(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.findOne(SELECTOR_DATA_TOGGLE$3, event.delegateTarget.parentNode);
    const instance = Dropdown.getOrCreateInstance(getToggleButton);
    if (isUpOrDownEvent) {
      event.stopPropagation();
      instance.show();
      instance._selectMenuItem(event);
      return;
    }
    if (instance._isShown()) {
      // else is escape and we check if it is shown
      event.stopPropagation();
      instance.hide();
      getToggleButton.focus();
    }
  }
}

/**
 * Data API implementation
 */

EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$3, Dropdown.dataApiKeydownHandler);
EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler);
EventHandler.on(document, EVENT_CLICK_DATA_API$3, Dropdown.clearMenus);
EventHandler.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);
EventHandler.on(document, EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, function (event) {
  event.preventDefault();
  Dropdown.getOrCreateInstance(this).toggle();
});

/**
 * jQuery
 */

defineJQueryPlugin(Dropdown);

/**
 * --------------------------------------------------------------------------
 * Bootstrap util/backdrop.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */

const NAME$9 = 'backdrop';
const CLASS_NAME_FADE$4 = 'fade';
const CLASS_NAME_SHOW$5 = 'show';
const EVENT_MOUSEDOWN = `mousedown.bs.${NAME$9}`;
const Default$8 = {
  className: 'modal-backdrop',
  clickCallback: null,
  isAnimated: false,
  isVisible: true,
  // if false, we use the backdrop helper without adding any element to the dom
  rootElement: 'body' // give the choice to place backdrop under different elements
};

const DefaultType$8 = {
  className: 'string',
  clickCallback: '(function|null)',
  isAnimated: 'boolean',
  isVisible: 'boolean',
  rootElement: '(element|string)'
};

/**
 * Class definition
 */

class Backdrop extends Config {
  constructor(config) {
    super();
    this._config = this._getConfig(config);
    this._isAppended = false;
    this._element = null;
  }

  // Getters
  static get Default() {
    return Default$8;
  }
  static get DefaultType() {
    return DefaultType$8;
  }
  static get NAME() {
    return NAME$9;
  }

  // Public
  show(callback) {
    if (!this._config.isVisible) {
      execute(callback);
      return;
    }
    this._append();
    const element = this._getElement();
    if (this._config.isAnimated) {
      reflow(element);
    }
    element.classList.add(CLASS_NAME_SHOW$5);
    this._emulateAnimation(() => {
      execute(callback);
    });
  }
  hide(callback) {
    if (!this._config.isVisible) {
      execute(callback);
      return;
    }
    this._getElement().classList.remove(CLASS_NAME_SHOW$5);
    this._emulateAnimation(() => {
      this.dispose();
      execute(callback);
    });
  }
  dispose() {
    if (!this._isAppended) {
      return;
    }
    EventHandler.off(this._element, EVENT_MOUSEDOWN);
    this._element.remove();
    this._isAppended = false;
  }

  // Private
  _getElement() {
    if (!this._element) {
      const backdrop = document.createElement('div');
      backdrop.className = this._config.className;
      if (this._config.isAnimated) {
        backdrop.classList.add(CLASS_NAME_FADE$4);
      }
      this._element = backdrop;
    }
    return this._element;
  }
  _configAfterMerge(config) {
    // use getElement() with the default "body" to get a fresh Element on each instantiation
    config.rootElement = getElement(config.rootElement);
    return config;
  }
  _append() {
    if (this._isAppended) {
      return;
    }
    const element = this._getElement();
    this._config.rootElement.append(element);
    EventHandler.on(element, EVENT_MOUSEDOWN, () => {
      execute(this._config.clickCallback);
    });
    this._isAppended = true;
  }
  _emulateAnimation(callback) {
    executeAfterTransition(callback, this._getElement(), this._config.isAnimated);
  }
}

/**
 * --------------------------------------------------------------------------
 * Bootstrap util/focustrap.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */

const NAME$8 = 'focustrap';
const DATA_KEY$5 = 'bs.focustrap';
const EVENT_KEY$5 = `.${DATA_KEY$5}`;
const EVENT_FOCUSIN$2 = `focusin${EVENT_KEY$5}`;
const EVENT_KEYDOWN_TAB = `keydown.tab${EVENT_KEY$5}`;
const TAB_KEY = 'Tab';
const TAB_NAV_FORWARD = 'forward';
const TAB_NAV_BACKWARD = 'backward';
const Default$7 = {
  autofocus: true,
  trapElement: null // The element to trap focus inside of
};

const DefaultType$7 = {
  autofocus: 'boolean',
  trapElement: 'element'
};

/**
 * Class definition
 */

class FocusTrap extends Config {
  constructor(config) {
    super();
    this._config = this._getConfig(config);
    this._isActive = false;
    this._lastTabNavDirection = null;
  }

  // Getters
  static get Default() {
    return Default$7;
  }
  static get DefaultType() {
    return DefaultType$7;
  }
  static get NAME() {
    return NAME$8;
  }

  // Public
  activate() {
    if (this._isActive) {
      return;
    }
    if (this._config.autofocus) {
      this._config.trapElement.focus();
    }
    EventHandler.off(document, EVENT_KEY$5); // guard against infinite focus loop
    EventHandler.on(document, EVENT_FOCUSIN$2, event => this._handleFocusin(event));
    EventHandler.on(document, EVENT_KEYDOWN_TAB, event => this._handleKeydown(event));
    this._isActive = true;
  }
  deactivate() {
    if (!this._isActive) {
      return;
    }
    this._isActive = false;
    EventHandler.off(document, EVENT_KEY$5);
  }

  // Private
  _handleFocusin(event) {
    const {
      trapElement
    } = this._config;
    if (event.target === document || event.target === trapElement || trapElement.contains(event.target)) {
      return;
    }
    const elements = SelectorEngine.focusableChildren(trapElement);
    if (elements.length === 0) {
      trapElement.focus();
    } else if (this._lastTabNavDirection === TAB_NAV_BACKWARD) {
      elements[elements.length - 1].focus();
    } else {
      elements[0].focus();
    }
  }
  _handleKeydown(event) {
    if (event.key !== TAB_KEY) {
      return;
    }
    this._lastTabNavDirection = event.shiftKey ? TAB_NAV_BACKWARD : TAB_NAV_FORWARD;
  }
}

/**
 * --------------------------------------------------------------------------
 * Bootstrap util/scrollBar.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */

const SELECTOR_FIXED_CONTENT = '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top';
const SELECTOR_STICKY_CONTENT = '.sticky-top';
const PROPERTY_PADDING = 'padding-right';
const PROPERTY_MARGIN = 'margin-right';

/**
 * Class definition
 */

class ScrollBarHelper {
  constructor() {
    this._element = document.body;
  }

  // Public
  getWidth() {
    // https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth#usage_notes
    const documentWidth = document.documentElement.clientWidth;
    return Math.abs(window.innerWidth - documentWidth);
  }
  hide() {
    const width = this.getWidth();
    this._disableOverFlow();
    // give padding to element to balance the hidden scrollbar width
    this._setElementAttributes(this._element, PROPERTY_PADDING, calculatedValue => calculatedValue + width);
    // trick: We adjust positive paddingRight and negative marginRight to sticky-top elements to keep showing fullwidth
    this._setElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING, calculatedValue => calculatedValue + width);
    this._setElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN, calculatedValue => calculatedValue - width);
  }
  reset() {
    this._resetElementAttributes(this._element, 'overflow');
    this._resetElementAttributes(this._element, PROPERTY_PADDING);
    this._resetElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING);
    this._resetElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN);
  }
  isOverflowing() {
    return this.getWidth() > 0;
  }

  // Private
  _disableOverFlow() {
    this._saveInitialAttribute(this._element, 'overflow');
    this._element.style.overflow = 'hidden';
  }
  _setElementAttributes(selector, styleProperty, callback) {
    const scrollbarWidth = this.getWidth();
    const manipulationCallBack = element => {
      if (element !== this._element && window.innerWidth > element.clientWidth + scrollbarWidth) {
        return;
      }
      this._saveInitialAttribute(element, styleProperty);
      const calculatedValue = window.getComputedStyle(element).getPropertyValue(styleProperty);
      element.style.setProperty(styleProperty, `${callback(Number.parseFloat(calculatedValue))}px`);
    };
    this._applyManipulationCallback(selector, manipulationCallBack);
  }
  _saveInitialAttribute(element, styleProperty) {
    const actualValue = element.style.getPropertyValue(styleProperty);
    if (actualValue) {
      Manipulator.setDataAttribute(element, styleProperty, actualValue);
    }
  }
  _resetElementAttributes(selector, styleProperty) {
    const manipulationCallBack = element => {
      const value = Manipulator.getDataAttribute(element, styleProperty);
      // We only want to remove the property if the value is `null`; the value can also be zero
      if (value === null) {
        element.style.removeProperty(styleProperty);
        return;
      }
      Manipulator.removeDataAttribute(element, styleProperty);
      element.style.setProperty(styleProperty, value);
    };
    this._applyManipulationCallback(selector, manipulationCallBack);
  }
  _applyManipulationCallback(selector, callBack) {
    if (isElement(selector)) {
      callBack(selector);
      return;
    }
    for (const sel of SelectorEngine.find(selector, this._element)) {
      callBack(sel);
    }
  }
}

/**
 * --------------------------------------------------------------------------
 * Bootstrap modal.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */

const NAME$7 = 'modal';
const DATA_KEY$4 = 'bs.modal';
const EVENT_KEY$4 = `.${DATA_KEY$4}`;
const DATA_API_KEY$2 = '.data-api';
const ESCAPE_KEY$1 = 'Escape';
const EVENT_HIDE$4 = `hide${EVENT_KEY$4}`;
const EVENT_HIDE_PREVENTED$1 = `hidePrevented${EVENT_KEY$4}`;
const EVENT_HIDDEN$4 = `hidden${EVENT_KEY$4}`;
const EVENT_SHOW$4 = `show${EVENT_KEY$4}`;
const EVENT_SHOWN$4 = `shown${EVENT_KEY$4}`;
const EVENT_RESIZE$1 = `resize${EVENT_KEY$4}`;
const EVENT_CLICK_DISMISS = `click.dismiss${EVENT_KEY$4}`;
const EVENT_MOUSEDOWN_DISMISS = `mousedown.dismiss${EVENT_KEY$4}`;
const EVENT_KEYDOWN_DISMISS$1 = `keydown.dismiss${EVENT_KEY$4}`;
const EVENT_CLICK_DATA_API$2 = `click${EVENT_KEY$4}${DATA_API_KEY$2}`;
const CLASS_NAME_OPEN = 'modal-open';
const CLASS_NAME_FADE$3 = 'fade';
const CLASS_NAME_SHOW$4 = 'show';
const CLASS_NAME_STATIC = 'modal-static';
const OPEN_SELECTOR$1 = '.modal.show';
const SELECTOR_DIALOG = '.modal-dialog';
const SELECTOR_MODAL_BODY = '.modal-body';
const SELECTOR_DATA_TOGGLE$2 = '[data-bs-toggle="modal"]';
const Default$6 = {
  backdrop: true,
  focus: true,
  keyboard: true
};
const DefaultType$6 = {
  backdrop: '(boolean|string)',
  focus: 'boolean',
  keyboard: 'boolean'
};

/**
 * Class definition
 */

class Modal extends BaseComponent {
  constructor(element, config) {
    super(element, config);
    this._dialog = SelectorEngine.findOne(SELECTOR_DIALOG, this._element);
    this._backdrop = this._initializeBackDrop();
    this._focustrap = this._initializeFocusTrap();
    this._isShown = false;
    this._isTransitioning = false;
    this._scrollBar = new ScrollBarHelper();
    this._addEventListeners();
  }

  // Getters
  static get Default() {
    return Default$6;
  }
  static get DefaultType() {
    return DefaultType$6;
  }
  static get NAME() {
    return NAME$7;
  }

  // Public
  toggle(relatedTarget) {
    return this._isShown ? this.hide() : this.show(relatedTarget);
  }
  show(relatedTarget) {
    if (this._isShown || this._isTransitioning) {
      return;
    }
    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$4, {
      relatedTarget
    });
    if (showEvent.defaultPrevented) {
      return;
    }
    this._isShown = true;
    this._isTransitioning = true;
    this._scrollBar.hide();
    document.body.classList.add(CLASS_NAME_OPEN);
    this._adjustDialog();
    this._backdrop.show(() => this._showElement(relatedTarget));
  }
  hide() {
    if (!this._isShown || this._isTransitioning) {
      return;
    }
    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$4);
    if (hideEvent.defaultPrevented) {
      return;
    }
    this._isShown = false;
    this._isTransitioning = true;
    this._focustrap.deactivate();
    this._element.classList.remove(CLASS_NAME_SHOW$4);
    this._queueCallback(() => this._hideModal(), this._element, this._isAnimated());
  }
  dispose() {
    EventHandler.off(window, EVENT_KEY$4);
    EventHandler.off(this._dialog, EVENT_KEY$4);
    this._backdrop.dispose();
    this._focustrap.deactivate();
    super.dispose();
  }
  handleUpdate() {
    this._adjustDialog();
  }

  // Private
  _initializeBackDrop() {
    return new Backdrop({
      isVisible: Boolean(this._config.backdrop),
      // 'static' option will be translated to true, and booleans will keep their value,
      isAnimated: this._isAnimated()
    });
  }
  _initializeFocusTrap() {
    return new FocusTrap({
      trapElement: this._element
    });
  }
  _showElement(relatedTarget) {
    // try to append dynamic modal
    if (!document.body.contains(this._element)) {
      document.body.append(this._element);
    }
    this._element.style.display = 'block';
    this._element.removeAttribute('aria-hidden');
    this._element.setAttribute('aria-modal', true);
    this._element.setAttribute('role', 'dialog');
    this._element.scrollTop = 0;
    const modalBody = SelectorEngine.findOne(SELECTOR_MODAL_BODY, this._dialog);
    if (modalBody) {
      modalBody.scrollTop = 0;
    }
    reflow(this._element);
    this._element.classList.add(CLASS_NAME_SHOW$4);
    const transitionComplete = () => {
      if (this._config.focus) {
        this._focustrap.activate();
      }
      this._isTransitioning = false;
      EventHandler.trigger(this._element, EVENT_SHOWN$4, {
        relatedTarget
      });
    };
    this._queueCallback(transitionComplete, this._dialog, this._isAnimated());
  }
  _addEventListeners() {
    EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS$1, event => {
      if (event.key !== ESCAPE_KEY$1) {
        return;
      }
      if (this._config.keyboard) {
        this.hide();
        return;
      }
      this._triggerBackdropTransition();
    });
    EventHandler.on(window, EVENT_RESIZE$1, () => {
      if (this._isShown && !this._isTransitioning) {
        this._adjustDialog();
      }
    });
    EventHandler.on(this._element, EVENT_MOUSEDOWN_DISMISS, event => {
      // a bad trick to segregate clicks that may start inside dialog but end outside, and avoid listen to scrollbar clicks
      EventHandler.one(this._element, EVENT_CLICK_DISMISS, event2 => {
        if (this._element !== event.target || this._element !== event2.target) {
          return;
        }
        if (this._config.backdrop === 'static') {
          this._triggerBackdropTransition();
          return;
        }
        if (this._config.backdrop) {
          this.hide();
        }
      });
    });
  }
  _hideModal() {
    this._element.style.display = 'none';
    this._element.setAttribute('aria-hidden', true);
    this._element.removeAttribute('aria-modal');
    this._element.removeAttribute('role');
    this._isTransitioning = false;
    this._backdrop.hide(() => {
      document.body.classList.remove(CLASS_NAME_OPEN);
      this._resetAdjustments();
      this._scrollBar.reset();
      EventHandler.trigger(this._element, EVENT_HIDDEN$4);
    });
  }
  _isAnimated() {
    return this._element.classList.contains(CLASS_NAME_FADE$3);
  }
  _triggerBackdropTransition() {
    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED$1);
    if (hideEvent.defaultPrevented) {
      return;
    }
    const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
    const initialOverflowY = this._element.style.overflowY;
    // return if the following background transition hasn't yet completed
    if (initialOverflowY === 'hidden' || this._element.classList.contains(CLASS_NAME_STATIC)) {
      return;
    }
    if (!isModalOverflowing) {
      this._element.style.overflowY = 'hidden';
    }
    this._element.classList.add(CLASS_NAME_STATIC);
    this._queueCallback(() => {
      this._element.classList.remove(CLASS_NAME_STATIC);
      this._queueCallback(() => {
        this._element.style.overflowY = initialOverflowY;
      }, this._dialog);
    }, this._dialog);
    this._element.focus();
  }

  /**
   * The following methods are used to handle overflowing modals
   */

  _adjustDialog() {
    const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
    const scrollbarWidth = this._scrollBar.getWidth();
    const isBodyOverflowing = scrollbarWidth > 0;
    if (isBodyOverflowing && !isModalOverflowing) {
      const property = isRTL() ? 'paddingLeft' : 'paddingRight';
      this._element.style[property] = `${scrollbarWidth}px`;
    }
    if (!isBodyOverflowing && isModalOverflowing) {
      const property = isRTL() ? 'paddingRight' : 'paddingLeft';
      this._element.style[property] = `${scrollbarWidth}px`;
    }
  }
  _resetAdjustments() {
    this._element.style.paddingLeft = '';
    this._element.style.paddingRight = '';
  }

  // Static
  static jQueryInterface(config, relatedTarget) {
    return this.each(function () {
      const data = Modal.getOrCreateInstance(this, config);
      if (typeof config !== 'string') {
        return;
      }
      if (typeof data[config] === 'undefined') {
        throw new TypeError(`No method named "${config}"`);
      }
      data[config](relatedTarget);
    });
  }
}

/**
 * Data API implementation
 */

EventHandler.on(document, EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, function (event) {
  const target = SelectorEngine.getElementFromSelector(this);
  if (['A', 'AREA'].includes(this.tagName)) {
    event.preventDefault();
  }
  EventHandler.one(target, EVENT_SHOW$4, showEvent => {
    if (showEvent.defaultPrevented) {
      // only register focus restorer if modal will actually get shown
      return;
    }
    EventHandler.one(target, EVENT_HIDDEN$4, () => {
      if (isVisible(this)) {
        this.focus();
      }
    });
  });

  // avoid conflict when clicking modal toggler while another one is open
  const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR$1);
  if (alreadyOpen) {
    Modal.getInstance(alreadyOpen).hide();
  }
  const data = Modal.getOrCreateInstance(target);
  data.toggle(this);
});
enableDismissTrigger(Modal);

/**
 * jQuery
 */

defineJQueryPlugin(Modal);

/**
 * --------------------------------------------------------------------------
 * Bootstrap offcanvas.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */

const NAME$6 = 'offcanvas';
const DATA_KEY$3 = 'bs.offcanvas';
const EVENT_KEY$3 = `.${DATA_KEY$3}`;
const DATA_API_KEY$1 = '.data-api';
const EVENT_LOAD_DATA_API$2 = `load${EVENT_KEY$3}${DATA_API_KEY$1}`;
const ESCAPE_KEY = 'Escape';
const CLASS_NAME_SHOW$3 = 'show';
const CLASS_NAME_SHOWING$1 = 'showing';
const CLASS_NAME_HIDING = 'hiding';
const CLASS_NAME_BACKDROP = 'offcanvas-backdrop';
const OPEN_SELECTOR = '.offcanvas.show';
const EVENT_SHOW$3 = `show${EVENT_KEY$3}`;
const EVENT_SHOWN$3 = `shown${EVENT_KEY$3}`;
const EVENT_HIDE$3 = `hide${EVENT_KEY$3}`;
const EVENT_HIDE_PREVENTED = `hidePrevented${EVENT_KEY$3}`;
const EVENT_HIDDEN$3 = `hidden${EVENT_KEY$3}`;
const EVENT_RESIZE = `resize${EVENT_KEY$3}`;
const EVENT_CLICK_DATA_API$1 = `click${EVENT_KEY$3}${DATA_API_KEY$1}`;
const EVENT_KEYDOWN_DISMISS = `keydown.dismiss${EVENT_KEY$3}`;
const SELECTOR_DATA_TOGGLE$1 = '[data-bs-toggle="offcanvas"]';
const Default$5 = {
  backdrop: true,
  keyboard: true,
  scroll: false
};
const DefaultType$5 = {
  backdrop: '(boolean|string)',
  keyboard: 'boolean',
  scroll: 'boolean'
};

/**
 * Class definition
 */

class Offcanvas extends BaseComponent {
  constructor(element, config) {
    super(element, config);
    this._isShown = false;
    this._backdrop = this._initializeBackDrop();
    this._focustrap = this._initializeFocusTrap();
    this._addEventListeners();
  }

  // Getters
  static get Default() {
    return Default$5;
  }
  static get DefaultType() {
    return DefaultType$5;
  }
  static get NAME() {
    return NAME$6;
  }

  // Public
  toggle(relatedTarget) {
    return this._isShown ? this.hide() : this.show(relatedTarget);
  }
  show(relatedTarget) {
    if (this._isShown) {
      return;
    }
    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$3, {
      relatedTarget
    });
    if (showEvent.defaultPrevented) {
      return;
    }
    this._isShown = true;
    this._backdrop.show();
    if (!this._config.scroll) {
      new ScrollBarHelper().hide();
    }
    this._element.setAttribute('aria-modal', true);
    this._element.setAttribute('role', 'dialog');
    this._element.classList.add(CLASS_NAME_SHOWING$1);
    const completeCallBack = () => {
      if (!this._config.scroll || this._config.backdrop) {
        this._focustrap.activate();
      }
      this._element.classList.add(CLASS_NAME_SHOW$3);
      this._element.classList.remove(CLASS_NAME_SHOWING$1);
      EventHandler.trigger(this._element, EVENT_SHOWN$3, {
        relatedTarget
      });
    };
    this._queueCallback(completeCallBack, this._element, true);
  }
  hide() {
    if (!this._isShown) {
      return;
    }
    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$3);
    if (hideEvent.defaultPrevented) {
      return;
    }
    this._focustrap.deactivate();
    this._element.blur();
    this._isShown = false;
    this._element.classList.add(CLASS_NAME_HIDING);
    this._backdrop.hide();
    const completeCallback = () => {
      this._element.classList.remove(CLASS_NAME_SHOW$3, CLASS_NAME_HIDING);
      this._element.removeAttribute('aria-modal');
      this._element.removeAttribute('role');
      if (!this._config.scroll) {
        new ScrollBarHelper().reset();
      }
      EventHandler.trigger(this._element, EVENT_HIDDEN$3);
    };
    this._queueCallback(completeCallback, this._element, true);
  }
  dispose() {
    this._backdrop.dispose();
    this._focustrap.deactivate();
    super.dispose();
  }

  // Private
  _initializeBackDrop() {
    const clickCallback = () => {
      if (this._config.backdrop === 'static') {
        EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);
        return;
      }
      this.hide();
    };

    // 'static' option will be translated to true, and booleans will keep their value
    const isVisible = Boolean(this._config.backdrop);
    return new Backdrop({
      className: CLASS_NAME_BACKDROP,
      isVisible,
      isAnimated: true,
      rootElement: this._element.parentNode,
      clickCallback: isVisible ? clickCallback : null
    });
  }
  _initializeFocusTrap() {
    return new FocusTrap({
      trapElement: this._element
    });
  }
  _addEventListeners() {
    EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, event => {
      if (event.key !== ESCAPE_KEY) {
        return;
      }
      if (this._config.keyboard) {
        this.hide();
        return;
      }
      EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);
    });
  }

  // Static
  static jQueryInterface(config) {
    return this.each(function () {
      const data = Offcanvas.getOrCreateInstance(this, config);
      if (typeof config !== 'string') {
        return;
      }
      if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {
        throw new TypeError(`No method named "${config}"`);
      }
      data[config](this);
    });
  }
}

/**
 * Data API implementation
 */

EventHandler.on(document, EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, function (event) {
  const target = SelectorEngine.getElementFromSelector(this);
  if (['A', 'AREA'].includes(this.tagName)) {
    event.preventDefault();
  }
  if (isDisabled(this)) {
    return;
  }
  EventHandler.one(target, EVENT_HIDDEN$3, () => {
    // focus on trigger when it is closed
    if (isVisible(this)) {
      this.focus();
    }
  });

  // avoid conflict when clicking a toggler of an offcanvas, while another is open
  const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR);
  if (alreadyOpen && alreadyOpen !== target) {
    Offcanvas.getInstance(alreadyOpen).hide();
  }
  const data = Offcanvas.getOrCreateInstance(target);
  data.toggle(this);
});
EventHandler.on(window, EVENT_LOAD_DATA_API$2, () => {
  for (const selector of SelectorEngine.find(OPEN_SELECTOR)) {
    Offcanvas.getOrCreateInstance(selector).show();
  }
});
EventHandler.on(window, EVENT_RESIZE, () => {
  for (const element of SelectorEngine.find('[aria-modal][class*=show][class*=offcanvas-]')) {
    if (getComputedStyle(element).position !== 'fixed') {
      Offcanvas.getOrCreateInstance(element).hide();
    }
  }
});
enableDismissTrigger(Offcanvas);

/**
 * jQuery
 */

defineJQueryPlugin(Offcanvas);

/**
 * --------------------------------------------------------------------------
 * Bootstrap util/sanitizer.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

const uriAttributes = new Set(['background', 'cite', 'href', 'itemtype', 'longdesc', 'poster', 'src', 'xlink:href']);

/**
 * A pattern that recognizes a commonly useful subset of URLs that are safe.
 *
 * Shout-out to Angular https://github.com/angular/angular/blob/12.2.x/packages/core/src/sanitization/url_sanitizer.ts
 */
const SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i;

/**
 * A pattern that matches safe data URLs. Only matches image, video and audio types.
 *
 * Shout-out to Angular https://github.com/angular/angular/blob/12.2.x/packages/core/src/sanitization/url_sanitizer.ts
 */
const DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i;
const allowedAttribute = (attribute, allowedAttributeList) => {
  const attributeName = attribute.nodeName.toLowerCase();
  if (allowedAttributeList.includes(attributeName)) {
    if (uriAttributes.has(attributeName)) {
      return Boolean(SAFE_URL_PATTERN.test(attribute.nodeValue) || DATA_URL_PATTERN.test(attribute.nodeValue));
    }
    return true;
  }

  // Check if a regular expression validates the attribute.
  return allowedAttributeList.filter(attributeRegex => attributeRegex instanceof RegExp).some(regex => regex.test(attributeName));
};

// js-docs-start allow-list
const ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i;
const DefaultAllowlist = {
  // Global attributes allowed on any supplied element below.
  '*': ['class', 'dir', 'id', 'lang', 'role', ARIA_ATTRIBUTE_PATTERN],
  a: ['target', 'href', 'title', 'rel'],
  area: [],
  b: [],
  br: [],
  col: [],
  code: [],
  div: [],
  em: [],
  hr: [],
  h1: [],
  h2: [],
  h3: [],
  h4: [],
  h5: [],
  h6: [],
  i: [],
  img: ['src', 'srcset', 'alt', 'title', 'width', 'height'],
  li: [],
  ol: [],
  p: [],
  pre: [],
  s: [],
  small: [],
  span: [],
  sub: [],
  sup: [],
  strong: [],
  u: [],
  ul: []
};
// js-docs-end allow-list

function sanitizeHtml(unsafeHtml, allowList, sanitizeFunction) {
  if (!unsafeHtml.length) {
    return unsafeHtml;
  }
  if (sanitizeFunction && typeof sanitizeFunction === 'function') {
    return sanitizeFunction(unsafeHtml);
  }
  const domParser = new window.DOMParser();
  const createdDocument = domParser.parseFromString(unsafeHtml, 'text/html');
  const elements = [].concat(...createdDocument.body.querySelectorAll('*'));
  for (const element of elements) {
    const elementName = element.nodeName.toLowerCase();
    if (!Object.keys(allowList).includes(elementName)) {
      element.remove();
      continue;
    }
    const attributeList = [].concat(...element.attributes);
    const allowedAttributes = [].concat(allowList['*'] || [], allowList[elementName] || []);
    for (const attribute of attributeList) {
      if (!allowedAttribute(attribute, allowedAttributes)) {
        element.removeAttribute(attribute.nodeName);
      }
    }
  }
  return createdDocument.body.innerHTML;
}

/**
 * --------------------------------------------------------------------------
 * Bootstrap util/template-factory.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */

const NAME$5 = 'TemplateFactory';
const Default$4 = {
  allowList: DefaultAllowlist,
  content: {},
  // { selector : text ,  selector2 : text2 , }
  extraClass: '',
  html: false,
  sanitize: true,
  sanitizeFn: null,
  template: '<div></div>'
};
const DefaultType$4 = {
  allowList: 'object',
  content: 'object',
  extraClass: '(string|function)',
  html: 'boolean',
  sanitize: 'boolean',
  sanitizeFn: '(null|function)',
  template: 'string'
};
const DefaultContentType = {
  entry: '(string|element|function|null)',
  selector: '(string|element)'
};

/**
 * Class definition
 */

class TemplateFactory extends Config {
  constructor(config) {
    super();
    this._config = this._getConfig(config);
  }

  // Getters
  static get Default() {
    return Default$4;
  }
  static get DefaultType() {
    return DefaultType$4;
  }
  static get NAME() {
    return NAME$5;
  }

  // Public
  getContent() {
    return Object.values(this._config.content).map(config => this._resolvePossibleFunction(config)).filter(Boolean);
  }
  hasContent() {
    return this.getContent().length > 0;
  }
  changeContent(content) {
    this._checkContent(content);
    this._config.content = {
      ...this._config.content,
      ...content
    };
    return this;
  }
  toHtml() {
    const templateWrapper = document.createElement('div');
    templateWrapper.innerHTML = this._maybeSanitize(this._config.template);
    for (const [selector, text] of Object.entries(this._config.content)) {
      this._setContent(templateWrapper, text, selector);
    }
    const template = templateWrapper.children[0];
    const extraClass = this._resolvePossibleFunction(this._config.extraClass);
    if (extraClass) {
      template.classList.add(...extraClass.split(' '));
    }
    return template;
  }

  // Private
  _typeCheckConfig(config) {
    super._typeCheckConfig(config);
    this._checkContent(config.content);
  }
  _checkContent(arg) {
    for (const [selector, content] of Object.entries(arg)) {
      super._typeCheckConfig({
        selector,
        entry: content
      }, DefaultContentType);
    }
  }
  _setContent(template, content, selector) {
    const templateElement = SelectorEngine.findOne(selector, template);
    if (!templateElement) {
      return;
    }
    content = this._resolvePossibleFunction(content);
    if (!content) {
      templateElement.remove();
      return;
    }
    if (isElement(content)) {
      this._putElementInTemplate(getElement(content), templateElement);
      return;
    }
    if (this._config.html) {
      templateElement.innerHTML = this._maybeSanitize(content);
      return;
    }
    templateElement.textContent = content;
  }
  _maybeSanitize(arg) {
    return this._config.sanitize ? sanitizeHtml(arg, this._config.allowList, this._config.sanitizeFn) : arg;
  }
  _resolvePossibleFunction(arg) {
    return execute(arg, [this]);
  }
  _putElementInTemplate(element, templateElement) {
    if (this._config.html) {
      templateElement.innerHTML = '';
      templateElement.append(element);
      return;
    }
    templateElement.textContent = element.textContent;
  }
}

/**
 * --------------------------------------------------------------------------
 * Bootstrap tooltip.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */

const NAME$4 = 'tooltip';
const DISALLOWED_ATTRIBUTES = new Set(['sanitize', 'allowList', 'sanitizeFn']);
const CLASS_NAME_FADE$2 = 'fade';
const CLASS_NAME_MODAL = 'modal';
const CLASS_NAME_SHOW$2 = 'show';
const SELECTOR_TOOLTIP_INNER = '.tooltip-inner';
const SELECTOR_MODAL = `.${CLASS_NAME_MODAL}`;
const EVENT_MODAL_HIDE = 'hide.bs.modal';
const TRIGGER_HOVER = 'hover';
const TRIGGER_FOCUS = 'focus';
const TRIGGER_CLICK = 'click';
const TRIGGER_MANUAL = 'manual';
const EVENT_HIDE$2 = 'hide';
const EVENT_HIDDEN$2 = 'hidden';
const EVENT_SHOW$2 = 'show';
const EVENT_SHOWN$2 = 'shown';
const EVENT_INSERTED = 'inserted';
const EVENT_CLICK$1 = 'click';
const EVENT_FOCUSIN$1 = 'focusin';
const EVENT_FOCUSOUT$1 = 'focusout';
const EVENT_MOUSEENTER = 'mouseenter';
const EVENT_MOUSELEAVE = 'mouseleave';
const AttachmentMap = {
  AUTO: 'auto',
  TOP: 'top',
  RIGHT: isRTL() ? 'left' : 'right',
  BOTTOM: 'bottom',
  LEFT: isRTL() ? 'right' : 'left'
};
const Default$3 = {
  allowList: DefaultAllowlist,
  animation: true,
  boundary: 'clippingParents',
  container: false,
  customClass: '',
  delay: 0,
  fallbackPlacements: ['top', 'right', 'bottom', 'left'],
  html: false,
  offset: [0, 6],
  placement: 'top',
  popperConfig: null,
  sanitize: true,
  sanitizeFn: null,
  selector: false,
  template: '<div class="tooltip" role="tooltip">' + '<div class="tooltip-arrow"></div>' + '<div class="tooltip-inner"></div>' + '</div>',
  title: '',
  trigger: 'hover focus'
};
const DefaultType$3 = {
  allowList: 'object',
  animation: 'boolean',
  boundary: '(string|element)',
  container: '(string|element|boolean)',
  customClass: '(string|function)',
  delay: '(number|object)',
  fallbackPlacements: 'array',
  html: 'boolean',
  offset: '(array|string|function)',
  placement: '(string|function)',
  popperConfig: '(null|object|function)',
  sanitize: 'boolean',
  sanitizeFn: '(null|function)',
  selector: '(string|boolean)',
  template: 'string',
  title: '(string|element|function)',
  trigger: 'string'
};

/**
 * Class definition
 */

class Tooltip extends BaseComponent {
  constructor(element, config) {
    if (typeof _popperjs_core__WEBPACK_IMPORTED_MODULE_0__ === 'undefined') {
      throw new TypeError('Bootstrap\'s tooltips require Popper (https://popper.js.org)');
    }
    super(element, config);

    // Private
    this._isEnabled = true;
    this._timeout = 0;
    this._isHovered = null;
    this._activeTrigger = {};
    this._popper = null;
    this._templateFactory = null;
    this._newContent = null;

    // Protected
    this.tip = null;
    this._setListeners();
    if (!this._config.selector) {
      this._fixTitle();
    }
  }

  // Getters
  static get Default() {
    return Default$3;
  }
  static get DefaultType() {
    return DefaultType$3;
  }
  static get NAME() {
    return NAME$4;
  }

  // Public
  enable() {
    this._isEnabled = true;
  }
  disable() {
    this._isEnabled = false;
  }
  toggleEnabled() {
    this._isEnabled = !this._isEnabled;
  }
  toggle() {
    if (!this._isEnabled) {
      return;
    }
    this._activeTrigger.click = !this._activeTrigger.click;
    if (this._isShown()) {
      this._leave();
      return;
    }
    this._enter();
  }
  dispose() {
    clearTimeout(this._timeout);
    EventHandler.off(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);
    if (this._element.getAttribute('data-bs-original-title')) {
      this._element.setAttribute('title', this._element.getAttribute('data-bs-original-title'));
    }
    this._disposePopper();
    super.dispose();
  }
  show() {
    if (this._element.style.display === 'none') {
      throw new Error('Please use show on visible elements');
    }
    if (!(this._isWithContent() && this._isEnabled)) {
      return;
    }
    const showEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOW$2));
    const shadowRoot = findShadowRoot(this._element);
    const isInTheDom = (shadowRoot || this._element.ownerDocument.documentElement).contains(this._element);
    if (showEvent.defaultPrevented || !isInTheDom) {
      return;
    }

    // TODO: v6 remove this or make it optional
    this._disposePopper();
    const tip = this._getTipElement();
    this._element.setAttribute('aria-describedby', tip.getAttribute('id'));
    const {
      container
    } = this._config;
    if (!this._element.ownerDocument.documentElement.contains(this.tip)) {
      container.append(tip);
      EventHandler.trigger(this._element, this.constructor.eventName(EVENT_INSERTED));
    }
    this._popper = this._createPopper(tip);
    tip.classList.add(CLASS_NAME_SHOW$2);

    // If this is a touch-enabled device we add extra
    // empty mouseover listeners to the body's immediate children;
    // only needed because of broken event delegation on iOS
    // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html
    if ('ontouchstart' in document.documentElement) {
      for (const element of [].concat(...document.body.children)) {
        EventHandler.on(element, 'mouseover', noop);
      }
    }
    const complete = () => {
      EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOWN$2));
      if (this._isHovered === false) {
        this._leave();
      }
      this._isHovered = false;
    };
    this._queueCallback(complete, this.tip, this._isAnimated());
  }
  hide() {
    if (!this._isShown()) {
      return;
    }
    const hideEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDE$2));
    if (hideEvent.defaultPrevented) {
      return;
    }
    const tip = this._getTipElement();
    tip.classList.remove(CLASS_NAME_SHOW$2);

    // If this is a touch-enabled device we remove the extra
    // empty mouseover listeners we added for iOS support
    if ('ontouchstart' in document.documentElement) {
      for (const element of [].concat(...document.body.children)) {
        EventHandler.off(element, 'mouseover', noop);
      }
    }
    this._activeTrigger[TRIGGER_CLICK] = false;
    this._activeTrigger[TRIGGER_FOCUS] = false;
    this._activeTrigger[TRIGGER_HOVER] = false;
    this._isHovered = null; // it is a trick to support manual triggering

    const complete = () => {
      if (this._isWithActiveTrigger()) {
        return;
      }
      if (!this._isHovered) {
        this._disposePopper();
      }
      this._element.removeAttribute('aria-describedby');
      EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDDEN$2));
    };
    this._queueCallback(complete, this.tip, this._isAnimated());
  }
  update() {
    if (this._popper) {
      this._popper.update();
    }
  }

  // Protected
  _isWithContent() {
    return Boolean(this._getTitle());
  }
  _getTipElement() {
    if (!this.tip) {
      this.tip = this._createTipElement(this._newContent || this._getContentForTemplate());
    }
    return this.tip;
  }
  _createTipElement(content) {
    const tip = this._getTemplateFactory(content).toHtml();

    // TODO: remove this check in v6
    if (!tip) {
      return null;
    }
    tip.classList.remove(CLASS_NAME_FADE$2, CLASS_NAME_SHOW$2);
    // TODO: v6 the following can be achieved with CSS only
    tip.classList.add(`bs-${this.constructor.NAME}-auto`);
    const tipId = getUID(this.constructor.NAME).toString();
    tip.setAttribute('id', tipId);
    if (this._isAnimated()) {
      tip.classList.add(CLASS_NAME_FADE$2);
    }
    return tip;
  }
  setContent(content) {
    this._newContent = content;
    if (this._isShown()) {
      this._disposePopper();
      this.show();
    }
  }
  _getTemplateFactory(content) {
    if (this._templateFactory) {
      this._templateFactory.changeContent(content);
    } else {
      this._templateFactory = new TemplateFactory({
        ...this._config,
        // the `content` var has to be after `this._config`
        // to override config.content in case of popover
        content,
        extraClass: this._resolvePossibleFunction(this._config.customClass)
      });
    }
    return this._templateFactory;
  }
  _getContentForTemplate() {
    return {
      [SELECTOR_TOOLTIP_INNER]: this._getTitle()
    };
  }
  _getTitle() {
    return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute('data-bs-original-title');
  }

  // Private
  _initializeOnDelegatedTarget(event) {
    return this.constructor.getOrCreateInstance(event.delegateTarget, this._getDelegateConfig());
  }
  _isAnimated() {
    return this._config.animation || this.tip && this.tip.classList.contains(CLASS_NAME_FADE$2);
  }
  _isShown() {
    return this.tip && this.tip.classList.contains(CLASS_NAME_SHOW$2);
  }
  _createPopper(tip) {
    const placement = execute(this._config.placement, [this, tip, this._element]);
    const attachment = AttachmentMap[placement.toUpperCase()];
    return _popperjs_core__WEBPACK_IMPORTED_MODULE_1__.createPopper(this._element, tip, this._getPopperConfig(attachment));
  }
  _getOffset() {
    const {
      offset
    } = this._config;
    if (typeof offset === 'string') {
      return offset.split(',').map(value => Number.parseInt(value, 10));
    }
    if (typeof offset === 'function') {
      return popperData => offset(popperData, this._element);
    }
    return offset;
  }
  _resolvePossibleFunction(arg) {
    return execute(arg, [this._element]);
  }
  _getPopperConfig(attachment) {
    const defaultBsPopperConfig = {
      placement: attachment,
      modifiers: [{
        name: 'flip',
        options: {
          fallbackPlacements: this._config.fallbackPlacements
        }
      }, {
        name: 'offset',
        options: {
          offset: this._getOffset()
        }
      }, {
        name: 'preventOverflow',
        options: {
          boundary: this._config.boundary
        }
      }, {
        name: 'arrow',
        options: {
          element: `.${this.constructor.NAME}-arrow`
        }
      }, {
        name: 'preSetPlacement',
        enabled: true,
        phase: 'beforeMain',
        fn: data => {
          // Pre-set Popper's placement attribute in order to read the arrow sizes properly.
          // Otherwise, Popper mixes up the width and height dimensions since the initial arrow style is for top placement
          this._getTipElement().setAttribute('data-popper-placement', data.state.placement);
        }
      }]
    };
    return {
      ...defaultBsPopperConfig,
      ...execute(this._config.popperConfig, [defaultBsPopperConfig])
    };
  }
  _setListeners() {
    const triggers = this._config.trigger.split(' ');
    for (const trigger of triggers) {
      if (trigger === 'click') {
        EventHandler.on(this._element, this.constructor.eventName(EVENT_CLICK$1), this._config.selector, event => {
          const context = this._initializeOnDelegatedTarget(event);
          context.toggle();
        });
      } else if (trigger !== TRIGGER_MANUAL) {
        const eventIn = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSEENTER) : this.constructor.eventName(EVENT_FOCUSIN$1);
        const eventOut = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSELEAVE) : this.constructor.eventName(EVENT_FOCUSOUT$1);
        EventHandler.on(this._element, eventIn, this._config.selector, event => {
          const context = this._initializeOnDelegatedTarget(event);
          context._activeTrigger[event.type === 'focusin' ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;
          context._enter();
        });
        EventHandler.on(this._element, eventOut, this._config.selector, event => {
          const context = this._initializeOnDelegatedTarget(event);
          context._activeTrigger[event.type === 'focusout' ? TRIGGER_FOCUS : TRIGGER_HOVER] = context._element.contains(event.relatedTarget);
          context._leave();
        });
      }
    }
    this._hideModalHandler = () => {
      if (this._element) {
        this.hide();
      }
    };
    EventHandler.on(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);
  }
  _fixTitle() {
    const title = this._element.getAttribute('title');
    if (!title) {
      return;
    }
    if (!this._element.getAttribute('aria-label') && !this._element.textContent.trim()) {
      this._element.setAttribute('aria-label', title);
    }
    this._element.setAttribute('data-bs-original-title', title); // DO NOT USE IT. Is only for backwards compatibility
    this._element.removeAttribute('title');
  }
  _enter() {
    if (this._isShown() || this._isHovered) {
      this._isHovered = true;
      return;
    }
    this._isHovered = true;
    this._setTimeout(() => {
      if (this._isHovered) {
        this.show();
      }
    }, this._config.delay.show);
  }
  _leave() {
    if (this._isWithActiveTrigger()) {
      return;
    }
    this._isHovered = false;
    this._setTimeout(() => {
      if (!this._isHovered) {
        this.hide();
      }
    }, this._config.delay.hide);
  }
  _setTimeout(handler, timeout) {
    clearTimeout(this._timeout);
    this._timeout = setTimeout(handler, timeout);
  }
  _isWithActiveTrigger() {
    return Object.values(this._activeTrigger).includes(true);
  }
  _getConfig(config) {
    const dataAttributes = Manipulator.getDataAttributes(this._element);
    for (const dataAttribute of Object.keys(dataAttributes)) {
      if (DISALLOWED_ATTRIBUTES.has(dataAttribute)) {
        delete dataAttributes[dataAttribute];
      }
    }
    config = {
      ...dataAttributes,
      ...(typeof config === 'object' && config ? config : {})
    };
    config = this._mergeConfigObj(config);
    config = this._configAfterMerge(config);
    this._typeCheckConfig(config);
    return config;
  }
  _configAfterMerge(config) {
    config.container = config.container === false ? document.body : getElement(config.container);
    if (typeof config.delay === 'number') {
      config.delay = {
        show: config.delay,
        hide: config.delay
      };
    }
    if (typeof config.title === 'number') {
      config.title = config.title.toString();
    }
    if (typeof config.content === 'number') {
      config.content = config.content.toString();
    }
    return config;
  }
  _getDelegateConfig() {
    const config = {};
    for (const [key, value] of Object.entries(this._config)) {
      if (this.constructor.Default[key] !== value) {
        config[key] = value;
      }
    }
    config.selector = false;
    config.trigger = 'manual';

    // In the future can be replaced with:
    // const keysWithDifferentValues = Object.entries(this._config).filter(entry => this.constructor.Default[entry[0]] !== this._config[entry[0]])
    // `Object.fromEntries(keysWithDifferentValues)`
    return config;
  }
  _disposePopper() {
    if (this._popper) {
      this._popper.destroy();
      this._popper = null;
    }
    if (this.tip) {
      this.tip.remove();
      this.tip = null;
    }
  }

  // Static
  static jQueryInterface(config) {
    return this.each(function () {
      const data = Tooltip.getOrCreateInstance(this, config);
      if (typeof config !== 'string') {
        return;
      }
      if (typeof data[config] === 'undefined') {
        throw new TypeError(`No method named "${config}"`);
      }
      data[config]();
    });
  }
}

/**
 * jQuery
 */

defineJQueryPlugin(Tooltip);

/**
 * --------------------------------------------------------------------------
 * Bootstrap popover.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */

const NAME$3 = 'popover';
const SELECTOR_TITLE = '.popover-header';
const SELECTOR_CONTENT = '.popover-body';
const Default$2 = {
  ...Tooltip.Default,
  content: '',
  offset: [0, 8],
  placement: 'right',
  template: '<div class="popover" role="tooltip">' + '<div class="popover-arrow"></div>' + '<h3 class="popover-header"></h3>' + '<div class="popover-body"></div>' + '</div>',
  trigger: 'click'
};
const DefaultType$2 = {
  ...Tooltip.DefaultType,
  content: '(null|string|element|function)'
};

/**
 * Class definition
 */

class Popover extends Tooltip {
  // Getters
  static get Default() {
    return Default$2;
  }
  static get DefaultType() {
    return DefaultType$2;
  }
  static get NAME() {
    return NAME$3;
  }

  // Overrides
  _isWithContent() {
    return this._getTitle() || this._getContent();
  }

  // Private
  _getContentForTemplate() {
    return {
      [SELECTOR_TITLE]: this._getTitle(),
      [SELECTOR_CONTENT]: this._getContent()
    };
  }
  _getContent() {
    return this._resolvePossibleFunction(this._config.content);
  }

  // Static
  static jQueryInterface(config) {
    return this.each(function () {
      const data = Popover.getOrCreateInstance(this, config);
      if (typeof config !== 'string') {
        return;
      }
      if (typeof data[config] === 'undefined') {
        throw new TypeError(`No method named "${config}"`);
      }
      data[config]();
    });
  }
}

/**
 * jQuery
 */

defineJQueryPlugin(Popover);

/**
 * --------------------------------------------------------------------------
 * Bootstrap scrollspy.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */

const NAME$2 = 'scrollspy';
const DATA_KEY$2 = 'bs.scrollspy';
const EVENT_KEY$2 = `.${DATA_KEY$2}`;
const DATA_API_KEY = '.data-api';
const EVENT_ACTIVATE = `activate${EVENT_KEY$2}`;
const EVENT_CLICK = `click${EVENT_KEY$2}`;
const EVENT_LOAD_DATA_API$1 = `load${EVENT_KEY$2}${DATA_API_KEY}`;
const CLASS_NAME_DROPDOWN_ITEM = 'dropdown-item';
const CLASS_NAME_ACTIVE$1 = 'active';
const SELECTOR_DATA_SPY = '[data-bs-spy="scroll"]';
const SELECTOR_TARGET_LINKS = '[href]';
const SELECTOR_NAV_LIST_GROUP = '.nav, .list-group';
const SELECTOR_NAV_LINKS = '.nav-link';
const SELECTOR_NAV_ITEMS = '.nav-item';
const SELECTOR_LIST_ITEMS = '.list-group-item';
const SELECTOR_LINK_ITEMS = `${SELECTOR_NAV_LINKS}, ${SELECTOR_NAV_ITEMS} > ${SELECTOR_NAV_LINKS}, ${SELECTOR_LIST_ITEMS}`;
const SELECTOR_DROPDOWN = '.dropdown';
const SELECTOR_DROPDOWN_TOGGLE$1 = '.dropdown-toggle';
const Default$1 = {
  offset: null,
  // TODO: v6 @deprecated, keep it for backwards compatibility reasons
  rootMargin: '0px 0px -25%',
  smoothScroll: false,
  target: null,
  threshold: [0.1, 0.5, 1]
};
const DefaultType$1 = {
  offset: '(number|null)',
  // TODO v6 @deprecated, keep it for backwards compatibility reasons
  rootMargin: 'string',
  smoothScroll: 'boolean',
  target: 'element',
  threshold: 'array'
};

/**
 * Class definition
 */

class ScrollSpy extends BaseComponent {
  constructor(element, config) {
    super(element, config);

    // this._element is the observablesContainer and config.target the menu links wrapper
    this._targetLinks = new Map();
    this._observableSections = new Map();
    this._rootElement = getComputedStyle(this._element).overflowY === 'visible' ? null : this._element;
    this._activeTarget = null;
    this._observer = null;
    this._previousScrollData = {
      visibleEntryTop: 0,
      parentScrollTop: 0
    };
    this.refresh(); // initialize
  }

  // Getters
  static get Default() {
    return Default$1;
  }
  static get DefaultType() {
    return DefaultType$1;
  }
  static get NAME() {
    return NAME$2;
  }

  // Public
  refresh() {
    this._initializeTargetsAndObservables();
    this._maybeEnableSmoothScroll();
    if (this._observer) {
      this._observer.disconnect();
    } else {
      this._observer = this._getNewObserver();
    }
    for (const section of this._observableSections.values()) {
      this._observer.observe(section);
    }
  }
  dispose() {
    this._observer.disconnect();
    super.dispose();
  }

  // Private
  _configAfterMerge(config) {
    // TODO: on v6 target should be given explicitly & remove the {target: 'ss-target'} case
    config.target = getElement(config.target) || document.body;

    // TODO: v6 Only for backwards compatibility reasons. Use rootMargin only
    config.rootMargin = config.offset ? `${config.offset}px 0px -30%` : config.rootMargin;
    if (typeof config.threshold === 'string') {
      config.threshold = config.threshold.split(',').map(value => Number.parseFloat(value));
    }
    return config;
  }
  _maybeEnableSmoothScroll() {
    if (!this._config.smoothScroll) {
      return;
    }

    // unregister any previous listeners
    EventHandler.off(this._config.target, EVENT_CLICK);
    EventHandler.on(this._config.target, EVENT_CLICK, SELECTOR_TARGET_LINKS, event => {
      const observableSection = this._observableSections.get(event.target.hash);
      if (observableSection) {
        event.preventDefault();
        const root = this._rootElement || window;
        const height = observableSection.offsetTop - this._element.offsetTop;
        if (root.scrollTo) {
          root.scrollTo({
            top: height,
            behavior: 'smooth'
          });
          return;
        }

        // Chrome 60 doesn't support `scrollTo`
        root.scrollTop = height;
      }
    });
  }
  _getNewObserver() {
    const options = {
      root: this._rootElement,
      threshold: this._config.threshold,
      rootMargin: this._config.rootMargin
    };
    return new IntersectionObserver(entries => this._observerCallback(entries), options);
  }

  // The logic of selection
  _observerCallback(entries) {
    const targetElement = entry => this._targetLinks.get(`#${entry.target.id}`);
    const activate = entry => {
      this._previousScrollData.visibleEntryTop = entry.target.offsetTop;
      this._process(targetElement(entry));
    };
    const parentScrollTop = (this._rootElement || document.documentElement).scrollTop;
    const userScrollsDown = parentScrollTop >= this._previousScrollData.parentScrollTop;
    this._previousScrollData.parentScrollTop = parentScrollTop;
    for (const entry of entries) {
      if (!entry.isIntersecting) {
        this._activeTarget = null;
        this._clearActiveClass(targetElement(entry));
        continue;
      }
      const entryIsLowerThanPrevious = entry.target.offsetTop >= this._previousScrollData.visibleEntryTop;
      // if we are scrolling down, pick the bigger offsetTop
      if (userScrollsDown && entryIsLowerThanPrevious) {
        activate(entry);
        // if parent isn't scrolled, let's keep the first visible item, breaking the iteration
        if (!parentScrollTop) {
          return;
        }
        continue;
      }

      // if we are scrolling up, pick the smallest offsetTop
      if (!userScrollsDown && !entryIsLowerThanPrevious) {
        activate(entry);
      }
    }
  }
  _initializeTargetsAndObservables() {
    this._targetLinks = new Map();
    this._observableSections = new Map();
    const targetLinks = SelectorEngine.find(SELECTOR_TARGET_LINKS, this._config.target);
    for (const anchor of targetLinks) {
      // ensure that the anchor has an id and is not disabled
      if (!anchor.hash || isDisabled(anchor)) {
        continue;
      }
      const observableSection = SelectorEngine.findOne(anchor.hash, this._element);

      // ensure that the observableSection exists & is visible
      if (isVisible(observableSection)) {
        this._targetLinks.set(anchor.hash, anchor);
        this._observableSections.set(anchor.hash, observableSection);
      }
    }
  }
  _process(target) {
    if (this._activeTarget === target) {
      return;
    }
    this._clearActiveClass(this._config.target);
    this._activeTarget = target;
    target.classList.add(CLASS_NAME_ACTIVE$1);
    this._activateParents(target);
    EventHandler.trigger(this._element, EVENT_ACTIVATE, {
      relatedTarget: target
    });
  }
  _activateParents(target) {
    // Activate dropdown parents
    if (target.classList.contains(CLASS_NAME_DROPDOWN_ITEM)) {
      SelectorEngine.findOne(SELECTOR_DROPDOWN_TOGGLE$1, target.closest(SELECTOR_DROPDOWN)).classList.add(CLASS_NAME_ACTIVE$1);
      return;
    }
    for (const listGroup of SelectorEngine.parents(target, SELECTOR_NAV_LIST_GROUP)) {
      // Set triggered links parents as active
      // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor
      for (const item of SelectorEngine.prev(listGroup, SELECTOR_LINK_ITEMS)) {
        item.classList.add(CLASS_NAME_ACTIVE$1);
      }
    }
  }
  _clearActiveClass(parent) {
    parent.classList.remove(CLASS_NAME_ACTIVE$1);
    const activeNodes = SelectorEngine.find(`${SELECTOR_TARGET_LINKS}.${CLASS_NAME_ACTIVE$1}`, parent);
    for (const node of activeNodes) {
      node.classList.remove(CLASS_NAME_ACTIVE$1);
    }
  }

  // Static
  static jQueryInterface(config) {
    return this.each(function () {
      const data = ScrollSpy.getOrCreateInstance(this, config);
      if (typeof config !== 'string') {
        return;
      }
      if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {
        throw new TypeError(`No method named "${config}"`);
      }
      data[config]();
    });
  }
}

/**
 * Data API implementation
 */

EventHandler.on(window, EVENT_LOAD_DATA_API$1, () => {
  for (const spy of SelectorEngine.find(SELECTOR_DATA_SPY)) {
    ScrollSpy.getOrCreateInstance(spy);
  }
});

/**
 * jQuery
 */

defineJQueryPlugin(ScrollSpy);

/**
 * --------------------------------------------------------------------------
 * Bootstrap tab.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */

const NAME$1 = 'tab';
const DATA_KEY$1 = 'bs.tab';
const EVENT_KEY$1 = `.${DATA_KEY$1}`;
const EVENT_HIDE$1 = `hide${EVENT_KEY$1}`;
const EVENT_HIDDEN$1 = `hidden${EVENT_KEY$1}`;
const EVENT_SHOW$1 = `show${EVENT_KEY$1}`;
const EVENT_SHOWN$1 = `shown${EVENT_KEY$1}`;
const EVENT_CLICK_DATA_API = `click${EVENT_KEY$1}`;
const EVENT_KEYDOWN = `keydown${EVENT_KEY$1}`;
const EVENT_LOAD_DATA_API = `load${EVENT_KEY$1}`;
const ARROW_LEFT_KEY = 'ArrowLeft';
const ARROW_RIGHT_KEY = 'ArrowRight';
const ARROW_UP_KEY = 'ArrowUp';
const ARROW_DOWN_KEY = 'ArrowDown';
const CLASS_NAME_ACTIVE = 'active';
const CLASS_NAME_FADE$1 = 'fade';
const CLASS_NAME_SHOW$1 = 'show';
const CLASS_DROPDOWN = 'dropdown';
const SELECTOR_DROPDOWN_TOGGLE = '.dropdown-toggle';
const SELECTOR_DROPDOWN_MENU = '.dropdown-menu';
const NOT_SELECTOR_DROPDOWN_TOGGLE = ':not(.dropdown-toggle)';
const SELECTOR_TAB_PANEL = '.list-group, .nav, [role="tablist"]';
const SELECTOR_OUTER = '.nav-item, .list-group-item';
const SELECTOR_INNER = `.nav-link${NOT_SELECTOR_DROPDOWN_TOGGLE}, .list-group-item${NOT_SELECTOR_DROPDOWN_TOGGLE}, [role="tab"]${NOT_SELECTOR_DROPDOWN_TOGGLE}`;
const SELECTOR_DATA_TOGGLE = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]'; // TODO: could only be `tab` in v6
const SELECTOR_INNER_ELEM = `${SELECTOR_INNER}, ${SELECTOR_DATA_TOGGLE}`;
const SELECTOR_DATA_TOGGLE_ACTIVE = `.${CLASS_NAME_ACTIVE}[data-bs-toggle="tab"], .${CLASS_NAME_ACTIVE}[data-bs-toggle="pill"], .${CLASS_NAME_ACTIVE}[data-bs-toggle="list"]`;

/**
 * Class definition
 */

class Tab extends BaseComponent {
  constructor(element) {
    super(element);
    this._parent = this._element.closest(SELECTOR_TAB_PANEL);
    if (!this._parent) {
      return;
      // TODO: should throw exception in v6
      // throw new TypeError(`${element.outerHTML} has not a valid parent ${SELECTOR_INNER_ELEM}`)
    }

    // Set up initial aria attributes
    this._setInitialAttributes(this._parent, this._getChildren());
    EventHandler.on(this._element, EVENT_KEYDOWN, event => this._keydown(event));
  }

  // Getters
  static get NAME() {
    return NAME$1;
  }

  // Public
  show() {
    // Shows this elem and deactivate the active sibling if exists
    const innerElem = this._element;
    if (this._elemIsActive(innerElem)) {
      return;
    }

    // Search for active tab on same parent to deactivate it
    const active = this._getActiveElem();
    const hideEvent = active ? EventHandler.trigger(active, EVENT_HIDE$1, {
      relatedTarget: innerElem
    }) : null;
    const showEvent = EventHandler.trigger(innerElem, EVENT_SHOW$1, {
      relatedTarget: active
    });
    if (showEvent.defaultPrevented || hideEvent && hideEvent.defaultPrevented) {
      return;
    }
    this._deactivate(active, innerElem);
    this._activate(innerElem, active);
  }

  // Private
  _activate(element, relatedElem) {
    if (!element) {
      return;
    }
    element.classList.add(CLASS_NAME_ACTIVE);
    this._activate(SelectorEngine.getElementFromSelector(element)); // Search and activate/show the proper section

    const complete = () => {
      if (element.getAttribute('role') !== 'tab') {
        element.classList.add(CLASS_NAME_SHOW$1);
        return;
      }
      element.removeAttribute('tabindex');
      element.setAttribute('aria-selected', true);
      this._toggleDropDown(element, true);
      EventHandler.trigger(element, EVENT_SHOWN$1, {
        relatedTarget: relatedElem
      });
    };
    this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));
  }
  _deactivate(element, relatedElem) {
    if (!element) {
      return;
    }
    element.classList.remove(CLASS_NAME_ACTIVE);
    element.blur();
    this._deactivate(SelectorEngine.getElementFromSelector(element)); // Search and deactivate the shown section too

    const complete = () => {
      if (element.getAttribute('role') !== 'tab') {
        element.classList.remove(CLASS_NAME_SHOW$1);
        return;
      }
      element.setAttribute('aria-selected', false);
      element.setAttribute('tabindex', '-1');
      this._toggleDropDown(element, false);
      EventHandler.trigger(element, EVENT_HIDDEN$1, {
        relatedTarget: relatedElem
      });
    };
    this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));
  }
  _keydown(event) {
    if (![ARROW_LEFT_KEY, ARROW_RIGHT_KEY, ARROW_UP_KEY, ARROW_DOWN_KEY].includes(event.key)) {
      return;
    }
    event.stopPropagation(); // stopPropagation/preventDefault both added to support up/down keys without scrolling the page
    event.preventDefault();
    const isNext = [ARROW_RIGHT_KEY, ARROW_DOWN_KEY].includes(event.key);
    const nextActiveElement = getNextActiveElement(this._getChildren().filter(element => !isDisabled(element)), event.target, isNext, true);
    if (nextActiveElement) {
      nextActiveElement.focus({
        preventScroll: true
      });
      Tab.getOrCreateInstance(nextActiveElement).show();
    }
  }
  _getChildren() {
    // collection of inner elements
    return SelectorEngine.find(SELECTOR_INNER_ELEM, this._parent);
  }
  _getActiveElem() {
    return this._getChildren().find(child => this._elemIsActive(child)) || null;
  }
  _setInitialAttributes(parent, children) {
    this._setAttributeIfNotExists(parent, 'role', 'tablist');
    for (const child of children) {
      this._setInitialAttributesOnChild(child);
    }
  }
  _setInitialAttributesOnChild(child) {
    child = this._getInnerElement(child);
    const isActive = this._elemIsActive(child);
    const outerElem = this._getOuterElement(child);
    child.setAttribute('aria-selected', isActive);
    if (outerElem !== child) {
      this._setAttributeIfNotExists(outerElem, 'role', 'presentation');
    }
    if (!isActive) {
      child.setAttribute('tabindex', '-1');
    }
    this._setAttributeIfNotExists(child, 'role', 'tab');

    // set attributes to the related panel too
    this._setInitialAttributesOnTargetPanel(child);
  }
  _setInitialAttributesOnTargetPanel(child) {
    const target = SelectorEngine.getElementFromSelector(child);
    if (!target) {
      return;
    }
    this._setAttributeIfNotExists(target, 'role', 'tabpanel');
    if (child.id) {
      this._setAttributeIfNotExists(target, 'aria-labelledby', `${child.id}`);
    }
  }
  _toggleDropDown(element, open) {
    const outerElem = this._getOuterElement(element);
    if (!outerElem.classList.contains(CLASS_DROPDOWN)) {
      return;
    }
    const toggle = (selector, className) => {
      const element = SelectorEngine.findOne(selector, outerElem);
      if (element) {
        element.classList.toggle(className, open);
      }
    };
    toggle(SELECTOR_DROPDOWN_TOGGLE, CLASS_NAME_ACTIVE);
    toggle(SELECTOR_DROPDOWN_MENU, CLASS_NAME_SHOW$1);
    outerElem.setAttribute('aria-expanded', open);
  }
  _setAttributeIfNotExists(element, attribute, value) {
    if (!element.hasAttribute(attribute)) {
      element.setAttribute(attribute, value);
    }
  }
  _elemIsActive(elem) {
    return elem.classList.contains(CLASS_NAME_ACTIVE);
  }

  // Try to get the inner element (usually the .nav-link)
  _getInnerElement(elem) {
    return elem.matches(SELECTOR_INNER_ELEM) ? elem : SelectorEngine.findOne(SELECTOR_INNER_ELEM, elem);
  }

  // Try to get the outer element (usually the .nav-item)
  _getOuterElement(elem) {
    return elem.closest(SELECTOR_OUTER) || elem;
  }

  // Static
  static jQueryInterface(config) {
    return this.each(function () {
      const data = Tab.getOrCreateInstance(this);
      if (typeof config !== 'string') {
        return;
      }
      if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {
        throw new TypeError(`No method named "${config}"`);
      }
      data[config]();
    });
  }
}

/**
 * Data API implementation
 */

EventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (event) {
  if (['A', 'AREA'].includes(this.tagName)) {
    event.preventDefault();
  }
  if (isDisabled(this)) {
    return;
  }
  Tab.getOrCreateInstance(this).show();
});

/**
 * Initialize on focus
 */
EventHandler.on(window, EVENT_LOAD_DATA_API, () => {
  for (const element of SelectorEngine.find(SELECTOR_DATA_TOGGLE_ACTIVE)) {
    Tab.getOrCreateInstance(element);
  }
});
/**
 * jQuery
 */

defineJQueryPlugin(Tab);

/**
 * --------------------------------------------------------------------------
 * Bootstrap toast.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */

const NAME = 'toast';
const DATA_KEY = 'bs.toast';
const EVENT_KEY = `.${DATA_KEY}`;
const EVENT_MOUSEOVER = `mouseover${EVENT_KEY}`;
const EVENT_MOUSEOUT = `mouseout${EVENT_KEY}`;
const EVENT_FOCUSIN = `focusin${EVENT_KEY}`;
const EVENT_FOCUSOUT = `focusout${EVENT_KEY}`;
const EVENT_HIDE = `hide${EVENT_KEY}`;
const EVENT_HIDDEN = `hidden${EVENT_KEY}`;
const EVENT_SHOW = `show${EVENT_KEY}`;
const EVENT_SHOWN = `shown${EVENT_KEY}`;
const CLASS_NAME_FADE = 'fade';
const CLASS_NAME_HIDE = 'hide'; // @deprecated - kept here only for backwards compatibility
const CLASS_NAME_SHOW = 'show';
const CLASS_NAME_SHOWING = 'showing';
const DefaultType = {
  animation: 'boolean',
  autohide: 'boolean',
  delay: 'number'
};
const Default = {
  animation: true,
  autohide: true,
  delay: 5000
};

/**
 * Class definition
 */

class Toast extends BaseComponent {
  constructor(element, config) {
    super(element, config);
    this._timeout = null;
    this._hasMouseInteraction = false;
    this._hasKeyboardInteraction = false;
    this._setListeners();
  }

  // Getters
  static get Default() {
    return Default;
  }
  static get DefaultType() {
    return DefaultType;
  }
  static get NAME() {
    return NAME;
  }

  // Public
  show() {
    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW);
    if (showEvent.defaultPrevented) {
      return;
    }
    this._clearTimeout();
    if (this._config.animation) {
      this._element.classList.add(CLASS_NAME_FADE);
    }
    const complete = () => {
      this._element.classList.remove(CLASS_NAME_SHOWING);
      EventHandler.trigger(this._element, EVENT_SHOWN);
      this._maybeScheduleHide();
    };
    this._element.classList.remove(CLASS_NAME_HIDE); // @deprecated
    reflow(this._element);
    this._element.classList.add(CLASS_NAME_SHOW, CLASS_NAME_SHOWING);
    this._queueCallback(complete, this._element, this._config.animation);
  }
  hide() {
    if (!this.isShown()) {
      return;
    }
    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE);
    if (hideEvent.defaultPrevented) {
      return;
    }
    const complete = () => {
      this._element.classList.add(CLASS_NAME_HIDE); // @deprecated
      this._element.classList.remove(CLASS_NAME_SHOWING, CLASS_NAME_SHOW);
      EventHandler.trigger(this._element, EVENT_HIDDEN);
    };
    this._element.classList.add(CLASS_NAME_SHOWING);
    this._queueCallback(complete, this._element, this._config.animation);
  }
  dispose() {
    this._clearTimeout();
    if (this.isShown()) {
      this._element.classList.remove(CLASS_NAME_SHOW);
    }
    super.dispose();
  }
  isShown() {
    return this._element.classList.contains(CLASS_NAME_SHOW);
  }

  // Private

  _maybeScheduleHide() {
    if (!this._config.autohide) {
      return;
    }
    if (this._hasMouseInteraction || this._hasKeyboardInteraction) {
      return;
    }
    this._timeout = setTimeout(() => {
      this.hide();
    }, this._config.delay);
  }
  _onInteraction(event, isInteracting) {
    switch (event.type) {
      case 'mouseover':
      case 'mouseout':
        {
          this._hasMouseInteraction = isInteracting;
          break;
        }
      case 'focusin':
      case 'focusout':
        {
          this._hasKeyboardInteraction = isInteracting;
          break;
        }
    }
    if (isInteracting) {
      this._clearTimeout();
      return;
    }
    const nextElement = event.relatedTarget;
    if (this._element === nextElement || this._element.contains(nextElement)) {
      return;
    }
    this._maybeScheduleHide();
  }
  _setListeners() {
    EventHandler.on(this._element, EVENT_MOUSEOVER, event => this._onInteraction(event, true));
    EventHandler.on(this._element, EVENT_MOUSEOUT, event => this._onInteraction(event, false));
    EventHandler.on(this._element, EVENT_FOCUSIN, event => this._onInteraction(event, true));
    EventHandler.on(this._element, EVENT_FOCUSOUT, event => this._onInteraction(event, false));
  }
  _clearTimeout() {
    clearTimeout(this._timeout);
    this._timeout = null;
  }

  // Static
  static jQueryInterface(config) {
    return this.each(function () {
      const data = Toast.getOrCreateInstance(this, config);
      if (typeof config === 'string') {
        if (typeof data[config] === 'undefined') {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config](this);
      }
    });
  }
}

/**
 * Data API implementation
 */

enableDismissTrigger(Toast);

/**
 * jQuery
 */

defineJQueryPlugin(Toast);


//# sourceMappingURL=bootstrap.esm.js.map


/***/ }),

/***/ "./node_modules/litepicker/dist/litepicker.umd.js":
/*!********************************************************!*\
  !*** ./node_modules/litepicker/dist/litepicker.umd.js ***!
  \********************************************************/
/***/ (function(module) {

/*!
 * 
 * litepicker.umd.js
 * Litepicker v2.0.12 (https://github.com/wakirin/Litepicker)
 * Package: litepicker (https://www.npmjs.com/package/litepicker)
 * License: MIT (https://github.com/wakirin/Litepicker/blob/master/LICENCE.md)
 * Copyright 2019-2021 Rinat G.
 *     
 * Hash: 504eef9c08cb42543660
 * 
 */
!function(t,e){ true?module.exports=e():0}(window,(function(){return function(t){var e={};function i(n){if(e[n])return e[n].exports;var o=e[n]={i:n,l:!1,exports:{}};return t[n].call(o.exports,o,o.exports,i),o.l=!0,o.exports}return i.m=t,i.c=e,i.d=function(t,e,n){i.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:n})},i.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},i.t=function(t,e){if(1&e&&(t=i(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var n=Object.create(null);if(i.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var o in t)i.d(n,o,function(e){return t[e]}.bind(null,o));return n},i.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return i.d(e,"a",e),e},i.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},i.p="",i(i.s=4)}([function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var n=function(){function t(e,i,n){void 0===e&&(e=null),void 0===i&&(i=null),void 0===n&&(n="en-US"),this.dateInstance="object"==typeof i&&null!==i?i.parse(e instanceof t?e.clone().toJSDate():e):"string"==typeof i?t.parseDateTime(e,i,n):e?t.parseDateTime(e):t.parseDateTime(new Date),this.lang=n}return t.parseDateTime=function(e,i,n){if(void 0===i&&(i="YYYY-MM-DD"),void 0===n&&(n="en-US"),!e)return new Date(NaN);if(e instanceof Date)return new Date(e);if(e instanceof t)return e.clone().toJSDate();if(/^-?\d{10,}$/.test(e))return t.getDateZeroTime(new Date(Number(e)));if("string"==typeof e){for(var o=[],s=null;null!=(s=t.regex.exec(i));)"\\"!==s[1]&&o.push(s);if(o.length){var r={year:null,month:null,shortMonth:null,longMonth:null,day:null,value:""};o[0].index>0&&(r.value+=".*?");for(var a=0,l=Object.entries(o);a<l.length;a++){var c=l[a],h=c[0],p=c[1],d=Number(h),u=t.formatPatterns(p[0],n),m=u.group,f=u.pattern;r[m]=d+1,r.value+=f,r.value+=".*?"}var g=new RegExp("^"+r.value+"$");if(g.test(e)){var v=g.exec(e),y=Number(v[r.year]),b=null;r.month?b=Number(v[r.month])-1:r.shortMonth?b=t.shortMonths(n).indexOf(v[r.shortMonth]):r.longMonth&&(b=t.longMonths(n).indexOf(v[r.longMonth]));var k=Number(v[r.day])||1;return new Date(y,b,k,0,0,0,0)}}}return t.getDateZeroTime(new Date(e))},t.convertArray=function(e,i){return e.map((function(e){return e instanceof Array?e.map((function(e){return new t(e,i)})):new t(e,i)}))},t.getDateZeroTime=function(t){return new Date(t.getFullYear(),t.getMonth(),t.getDate(),0,0,0,0)},t.shortMonths=function(e){return t.MONTH_JS.map((function(t){return new Date(2019,t).toLocaleString(e,{month:"short"})}))},t.longMonths=function(e){return t.MONTH_JS.map((function(t){return new Date(2019,t).toLocaleString(e,{month:"long"})}))},t.formatPatterns=function(e,i){switch(e){case"YY":case"YYYY":return{group:"year",pattern:"(\\d{"+e.length+"})"};case"M":return{group:"month",pattern:"(\\d{1,2})"};case"MM":return{group:"month",pattern:"(\\d{2})"};case"MMM":return{group:"shortMonth",pattern:"("+t.shortMonths(i).join("|")+")"};case"MMMM":return{group:"longMonth",pattern:"("+t.longMonths(i).join("|")+")"};case"D":return{group:"day",pattern:"(\\d{1,2})"};case"DD":return{group:"day",pattern:"(\\d{2})"}}},t.prototype.toJSDate=function(){return this.dateInstance},t.prototype.toLocaleString=function(t,e){return this.dateInstance.toLocaleString(t,e)},t.prototype.toDateString=function(){return this.dateInstance.toDateString()},t.prototype.getSeconds=function(){return this.dateInstance.getSeconds()},t.prototype.getDay=function(){return this.dateInstance.getDay()},t.prototype.getTime=function(){return this.dateInstance.getTime()},t.prototype.getDate=function(){return this.dateInstance.getDate()},t.prototype.getMonth=function(){return this.dateInstance.getMonth()},t.prototype.getFullYear=function(){return this.dateInstance.getFullYear()},t.prototype.setMonth=function(t){return this.dateInstance.setMonth(t)},t.prototype.setHours=function(t,e,i,n){void 0===t&&(t=0),void 0===e&&(e=0),void 0===i&&(i=0),void 0===n&&(n=0),this.dateInstance.setHours(t,e,i,n)},t.prototype.setSeconds=function(t){return this.dateInstance.setSeconds(t)},t.prototype.setDate=function(t){return this.dateInstance.setDate(t)},t.prototype.setFullYear=function(t){return this.dateInstance.setFullYear(t)},t.prototype.getWeek=function(t){var e=new Date(this.timestamp()),i=(this.getDay()+(7-t))%7;e.setDate(e.getDate()-i);var n=e.getTime();return e.setMonth(0,1),e.getDay()!==t&&e.setMonth(0,1+(4-e.getDay()+7)%7),1+Math.ceil((n-e.getTime())/6048e5)},t.prototype.clone=function(){return new t(this.toJSDate())},t.prototype.isBetween=function(t,e,i){switch(void 0===i&&(i="()"),i){default:case"()":return this.timestamp()>t.getTime()&&this.timestamp()<e.getTime();case"[)":return this.timestamp()>=t.getTime()&&this.timestamp()<e.getTime();case"(]":return this.timestamp()>t.getTime()&&this.timestamp()<=e.getTime();case"[]":return this.timestamp()>=t.getTime()&&this.timestamp()<=e.getTime()}},t.prototype.isBefore=function(t,e){switch(void 0===e&&(e="seconds"),e){case"second":case"seconds":return t.getTime()>this.getTime();case"day":case"days":return new Date(t.getFullYear(),t.getMonth(),t.getDate()).getTime()>new Date(this.getFullYear(),this.getMonth(),this.getDate()).getTime();case"month":case"months":return new Date(t.getFullYear(),t.getMonth(),1).getTime()>new Date(this.getFullYear(),this.getMonth(),1).getTime();case"year":case"years":return t.getFullYear()>this.getFullYear()}throw new Error("isBefore: Invalid unit!")},t.prototype.isSameOrBefore=function(t,e){switch(void 0===e&&(e="seconds"),e){case"second":case"seconds":return t.getTime()>=this.getTime();case"day":case"days":return new Date(t.getFullYear(),t.getMonth(),t.getDate()).getTime()>=new Date(this.getFullYear(),this.getMonth(),this.getDate()).getTime();case"month":case"months":return new Date(t.getFullYear(),t.getMonth(),1).getTime()>=new Date(this.getFullYear(),this.getMonth(),1).getTime()}throw new Error("isSameOrBefore: Invalid unit!")},t.prototype.isAfter=function(t,e){switch(void 0===e&&(e="seconds"),e){case"second":case"seconds":return this.getTime()>t.getTime();case"day":case"days":return new Date(this.getFullYear(),this.getMonth(),this.getDate()).getTime()>new Date(t.getFullYear(),t.getMonth(),t.getDate()).getTime();case"month":case"months":return new Date(this.getFullYear(),this.getMonth(),1).getTime()>new Date(t.getFullYear(),t.getMonth(),1).getTime();case"year":case"years":return this.getFullYear()>t.getFullYear()}throw new Error("isAfter: Invalid unit!")},t.prototype.isSameOrAfter=function(t,e){switch(void 0===e&&(e="seconds"),e){case"second":case"seconds":return this.getTime()>=t.getTime();case"day":case"days":return new Date(this.getFullYear(),this.getMonth(),this.getDate()).getTime()>=new Date(t.getFullYear(),t.getMonth(),t.getDate()).getTime();case"month":case"months":return new Date(this.getFullYear(),this.getMonth(),1).getTime()>=new Date(t.getFullYear(),t.getMonth(),1).getTime()}throw new Error("isSameOrAfter: Invalid unit!")},t.prototype.isSame=function(t,e){switch(void 0===e&&(e="seconds"),e){case"second":case"seconds":return this.getTime()===t.getTime();case"day":case"days":return new Date(this.getFullYear(),this.getMonth(),this.getDate()).getTime()===new Date(t.getFullYear(),t.getMonth(),t.getDate()).getTime();case"month":case"months":return new Date(this.getFullYear(),this.getMonth(),1).getTime()===new Date(t.getFullYear(),t.getMonth(),1).getTime()}throw new Error("isSame: Invalid unit!")},t.prototype.add=function(t,e){switch(void 0===e&&(e="seconds"),e){case"second":case"seconds":this.setSeconds(this.getSeconds()+t);break;case"day":case"days":this.setDate(this.getDate()+t);break;case"month":case"months":this.setMonth(this.getMonth()+t)}return this},t.prototype.subtract=function(t,e){switch(void 0===e&&(e="seconds"),e){case"second":case"seconds":this.setSeconds(this.getSeconds()-t);break;case"day":case"days":this.setDate(this.getDate()-t);break;case"month":case"months":this.setMonth(this.getMonth()-t)}return this},t.prototype.diff=function(t,e){void 0===e&&(e="seconds");switch(e){default:case"second":case"seconds":return this.getTime()-t.getTime();case"day":case"days":return Math.round((this.timestamp()-t.getTime())/864e5);case"month":case"months":}},t.prototype.format=function(e,i){if(void 0===i&&(i="en-US"),"object"==typeof e)return e.output(this.clone().toJSDate());for(var n="",o=[],s=null;null!=(s=t.regex.exec(e));)"\\"!==s[1]&&o.push(s);if(o.length){o[0].index>0&&(n+=e.substring(0,o[0].index));for(var r=0,a=Object.entries(o);r<a.length;r++){var l=a[r],c=l[0],h=l[1],p=Number(c);n+=this.formatTokens(h[0],i),o[p+1]&&(n+=e.substring(h.index+h[0].length,o[p+1].index)),p===o.length-1&&(n+=e.substring(h.index+h[0].length))}}return n.replace(/\\/g,"")},t.prototype.timestamp=function(){return new Date(this.getFullYear(),this.getMonth(),this.getDate(),0,0,0,0).getTime()},t.prototype.formatTokens=function(e,i){switch(e){case"YY":return String(this.getFullYear()).slice(-2);case"YYYY":return String(this.getFullYear());case"M":return String(this.getMonth()+1);case"MM":return("0"+(this.getMonth()+1)).slice(-2);case"MMM":return t.shortMonths(i)[this.getMonth()];case"MMMM":return t.longMonths(i)[this.getMonth()];case"D":return String(this.getDate());case"DD":return("0"+this.getDate()).slice(-2);default:return""}},t.regex=/(\\)?(Y{2,4}|M{1,4}|D{1,2}|d{1,4})/g,t.MONTH_JS=[0,1,2,3,4,5,6,7,8,9,10,11],t}();e.DateTime=n},function(t,e,i){"use strict";var n,o=this&&this.__extends||(n=function(t,e){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i])})(t,e)},function(t,e){function i(){this.constructor=t}n(t,e),t.prototype=null===e?Object.create(e):(i.prototype=e.prototype,new i)}),s=this&&this.__spreadArrays||function(){for(var t=0,e=0,i=arguments.length;e<i;e++)t+=arguments[e].length;var n=Array(t),o=0;for(e=0;e<i;e++)for(var s=arguments[e],r=0,a=s.length;r<a;r++,o++)n[o]=s[r];return n};Object.defineProperty(e,"__esModule",{value:!0});var r=i(5),a=i(0),l=i(3),c=i(2),h=function(t){function e(e){var i=t.call(this,e)||this;return i.preventClick=!1,i.bindEvents(),i}return o(e,t),e.prototype.scrollToDate=function(t){if(this.options.scrollToDate){var e=this.options.startDate instanceof a.DateTime?this.options.startDate.clone():null,i=this.options.endDate instanceof a.DateTime?this.options.endDate.clone():null;!this.options.startDate||t&&t!==this.options.element?t&&this.options.endDate&&t===this.options.elementEnd&&(i.setDate(1),this.options.numberOfMonths>1&&i.isAfter(e)&&i.setMonth(i.getMonth()-(this.options.numberOfMonths-1)),this.calendars[0]=i.clone()):(e.setDate(1),this.calendars[0]=e.clone())}},e.prototype.bindEvents=function(){document.addEventListener("click",this.onClick.bind(this),!0),this.ui=document.createElement("div"),this.ui.className=l.litepicker,this.ui.style.display="none",this.ui.addEventListener("mouseenter",this.onMouseEnter.bind(this),!0),this.ui.addEventListener("mouseleave",this.onMouseLeave.bind(this),!1),this.options.autoRefresh?(this.options.element instanceof HTMLElement&&this.options.element.addEventListener("keyup",this.onInput.bind(this),!0),this.options.elementEnd instanceof HTMLElement&&this.options.elementEnd.addEventListener("keyup",this.onInput.bind(this),!0)):(this.options.element instanceof HTMLElement&&this.options.element.addEventListener("change",this.onInput.bind(this),!0),this.options.elementEnd instanceof HTMLElement&&this.options.elementEnd.addEventListener("change",this.onInput.bind(this),!0)),this.options.parentEl?this.options.parentEl instanceof HTMLElement?this.options.parentEl.appendChild(this.ui):document.querySelector(this.options.parentEl).appendChild(this.ui):this.options.inlineMode?this.options.element instanceof HTMLInputElement?this.options.element.parentNode.appendChild(this.ui):this.options.element.appendChild(this.ui):document.body.appendChild(this.ui),this.updateInput(),this.init(),"function"==typeof this.options.setup&&this.options.setup.call(this,this),this.render(),this.options.inlineMode&&this.show()},e.prototype.updateInput=function(){if(this.options.element instanceof HTMLInputElement){var t=this.options.startDate,e=this.options.endDate;if(this.options.singleMode&&t)this.options.element.value=t.format(this.options.format,this.options.lang);else if(!this.options.singleMode&&t&&e){var i=t.format(this.options.format,this.options.lang),n=e.format(this.options.format,this.options.lang);this.options.elementEnd instanceof HTMLInputElement?(this.options.element.value=i,this.options.elementEnd.value=n):this.options.element.value=""+i+this.options.delimiter+n}t||e||(this.options.element.value="",this.options.elementEnd instanceof HTMLInputElement&&(this.options.elementEnd.value=""))}},e.prototype.isSamePicker=function(t){return t.closest("."+l.litepicker)===this.ui},e.prototype.shouldShown=function(t){return!t.disabled&&(t===this.options.element||this.options.elementEnd&&t===this.options.elementEnd)},e.prototype.shouldResetDatePicked=function(){return this.options.singleMode||2===this.datePicked.length},e.prototype.shouldSwapDatePicked=function(){return 2===this.datePicked.length&&this.datePicked[0].getTime()>this.datePicked[1].getTime()},e.prototype.shouldCheckLockDays=function(){return this.options.disallowLockDaysInRange&&2===this.datePicked.length},e.prototype.onClick=function(t){var e=t.target;if(t.target.shadowRoot&&(e=t.composedPath()[0]),e&&this.ui)if(this.shouldShown(e))this.show(e);else if(e.closest("."+l.litepicker)||!this.isShowning()){if(this.isSamePicker(e))if(this.emit("before:click",e),this.preventClick)this.preventClick=!1;else{if(e.classList.contains(l.dayItem)){if(t.preventDefault(),e.classList.contains(l.isLocked))return;if(this.shouldResetDatePicked()&&(this.datePicked.length=0),this.datePicked[this.datePicked.length]=new a.DateTime(e.dataset.time),this.shouldSwapDatePicked()){var i=this.datePicked[1].clone();this.datePicked[1]=this.datePicked[0].clone(),this.datePicked[0]=i.clone()}if(this.shouldCheckLockDays())c.rangeIsLocked(this.datePicked,this.options)&&(this.emit("error:range",this.datePicked),this.datePicked.length=0);return this.render(),this.emit.apply(this,s(["preselect"],s(this.datePicked).map((function(t){return t.clone()})))),void(this.options.autoApply&&(this.options.singleMode&&this.datePicked.length?(this.setDate(this.datePicked[0]),this.hide()):this.options.singleMode||2!==this.datePicked.length||(this.setDateRange(this.datePicked[0],this.datePicked[1]),this.hide())))}if(e.classList.contains(l.buttonPreviousMonth)){t.preventDefault();var n=0,o=this.options.switchingMonths||this.options.numberOfMonths;if(this.options.splitView){var r=e.closest("."+l.monthItem);n=c.findNestedMonthItem(r),o=1}return this.calendars[n].setMonth(this.calendars[n].getMonth()-o),this.gotoDate(this.calendars[n],n),void this.emit("change:month",this.calendars[n],n)}if(e.classList.contains(l.buttonNextMonth)){t.preventDefault();n=0,o=this.options.switchingMonths||this.options.numberOfMonths;if(this.options.splitView){r=e.closest("."+l.monthItem);n=c.findNestedMonthItem(r),o=1}return this.calendars[n].setMonth(this.calendars[n].getMonth()+o),this.gotoDate(this.calendars[n],n),void this.emit("change:month",this.calendars[n],n)}e.classList.contains(l.buttonCancel)&&(t.preventDefault(),this.hide(),this.emit("button:cancel")),e.classList.contains(l.buttonApply)&&(t.preventDefault(),this.options.singleMode&&this.datePicked.length?this.setDate(this.datePicked[0]):this.options.singleMode||2!==this.datePicked.length||this.setDateRange(this.datePicked[0],this.datePicked[1]),this.hide(),this.emit("button:apply",this.options.startDate,this.options.endDate))}}else this.hide()},e.prototype.showTooltip=function(t,e){var i=this.ui.querySelector("."+l.containerTooltip);i.style.visibility="visible",i.innerHTML=e;var n=this.ui.getBoundingClientRect(),o=i.getBoundingClientRect(),s=t.getBoundingClientRect(),r=s.top,a=s.left;if(this.options.inlineMode&&this.options.parentEl){var c=this.ui.parentNode.getBoundingClientRect();r-=c.top,a-=c.left}else r-=n.top,a-=n.left;r-=o.height,a-=o.width/2,a+=s.width/2,i.style.top=r+"px",i.style.left=a+"px",this.emit("tooltip",i,t)},e.prototype.hideTooltip=function(){this.ui.querySelector("."+l.containerTooltip).style.visibility="hidden"},e.prototype.shouldAllowMouseEnter=function(t){return!this.options.singleMode&&!t.classList.contains(l.isLocked)},e.prototype.shouldAllowRepick=function(){return this.options.elementEnd&&this.options.allowRepick&&this.options.startDate&&this.options.endDate},e.prototype.isDayItem=function(t){return t.classList.contains(l.dayItem)},e.prototype.onMouseEnter=function(t){var e=this,i=t.target;if(this.isDayItem(i)&&this.shouldAllowMouseEnter(i)){if(this.shouldAllowRepick()&&(this.triggerElement===this.options.element?this.datePicked[0]=this.options.endDate.clone():this.triggerElement===this.options.elementEnd&&(this.datePicked[0]=this.options.startDate.clone())),1!==this.datePicked.length)return;var n=this.ui.querySelector("."+l.dayItem+'[data-time="'+this.datePicked[0].getTime()+'"]'),o=this.datePicked[0].clone(),s=new a.DateTime(i.dataset.time),r=!1;if(o.getTime()>s.getTime()){var c=o.clone();o=s.clone(),s=c.clone(),r=!0}if(Array.prototype.slice.call(this.ui.querySelectorAll("."+l.dayItem)).forEach((function(t){var i=new a.DateTime(t.dataset.time),n=e.renderDay(i);i.isBetween(o,s)&&n.classList.add(l.isInRange),t.className=n.className})),i.classList.add(l.isEndDate),r?(n&&n.classList.add(l.isFlipped),i.classList.add(l.isFlipped)):(n&&n.classList.remove(l.isFlipped),i.classList.remove(l.isFlipped)),this.options.showTooltip){var h=s.diff(o,"day")+1;if("function"==typeof this.options.tooltipNumber&&(h=this.options.tooltipNumber.call(this,h)),h>0){var p=this.pluralSelector(h),d=h+" "+(this.options.tooltipText[p]?this.options.tooltipText[p]:"["+p+"]");this.showTooltip(i,d);var u=window.navigator.userAgent,m=/(iphone|ipad)/i.test(u),f=/OS 1([0-2])/i.test(u);m&&f&&i.dispatchEvent(new Event("click"))}else this.hideTooltip()}}},e.prototype.onMouseLeave=function(t){t.target;this.options.allowRepick&&(!this.options.allowRepick||this.options.startDate||this.options.endDate)&&(this.datePicked.length=0,this.render())},e.prototype.onInput=function(t){var e=this.parseInput(),i=e[0],n=e[1],o=this.options.format;if(this.options.elementEnd?i instanceof a.DateTime&&n instanceof a.DateTime&&i.format(o)===this.options.element.value&&n.format(o)===this.options.elementEnd.value:this.options.singleMode?i instanceof a.DateTime&&i.format(o)===this.options.element.value:i instanceof a.DateTime&&n instanceof a.DateTime&&""+i.format(o)+this.options.delimiter+n.format(o)===this.options.element.value){if(n&&i.getTime()>n.getTime()){var s=i.clone();i=n.clone(),n=s.clone()}this.options.startDate=new a.DateTime(i,this.options.format,this.options.lang),n&&(this.options.endDate=new a.DateTime(n,this.options.format,this.options.lang)),this.updateInput(),this.render();var r=i.clone(),l=0;(this.options.elementEnd?i.format(o)===t.target.value:t.target.value.startsWith(i.format(o)))||(r=n.clone(),l=this.options.numberOfMonths-1),this.emit("selected",this.getStartDate(),this.getEndDate()),this.gotoDate(r,l)}},e}(r.Calendar);e.Litepicker=h},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.findNestedMonthItem=function(t){for(var e=t.parentNode.childNodes,i=0;i<e.length;i+=1){if(e.item(i)===t)return i}return 0},e.dateIsLocked=function(t,e,i){var n=!1;return e.lockDays.length&&(n=e.lockDays.filter((function(i){return i instanceof Array?t.isBetween(i[0],i[1],e.lockDaysInclusivity):i.isSame(t,"day")})).length),n||"function"!=typeof e.lockDaysFilter||(n=e.lockDaysFilter.call(this,t.clone(),null,i)),n},e.rangeIsLocked=function(t,e){var i=!1;return e.lockDays.length&&(i=e.lockDays.filter((function(i){if(i instanceof Array){var n=t[0].toDateString()===i[0].toDateString()&&t[1].toDateString()===i[1].toDateString();return i[0].isBetween(t[0],t[1],e.lockDaysInclusivity)||i[1].isBetween(t[0],t[1],e.lockDaysInclusivity)||n}return i.isBetween(t[0],t[1],e.lockDaysInclusivity)})).length),i||"function"!=typeof e.lockDaysFilter||(i=e.lockDaysFilter.call(this,t[0].clone(),t[1].clone(),t)),i}},function(t,e,i){var n=i(8);"string"==typeof n&&(n=[[t.i,n,""]]);var o={insert:function(t){var e=document.querySelector("head"),i=window._lastElementInsertedByStyleLoader;window.disableLitepickerStyles||(i?i.nextSibling?e.insertBefore(t,i.nextSibling):e.appendChild(t):e.insertBefore(t,e.firstChild),window._lastElementInsertedByStyleLoader=t)},singleton:!1};i(10)(n,o);n.locals&&(t.exports=n.locals)},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var n=i(1);e.Litepicker=n.Litepicker,i(11),window.Litepicker=n.Litepicker,e.default=n.Litepicker},function(t,e,i){"use strict";var n,o=this&&this.__extends||(n=function(t,e){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i])})(t,e)},function(t,e){function i(){this.constructor=t}n(t,e),t.prototype=null===e?Object.create(e):(i.prototype=e.prototype,new i)});Object.defineProperty(e,"__esModule",{value:!0});var s=i(6),r=i(0),a=i(3),l=i(2),c=function(t){function e(e){return t.call(this,e)||this}return o(e,t),e.prototype.render=function(){var t=this;this.emit("before:render",this.ui);var e=document.createElement("div");e.className=a.containerMain;var i=document.createElement("div");i.className=a.containerMonths,a["columns"+this.options.numberOfColumns]&&(i.classList.remove(a.columns2,a.columns3,a.columns4),i.classList.add(a["columns"+this.options.numberOfColumns])),this.options.splitView&&i.classList.add(a.splitView),this.options.showWeekNumbers&&i.classList.add(a.showWeekNumbers);for(var n=this.calendars[0].clone(),o=n.getMonth(),s=n.getMonth()+this.options.numberOfMonths,r=0,l=o;l<s;l+=1){var c=n.clone();c.setDate(1),c.setHours(0,0,0,0),this.options.splitView?c=this.calendars[r].clone():c.setMonth(l),i.appendChild(this.renderMonth(c,r)),r+=1}if(this.ui.innerHTML="",e.appendChild(i),this.options.resetButton){var h=void 0;"function"==typeof this.options.resetButton?h=this.options.resetButton.call(this):((h=document.createElement("button")).type="button",h.className=a.resetButton,h.innerHTML=this.options.buttonText.reset),h.addEventListener("click",(function(e){e.preventDefault(),t.clearSelection()})),e.querySelector("."+a.monthItem+":last-child").querySelector("."+a.monthItemHeader).appendChild(h)}this.ui.appendChild(e),this.options.autoApply&&!this.options.footerHTML||this.ui.appendChild(this.renderFooter()),this.options.showTooltip&&this.ui.appendChild(this.renderTooltip()),this.ui.dataset.plugins=(this.options.plugins||[]).join("|"),this.emit("render",this.ui)},e.prototype.renderMonth=function(t,e){var i=this,n=t.clone(),o=32-new Date(n.getFullYear(),n.getMonth(),32).getDate(),s=document.createElement("div");s.className=a.monthItem;var c=document.createElement("div");c.className=a.monthItemHeader;var h=document.createElement("div");if(this.options.dropdowns.months){var p=document.createElement("select");p.className=a.monthItemName;for(var d=0;d<12;d+=1){var u=document.createElement("option"),m=new r.DateTime(new Date(t.getFullYear(),d,2,0,0,0)),f=new r.DateTime(new Date(t.getFullYear(),d,1,0,0,0));u.value=String(d),u.text=m.toLocaleString(this.options.lang,{month:"long"}),u.disabled=this.options.minDate&&f.isBefore(new r.DateTime(this.options.minDate),"month")||this.options.maxDate&&f.isAfter(new r.DateTime(this.options.maxDate),"month"),u.selected=f.getMonth()===t.getMonth(),p.appendChild(u)}p.addEventListener("change",(function(t){var e=t.target,n=0;if(i.options.splitView){var o=e.closest("."+a.monthItem);n=l.findNestedMonthItem(o)}i.calendars[n].setMonth(Number(e.value)),i.render(),i.emit("change:month",i.calendars[n],n,t)})),h.appendChild(p)}else{(m=document.createElement("strong")).className=a.monthItemName,m.innerHTML=t.toLocaleString(this.options.lang,{month:"long"}),h.appendChild(m)}if(this.options.dropdowns.years){var g=document.createElement("select");g.className=a.monthItemYear;var v=this.options.dropdowns.minYear,y=this.options.dropdowns.maxYear?this.options.dropdowns.maxYear:(new Date).getFullYear();if(t.getFullYear()>y)(u=document.createElement("option")).value=String(t.getFullYear()),u.text=String(t.getFullYear()),u.selected=!0,u.disabled=!0,g.appendChild(u);for(d=y;d>=v;d-=1){var u=document.createElement("option"),b=new r.DateTime(new Date(d,0,1,0,0,0));u.value=String(d),u.text=String(d),u.disabled=this.options.minDate&&b.isBefore(new r.DateTime(this.options.minDate),"year")||this.options.maxDate&&b.isAfter(new r.DateTime(this.options.maxDate),"year"),u.selected=t.getFullYear()===d,g.appendChild(u)}if(t.getFullYear()<v)(u=document.createElement("option")).value=String(t.getFullYear()),u.text=String(t.getFullYear()),u.selected=!0,u.disabled=!0,g.appendChild(u);if("asc"===this.options.dropdowns.years){var k=Array.prototype.slice.call(g.childNodes).reverse();g.innerHTML="",k.forEach((function(t){t.innerHTML=t.value,g.appendChild(t)}))}g.addEventListener("change",(function(t){var e=t.target,n=0;if(i.options.splitView){var o=e.closest("."+a.monthItem);n=l.findNestedMonthItem(o)}i.calendars[n].setFullYear(Number(e.value)),i.render(),i.emit("change:year",i.calendars[n],n,t)})),h.appendChild(g)}else{var w=document.createElement("span");w.className=a.monthItemYear,w.innerHTML=String(t.getFullYear()),h.appendChild(w)}var D=document.createElement("button");D.type="button",D.className=a.buttonPreviousMonth,D.innerHTML=this.options.buttonText.previousMonth;var x=document.createElement("button");x.type="button",x.className=a.buttonNextMonth,x.innerHTML=this.options.buttonText.nextMonth,c.appendChild(D),c.appendChild(h),c.appendChild(x),this.options.minDate&&n.isSameOrBefore(new r.DateTime(this.options.minDate),"month")&&s.classList.add(a.noPreviousMonth),this.options.maxDate&&n.isSameOrAfter(new r.DateTime(this.options.maxDate),"month")&&s.classList.add(a.noNextMonth);var M=document.createElement("div");M.className=a.monthItemWeekdaysRow,this.options.showWeekNumbers&&(M.innerHTML="<div>W</div>");for(var _=1;_<=7;_+=1){var T=3+this.options.firstDay+_,L=document.createElement("div");L.innerHTML=this.weekdayName(T),L.title=this.weekdayName(T,"long"),M.appendChild(L)}var E=document.createElement("div");E.className=a.containerDays;var S=this.calcSkipDays(n);this.options.showWeekNumbers&&S&&E.appendChild(this.renderWeekNumber(n));for(var I=0;I<S;I+=1){var P=document.createElement("div");E.appendChild(P)}for(I=1;I<=o;I+=1)n.setDate(I),this.options.showWeekNumbers&&n.getDay()===this.options.firstDay&&E.appendChild(this.renderWeekNumber(n)),E.appendChild(this.renderDay(n));return s.appendChild(c),s.appendChild(M),s.appendChild(E),this.emit("render:month",s,t),s},e.prototype.renderDay=function(t){t.setHours();var e=document.createElement("div");if(e.className=a.dayItem,e.innerHTML=String(t.getDate()),e.dataset.time=String(t.getTime()),t.toDateString()===(new Date).toDateString()&&e.classList.add(a.isToday),this.datePicked.length)this.datePicked[0].toDateString()===t.toDateString()&&(e.classList.add(a.isStartDate),this.options.singleMode&&e.classList.add(a.isEndDate)),2===this.datePicked.length&&this.datePicked[1].toDateString()===t.toDateString()&&e.classList.add(a.isEndDate),2===this.datePicked.length&&t.isBetween(this.datePicked[0],this.datePicked[1])&&e.classList.add(a.isInRange);else if(this.options.startDate){var i=this.options.startDate,n=this.options.endDate;i.toDateString()===t.toDateString()&&(e.classList.add(a.isStartDate),this.options.singleMode&&e.classList.add(a.isEndDate)),n&&n.toDateString()===t.toDateString()&&e.classList.add(a.isEndDate),i&&n&&t.isBetween(i,n)&&e.classList.add(a.isInRange)}if(this.options.minDate&&t.isBefore(new r.DateTime(this.options.minDate))&&e.classList.add(a.isLocked),this.options.maxDate&&t.isAfter(new r.DateTime(this.options.maxDate))&&e.classList.add(a.isLocked),this.options.minDays>1&&1===this.datePicked.length){var o=this.options.minDays-1,s=this.datePicked[0].clone().subtract(o,"day"),c=this.datePicked[0].clone().add(o,"day");t.isBetween(s,this.datePicked[0],"(]")&&e.classList.add(a.isLocked),t.isBetween(this.datePicked[0],c,"[)")&&e.classList.add(a.isLocked)}if(this.options.maxDays&&1===this.datePicked.length){var h=this.options.maxDays;s=this.datePicked[0].clone().subtract(h,"day"),c=this.datePicked[0].clone().add(h,"day");t.isSameOrBefore(s)&&e.classList.add(a.isLocked),t.isSameOrAfter(c)&&e.classList.add(a.isLocked)}(this.options.selectForward&&1===this.datePicked.length&&t.isBefore(this.datePicked[0])&&e.classList.add(a.isLocked),this.options.selectBackward&&1===this.datePicked.length&&t.isAfter(this.datePicked[0])&&e.classList.add(a.isLocked),l.dateIsLocked(t,this.options,this.datePicked)&&e.classList.add(a.isLocked),this.options.highlightedDays.length)&&(this.options.highlightedDays.filter((function(e){return e instanceof Array?t.isBetween(e[0],e[1],"[]"):e.isSame(t,"day")})).length&&e.classList.add(a.isHighlighted));return e.tabIndex=e.classList.contains("is-locked")?-1:0,this.emit("render:day",e,t),e},e.prototype.renderFooter=function(){var t=document.createElement("div");if(t.className=a.containerFooter,this.options.footerHTML?t.innerHTML=this.options.footerHTML:t.innerHTML='\n      <span class="'+a.previewDateRange+'"></span>\n      <button type="button" class="'+a.buttonCancel+'">'+this.options.buttonText.cancel+'</button>\n      <button type="button" class="'+a.buttonApply+'">'+this.options.buttonText.apply+"</button>\n      ",this.options.singleMode){if(1===this.datePicked.length){var e=this.datePicked[0].format(this.options.format,this.options.lang);t.querySelector("."+a.previewDateRange).innerHTML=e}}else if(1===this.datePicked.length&&t.querySelector("."+a.buttonApply).setAttribute("disabled",""),2===this.datePicked.length){e=this.datePicked[0].format(this.options.format,this.options.lang);var i=this.datePicked[1].format(this.options.format,this.options.lang);t.querySelector("."+a.previewDateRange).innerHTML=""+e+this.options.delimiter+i}return this.emit("render:footer",t),t},e.prototype.renderWeekNumber=function(t){var e=document.createElement("div"),i=t.getWeek(this.options.firstDay);return e.className=a.weekNumber,e.innerHTML=53===i&&0===t.getMonth()?"53 / 1":i,e},e.prototype.renderTooltip=function(){var t=document.createElement("div");return t.className=a.containerTooltip,t},e.prototype.weekdayName=function(t,e){return void 0===e&&(e="short"),new Date(1970,0,t,12,0,0,0).toLocaleString(this.options.lang,{weekday:e})},e.prototype.calcSkipDays=function(t){var e=t.getDay()-this.options.firstDay;return e<0&&(e+=7),e},e}(s.LPCore);e.Calendar=c},function(t,e,i){"use strict";var n,o=this&&this.__extends||(n=function(t,e){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i])})(t,e)},function(t,e){function i(){this.constructor=t}n(t,e),t.prototype=null===e?Object.create(e):(i.prototype=e.prototype,new i)}),s=this&&this.__assign||function(){return(s=Object.assign||function(t){for(var e,i=1,n=arguments.length;i<n;i++)for(var o in e=arguments[i])Object.prototype.hasOwnProperty.call(e,o)&&(t[o]=e[o]);return t}).apply(this,arguments)};Object.defineProperty(e,"__esModule",{value:!0});var r=i(7),a=i(0),l=i(1),c=function(t){function e(e){var i=t.call(this)||this;i.datePicked=[],i.calendars=[],i.options={element:null,elementEnd:null,parentEl:null,firstDay:1,format:"YYYY-MM-DD",lang:"en-US",delimiter:" - ",numberOfMonths:1,numberOfColumns:1,startDate:null,endDate:null,zIndex:9999,position:"auto",selectForward:!1,selectBackward:!1,splitView:!1,inlineMode:!1,singleMode:!0,autoApply:!0,allowRepick:!1,showWeekNumbers:!1,showTooltip:!0,scrollToDate:!0,mobileFriendly:!0,resetButton:!1,autoRefresh:!1,lockDaysFormat:"YYYY-MM-DD",lockDays:[],disallowLockDaysInRange:!1,lockDaysInclusivity:"[]",highlightedDaysFormat:"YYYY-MM-DD",highlightedDays:[],dropdowns:{minYear:1990,maxYear:null,months:!1,years:!1},buttonText:{apply:"Apply",cancel:"Cancel",previousMonth:'<svg width="11" height="16" xmlns="http://www.w3.org/2000/svg"><path d="M7.919 0l2.748 2.667L5.333 8l5.334 5.333L7.919 16 0 8z" fill-rule="nonzero"/></svg>',nextMonth:'<svg width="11" height="16" xmlns="http://www.w3.org/2000/svg"><path d="M2.748 16L0 13.333 5.333 8 0 2.667 2.748 0l7.919 8z" fill-rule="nonzero"/></svg>',reset:'<svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24">\n        <path d="M0 0h24v24H0z" fill="none"/>\n        <path d="M13 3c-4.97 0-9 4.03-9 9H1l3.89 3.89.07.14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.93 0-3.68-.79-4.94-2.06l-1.42 1.42C8.27 19.99 10.51 21 13 21c4.97 0 9-4.03 9-9s-4.03-9-9-9zm-1 5v5l4.28 2.54.72-1.21-3.5-2.08V8H12z"/>\n      </svg>'},tooltipText:{one:"day",other:"days"}},i.options=s(s({},i.options),e.element.dataset),Object.keys(i.options).forEach((function(t){"true"!==i.options[t]&&"false"!==i.options[t]||(i.options[t]="true"===i.options[t])}));var n=s(s({},i.options.dropdowns),e.dropdowns),o=s(s({},i.options.buttonText),e.buttonText),r=s(s({},i.options.tooltipText),e.tooltipText);i.options=s(s({},i.options),e),i.options.dropdowns=s({},n),i.options.buttonText=s({},o),i.options.tooltipText=s({},r),i.options.elementEnd||(i.options.allowRepick=!1),i.options.lockDays.length&&(i.options.lockDays=a.DateTime.convertArray(i.options.lockDays,i.options.lockDaysFormat)),i.options.highlightedDays.length&&(i.options.highlightedDays=a.DateTime.convertArray(i.options.highlightedDays,i.options.highlightedDaysFormat));var l=i.parseInput(),c=l[0],h=l[1];i.options.startDate&&(i.options.singleMode||i.options.endDate)&&(c=new a.DateTime(i.options.startDate,i.options.format,i.options.lang)),c&&i.options.endDate&&(h=new a.DateTime(i.options.endDate,i.options.format,i.options.lang)),c instanceof a.DateTime&&!isNaN(c.getTime())&&(i.options.startDate=c),i.options.startDate&&h instanceof a.DateTime&&!isNaN(h.getTime())&&(i.options.endDate=h),!i.options.singleMode||i.options.startDate instanceof a.DateTime||(i.options.startDate=null),i.options.singleMode||i.options.startDate instanceof a.DateTime&&i.options.endDate instanceof a.DateTime||(i.options.startDate=null,i.options.endDate=null);for(var p=0;p<i.options.numberOfMonths;p+=1){var d=i.options.startDate instanceof a.DateTime?i.options.startDate.clone():new a.DateTime;if(!i.options.startDate&&(0===p||i.options.splitView)){var u=i.options.maxDate?new a.DateTime(i.options.maxDate):null,m=i.options.minDate?new a.DateTime(i.options.minDate):null,f=i.options.numberOfMonths-1;m&&u&&d.isAfter(u)?(d=m.clone()).setDate(1):!m&&u&&d.isAfter(u)&&((d=u.clone()).setDate(1),d.setMonth(d.getMonth()-f))}d.setDate(1),d.setMonth(d.getMonth()+p),i.calendars[p]=d}if(i.options.showTooltip)if(i.options.tooltipPluralSelector)i.pluralSelector=i.options.tooltipPluralSelector;else try{var g=new Intl.PluralRules(i.options.lang);i.pluralSelector=g.select.bind(g)}catch(t){i.pluralSelector=function(t){return 0===Math.abs(t)?"one":"other"}}return i}return o(e,t),e.add=function(t,e){l.Litepicker.prototype[t]=e},e.prototype.DateTime=function(t,e){return t?new a.DateTime(t,e):new a.DateTime},e.prototype.init=function(){var t=this;this.options.plugins&&this.options.plugins.length&&this.options.plugins.forEach((function(e){l.Litepicker.prototype.hasOwnProperty(e)?l.Litepicker.prototype[e].init.call(t,t):console.warn("Litepicker: plugin «"+e+"» not found.")}))},e.prototype.parseInput=function(){var t=this.options.delimiter,e=new RegExp(""+t),i=this.options.element instanceof HTMLInputElement?this.options.element.value.split(t):[];if(this.options.elementEnd){if(this.options.element instanceof HTMLInputElement&&this.options.element.value.length&&this.options.elementEnd instanceof HTMLInputElement&&this.options.elementEnd.value.length)return[new a.DateTime(this.options.element.value,this.options.format),new a.DateTime(this.options.elementEnd.value,this.options.format)]}else if(this.options.singleMode){if(this.options.element instanceof HTMLInputElement&&this.options.element.value.length)return[new a.DateTime(this.options.element.value,this.options.format)]}else if(this.options.element instanceof HTMLInputElement&&e.test(this.options.element.value)&&i.length&&i.length%2==0){var n=i.slice(0,i.length/2).join(t),o=i.slice(i.length/2).join(t);return[new a.DateTime(n,this.options.format),new a.DateTime(o,this.options.format)]}return[]},e.prototype.isShowning=function(){return this.ui&&"none"!==this.ui.style.display},e.prototype.findPosition=function(t){var e=t.getBoundingClientRect(),i=this.ui.getBoundingClientRect(),n=this.options.position.split(" "),o=window.scrollX||window.pageXOffset,s=window.scrollY||window.pageYOffset,r=0,a=0;if("auto"!==n[0]&&/top|bottom/.test(n[0]))r=e[n[0]]+s,"top"===n[0]&&(r-=i.height);else{r=e.bottom+s;var l=e.bottom+i.height>window.innerHeight,c=e.top+s-i.height>=i.height;l&&c&&(r=e.top+s-i.height)}if(/left|right/.test(n[0])||n[1]&&"auto"!==n[1]&&/left|right/.test(n[1]))a=/left|right/.test(n[0])?e[n[0]]+o:e[n[1]]+o,"right"!==n[0]&&"right"!==n[1]||(a-=i.width);else{a=e.left+o;l=e.left+i.width>window.innerWidth;var h=e.right+o-i.width>=0;l&&h&&(a=e.right+o-i.width)}return{left:a,top:r}},e}(r.EventEmitter);e.LPCore=c},function(t,e,i){"use strict";var n,o="object"==typeof Reflect?Reflect:null,s=o&&"function"==typeof o.apply?o.apply:function(t,e,i){return Function.prototype.apply.call(t,e,i)};n=o&&"function"==typeof o.ownKeys?o.ownKeys:Object.getOwnPropertySymbols?function(t){return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t))}:function(t){return Object.getOwnPropertyNames(t)};var r=Number.isNaN||function(t){return t!=t};function a(){a.init.call(this)}t.exports=a,a.EventEmitter=a,a.prototype._events=void 0,a.prototype._eventsCount=0,a.prototype._maxListeners=void 0;var l=10;function c(t){return void 0===t._maxListeners?a.defaultMaxListeners:t._maxListeners}function h(t,e,i,n){var o,s,r,a;if("function"!=typeof i)throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof i);if(void 0===(s=t._events)?(s=t._events=Object.create(null),t._eventsCount=0):(void 0!==s.newListener&&(t.emit("newListener",e,i.listener?i.listener:i),s=t._events),r=s[e]),void 0===r)r=s[e]=i,++t._eventsCount;else if("function"==typeof r?r=s[e]=n?[i,r]:[r,i]:n?r.unshift(i):r.push(i),(o=c(t))>0&&r.length>o&&!r.warned){r.warned=!0;var l=new Error("Possible EventEmitter memory leak detected. "+r.length+" "+String(e)+" listeners added. Use emitter.setMaxListeners() to increase limit");l.name="MaxListenersExceededWarning",l.emitter=t,l.type=e,l.count=r.length,a=l,console&&console.warn&&console.warn(a)}return t}function p(){for(var t=[],e=0;e<arguments.length;e++)t.push(arguments[e]);this.fired||(this.target.removeListener(this.type,this.wrapFn),this.fired=!0,s(this.listener,this.target,t))}function d(t,e,i){var n={fired:!1,wrapFn:void 0,target:t,type:e,listener:i},o=p.bind(n);return o.listener=i,n.wrapFn=o,o}function u(t,e,i){var n=t._events;if(void 0===n)return[];var o=n[e];return void 0===o?[]:"function"==typeof o?i?[o.listener||o]:[o]:i?function(t){for(var e=new Array(t.length),i=0;i<e.length;++i)e[i]=t[i].listener||t[i];return e}(o):f(o,o.length)}function m(t){var e=this._events;if(void 0!==e){var i=e[t];if("function"==typeof i)return 1;if(void 0!==i)return i.length}return 0}function f(t,e){for(var i=new Array(e),n=0;n<e;++n)i[n]=t[n];return i}Object.defineProperty(a,"defaultMaxListeners",{enumerable:!0,get:function(){return l},set:function(t){if("number"!=typeof t||t<0||r(t))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+t+".");l=t}}),a.init=function(){void 0!==this._events&&this._events!==Object.getPrototypeOf(this)._events||(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},a.prototype.setMaxListeners=function(t){if("number"!=typeof t||t<0||r(t))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+t+".");return this._maxListeners=t,this},a.prototype.getMaxListeners=function(){return c(this)},a.prototype.emit=function(t){for(var e=[],i=1;i<arguments.length;i++)e.push(arguments[i]);var n="error"===t,o=this._events;if(void 0!==o)n=n&&void 0===o.error;else if(!n)return!1;if(n){var r;if(e.length>0&&(r=e[0]),r instanceof Error)throw r;var a=new Error("Unhandled error."+(r?" ("+r.message+")":""));throw a.context=r,a}var l=o[t];if(void 0===l)return!1;if("function"==typeof l)s(l,this,e);else{var c=l.length,h=f(l,c);for(i=0;i<c;++i)s(h[i],this,e)}return!0},a.prototype.addListener=function(t,e){return h(this,t,e,!1)},a.prototype.on=a.prototype.addListener,a.prototype.prependListener=function(t,e){return h(this,t,e,!0)},a.prototype.once=function(t,e){if("function"!=typeof e)throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof e);return this.on(t,d(this,t,e)),this},a.prototype.prependOnceListener=function(t,e){if("function"!=typeof e)throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof e);return this.prependListener(t,d(this,t,e)),this},a.prototype.removeListener=function(t,e){var i,n,o,s,r;if("function"!=typeof e)throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof e);if(void 0===(n=this._events))return this;if(void 0===(i=n[t]))return this;if(i===e||i.listener===e)0==--this._eventsCount?this._events=Object.create(null):(delete n[t],n.removeListener&&this.emit("removeListener",t,i.listener||e));else if("function"!=typeof i){for(o=-1,s=i.length-1;s>=0;s--)if(i[s]===e||i[s].listener===e){r=i[s].listener,o=s;break}if(o<0)return this;0===o?i.shift():function(t,e){for(;e+1<t.length;e++)t[e]=t[e+1];t.pop()}(i,o),1===i.length&&(n[t]=i[0]),void 0!==n.removeListener&&this.emit("removeListener",t,r||e)}return this},a.prototype.off=a.prototype.removeListener,a.prototype.removeAllListeners=function(t){var e,i,n;if(void 0===(i=this._events))return this;if(void 0===i.removeListener)return 0===arguments.length?(this._events=Object.create(null),this._eventsCount=0):void 0!==i[t]&&(0==--this._eventsCount?this._events=Object.create(null):delete i[t]),this;if(0===arguments.length){var o,s=Object.keys(i);for(n=0;n<s.length;++n)"removeListener"!==(o=s[n])&&this.removeAllListeners(o);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if("function"==typeof(e=i[t]))this.removeListener(t,e);else if(void 0!==e)for(n=e.length-1;n>=0;n--)this.removeListener(t,e[n]);return this},a.prototype.listeners=function(t){return u(this,t,!0)},a.prototype.rawListeners=function(t){return u(this,t,!1)},a.listenerCount=function(t,e){return"function"==typeof t.listenerCount?t.listenerCount(e):m.call(t,e)},a.prototype.listenerCount=m,a.prototype.eventNames=function(){return this._eventsCount>0?n(this._events):[]}},function(t,e,i){(e=i(9)(!1)).push([t.i,':root{--litepicker-container-months-color-bg: #fff;--litepicker-container-months-box-shadow-color: #ddd;--litepicker-footer-color-bg: #fafafa;--litepicker-footer-box-shadow-color: #ddd;--litepicker-tooltip-color-bg: #fff;--litepicker-month-header-color: #333;--litepicker-button-prev-month-color: #9e9e9e;--litepicker-button-next-month-color: #9e9e9e;--litepicker-button-prev-month-color-hover: #2196f3;--litepicker-button-next-month-color-hover: #2196f3;--litepicker-month-width: calc(var(--litepicker-day-width) * 7);--litepicker-month-weekday-color: #9e9e9e;--litepicker-month-week-number-color: #9e9e9e;--litepicker-day-width: 38px;--litepicker-day-color: #333;--litepicker-day-color-hover: #2196f3;--litepicker-is-today-color: #f44336;--litepicker-is-in-range-color: #bbdefb;--litepicker-is-locked-color: #9e9e9e;--litepicker-is-start-color: #fff;--litepicker-is-start-color-bg: #2196f3;--litepicker-is-end-color: #fff;--litepicker-is-end-color-bg: #2196f3;--litepicker-button-cancel-color: #fff;--litepicker-button-cancel-color-bg: #9e9e9e;--litepicker-button-apply-color: #fff;--litepicker-button-apply-color-bg: #2196f3;--litepicker-button-reset-color: #909090;--litepicker-button-reset-color-hover: #2196f3;--litepicker-highlighted-day-color: #333;--litepicker-highlighted-day-color-bg: #ffeb3b}.show-week-numbers{--litepicker-month-width: calc(var(--litepicker-day-width) * 8)}.litepicker{font-family:-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;font-size:0.8em;display:none}.litepicker button{border:none;background:none}.litepicker .container__main{display:-webkit-box;display:-ms-flexbox;display:flex}.litepicker .container__months{display:-webkit-box;display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap;background-color:var(--litepicker-container-months-color-bg);border-radius:5px;-webkit-box-shadow:0 0 5px var(--litepicker-container-months-box-shadow-color);box-shadow:0 0 5px var(--litepicker-container-months-box-shadow-color);width:calc(var(--litepicker-month-width) + 10px);-webkit-box-sizing:content-box;box-sizing:content-box}.litepicker .container__months.columns-2{width:calc((var(--litepicker-month-width) * 2) + 20px)}.litepicker .container__months.columns-3{width:calc((var(--litepicker-month-width) * 3) + 30px)}.litepicker .container__months.columns-4{width:calc((var(--litepicker-month-width) * 4) + 40px)}.litepicker .container__months.split-view .month-item-header .button-previous-month,.litepicker .container__months.split-view .month-item-header .button-next-month{visibility:visible}.litepicker .container__months .month-item{padding:5px;width:var(--litepicker-month-width);-webkit-box-sizing:content-box;box-sizing:content-box}.litepicker .container__months .month-item-header{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between;font-weight:500;padding:10px 5px;text-align:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;color:var(--litepicker-month-header-color)}.litepicker .container__months .month-item-header div{-webkit-box-flex:1;-ms-flex:1;flex:1}.litepicker .container__months .month-item-header div>.month-item-name{margin-right:5px}.litepicker .container__months .month-item-header div>.month-item-year{padding:0}.litepicker .container__months .month-item-header .reset-button{color:var(--litepicker-button-reset-color)}.litepicker .container__months .month-item-header .reset-button>svg{fill:var(--litepicker-button-reset-color)}.litepicker .container__months .month-item-header .reset-button *{pointer-events:none}.litepicker .container__months .month-item-header .reset-button:hover{color:var(--litepicker-button-reset-color-hover)}.litepicker .container__months .month-item-header .reset-button:hover>svg{fill:var(--litepicker-button-reset-color-hover)}.litepicker .container__months .month-item-header .button-previous-month,.litepicker .container__months .month-item-header .button-next-month{visibility:hidden;text-decoration:none;padding:3px 5px;border-radius:3px;-webkit-transition:color 0.3s, border 0.3s;transition:color 0.3s, border 0.3s;cursor:default}.litepicker .container__months .month-item-header .button-previous-month *,.litepicker .container__months .month-item-header .button-next-month *{pointer-events:none}.litepicker .container__months .month-item-header .button-previous-month{color:var(--litepicker-button-prev-month-color)}.litepicker .container__months .month-item-header .button-previous-month>svg,.litepicker .container__months .month-item-header .button-previous-month>img{fill:var(--litepicker-button-prev-month-color)}.litepicker .container__months .month-item-header .button-previous-month:hover{color:var(--litepicker-button-prev-month-color-hover)}.litepicker .container__months .month-item-header .button-previous-month:hover>svg{fill:var(--litepicker-button-prev-month-color-hover)}.litepicker .container__months .month-item-header .button-next-month{color:var(--litepicker-button-next-month-color)}.litepicker .container__months .month-item-header .button-next-month>svg,.litepicker .container__months .month-item-header .button-next-month>img{fill:var(--litepicker-button-next-month-color)}.litepicker .container__months .month-item-header .button-next-month:hover{color:var(--litepicker-button-next-month-color-hover)}.litepicker .container__months .month-item-header .button-next-month:hover>svg{fill:var(--litepicker-button-next-month-color-hover)}.litepicker .container__months .month-item-weekdays-row{display:-webkit-box;display:-ms-flexbox;display:flex;justify-self:center;-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;color:var(--litepicker-month-weekday-color)}.litepicker .container__months .month-item-weekdays-row>div{padding:5px 0;font-size:85%;-webkit-box-flex:1;-ms-flex:1;flex:1;width:var(--litepicker-day-width);text-align:center}.litepicker .container__months .month-item:first-child .button-previous-month{visibility:visible}.litepicker .container__months .month-item:last-child .button-next-month{visibility:visible}.litepicker .container__months .month-item.no-previous-month .button-previous-month{visibility:hidden}.litepicker .container__months .month-item.no-next-month .button-next-month{visibility:hidden}.litepicker .container__days{display:-webkit-box;display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap;justify-self:center;-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:center;-webkit-box-sizing:content-box;box-sizing:content-box}.litepicker .container__days>div,.litepicker .container__days>a{padding:5px 0;width:var(--litepicker-day-width)}.litepicker .container__days .day-item{color:var(--litepicker-day-color);text-align:center;text-decoration:none;border-radius:3px;-webkit-transition:color 0.3s, border 0.3s;transition:color 0.3s, border 0.3s;cursor:default}.litepicker .container__days .day-item:hover{color:var(--litepicker-day-color-hover);-webkit-box-shadow:inset 0 0 0 1px var(--litepicker-day-color-hover);box-shadow:inset 0 0 0 1px var(--litepicker-day-color-hover)}.litepicker .container__days .day-item.is-today{color:var(--litepicker-is-today-color)}.litepicker .container__days .day-item.is-locked{color:var(--litepicker-is-locked-color)}.litepicker .container__days .day-item.is-locked:hover{color:var(--litepicker-is-locked-color);-webkit-box-shadow:none;box-shadow:none;cursor:default}.litepicker .container__days .day-item.is-in-range{background-color:var(--litepicker-is-in-range-color);border-radius:0}.litepicker .container__days .day-item.is-start-date{color:var(--litepicker-is-start-color);background-color:var(--litepicker-is-start-color-bg);border-top-left-radius:5px;border-bottom-left-radius:5px;border-top-right-radius:0;border-bottom-right-radius:0}.litepicker .container__days .day-item.is-start-date.is-flipped{border-top-left-radius:0;border-bottom-left-radius:0;border-top-right-radius:5px;border-bottom-right-radius:5px}.litepicker .container__days .day-item.is-end-date{color:var(--litepicker-is-end-color);background-color:var(--litepicker-is-end-color-bg);border-top-left-radius:0;border-bottom-left-radius:0;border-top-right-radius:5px;border-bottom-right-radius:5px}.litepicker .container__days .day-item.is-end-date.is-flipped{border-top-left-radius:5px;border-bottom-left-radius:5px;border-top-right-radius:0;border-bottom-right-radius:0}.litepicker .container__days .day-item.is-start-date.is-end-date{border-top-left-radius:5px;border-bottom-left-radius:5px;border-top-right-radius:5px;border-bottom-right-radius:5px}.litepicker .container__days .day-item.is-highlighted{color:var(--litepicker-highlighted-day-color);background-color:var(--litepicker-highlighted-day-color-bg)}.litepicker .container__days .week-number{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;color:var(--litepicker-month-week-number-color);font-size:85%}.litepicker .container__footer{text-align:right;padding:10px 5px;margin:0 5px;background-color:var(--litepicker-footer-color-bg);-webkit-box-shadow:inset 0px 3px 3px 0px var(--litepicker-footer-box-shadow-color);box-shadow:inset 0px 3px 3px 0px var(--litepicker-footer-box-shadow-color);border-bottom-left-radius:5px;border-bottom-right-radius:5px}.litepicker .container__footer .preview-date-range{margin-right:10px;font-size:90%}.litepicker .container__footer .button-cancel{background-color:var(--litepicker-button-cancel-color-bg);color:var(--litepicker-button-cancel-color);border:0;padding:3px 7px 4px;border-radius:3px}.litepicker .container__footer .button-cancel *{pointer-events:none}.litepicker .container__footer .button-apply{background-color:var(--litepicker-button-apply-color-bg);color:var(--litepicker-button-apply-color);border:0;padding:3px 7px 4px;border-radius:3px;margin-left:10px;margin-right:10px}.litepicker .container__footer .button-apply:disabled{opacity:0.7}.litepicker .container__footer .button-apply *{pointer-events:none}.litepicker .container__tooltip{position:absolute;margin-top:-4px;padding:4px 8px;border-radius:4px;background-color:var(--litepicker-tooltip-color-bg);-webkit-box-shadow:0 1px 3px rgba(0,0,0,0.25);box-shadow:0 1px 3px rgba(0,0,0,0.25);white-space:nowrap;font-size:11px;pointer-events:none;visibility:hidden}.litepicker .container__tooltip:before{position:absolute;bottom:-5px;left:calc(50% - 5px);border-top:5px solid rgba(0,0,0,0.12);border-right:5px solid transparent;border-left:5px solid transparent;content:""}.litepicker .container__tooltip:after{position:absolute;bottom:-4px;left:calc(50% - 4px);border-top:4px solid var(--litepicker-tooltip-color-bg);border-right:4px solid transparent;border-left:4px solid transparent;content:""}\n',""]),e.locals={showWeekNumbers:"show-week-numbers",litepicker:"litepicker",containerMain:"container__main",containerMonths:"container__months",columns2:"columns-2",columns3:"columns-3",columns4:"columns-4",splitView:"split-view",monthItemHeader:"month-item-header",buttonPreviousMonth:"button-previous-month",buttonNextMonth:"button-next-month",monthItem:"month-item",monthItemName:"month-item-name",monthItemYear:"month-item-year",resetButton:"reset-button",monthItemWeekdaysRow:"month-item-weekdays-row",noPreviousMonth:"no-previous-month",noNextMonth:"no-next-month",containerDays:"container__days",dayItem:"day-item",isToday:"is-today",isLocked:"is-locked",isInRange:"is-in-range",isStartDate:"is-start-date",isFlipped:"is-flipped",isEndDate:"is-end-date",isHighlighted:"is-highlighted",weekNumber:"week-number",containerFooter:"container__footer",previewDateRange:"preview-date-range",buttonCancel:"button-cancel",buttonApply:"button-apply",containerTooltip:"container__tooltip"},t.exports=e},function(t,e,i){"use strict";t.exports=function(t){var e=[];return e.toString=function(){return this.map((function(e){var i=function(t,e){var i=t[1]||"",n=t[3];if(!n)return i;if(e&&"function"==typeof btoa){var o=(r=n,a=btoa(unescape(encodeURIComponent(JSON.stringify(r)))),l="sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(a),"/*# ".concat(l," */")),s=n.sources.map((function(t){return"/*# sourceURL=".concat(n.sourceRoot||"").concat(t," */")}));return[i].concat(s).concat([o]).join("\n")}var r,a,l;return[i].join("\n")}(e,t);return e[2]?"@media ".concat(e[2]," {").concat(i,"}"):i})).join("")},e.i=function(t,i,n){"string"==typeof t&&(t=[[null,t,""]]);var o={};if(n)for(var s=0;s<this.length;s++){var r=this[s][0];null!=r&&(o[r]=!0)}for(var a=0;a<t.length;a++){var l=[].concat(t[a]);n&&o[l[0]]||(i&&(l[2]?l[2]="".concat(i," and ").concat(l[2]):l[2]=i),e.push(l))}},e}},function(t,e,i){"use strict";var n,o={},s=function(){return void 0===n&&(n=Boolean(window&&document&&document.all&&!window.atob)),n},r=function(){var t={};return function(e){if(void 0===t[e]){var i=document.querySelector(e);if(window.HTMLIFrameElement&&i instanceof window.HTMLIFrameElement)try{i=i.contentDocument.head}catch(t){i=null}t[e]=i}return t[e]}}();function a(t,e){for(var i=[],n={},o=0;o<t.length;o++){var s=t[o],r=e.base?s[0]+e.base:s[0],a={css:s[1],media:s[2],sourceMap:s[3]};n[r]?n[r].parts.push(a):i.push(n[r]={id:r,parts:[a]})}return i}function l(t,e){for(var i=0;i<t.length;i++){var n=t[i],s=o[n.id],r=0;if(s){for(s.refs++;r<s.parts.length;r++)s.parts[r](n.parts[r]);for(;r<n.parts.length;r++)s.parts.push(g(n.parts[r],e))}else{for(var a=[];r<n.parts.length;r++)a.push(g(n.parts[r],e));o[n.id]={id:n.id,refs:1,parts:a}}}}function c(t){var e=document.createElement("style");if(void 0===t.attributes.nonce){var n=i.nc;n&&(t.attributes.nonce=n)}if(Object.keys(t.attributes).forEach((function(i){e.setAttribute(i,t.attributes[i])})),"function"==typeof t.insert)t.insert(e);else{var o=r(t.insert||"head");if(!o)throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");o.appendChild(e)}return e}var h,p=(h=[],function(t,e){return h[t]=e,h.filter(Boolean).join("\n")});function d(t,e,i,n){var o=i?"":n.css;if(t.styleSheet)t.styleSheet.cssText=p(e,o);else{var s=document.createTextNode(o),r=t.childNodes;r[e]&&t.removeChild(r[e]),r.length?t.insertBefore(s,r[e]):t.appendChild(s)}}function u(t,e,i){var n=i.css,o=i.media,s=i.sourceMap;if(o&&t.setAttribute("media",o),s&&btoa&&(n+="\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(s))))," */")),t.styleSheet)t.styleSheet.cssText=n;else{for(;t.firstChild;)t.removeChild(t.firstChild);t.appendChild(document.createTextNode(n))}}var m=null,f=0;function g(t,e){var i,n,o;if(e.singleton){var s=f++;i=m||(m=c(e)),n=d.bind(null,i,s,!1),o=d.bind(null,i,s,!0)}else i=c(e),n=u.bind(null,i,e),o=function(){!function(t){if(null===t.parentNode)return!1;t.parentNode.removeChild(t)}(i)};return n(t),function(e){if(e){if(e.css===t.css&&e.media===t.media&&e.sourceMap===t.sourceMap)return;n(t=e)}else o()}}t.exports=function(t,e){(e=e||{}).attributes="object"==typeof e.attributes?e.attributes:{},e.singleton||"boolean"==typeof e.singleton||(e.singleton=s());var i=a(t,e);return l(i,e),function(t){for(var n=[],s=0;s<i.length;s++){var r=i[s],c=o[r.id];c&&(c.refs--,n.push(c))}t&&l(a(t,e),e);for(var h=0;h<n.length;h++){var p=n[h];if(0===p.refs){for(var d=0;d<p.parts.length;d++)p.parts[d]();delete o[p.id]}}}}},function(t,e,i){"use strict";var n=this&&this.__assign||function(){return(n=Object.assign||function(t){for(var e,i=1,n=arguments.length;i<n;i++)for(var o in e=arguments[i])Object.prototype.hasOwnProperty.call(e,o)&&(t[o]=e[o]);return t}).apply(this,arguments)};Object.defineProperty(e,"__esModule",{value:!0});var o=i(0),s=i(1),r=i(2);s.Litepicker.prototype.show=function(t){void 0===t&&(t=null),this.emit("before:show",t);var e=t||this.options.element;if(this.triggerElement=e,!this.isShowning()){if(this.options.inlineMode)return this.ui.style.position="relative",this.ui.style.display="inline-block",this.ui.style.top=null,this.ui.style.left=null,this.ui.style.bottom=null,void(this.ui.style.right=null);this.scrollToDate(t),this.render(),this.ui.style.position="absolute",this.ui.style.display="block",this.ui.style.zIndex=this.options.zIndex;var i=this.findPosition(e);this.ui.style.top=i.top+"px",this.ui.style.left=i.left+"px",this.ui.style.right=null,this.ui.style.bottom=null,this.emit("show",t)}},s.Litepicker.prototype.hide=function(){this.isShowning()&&(this.datePicked.length=0,this.updateInput(),this.options.inlineMode?this.render():(this.ui.style.display="none",this.emit("hide")))},s.Litepicker.prototype.getDate=function(){return this.getStartDate()},s.Litepicker.prototype.getStartDate=function(){return this.options.startDate?this.options.startDate.clone():null},s.Litepicker.prototype.getEndDate=function(){return this.options.endDate?this.options.endDate.clone():null},s.Litepicker.prototype.setDate=function(t,e){void 0===e&&(e=!1);var i=new o.DateTime(t,this.options.format,this.options.lang);r.dateIsLocked(i,this.options,[i])&&!e?this.emit("error:date",i):(this.setStartDate(t),this.options.inlineMode&&this.render(),this.emit("selected",this.getDate()))},s.Litepicker.prototype.setStartDate=function(t){t&&(this.options.startDate=new o.DateTime(t,this.options.format,this.options.lang),this.updateInput())},s.Litepicker.prototype.setEndDate=function(t){t&&(this.options.endDate=new o.DateTime(t,this.options.format,this.options.lang),this.options.startDate.getTime()>this.options.endDate.getTime()&&(this.options.endDate=this.options.startDate.clone(),this.options.startDate=new o.DateTime(t,this.options.format,this.options.lang)),this.updateInput())},s.Litepicker.prototype.setDateRange=function(t,e,i){void 0===i&&(i=!1),this.triggerElement=void 0;var n=new o.DateTime(t,this.options.format,this.options.lang),s=new o.DateTime(e,this.options.format,this.options.lang);(this.options.disallowLockDaysInRange?r.rangeIsLocked([n,s],this.options):r.dateIsLocked(n,this.options,[n,s])||r.dateIsLocked(s,this.options,[n,s]))&&!i?this.emit("error:range",[n,s]):(this.setStartDate(n),this.setEndDate(s),this.options.inlineMode&&this.render(),this.updateInput(),this.emit("selected",this.getStartDate(),this.getEndDate()))},s.Litepicker.prototype.gotoDate=function(t,e){void 0===e&&(e=0);var i=new o.DateTime(t);i.setDate(1),this.calendars[e]=i.clone(),this.render()},s.Litepicker.prototype.setLockDays=function(t){this.options.lockDays=o.DateTime.convertArray(t,this.options.lockDaysFormat),this.render()},s.Litepicker.prototype.setHighlightedDays=function(t){this.options.highlightedDays=o.DateTime.convertArray(t,this.options.highlightedDaysFormat),this.render()},s.Litepicker.prototype.setOptions=function(t){delete t.element,delete t.elementEnd,delete t.parentEl,t.startDate&&(t.startDate=new o.DateTime(t.startDate,this.options.format,this.options.lang)),t.endDate&&(t.endDate=new o.DateTime(t.endDate,this.options.format,this.options.lang));var e=n(n({},this.options.dropdowns),t.dropdowns),i=n(n({},this.options.buttonText),t.buttonText),s=n(n({},this.options.tooltipText),t.tooltipText);this.options=n(n({},this.options),t),this.options.dropdowns=n({},e),this.options.buttonText=n({},i),this.options.tooltipText=n({},s),!this.options.singleMode||this.options.startDate instanceof o.DateTime||(this.options.startDate=null,this.options.endDate=null),this.options.singleMode||this.options.startDate instanceof o.DateTime&&this.options.endDate instanceof o.DateTime||(this.options.startDate=null,this.options.endDate=null);for(var r=0;r<this.options.numberOfMonths;r+=1){var a=this.options.startDate?this.options.startDate.clone():new o.DateTime;a.setDate(1),a.setMonth(a.getMonth()+r),this.calendars[r]=a}this.options.lockDays.length&&(this.options.lockDays=o.DateTime.convertArray(this.options.lockDays,this.options.lockDaysFormat)),this.options.highlightedDays.length&&(this.options.highlightedDays=o.DateTime.convertArray(this.options.highlightedDays,this.options.highlightedDaysFormat)),this.render(),this.options.inlineMode&&this.show(),this.updateInput()},s.Litepicker.prototype.clearSelection=function(){this.options.startDate=null,this.options.endDate=null,this.datePicked.length=0,this.updateInput(),this.isShowning()&&this.render(),this.emit("clear:selection")},s.Litepicker.prototype.destroy=function(){this.ui&&this.ui.parentNode&&(this.ui.parentNode.removeChild(this.ui),this.ui=null),this.emit("destroy")}}])}));

/***/ }),

/***/ "./node_modules/litepicker/dist/plugins/mobilefriendly.js":
/*!****************************************************************!*\
  !*** ./node_modules/litepicker/dist/plugins/mobilefriendly.js ***!
  \****************************************************************/
/***/ (function() {

/*!
 * 
 * plugins/mobilefriendly.js
 * Litepicker v2.0.12 (https://github.com/wakirin/Litepicker)
 * Package: litepicker (https://www.npmjs.com/package/litepicker)
 * License: MIT (https://github.com/wakirin/Litepicker/blob/master/LICENCE.md)
 * Copyright 2019-2021 Rinat G.
 *     
 * Hash: b9a648207aabe31b2912
 * 
 */!function(e){var t={};function n(r){if(t[r])return t[r].exports;var i=t[r]={i:r,l:!1,exports:{}};return e[r].call(i.exports,i,i.exports,n),i.l=!0,i.exports}n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)n.d(r,i,function(t){return e[t]}.bind(null,i));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=5)}([function(e,t,n){"use strict";e.exports=function(e){var t=[];return t.toString=function(){return this.map((function(t){var n=function(e,t){var n=e[1]||"",r=e[3];if(!r)return n;if(t&&"function"==typeof btoa){var i=(a=r,l=btoa(unescape(encodeURIComponent(JSON.stringify(a)))),c="sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(l),"/*# ".concat(c," */")),o=r.sources.map((function(e){return"/*# sourceURL=".concat(r.sourceRoot||"").concat(e," */")}));return[n].concat(o).concat([i]).join("\n")}var a,l,c;return[n].join("\n")}(t,e);return t[2]?"@media ".concat(t[2]," {").concat(n,"}"):n})).join("")},t.i=function(e,n,r){"string"==typeof e&&(e=[[null,e,""]]);var i={};if(r)for(var o=0;o<this.length;o++){var a=this[o][0];null!=a&&(i[a]=!0)}for(var l=0;l<e.length;l++){var c=[].concat(e[l]);r&&i[c[0]]||(n&&(c[2]?c[2]="".concat(n," and ").concat(c[2]):c[2]=n),t.push(c))}},t}},function(e,t,n){"use strict";var r,i={},o=function(){return void 0===r&&(r=Boolean(window&&document&&document.all&&!window.atob)),r},a=function(){var e={};return function(t){if(void 0===e[t]){var n=document.querySelector(t);if(window.HTMLIFrameElement&&n instanceof window.HTMLIFrameElement)try{n=n.contentDocument.head}catch(e){n=null}e[t]=n}return e[t]}}();function l(e,t){for(var n=[],r={},i=0;i<e.length;i++){var o=e[i],a=t.base?o[0]+t.base:o[0],l={css:o[1],media:o[2],sourceMap:o[3]};r[a]?r[a].parts.push(l):n.push(r[a]={id:a,parts:[l]})}return n}function c(e,t){for(var n=0;n<e.length;n++){var r=e[n],o=i[r.id],a=0;if(o){for(o.refs++;a<o.parts.length;a++)o.parts[a](r.parts[a]);for(;a<r.parts.length;a++)o.parts.push(b(r.parts[a],t))}else{for(var l=[];a<r.parts.length;a++)l.push(b(r.parts[a],t));i[r.id]={id:r.id,refs:1,parts:l}}}}function s(e){var t=document.createElement("style");if(void 0===e.attributes.nonce){var r=n.nc;r&&(e.attributes.nonce=r)}if(Object.keys(e.attributes).forEach((function(n){t.setAttribute(n,e.attributes[n])})),"function"==typeof e.insert)e.insert(t);else{var i=a(e.insert||"head");if(!i)throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");i.appendChild(t)}return t}var u,d=(u=[],function(e,t){return u[e]=t,u.filter(Boolean).join("\n")});function p(e,t,n,r){var i=n?"":r.css;if(e.styleSheet)e.styleSheet.cssText=d(t,i);else{var o=document.createTextNode(i),a=e.childNodes;a[t]&&e.removeChild(a[t]),a.length?e.insertBefore(o,a[t]):e.appendChild(o)}}function f(e,t,n){var r=n.css,i=n.media,o=n.sourceMap;if(i&&e.setAttribute("media",i),o&&btoa&&(r+="\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(o))))," */")),e.styleSheet)e.styleSheet.cssText=r;else{for(;e.firstChild;)e.removeChild(e.firstChild);e.appendChild(document.createTextNode(r))}}var m=null,h=0;function b(e,t){var n,r,i;if(t.singleton){var o=h++;n=m||(m=s(t)),r=p.bind(null,n,o,!1),i=p.bind(null,n,o,!0)}else n=s(t),r=f.bind(null,n,t),i=function(){!function(e){if(null===e.parentNode)return!1;e.parentNode.removeChild(e)}(n)};return r(e),function(t){if(t){if(t.css===e.css&&t.media===e.media&&t.sourceMap===e.sourceMap)return;r(e=t)}else i()}}e.exports=function(e,t){(t=t||{}).attributes="object"==typeof t.attributes?t.attributes:{},t.singleton||"boolean"==typeof t.singleton||(t.singleton=o());var n=l(e,t);return c(n,t),function(e){for(var r=[],o=0;o<n.length;o++){var a=n[o],s=i[a.id];s&&(s.refs--,r.push(s))}e&&c(l(e,t),t);for(var u=0;u<r.length;u++){var d=r[u];if(0===d.refs){for(var p=0;p<d.parts.length;p++)d.parts[p]();delete i[d.id]}}}}},,,,function(e,t,n){"use strict";n.r(t);n(6);function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}Litepicker.add("mobilefriendly",{init:function(e){var t=e.options;e.options.mobilefriendly=i(i({},{breakpoint:480}),t.mobilefriendly),Object.defineProperties(e,{xTouchDown:{value:null,writable:!0},yTouchDown:{value:null,writable:!0},touchTargetMonth:{value:null,writable:!0}});var n=!1;try{var r=Object.defineProperty({},"passive",{get:function(){n=!0}});window.addEventListener("testPassive",null,r),window.removeEventListener("testPassive",null,r)}catch(e){}function o(){var t="portrait"===a();return window.matchMedia("(max-device-".concat(t?"width":"height",": ").concat(e.options.mobilefriendly.breakpoint,"px)")).matches}function a(){return"orientation"in window.screen&&"type"in window.screen.orientation?window.screen.orientation.type.replace(/\-\w+$/,""):window.matchMedia("(orientation: portrait)").matches?"portrait":"landscape"}function l(){"portrait"===a()?(e.options.numberOfMonths=1,e.options.numberOfColumns=1):(e.options.numberOfMonths=2,e.options.numberOfColumns=2)}var c=function(t){var n=t.touches[0];e.xTouchDown=n.clientX,e.yTouchDown=n.clientY},s=function(t){if(e.xTouchDown&&e.yTouchDown){var n=t.touches[0].clientX,r=t.touches[0].clientY,i=e.xTouchDown-n,o=e.yTouchDown-r,a=Math.abs(i)>Math.abs(o),l=e.options.numberOfMonths,c=null,s=!1,u="",d=Array.from(e.ui.querySelectorAll(".month-item"));if(a){var p=e.DateTime(e.ui.querySelector(".day-item").dataset.time),f=Number("".concat(1-Math.abs(i)/100)),m=0;if(i>0){m=-Math.abs(i),c=p.clone().add(l,"month");var h=e.options.maxDate;s=!h||c.isSameOrBefore(e.DateTime(h),"month"),u="next"}else{m=Math.abs(i),c=p.clone().subtract(l,"month");var b=e.options.minDate;s=!b||c.isSameOrAfter(e.DateTime(b),"month"),u="prev"}s&&d.map((function(e){e.style.opacity=f,e.style.transform="translateX(".concat(m,"px)")}))}Math.abs(i)+Math.abs(o)>100&&a&&c&&s&&(e.touchTargetMonth=u,e.gotoDate(c))}},u=function(t){e.touchTargetMonth||Array.from(e.ui.querySelectorAll(".month-item")).map((function(e){e.style.transform="translateX(0px)",e.style.opacity=1}));e.xTouchDown=null,e.yTouchDown=null};e.backdrop=document.createElement("div"),e.backdrop.className="litepicker-backdrop",e.backdrop.addEventListener("click",e.hide()),t.element&&t.element.parentNode&&t.element.parentNode.appendChild(e.backdrop),window.addEventListener("orientationchange",(function(n){window.addEventListener("resize",(function n(){if(o()&&e.isShowning()){var r=a();switch(r){case"landscape":t.numberOfMonths=2,t.numberOfColumns=2;break;default:t.numberOfMonths=1,t.numberOfColumns=1}e.ui.classList.toggle("mobilefriendly-portrait","portrait"===r),e.ui.classList.toggle("mobilefriendly-landscape","landscape"===r),e.render()}window.removeEventListener("resize",n)}))})),t.inlineMode&&o()&&(window.dispatchEvent(new Event("orientationchange")),window.dispatchEvent(new Event("resize"))),e.on("before:show",(function(t){if(e.triggerElement=t,!e.options.inlineMode&&o()){e.emit("mobilefriendly.before:show",t),e.ui.style.position="fixed",e.ui.style.display="block",l(),e.scrollToDate(t),e.render();var n=a();e.ui.classList.add("mobilefriendly"),e.ui.classList.toggle("mobilefriendly-portrait","portrait"===n),e.ui.classList.toggle("mobilefriendly-landscape","landscape"===n),e.ui.style.top="50%",e.ui.style.left="50%",e.ui.style.right=null,e.ui.style.bottom=null,e.ui.style.zIndex=e.options.zIndex,e.backdrop.style.display="block",e.backdrop.style.zIndex=e.options.zIndex-1,document.body.classList.add("litepicker-open"),(t||e.options.element).blur(),e.emit("mobilefriendly.show",t)}else o()&&(l(),e.render())})),e.on("render",(function(t){e.touchTargetMonth&&Array.from(e.ui.querySelectorAll(".month-item")).map((function(t){return t.classList.add("touch-target-".concat(e.touchTargetMonth))}));e.touchTargetMonth=null})),e.on("hide",(function(){document.body.classList.remove("litepicker-open"),e.backdrop.style.display="none",e.ui.classList.remove("mobilefriendly","mobilefriendly-portrait","mobilefriendly-landscape")})),e.on("destroy",(function(){e.backdrop&&e.backdrop.parentNode&&e.backdrop.parentNode.removeChild(e.backdrop)})),e.ui.addEventListener("touchstart",c,!!n&&{passive:!0}),e.ui.addEventListener("touchmove",s,!!n&&{passive:!0}),e.ui.addEventListener("touchend",u,!!n&&{passive:!0})}})},function(e,t,n){var r=n(7);"string"==typeof r&&(r=[[e.i,r,""]]);var i={insert:function(e){var t=document.querySelector("head"),n=window._lastElementInsertedByStyleLoader;window.disableLitepickerStyles||(n?n.nextSibling?t.insertBefore(e,n.nextSibling):t.appendChild(e):t.insertBefore(e,t.firstChild),window._lastElementInsertedByStyleLoader=e)},singleton:!1};n(1)(r,i);r.locals&&(e.exports=r.locals)},function(e,t,n){(t=n(0)(!1)).push([e.i,':root {\n  --litepicker-mobilefriendly-backdrop-color-bg: #000;\n}\n\n.litepicker-backdrop {\n  display: none;\n  background-color: var(--litepicker-mobilefriendly-backdrop-color-bg);\n  opacity: 0.3;\n  position: fixed;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n}\n\n.litepicker-open {\n  overflow: hidden;\n}\n\n.litepicker.mobilefriendly[data-plugins*="mobilefriendly"] {\n  transform: translate(-50%, -50%);\n  font-size: 1.1rem;\n  --litepicker-container-months-box-shadow-color: #616161;\n}\n.litepicker.mobilefriendly-portrait {\n  --litepicker-day-width: 13.5vw;\n  --litepicker-month-width: calc(var(--litepicker-day-width) * 7);\n}\n.litepicker.mobilefriendly-landscape {\n  --litepicker-day-width: 5.5vw;\n  --litepicker-month-width: calc(var(--litepicker-day-width) * 7);\n}\n\n.litepicker[data-plugins*="mobilefriendly"] .container__months {\n  overflow: hidden;\n}\n\n.litepicker.mobilefriendly[data-plugins*="mobilefriendly"] .container__months .month-item-header {\n  height: var(--litepicker-day-width);\n}\n\n.litepicker.mobilefriendly[data-plugins*="mobilefriendly"] .container__days > div {\n  height: var(--litepicker-day-width);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n\n.litepicker[data-plugins*="mobilefriendly"] .container__months .month-item {\n  transform-origin: center;\n}\n\n.litepicker[data-plugins*="mobilefriendly"] .container__months .month-item.touch-target-next {\n  animation-name: lp-bounce-target-next;\n  animation-duration: .5s;\n  animation-timing-function: ease;\n}\n\n.litepicker[data-plugins*="mobilefriendly"] .container__months .month-item.touch-target-prev {\n  animation-name: lp-bounce-target-prev;\n  animation-duration: .5s;\n  animation-timing-function: ease;\n}\n\n@keyframes lp-bounce-target-next {\n  from {\n    transform: translateX(100px) scale(0.5);\n  }\n  to {\n    transform: translateX(0px) scale(1);\n  }\n}\n\n@keyframes lp-bounce-target-prev {\n  from {\n    transform: translateX(-100px) scale(0.5);\n  }\n  to {\n    transform: translateX(0px) scale(1);\n  }\n}',""]),e.exports=t}]);

/***/ }),

/***/ "./assets/sass/_app.scss":
/*!*******************************!*\
  !*** ./assets/sass/_app.scss ***!
  \*******************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./node_modules/tom-select/dist/js/tom-select.complete.js":
/*!****************************************************************!*\
  !*** ./node_modules/tom-select/dist/js/tom-select.complete.js ***!
  \****************************************************************/
/***/ (function(module) {

/**
* Tom Select v2.2.2
* Licensed under the Apache License, Version 2.0 (the "License");
*/

(function (global, factory) {
	 true ? module.exports = factory() :
	0;
})(this, (function () { 'use strict';

	/**
	 * MicroEvent - to make any js object an event emitter
	 *
	 * - pure javascript - server compatible, browser compatible
	 * - dont rely on the browser doms
	 * - super simple - you get it immediatly, no mistery, no magic involved
	 *
	 * @author Jerome Etienne (https://github.com/jeromeetienne)
	 */

	/**
	 * Execute callback for each event in space separated list of event names
	 *
	 */
	function forEvents(events, callback) {
	  events.split(/\s+/).forEach(event => {
	    callback(event);
	  });
	}

	class MicroEvent {
	  constructor() {
	    this._events = void 0;
	    this._events = {};
	  }

	  on(events, fct) {
	    forEvents(events, event => {
	      const event_array = this._events[event] || [];
	      event_array.push(fct);
	      this._events[event] = event_array;
	    });
	  }

	  off(events, fct) {
	    var n = arguments.length;

	    if (n === 0) {
	      this._events = {};
	      return;
	    }

	    forEvents(events, event => {
	      if (n === 1) {
	        delete this._events[event];
	        return;
	      }

	      const event_array = this._events[event];
	      if (event_array === undefined) return;
	      event_array.splice(event_array.indexOf(fct), 1);
	      this._events[event] = event_array;
	    });
	  }

	  trigger(events, ...args) {
	    var self = this;
	    forEvents(events, event => {
	      const event_array = self._events[event];
	      if (event_array === undefined) return;
	      event_array.forEach(fct => {
	        fct.apply(self, args);
	      });
	    });
	  }

	}

	/**
	 * microplugin.js
	 * Copyright (c) 2013 Brian Reavis & contributors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
	 * file except in compliance with the License. You may obtain a copy of the License at:
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under
	 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
	 * ANY KIND, either express or implied. See the License for the specific language
	 * governing permissions and limitations under the License.
	 *
	 * @author Brian Reavis <brian@thirdroute.com>
	 */
	function MicroPlugin(Interface) {
	  Interface.plugins = {};
	  return class extends Interface {
	    constructor(...args) {
	      super(...args);
	      this.plugins = {
	        names: [],
	        settings: {},
	        requested: {},
	        loaded: {}
	      };
	    }

	    /**
	     * Registers a plugin.
	     *
	     * @param {function} fn
	     */
	    static define(name, fn) {
	      Interface.plugins[name] = {
	        'name': name,
	        'fn': fn
	      };
	    }
	    /**
	     * Initializes the listed plugins (with options).
	     * Acceptable formats:
	     *
	     * List (without options):
	     *   ['a', 'b', 'c']
	     *
	     * List (with options):
	     *   [{'name': 'a', options: {}}, {'name': 'b', options: {}}]
	     *
	     * Hash (with options):
	     *   {'a': { ... }, 'b': { ... }, 'c': { ... }}
	     *
	     * @param {array|object} plugins
	     */


	    initializePlugins(plugins) {
	      var key, name;
	      const self = this;
	      const queue = [];

	      if (Array.isArray(plugins)) {
	        plugins.forEach(plugin => {
	          if (typeof plugin === 'string') {
	            queue.push(plugin);
	          } else {
	            self.plugins.settings[plugin.name] = plugin.options;
	            queue.push(plugin.name);
	          }
	        });
	      } else if (plugins) {
	        for (key in plugins) {
	          if (plugins.hasOwnProperty(key)) {
	            self.plugins.settings[key] = plugins[key];
	            queue.push(key);
	          }
	        }
	      }

	      while (name = queue.shift()) {
	        self.require(name);
	      }
	    }

	    loadPlugin(name) {
	      var self = this;
	      var plugins = self.plugins;
	      var plugin = Interface.plugins[name];

	      if (!Interface.plugins.hasOwnProperty(name)) {
	        throw new Error('Unable to find "' + name + '" plugin');
	      }

	      plugins.requested[name] = true;
	      plugins.loaded[name] = plugin.fn.apply(self, [self.plugins.settings[name] || {}]);
	      plugins.names.push(name);
	    }
	    /**
	     * Initializes a plugin.
	     *
	     */


	    require(name) {
	      var self = this;
	      var plugins = self.plugins;

	      if (!self.plugins.loaded.hasOwnProperty(name)) {
	        if (plugins.requested[name]) {
	          throw new Error('Plugin has circular dependency ("' + name + '")');
	        }

	        self.loadPlugin(name);
	      }

	      return plugins.loaded[name];
	    }

	  };
	}

	/*! @orchidjs/unicode-variants | https://github.com/orchidjs/unicode-variants | Apache License (v2) */
	/**
	 * Convert array of strings to a regular expression
	 *	ex ['ab','a'] => (?:ab|a)
	 * 	ex ['a','b'] => [ab]
	 * @param {string[]} chars
	 * @return {string}
	 */
	const arrayToPattern = chars => {
	  chars = chars.filter(Boolean);

	  if (chars.length < 2) {
	    return chars[0] || '';
	  }

	  return maxValueLength(chars) == 1 ? '[' + chars.join('') + ']' : '(?:' + chars.join('|') + ')';
	};
	/**
	 * @param {string[]} array
	 * @return {string}
	 */

	const sequencePattern = array => {
	  if (!hasDuplicates(array)) {
	    return array.join('');
	  }

	  let pattern = '';
	  let prev_char_count = 0;

	  const prev_pattern = () => {
	    if (prev_char_count > 1) {
	      pattern += '{' + prev_char_count + '}';
	    }
	  };

	  array.forEach((char, i) => {
	    if (char === array[i - 1]) {
	      prev_char_count++;
	      return;
	    }

	    prev_pattern();
	    pattern += char;
	    prev_char_count = 1;
	  });
	  prev_pattern();
	  return pattern;
	};
	/**
	 * Convert array of strings to a regular expression
	 *	ex ['ab','a'] => (?:ab|a)
	 * 	ex ['a','b'] => [ab]
	 * @param {Set<string>} chars
	 * @return {string}
	 */

	const setToPattern = chars => {
	  let array = toArray(chars);
	  return arrayToPattern(array);
	};
	/**
	 *
	 * https://stackoverflow.com/questions/7376598/in-javascript-how-do-i-check-if-an-array-has-duplicate-values
	 * @param {any[]} array
	 */

	const hasDuplicates = array => {
	  return new Set(array).size !== array.length;
	};
	/**
	 * https://stackoverflow.com/questions/63006601/why-does-u-throw-an-invalid-escape-error
	 * @param {string} str
	 * @return {string}
	 */

	const escape_regex = str => {
	  return (str + '').replace(/([\$\(\)\*\+\.\?\[\]\^\{\|\}\\])/gu, '\\$1');
	};
	/**
	 * Return the max length of array values
	 * @param {string[]} array
	 *
	 */

	const maxValueLength = array => {
	  return array.reduce((longest, value) => Math.max(longest, unicodeLength(value)), 0);
	};
	/**
	 * @param {string} str
	 */

	const unicodeLength = str => {
	  return toArray(str).length;
	};
	/**
	 * @param {any} p
	 * @return {any[]}
	 */

	const toArray = p => Array.from(p);

	/*! @orchidjs/unicode-variants | https://github.com/orchidjs/unicode-variants | Apache License (v2) */
	/**
	 * Get all possible combinations of substrings that add up to the given string
	 * https://stackoverflow.com/questions/30169587/find-all-the-combination-of-substrings-that-add-up-to-the-given-string
	 * @param {string} input
	 * @return {string[][]}
	 */
	const allSubstrings = input => {
	  if (input.length === 1) return [[input]];
	  /** @type {string[][]} */

	  let result = [];
	  const start = input.substring(1);
	  const suba = allSubstrings(start);
	  suba.forEach(function (subresult) {
	    let tmp = subresult.slice(0);
	    tmp[0] = input.charAt(0) + tmp[0];
	    result.push(tmp);
	    tmp = subresult.slice(0);
	    tmp.unshift(input.charAt(0));
	    result.push(tmp);
	  });
	  return result;
	};

	/*! @orchidjs/unicode-variants | https://github.com/orchidjs/unicode-variants | Apache License (v2) */

	/**
	 * @typedef {{[key:string]:string}} TUnicodeMap
	 * @typedef {{[key:string]:Set<string>}} TUnicodeSets
	 * @typedef {[[number,number]]} TCodePoints
	 * @typedef {{folded:string,composed:string,code_point:number}} TCodePointObj
	 * @typedef {{start:number,end:number,length:number,substr:string}} TSequencePart
	 */
	/** @type {TCodePoints} */

	const code_points = [[0, 65535]];
	const accent_pat = '[\u0300-\u036F\u{b7}\u{2be}\u{2bc}]';
	/** @type {TUnicodeMap} */

	let unicode_map;
	/** @type {RegExp} */

	let multi_char_reg;
	const max_char_length = 3;
	/** @type {TUnicodeMap} */

	const latin_convert = {};
	/** @type {TUnicodeMap} */

	const latin_condensed = {
	  '/': '⁄∕',
	  '0': '߀',
	  "a": "ⱥɐɑ",
	  "aa": "ꜳ",
	  "ae": "æǽǣ",
	  "ao": "ꜵ",
	  "au": "ꜷ",
	  "av": "ꜹꜻ",
	  "ay": "ꜽ",
	  "b": "ƀɓƃ",
	  "c": "ꜿƈȼↄ",
	  "d": "đɗɖᴅƌꮷԁɦ",
	  "e": "ɛǝᴇɇ",
	  "f": "ꝼƒ",
	  "g": "ǥɠꞡᵹꝿɢ",
	  "h": "ħⱨⱶɥ",
	  "i": "ɨı",
	  "j": "ɉȷ",
	  "k": "ƙⱪꝁꝃꝅꞣ",
	  "l": "łƚɫⱡꝉꝇꞁɭ",
	  "m": "ɱɯϻ",
	  "n": "ꞥƞɲꞑᴎлԉ",
	  "o": "øǿɔɵꝋꝍᴑ",
	  "oe": "œ",
	  "oi": "ƣ",
	  "oo": "ꝏ",
	  "ou": "ȣ",
	  "p": "ƥᵽꝑꝓꝕρ",
	  "q": "ꝗꝙɋ",
	  "r": "ɍɽꝛꞧꞃ",
	  "s": "ßȿꞩꞅʂ",
	  "t": "ŧƭʈⱦꞇ",
	  "th": "þ",
	  "tz": "ꜩ",
	  "u": "ʉ",
	  "v": "ʋꝟʌ",
	  "vy": "ꝡ",
	  "w": "ⱳ",
	  "y": "ƴɏỿ",
	  "z": "ƶȥɀⱬꝣ",
	  "hv": "ƕ"
	};

	for (let latin in latin_condensed) {
	  let unicode = latin_condensed[latin] || '';

	  for (let i = 0; i < unicode.length; i++) {
	    let char = unicode.substring(i, i + 1);
	    latin_convert[char] = latin;
	  }
	}

	const convert_pat = new RegExp(Object.keys(latin_convert).join('|') + '|' + accent_pat, 'gu');
	/**
	 * Initialize the unicode_map from the give code point ranges
	 *
	 * @param {TCodePoints=} _code_points
	 */

	const initialize = _code_points => {
	  if (unicode_map !== undefined) return;
	  unicode_map = generateMap(_code_points || code_points);
	};
	/**
	 * Helper method for normalize a string
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize
	 * @param {string} str
	 * @param {string} form
	 */

	const normalize = (str, form = 'NFKD') => str.normalize(form);
	/**
	 * Remove accents without reordering string
	 * calling str.normalize('NFKD') on \u{594}\u{595}\u{596} becomes \u{596}\u{594}\u{595}
	 * via https://github.com/krisk/Fuse/issues/133#issuecomment-318692703
	 * @param {string} str
	 * @return {string}
	 */

	const asciifold = str => {
	  return toArray(str).reduce(
	  /**
	   * @param {string} result
	   * @param {string} char
	   */
	  (result, char) => {
	    return result + _asciifold(char);
	  }, '');
	};
	/**
	 * @param {string} str
	 * @return {string}
	 */

	const _asciifold = str => {
	  str = normalize(str).toLowerCase().replace(convert_pat, (
	  /** @type {string} */
	  char) => {
	    return latin_convert[char] || '';
	  }); //return str;

	  return normalize(str, 'NFC');
	};
	/**
	 * Generate a list of unicode variants from the list of code points
	 * @param {TCodePoints} code_points
	 * @yield {TCodePointObj}
	 */

	function* generator(code_points) {
	  for (const [code_point_min, code_point_max] of code_points) {
	    for (let i = code_point_min; i <= code_point_max; i++) {
	      let composed = String.fromCharCode(i);
	      let folded = asciifold(composed);

	      if (folded == composed.toLowerCase()) {
	        continue;
	      } // skip when folded is a string longer than 3 characters long
	      // bc the resulting regex patterns will be long
	      // eg:
	      // folded صلى الله عليه وسلم length 18 code point 65018
	      // folded جل جلاله length 8 code point 65019


	      if (folded.length > max_char_length) {
	        continue;
	      }

	      if (folded.length == 0) {
	        continue;
	      }

	      yield {
	        folded: folded,
	        composed: composed,
	        code_point: i
	      };
	    }
	  }
	}
	/**
	 * Generate a unicode map from the list of code points
	 * @param {TCodePoints} code_points
	 * @return {TUnicodeSets}
	 */

	const generateSets = code_points => {
	  /** @type {{[key:string]:Set<string>}} */
	  const unicode_sets = {};
	  /**
	   * @param {string} folded
	   * @param {string} to_add
	   */

	  const addMatching = (folded, to_add) => {
	    /** @type {Set<string>} */
	    const folded_set = unicode_sets[folded] || new Set();
	    const patt = new RegExp('^' + setToPattern(folded_set) + '$', 'iu');

	    if (to_add.match(patt)) {
	      return;
	    }

	    folded_set.add(escape_regex(to_add));
	    unicode_sets[folded] = folded_set;
	  };

	  for (let value of generator(code_points)) {
	    addMatching(value.folded, value.folded);
	    addMatching(value.folded, value.composed);
	  }

	  return unicode_sets;
	};
	/**
	 * Generate a unicode map from the list of code points
	 * ae => (?:(?:ae|Æ|Ǽ|Ǣ)|(?:A|Ⓐ|Ａ...)(?:E|ɛ|Ⓔ...))
	 *
	 * @param {TCodePoints} code_points
	 * @return {TUnicodeMap}
	 */

	const generateMap = code_points => {
	  /** @type {TUnicodeSets} */
	  const unicode_sets = generateSets(code_points);
	  /** @type {TUnicodeMap} */

	  const unicode_map = {};
	  /** @type {string[]} */

	  let multi_char = [];

	  for (let folded in unicode_sets) {
	    let set = unicode_sets[folded];

	    if (set) {
	      unicode_map[folded] = setToPattern(set);
	    }

	    if (folded.length > 1) {
	      multi_char.push(escape_regex(folded));
	    }
	  }

	  multi_char.sort((a, b) => b.length - a.length);
	  const multi_char_patt = arrayToPattern(multi_char);
	  multi_char_reg = new RegExp('^' + multi_char_patt, 'u');
	  return unicode_map;
	};
	/**
	 * Map each element of an array from it's folded value to all possible unicode matches
	 * @param {string[]} strings
	 * @param {number} min_replacement
	 * @return {string}
	 */

	const mapSequence = (strings, min_replacement = 1) => {
	  let chars_replaced = 0;
	  strings = strings.map(str => {
	    if (unicode_map[str]) {
	      chars_replaced += str.length;
	    }

	    return unicode_map[str] || str;
	  });

	  if (chars_replaced >= min_replacement) {
	    return sequencePattern(strings);
	  }

	  return '';
	};
	/**
	 * Convert a short string and split it into all possible patterns
	 * Keep a pattern only if min_replacement is met
	 *
	 * 'abc'
	 * 		=> [['abc'],['ab','c'],['a','bc'],['a','b','c']]
	 *		=> ['abc-pattern','ab-c-pattern'...]
	 *
	 *
	 * @param {string} str
	 * @param {number} min_replacement
	 * @return {string}
	 */

	const substringsToPattern = (str, min_replacement = 1) => {
	  min_replacement = Math.max(min_replacement, str.length - 1);
	  return arrayToPattern(allSubstrings(str).map(sub_pat => {
	    return mapSequence(sub_pat, min_replacement);
	  }));
	};
	/**
	 * Convert an array of sequences into a pattern
	 * [{start:0,end:3,length:3,substr:'iii'}...] => (?:iii...)
	 *
	 * @param {Sequence[]} sequences
	 * @param {boolean} all
	 */

	const sequencesToPattern = (sequences, all = true) => {
	  let min_replacement = sequences.length > 1 ? 1 : 0;
	  return arrayToPattern(sequences.map(sequence => {
	    let seq = [];
	    const len = all ? sequence.length() : sequence.length() - 1;

	    for (let j = 0; j < len; j++) {
	      seq.push(substringsToPattern(sequence.substrs[j] || '', min_replacement));
	    }

	    return sequencePattern(seq);
	  }));
	};
	/**
	 * Return true if the sequence is already in the sequences
	 * @param {Sequence} needle_seq
	 * @param {Sequence[]} sequences
	 */


	const inSequences = (needle_seq, sequences) => {
	  for (const seq of sequences) {
	    if (seq.start != needle_seq.start || seq.end != needle_seq.end) {
	      continue;
	    }

	    if (seq.substrs.join('') !== needle_seq.substrs.join('')) {
	      continue;
	    }

	    let needle_parts = needle_seq.parts;
	    /**
	     * @param {TSequencePart} part
	     */

	    const filter = part => {
	      for (const needle_part of needle_parts) {
	        if (needle_part.start === part.start && needle_part.substr === part.substr) {
	          return false;
	        }

	        if (part.length == 1 || needle_part.length == 1) {
	          continue;
	        } // check for overlapping parts
	        // a = ['::=','==']
	        // b = ['::','===']
	        // a = ['r','sm']
	        // b = ['rs','m']


	        if (part.start < needle_part.start && part.end > needle_part.start) {
	          return true;
	        }

	        if (needle_part.start < part.start && needle_part.end > part.start) {
	          return true;
	        }
	      }

	      return false;
	    };

	    let filtered = seq.parts.filter(filter);

	    if (filtered.length > 0) {
	      continue;
	    }

	    return true;
	  }

	  return false;
	};

	class Sequence {
	  constructor() {
	    /** @type {TSequencePart[]} */
	    this.parts = [];
	    /** @type {string[]} */

	    this.substrs = [];
	    this.start = 0;
	    this.end = 0;
	  }
	  /**
	   * @param {TSequencePart|undefined} part
	   */


	  add(part) {
	    if (part) {
	      this.parts.push(part);
	      this.substrs.push(part.substr);
	      this.start = Math.min(part.start, this.start);
	      this.end = Math.max(part.end, this.end);
	    }
	  }

	  last() {
	    return this.parts[this.parts.length - 1];
	  }

	  length() {
	    return this.parts.length;
	  }
	  /**
	   * @param {number} position
	   * @param {TSequencePart} last_piece
	   */


	  clone(position, last_piece) {
	    let clone = new Sequence();
	    let parts = JSON.parse(JSON.stringify(this.parts));
	    let last_part = parts.pop();

	    for (const part of parts) {
	      clone.add(part);
	    }

	    let last_substr = last_piece.substr.substring(0, position - last_part.start);
	    let clone_last_len = last_substr.length;
	    clone.add({
	      start: last_part.start,
	      end: last_part.start + clone_last_len,
	      length: clone_last_len,
	      substr: last_substr
	    });
	    return clone;
	  }

	}
	/**
	 * Expand a regular expression pattern to include unicode variants
	 * 	eg /a/ becomes /aⓐａẚàáâầấẫẩãāăằắẵẳȧǡäǟảåǻǎȁȃạậặḁąⱥɐɑAⒶＡÀÁÂẦẤẪẨÃĀĂẰẮẴẲȦǠÄǞẢÅǺǍȀȂẠẬẶḀĄȺⱯ/
	 *
	 * Issue:
	 *  ﺊﺋ [ 'ﺊ = \\u{fe8a}', 'ﺋ = \\u{fe8b}' ]
	 *	becomes:	ئئ [ 'ي = \\u{64a}', 'ٔ = \\u{654}', 'ي = \\u{64a}', 'ٔ = \\u{654}' ]
	 *
	 *	İĲ = IIJ = ⅡJ
	 *
	 * 	1/2/4
	 *
	 * @param {string} str
	 * @return {string|undefined}
	 */


	const getPattern = str => {
	  initialize();
	  str = asciifold(str);
	  let pattern = '';
	  let sequences = [new Sequence()];

	  for (let i = 0; i < str.length; i++) {
	    let substr = str.substring(i);
	    let match = substr.match(multi_char_reg);
	    const char = str.substring(i, i + 1);
	    const match_str = match ? match[0] : null; // loop through sequences
	    // add either the char or multi_match

	    let overlapping = [];
	    let added_types = new Set();

	    for (const sequence of sequences) {
	      const last_piece = sequence.last();

	      if (!last_piece || last_piece.length == 1 || last_piece.end <= i) {
	        // if we have a multi match
	        if (match_str) {
	          const len = match_str.length;
	          sequence.add({
	            start: i,
	            end: i + len,
	            length: len,
	            substr: match_str
	          });
	          added_types.add('1');
	        } else {
	          sequence.add({
	            start: i,
	            end: i + 1,
	            length: 1,
	            substr: char
	          });
	          added_types.add('2');
	        }
	      } else if (match_str) {
	        let clone = sequence.clone(i, last_piece);
	        const len = match_str.length;
	        clone.add({
	          start: i,
	          end: i + len,
	          length: len,
	          substr: match_str
	        });
	        overlapping.push(clone);
	      } else {
	        // don't add char
	        // adding would create invalid patterns: 234 => [2,34,4]
	        added_types.add('3');
	      }
	    } // if we have overlapping


	    if (overlapping.length > 0) {
	      // ['ii','iii'] before ['i','i','iii']
	      overlapping = overlapping.sort((a, b) => {
	        return a.length() - b.length();
	      });

	      for (let clone of overlapping) {
	        // don't add if we already have an equivalent sequence
	        if (inSequences(clone, sequences)) {
	          continue;
	        }

	        sequences.push(clone);
	      }

	      continue;
	    } // if we haven't done anything unique
	    // clean up the patterns
	    // helps keep patterns smaller
	    // if str = 'r₨㎧aarss', pattern will be 446 instead of 655


	    if (i > 0 && added_types.size == 1 && !added_types.has('3')) {
	      pattern += sequencesToPattern(sequences, false);
	      let new_seq = new Sequence();
	      const old_seq = sequences[0];

	      if (old_seq) {
	        new_seq.add(old_seq.last());
	      }

	      sequences = [new_seq];
	    }
	  }

	  pattern += sequencesToPattern(sequences, true);
	  return pattern;
	};

	/*! sifter.js | https://github.com/orchidjs/sifter.js | Apache License (v2) */

	/**
	 * A property getter resolving dot-notation
	 * @param  {Object}  obj     The root object to fetch property on
	 * @param  {String}  name    The optionally dotted property name to fetch
	 * @return {Object}          The resolved property value
	 */
	const getAttr = (obj, name) => {
	  if (!obj) return;
	  return obj[name];
	};
	/**
	 * A property getter resolving dot-notation
	 * @param  {Object}  obj     The root object to fetch property on
	 * @param  {String}  name    The optionally dotted property name to fetch
	 * @return {Object}          The resolved property value
	 */

	const getAttrNesting = (obj, name) => {
	  if (!obj) return;
	  var part,
	      names = name.split(".");

	  while ((part = names.shift()) && (obj = obj[part]));

	  return obj;
	};
	/**
	 * Calculates how close of a match the
	 * given value is against a search token.
	 *
	 */

	const scoreValue = (value, token, weight) => {
	  var score, pos;
	  if (!value) return 0;
	  value = value + '';
	  if (token.regex == null) return 0;
	  pos = value.search(token.regex);
	  if (pos === -1) return 0;
	  score = token.string.length / value.length;
	  if (pos === 0) score += 0.5;
	  return score * weight;
	};
	/**
	 * Cast object property to an array if it exists and has a value
	 *
	 */

	const propToArray = (obj, key) => {
	  var value = obj[key];
	  if (typeof value == 'function') return value;

	  if (value && !Array.isArray(value)) {
	    obj[key] = [value];
	  }
	};
	/**
	 * Iterates over arrays and hashes.
	 *
	 * ```
	 * iterate(this.items, function(item, id) {
	 *    // invoked for each item
	 * });
	 * ```
	 *
	 */

	const iterate$1 = (object, callback) => {
	  if (Array.isArray(object)) {
	    object.forEach(callback);
	  } else {
	    for (var key in object) {
	      if (object.hasOwnProperty(key)) {
	        callback(object[key], key);
	      }
	    }
	  }
	};
	const cmp = (a, b) => {
	  if (typeof a === 'number' && typeof b === 'number') {
	    return a > b ? 1 : a < b ? -1 : 0;
	  }

	  a = asciifold(a + '').toLowerCase();
	  b = asciifold(b + '').toLowerCase();
	  if (a > b) return 1;
	  if (b > a) return -1;
	  return 0;
	};

	/*! sifter.js | https://github.com/orchidjs/sifter.js | Apache License (v2) */

	/**
	 * sifter.js
	 * Copyright (c) 2013–2020 Brian Reavis & contributors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
	 * file except in compliance with the License. You may obtain a copy of the License at:
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under
	 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
	 * ANY KIND, either express or implied. See the License for the specific language
	 * governing permissions and limitations under the License.
	 *
	 * @author Brian Reavis <brian@thirdroute.com>
	 */

	class Sifter {
	  // []|{};

	  /**
	   * Textually searches arrays and hashes of objects
	   * by property (or multiple properties). Designed
	   * specifically for autocomplete.
	   *
	   */
	  constructor(items, settings) {
	    this.items = void 0;
	    this.settings = void 0;
	    this.items = items;
	    this.settings = settings || {
	      diacritics: true
	    };
	  }

	  /**
	   * Splits a search string into an array of individual
	   * regexps to be used to match results.
	   *
	   */
	  tokenize(query, respect_word_boundaries, weights) {
	    if (!query || !query.length) return [];
	    const tokens = [];
	    const words = query.split(/\s+/);
	    var field_regex;

	    if (weights) {
	      field_regex = new RegExp('^(' + Object.keys(weights).map(escape_regex).join('|') + ')\:(.*)$');
	    }

	    words.forEach(word => {
	      let field_match;
	      let field = null;
	      let regex = null; // look for "field:query" tokens

	      if (field_regex && (field_match = word.match(field_regex))) {
	        field = field_match[1];
	        word = field_match[2];
	      }

	      if (word.length > 0) {
	        if (this.settings.diacritics) {
	          regex = getPattern(word) || null;
	        } else {
	          regex = escape_regex(word);
	        }

	        if (regex && respect_word_boundaries) regex = "\\b" + regex;
	      }

	      tokens.push({
	        string: word,
	        regex: regex ? new RegExp(regex, 'iu') : null,
	        field: field
	      });
	    });
	    return tokens;
	  }

	  /**
	   * Returns a function to be used to score individual results.
	   *
	   * Good matches will have a higher score than poor matches.
	   * If an item is not a match, 0 will be returned by the function.
	   *
	   * @returns {T.ScoreFn}
	   */
	  getScoreFunction(query, options) {
	    var search = this.prepareSearch(query, options);
	    return this._getScoreFunction(search);
	  }
	  /**
	   * @returns {T.ScoreFn}
	   *
	   */


	  _getScoreFunction(search) {
	    const tokens = search.tokens,
	          token_count = tokens.length;

	    if (!token_count) {
	      return function () {
	        return 0;
	      };
	    }

	    const fields = search.options.fields,
	          weights = search.weights,
	          field_count = fields.length,
	          getAttrFn = search.getAttrFn;

	    if (!field_count) {
	      return function () {
	        return 1;
	      };
	    }
	    /**
	     * Calculates the score of an object
	     * against the search query.
	     *
	     */


	    const scoreObject = function () {
	      if (field_count === 1) {
	        return function (token, data) {
	          const field = fields[0].field;
	          return scoreValue(getAttrFn(data, field), token, weights[field] || 1);
	        };
	      }

	      return function (token, data) {
	        var sum = 0; // is the token specific to a field?

	        if (token.field) {
	          const value = getAttrFn(data, token.field);

	          if (!token.regex && value) {
	            sum += 1 / field_count;
	          } else {
	            sum += scoreValue(value, token, 1);
	          }
	        } else {
	          iterate$1(weights, (weight, field) => {
	            sum += scoreValue(getAttrFn(data, field), token, weight);
	          });
	        }

	        return sum / field_count;
	      };
	    }();

	    if (token_count === 1) {
	      return function (data) {
	        return scoreObject(tokens[0], data);
	      };
	    }

	    if (search.options.conjunction === 'and') {
	      return function (data) {
	        var score,
	            sum = 0;

	        for (let token of tokens) {
	          score = scoreObject(token, data);
	          if (score <= 0) return 0;
	          sum += score;
	        }

	        return sum / token_count;
	      };
	    } else {
	      return function (data) {
	        var sum = 0;
	        iterate$1(tokens, token => {
	          sum += scoreObject(token, data);
	        });
	        return sum / token_count;
	      };
	    }
	  }

	  /**
	   * Returns a function that can be used to compare two
	   * results, for sorting purposes. If no sorting should
	   * be performed, `null` will be returned.
	   *
	   * @return function(a,b)
	   */
	  getSortFunction(query, options) {
	    var search = this.prepareSearch(query, options);
	    return this._getSortFunction(search);
	  }

	  _getSortFunction(search) {
	    var implicit_score,
	        sort_flds = [];
	    const self = this,
	          options = search.options,
	          sort = !search.query && options.sort_empty ? options.sort_empty : options.sort;

	    if (typeof sort == 'function') {
	      return sort.bind(this);
	    }
	    /**
	     * Fetches the specified sort field value
	     * from a search result item.
	     *
	     */


	    const get_field = function get_field(name, result) {
	      if (name === '$score') return result.score;
	      return search.getAttrFn(self.items[result.id], name);
	    }; // parse options


	    if (sort) {
	      for (let s of sort) {
	        if (search.query || s.field !== '$score') {
	          sort_flds.push(s);
	        }
	      }
	    } // the "$score" field is implied to be the primary
	    // sort field, unless it's manually specified


	    if (search.query) {
	      implicit_score = true;

	      for (let fld of sort_flds) {
	        if (fld.field === '$score') {
	          implicit_score = false;
	          break;
	        }
	      }

	      if (implicit_score) {
	        sort_flds.unshift({
	          field: '$score',
	          direction: 'desc'
	        });
	      } // without a search.query, all items will have the same score

	    } else {
	      sort_flds = sort_flds.filter(fld => fld.field !== '$score');
	    } // build function


	    const sort_flds_count = sort_flds.length;

	    if (!sort_flds_count) {
	      return null;
	    }

	    return function (a, b) {
	      var result, field;

	      for (let sort_fld of sort_flds) {
	        field = sort_fld.field;
	        let multiplier = sort_fld.direction === 'desc' ? -1 : 1;
	        result = multiplier * cmp(get_field(field, a), get_field(field, b));
	        if (result) return result;
	      }

	      return 0;
	    };
	  }

	  /**
	   * Parses a search query and returns an object
	   * with tokens and fields ready to be populated
	   * with results.
	   *
	   */
	  prepareSearch(query, optsUser) {
	    const weights = {};
	    var options = Object.assign({}, optsUser);
	    propToArray(options, 'sort');
	    propToArray(options, 'sort_empty'); // convert fields to new format

	    if (options.fields) {
	      propToArray(options, 'fields');
	      const fields = [];
	      options.fields.forEach(field => {
	        if (typeof field == 'string') {
	          field = {
	            field: field,
	            weight: 1
	          };
	        }

	        fields.push(field);
	        weights[field.field] = 'weight' in field ? field.weight : 1;
	      });
	      options.fields = fields;
	    }

	    return {
	      options: options,
	      query: query.toLowerCase().trim(),
	      tokens: this.tokenize(query, options.respect_word_boundaries, weights),
	      total: 0,
	      items: [],
	      weights: weights,
	      getAttrFn: options.nesting ? getAttrNesting : getAttr
	    };
	  }

	  /**
	   * Searches through all items and returns a sorted array of matches.
	   *
	   */
	  search(query, options) {
	    var self = this,
	        score,
	        search;
	    search = this.prepareSearch(query, options);
	    options = search.options;
	    query = search.query; // generate result scoring function

	    const fn_score = options.score || self._getScoreFunction(search); // perform search and sort


	    if (query.length) {
	      iterate$1(self.items, (item, id) => {
	        score = fn_score(item);

	        if (options.filter === false || score > 0) {
	          search.items.push({
	            'score': score,
	            'id': id
	          });
	        }
	      });
	    } else {
	      iterate$1(self.items, (_, id) => {
	        search.items.push({
	          'score': 1,
	          'id': id
	        });
	      });
	    }

	    const fn_sort = self._getSortFunction(search);

	    if (fn_sort) search.items.sort(fn_sort); // apply limits

	    search.total = search.items.length;

	    if (typeof options.limit === 'number') {
	      search.items = search.items.slice(0, options.limit);
	    }

	    return search;
	  }

	}

	/**
	 * Iterates over arrays and hashes.
	 *
	 * ```
	 * iterate(this.items, function(item, id) {
	 *    // invoked for each item
	 * });
	 * ```
	 *
	 */

	const iterate = (object, callback) => {
	  if (Array.isArray(object)) {
	    object.forEach(callback);
	  } else {
	    for (var key in object) {
	      if (object.hasOwnProperty(key)) {
	        callback(object[key], key);
	      }
	    }
	  }
	};

	/**
	 * Return a dom element from either a dom query string, jQuery object, a dom element or html string
	 * https://stackoverflow.com/questions/494143/creating-a-new-dom-element-from-an-html-string-using-built-in-dom-methods-or-pro/35385518#35385518
	 *
	 * param query should be {}
	 */

	const getDom = query => {
	  if (query.jquery) {
	    return query[0];
	  }

	  if (query instanceof HTMLElement) {
	    return query;
	  }

	  if (isHtmlString(query)) {
	    var tpl = document.createElement('template');
	    tpl.innerHTML = query.trim(); // Never return a text node of whitespace as the result

	    return tpl.content.firstChild;
	  }

	  return document.querySelector(query);
	};
	const isHtmlString = arg => {
	  if (typeof arg === 'string' && arg.indexOf('<') > -1) {
	    return true;
	  }

	  return false;
	};
	const escapeQuery = query => {
	  return query.replace(/['"\\]/g, '\\$&');
	};
	/**
	 * Dispatch an event
	 *
	 */

	const triggerEvent = (dom_el, event_name) => {
	  var event = document.createEvent('HTMLEvents');
	  event.initEvent(event_name, true, false);
	  dom_el.dispatchEvent(event);
	};
	/**
	 * Apply CSS rules to a dom element
	 *
	 */

	const applyCSS = (dom_el, css) => {
	  Object.assign(dom_el.style, css);
	};
	/**
	 * Add css classes
	 *
	 */

	const addClasses = (elmts, ...classes) => {
	  var norm_classes = classesArray(classes);
	  elmts = castAsArray(elmts);
	  elmts.map(el => {
	    norm_classes.map(cls => {
	      el.classList.add(cls);
	    });
	  });
	};
	/**
	 * Remove css classes
	 *
	 */

	const removeClasses = (elmts, ...classes) => {
	  var norm_classes = classesArray(classes);
	  elmts = castAsArray(elmts);
	  elmts.map(el => {
	    norm_classes.map(cls => {
	      el.classList.remove(cls);
	    });
	  });
	};
	/**
	 * Return arguments
	 *
	 */

	const classesArray = args => {
	  var classes = [];
	  iterate(args, _classes => {
	    if (typeof _classes === 'string') {
	      _classes = _classes.trim().split(/[\11\12\14\15\40]/);
	    }

	    if (Array.isArray(_classes)) {
	      classes = classes.concat(_classes);
	    }
	  });
	  return classes.filter(Boolean);
	};
	/**
	 * Create an array from arg if it's not already an array
	 *
	 */

	const castAsArray = arg => {
	  if (!Array.isArray(arg)) {
	    arg = [arg];
	  }

	  return arg;
	};
	/**
	 * Get the closest node to the evt.target matching the selector
	 * Stops at wrapper
	 *
	 */

	const parentMatch = (target, selector, wrapper) => {
	  if (wrapper && !wrapper.contains(target)) {
	    return;
	  }

	  while (target && target.matches) {
	    if (target.matches(selector)) {
	      return target;
	    }

	    target = target.parentNode;
	  }
	};
	/**
	 * Get the first or last item from an array
	 *
	 * > 0 - right (last)
	 * <= 0 - left (first)
	 *
	 */

	const getTail = (list, direction = 0) => {
	  if (direction > 0) {
	    return list[list.length - 1];
	  }

	  return list[0];
	};
	/**
	 * Return true if an object is empty
	 *
	 */

	const isEmptyObject = obj => {
	  return Object.keys(obj).length === 0;
	};
	/**
	 * Get the index of an element amongst sibling nodes of the same type
	 *
	 */

	const nodeIndex = (el, amongst) => {
	  if (!el) return -1;
	  amongst = amongst || el.nodeName;
	  var i = 0;

	  while (el = el.previousElementSibling) {
	    if (el.matches(amongst)) {
	      i++;
	    }
	  }

	  return i;
	};
	/**
	 * Set attributes of an element
	 *
	 */

	const setAttr = (el, attrs) => {
	  iterate(attrs, (val, attr) => {
	    if (val == null) {
	      el.removeAttribute(attr);
	    } else {
	      el.setAttribute(attr, '' + val);
	    }
	  });
	};
	/**
	 * Replace a node
	 */

	const replaceNode = (existing, replacement) => {
	  if (existing.parentNode) existing.parentNode.replaceChild(replacement, existing);
	};

	/**
	 * highlight v3 | MIT license | Johann Burkard <jb@eaio.com>
	 * Highlights arbitrary terms in a node.
	 *
	 * - Modified by Marshal <beatgates@gmail.com> 2011-6-24 (added regex)
	 * - Modified by Brian Reavis <brian@thirdroute.com> 2012-8-27 (cleanup)
	 */
	const highlight = (element, regex) => {
	  if (regex === null) return; // convet string to regex

	  if (typeof regex === 'string') {
	    if (!regex.length) return;
	    regex = new RegExp(regex, 'i');
	  } // Wrap matching part of text node with highlighting <span>, e.g.
	  // Soccer  ->  <span class="highlight">Soc</span>cer  for regex = /soc/i


	  const highlightText = node => {
	    var match = node.data.match(regex);

	    if (match && node.data.length > 0) {
	      var spannode = document.createElement('span');
	      spannode.className = 'highlight';
	      var middlebit = node.splitText(match.index);
	      middlebit.splitText(match[0].length);
	      var middleclone = middlebit.cloneNode(true);
	      spannode.appendChild(middleclone);
	      replaceNode(middlebit, spannode);
	      return 1;
	    }

	    return 0;
	  }; // Recurse element node, looking for child text nodes to highlight, unless element
	  // is childless, <script>, <style>, or already highlighted: <span class="hightlight">


	  const highlightChildren = node => {
	    if (node.nodeType === 1 && node.childNodes && !/(script|style)/i.test(node.tagName) && (node.className !== 'highlight' || node.tagName !== 'SPAN')) {
	      Array.from(node.childNodes).forEach(element => {
	        highlightRecursive(element);
	      });
	    }
	  };

	  const highlightRecursive = node => {
	    if (node.nodeType === 3) {
	      return highlightText(node);
	    }

	    highlightChildren(node);
	    return 0;
	  };

	  highlightRecursive(element);
	};
	/**
	 * removeHighlight fn copied from highlight v5 and
	 * edited to remove with(), pass js strict mode, and use without jquery
	 */

	const removeHighlight = el => {
	  var elements = el.querySelectorAll("span.highlight");
	  Array.prototype.forEach.call(elements, function (el) {
	    var parent = el.parentNode;
	    parent.replaceChild(el.firstChild, el);
	    parent.normalize();
	  });
	};

	const KEY_A = 65;
	const KEY_RETURN = 13;
	const KEY_ESC = 27;
	const KEY_LEFT = 37;
	const KEY_UP = 38;
	const KEY_RIGHT = 39;
	const KEY_DOWN = 40;
	const KEY_BACKSPACE = 8;
	const KEY_DELETE = 46;
	const KEY_TAB = 9;
	const IS_MAC = typeof navigator === 'undefined' ? false : /Mac/.test(navigator.userAgent);
	const KEY_SHORTCUT = IS_MAC ? 'metaKey' : 'ctrlKey'; // ctrl key or apple key for ma

	var defaults = {
	  options: [],
	  optgroups: [],
	  plugins: [],
	  delimiter: ',',
	  splitOn: null,
	  // regexp or string for splitting up values from a paste command
	  persist: true,
	  diacritics: true,
	  create: null,
	  createOnBlur: false,
	  createFilter: null,
	  highlight: true,
	  openOnFocus: true,
	  shouldOpen: null,
	  maxOptions: 50,
	  maxItems: null,
	  hideSelected: null,
	  duplicates: false,
	  addPrecedence: false,
	  selectOnTab: false,
	  preload: null,
	  allowEmptyOption: false,
	  //closeAfterSelect: false,
	  loadThrottle: 300,
	  loadingClass: 'loading',
	  dataAttr: null,
	  //'data-data',
	  optgroupField: 'optgroup',
	  valueField: 'value',
	  labelField: 'text',
	  disabledField: 'disabled',
	  optgroupLabelField: 'label',
	  optgroupValueField: 'value',
	  lockOptgroupOrder: false,
	  sortField: '$order',
	  searchField: ['text'],
	  searchConjunction: 'and',
	  mode: null,
	  wrapperClass: 'ts-wrapper',
	  controlClass: 'ts-control',
	  dropdownClass: 'ts-dropdown',
	  dropdownContentClass: 'ts-dropdown-content',
	  itemClass: 'item',
	  optionClass: 'option',
	  dropdownParent: null,
	  controlInput: '<input type="text" autocomplete="off" size="1" />',
	  copyClassesToDropdown: false,
	  placeholder: null,
	  hidePlaceholder: null,
	  shouldLoad: function (query) {
	    return query.length > 0;
	  },

	  /*
	  load                 : null, // function(query, callback) { ... }
	  score                : null, // function(search) { ... }
	  onInitialize         : null, // function() { ... }
	  onChange             : null, // function(value) { ... }
	  onItemAdd            : null, // function(value, $item) { ... }
	  onItemRemove         : null, // function(value) { ... }
	  onClear              : null, // function() { ... }
	  onOptionAdd          : null, // function(value, data) { ... }
	  onOptionRemove       : null, // function(value) { ... }
	  onOptionClear        : null, // function() { ... }
	  onOptionGroupAdd     : null, // function(id, data) { ... }
	  onOptionGroupRemove  : null, // function(id) { ... }
	  onOptionGroupClear   : null, // function() { ... }
	  onDropdownOpen       : null, // function(dropdown) { ... }
	  onDropdownClose      : null, // function(dropdown) { ... }
	  onType               : null, // function(str) { ... }
	  onDelete             : null, // function(values) { ... }
	  */
	  render: {
	    /*
	    item: null,
	    optgroup: null,
	    optgroup_header: null,
	    option: null,
	    option_create: null
	    */
	  }
	};

	/**
	 * Converts a scalar to its best string representation
	 * for hash keys and HTML attribute values.
	 *
	 * Transformations:
	 *   'str'     -> 'str'
	 *   null      -> ''
	 *   undefined -> ''
	 *   true      -> '1'
	 *   false     -> '0'
	 *   0         -> '0'
	 *   1         -> '1'
	 *
	 */
	const hash_key = value => {
	  if (typeof value === 'undefined' || value === null) return null;
	  return get_hash(value);
	};
	const get_hash = value => {
	  if (typeof value === 'boolean') return value ? '1' : '0';
	  return value + '';
	};
	/**
	 * Escapes a string for use within HTML.
	 *
	 */

	const escape_html = str => {
	  return (str + '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
	};
	/**
	 * Debounce the user provided load function
	 *
	 */

	const loadDebounce = (fn, delay) => {
	  var timeout;
	  return function (value, callback) {
	    var self = this;

	    if (timeout) {
	      self.loading = Math.max(self.loading - 1, 0);
	      clearTimeout(timeout);
	    }

	    timeout = setTimeout(function () {
	      timeout = null;
	      self.loadedSearches[value] = true;
	      fn.call(self, value, callback);
	    }, delay);
	  };
	};
	/**
	 * Debounce all fired events types listed in `types`
	 * while executing the provided `fn`.
	 *
	 */

	const debounce_events = (self, types, fn) => {
	  var type;
	  var trigger = self.trigger;
	  var event_args = {}; // override trigger method

	  self.trigger = function () {
	    var type = arguments[0];

	    if (types.indexOf(type) !== -1) {
	      event_args[type] = arguments;
	    } else {
	      return trigger.apply(self, arguments);
	    }
	  }; // invoke provided function


	  fn.apply(self, []);
	  self.trigger = trigger; // trigger queued events

	  for (type of types) {
	    if (type in event_args) {
	      trigger.apply(self, event_args[type]);
	    }
	  }
	};
	/**
	 * Determines the current selection within a text input control.
	 * Returns an object containing:
	 *   - start
	 *   - length
	 *
	 */

	const getSelection = input => {
	  return {
	    start: input.selectionStart || 0,
	    length: (input.selectionEnd || 0) - (input.selectionStart || 0)
	  };
	};
	/**
	 * Prevent default
	 *
	 */

	const preventDefault = (evt, stop = false) => {
	  if (evt) {
	    evt.preventDefault();

	    if (stop) {
	      evt.stopPropagation();
	    }
	  }
	};
	/**
	 * Add event helper
	 *
	 */

	const addEvent = (target, type, callback, options) => {
	  target.addEventListener(type, callback, options);
	};
	/**
	 * Return true if the requested key is down
	 * Will return false if more than one control character is pressed ( when [ctrl+shift+a] != [ctrl+a] )
	 * The current evt may not always set ( eg calling advanceSelection() )
	 *
	 */

	const isKeyDown = (key_name, evt) => {
	  if (!evt) {
	    return false;
	  }

	  if (!evt[key_name]) {
	    return false;
	  }

	  var count = (evt.altKey ? 1 : 0) + (evt.ctrlKey ? 1 : 0) + (evt.shiftKey ? 1 : 0) + (evt.metaKey ? 1 : 0);

	  if (count === 1) {
	    return true;
	  }

	  return false;
	};
	/**
	 * Get the id of an element
	 * If the id attribute is not set, set the attribute with the given id
	 *
	 */

	const getId = (el, id) => {
	  const existing_id = el.getAttribute('id');

	  if (existing_id) {
	    return existing_id;
	  }

	  el.setAttribute('id', id);
	  return id;
	};
	/**
	 * Returns a string with backslashes added before characters that need to be escaped.
	 */

	const addSlashes = str => {
	  return str.replace(/[\\"']/g, '\\$&');
	};
	/**
	 *
	 */

	const append = (parent, node) => {
	  if (node) parent.append(node);
	};

	function getSettings(input, settings_user) {
	  var settings = Object.assign({}, defaults, settings_user);
	  var attr_data = settings.dataAttr;
	  var field_label = settings.labelField;
	  var field_value = settings.valueField;
	  var field_disabled = settings.disabledField;
	  var field_optgroup = settings.optgroupField;
	  var field_optgroup_label = settings.optgroupLabelField;
	  var field_optgroup_value = settings.optgroupValueField;
	  var tag_name = input.tagName.toLowerCase();
	  var placeholder = input.getAttribute('placeholder') || input.getAttribute('data-placeholder');

	  if (!placeholder && !settings.allowEmptyOption) {
	    let option = input.querySelector('option[value=""]');

	    if (option) {
	      placeholder = option.textContent;
	    }
	  }

	  var settings_element = {
	    placeholder: placeholder,
	    options: [],
	    optgroups: [],
	    items: [],
	    maxItems: null
	  };
	  /**
	   * Initialize from a <select> element.
	   *
	   */

	  var init_select = () => {
	    var tagName;
	    var options = settings_element.options;
	    var optionsMap = {};
	    var group_count = 1;

	    var readData = el => {
	      var data = Object.assign({}, el.dataset); // get plain object from DOMStringMap

	      var json = attr_data && data[attr_data];

	      if (typeof json === 'string' && json.length) {
	        data = Object.assign(data, JSON.parse(json));
	      }

	      return data;
	    };

	    var addOption = (option, group) => {
	      var value = hash_key(option.value);
	      if (value == null) return;
	      if (!value && !settings.allowEmptyOption) return; // if the option already exists, it's probably been
	      // duplicated in another optgroup. in this case, push
	      // the current group to the "optgroup" property on the
	      // existing option so that it's rendered in both places.

	      if (optionsMap.hasOwnProperty(value)) {
	        if (group) {
	          var arr = optionsMap[value][field_optgroup];

	          if (!arr) {
	            optionsMap[value][field_optgroup] = group;
	          } else if (!Array.isArray(arr)) {
	            optionsMap[value][field_optgroup] = [arr, group];
	          } else {
	            arr.push(group);
	          }
	        }
	      } else {
	        var option_data = readData(option);
	        option_data[field_label] = option_data[field_label] || option.textContent;
	        option_data[field_value] = option_data[field_value] || value;
	        option_data[field_disabled] = option_data[field_disabled] || option.disabled;
	        option_data[field_optgroup] = option_data[field_optgroup] || group;
	        option_data.$option = option;
	        optionsMap[value] = option_data;
	        options.push(option_data);
	      }

	      if (option.selected) {
	        settings_element.items.push(value);
	      }
	    };

	    var addGroup = optgroup => {
	      var id, optgroup_data;
	      optgroup_data = readData(optgroup);
	      optgroup_data[field_optgroup_label] = optgroup_data[field_optgroup_label] || optgroup.getAttribute('label') || '';
	      optgroup_data[field_optgroup_value] = optgroup_data[field_optgroup_value] || group_count++;
	      optgroup_data[field_disabled] = optgroup_data[field_disabled] || optgroup.disabled;
	      settings_element.optgroups.push(optgroup_data);
	      id = optgroup_data[field_optgroup_value];
	      iterate(optgroup.children, option => {
	        addOption(option, id);
	      });
	    };

	    settings_element.maxItems = input.hasAttribute('multiple') ? null : 1;
	    iterate(input.children, child => {
	      tagName = child.tagName.toLowerCase();

	      if (tagName === 'optgroup') {
	        addGroup(child);
	      } else if (tagName === 'option') {
	        addOption(child);
	      }
	    });
	  };
	  /**
	   * Initialize from a <input type="text"> element.
	   *
	   */


	  var init_textbox = () => {
	    const data_raw = input.getAttribute(attr_data);

	    if (!data_raw) {
	      var value = input.value.trim() || '';
	      if (!settings.allowEmptyOption && !value.length) return;
	      const values = value.split(settings.delimiter);
	      iterate(values, value => {
	        const option = {};
	        option[field_label] = value;
	        option[field_value] = value;
	        settings_element.options.push(option);
	      });
	      settings_element.items = values;
	    } else {
	      settings_element.options = JSON.parse(data_raw);
	      iterate(settings_element.options, opt => {
	        settings_element.items.push(opt[field_value]);
	      });
	    }
	  };

	  if (tag_name === 'select') {
	    init_select();
	  } else {
	    init_textbox();
	  }

	  return Object.assign({}, defaults, settings_element, settings_user);
	}

	var instance_i = 0;
	class TomSelect extends MicroPlugin(MicroEvent) {
	  // @deprecated 1.8
	  constructor(input_arg, user_settings) {
	    super();
	    this.control_input = void 0;
	    this.wrapper = void 0;
	    this.dropdown = void 0;
	    this.control = void 0;
	    this.dropdown_content = void 0;
	    this.focus_node = void 0;
	    this.order = 0;
	    this.settings = void 0;
	    this.input = void 0;
	    this.tabIndex = void 0;
	    this.is_select_tag = void 0;
	    this.rtl = void 0;
	    this.inputId = void 0;
	    this._destroy = void 0;
	    this.sifter = void 0;
	    this.isOpen = false;
	    this.isDisabled = false;
	    this.isRequired = void 0;
	    this.isInvalid = false;
	    this.isValid = true;
	    this.isLocked = false;
	    this.isFocused = false;
	    this.isInputHidden = false;
	    this.isSetup = false;
	    this.ignoreFocus = false;
	    this.ignoreHover = false;
	    this.hasOptions = false;
	    this.currentResults = void 0;
	    this.lastValue = '';
	    this.caretPos = 0;
	    this.loading = 0;
	    this.loadedSearches = {};
	    this.activeOption = null;
	    this.activeItems = [];
	    this.optgroups = {};
	    this.options = {};
	    this.userOptions = {};
	    this.items = [];
	    instance_i++;
	    var dir;
	    var input = getDom(input_arg);

	    if (input.tomselect) {
	      throw new Error('Tom Select already initialized on this element');
	    }

	    input.tomselect = this; // detect rtl environment

	    var computedStyle = window.getComputedStyle && window.getComputedStyle(input, null);
	    dir = computedStyle.getPropertyValue('direction'); // setup default state

	    const settings = getSettings(input, user_settings);
	    this.settings = settings;
	    this.input = input;
	    this.tabIndex = input.tabIndex || 0;
	    this.is_select_tag = input.tagName.toLowerCase() === 'select';
	    this.rtl = /rtl/i.test(dir);
	    this.inputId = getId(input, 'tomselect-' + instance_i);
	    this.isRequired = input.required; // search system

	    this.sifter = new Sifter(this.options, {
	      diacritics: settings.diacritics
	    }); // option-dependent defaults

	    settings.mode = settings.mode || (settings.maxItems === 1 ? 'single' : 'multi');

	    if (typeof settings.hideSelected !== 'boolean') {
	      settings.hideSelected = settings.mode === 'multi';
	    }

	    if (typeof settings.hidePlaceholder !== 'boolean') {
	      settings.hidePlaceholder = settings.mode !== 'multi';
	    } // set up createFilter callback


	    var filter = settings.createFilter;

	    if (typeof filter !== 'function') {
	      if (typeof filter === 'string') {
	        filter = new RegExp(filter);
	      }

	      if (filter instanceof RegExp) {
	        settings.createFilter = input => filter.test(input);
	      } else {
	        settings.createFilter = value => {
	          return this.settings.duplicates || !this.options[value];
	        };
	      }
	    }

	    this.initializePlugins(settings.plugins);
	    this.setupCallbacks();
	    this.setupTemplates(); // Create all elements

	    const wrapper = getDom('<div>');
	    const control = getDom('<div>');

	    const dropdown = this._render('dropdown');

	    const dropdown_content = getDom(`<div role="listbox" tabindex="-1">`);
	    const classes = this.input.getAttribute('class') || '';
	    const inputMode = settings.mode;
	    var control_input;
	    addClasses(wrapper, settings.wrapperClass, classes, inputMode);
	    addClasses(control, settings.controlClass);
	    append(wrapper, control);
	    addClasses(dropdown, settings.dropdownClass, inputMode);

	    if (settings.copyClassesToDropdown) {
	      addClasses(dropdown, classes);
	    }

	    addClasses(dropdown_content, settings.dropdownContentClass);
	    append(dropdown, dropdown_content);
	    getDom(settings.dropdownParent || wrapper).appendChild(dropdown); // default controlInput

	    if (isHtmlString(settings.controlInput)) {
	      control_input = getDom(settings.controlInput); // set attributes

	      var attrs = ['autocorrect', 'autocapitalize', 'autocomplete'];
	      iterate$1(attrs, attr => {
	        if (input.getAttribute(attr)) {
	          setAttr(control_input, {
	            [attr]: input.getAttribute(attr)
	          });
	        }
	      });
	      control_input.tabIndex = -1;
	      control.appendChild(control_input);
	      this.focus_node = control_input; // dom element
	    } else if (settings.controlInput) {
	      control_input = getDom(settings.controlInput);
	      this.focus_node = control_input;
	    } else {
	      control_input = getDom('<input/>');
	      this.focus_node = control;
	    }

	    this.wrapper = wrapper;
	    this.dropdown = dropdown;
	    this.dropdown_content = dropdown_content;
	    this.control = control;
	    this.control_input = control_input;
	    this.setup();
	  }
	  /**
	   * set up event bindings.
	   *
	   */


	  setup() {
	    const self = this;
	    const settings = self.settings;
	    const control_input = self.control_input;
	    const dropdown = self.dropdown;
	    const dropdown_content = self.dropdown_content;
	    const wrapper = self.wrapper;
	    const control = self.control;
	    const input = self.input;
	    const focus_node = self.focus_node;
	    const passive_event = {
	      passive: true
	    };
	    const listboxId = self.inputId + '-ts-dropdown';
	    setAttr(dropdown_content, {
	      id: listboxId
	    });
	    setAttr(focus_node, {
	      role: 'combobox',
	      'aria-haspopup': 'listbox',
	      'aria-expanded': 'false',
	      'aria-controls': listboxId
	    });
	    const control_id = getId(focus_node, self.inputId + '-ts-control');
	    const query = "label[for='" + escapeQuery(self.inputId) + "']";
	    const label = document.querySelector(query);
	    const label_click = self.focus.bind(self);

	    if (label) {
	      addEvent(label, 'click', label_click);
	      setAttr(label, {
	        for: control_id
	      });
	      const label_id = getId(label, self.inputId + '-ts-label');
	      setAttr(focus_node, {
	        'aria-labelledby': label_id
	      });
	      setAttr(dropdown_content, {
	        'aria-labelledby': label_id
	      });
	    }

	    wrapper.style.width = input.style.width;

	    if (self.plugins.names.length) {
	      const classes_plugins = 'plugin-' + self.plugins.names.join(' plugin-');
	      addClasses([wrapper, dropdown], classes_plugins);
	    }

	    if ((settings.maxItems === null || settings.maxItems > 1) && self.is_select_tag) {
	      setAttr(input, {
	        multiple: 'multiple'
	      });
	    }

	    if (settings.placeholder) {
	      setAttr(control_input, {
	        placeholder: settings.placeholder
	      });
	    } // if splitOn was not passed in, construct it from the delimiter to allow pasting universally


	    if (!settings.splitOn && settings.delimiter) {
	      settings.splitOn = new RegExp('\\s*' + escape_regex(settings.delimiter) + '+\\s*');
	    } // debounce user defined load() if loadThrottle > 0
	    // after initializePlugins() so plugins can create/modify user defined loaders


	    if (settings.load && settings.loadThrottle) {
	      settings.load = loadDebounce(settings.load, settings.loadThrottle);
	    }

	    self.control_input.type = input.type;
	    addEvent(dropdown, 'mousemove', () => {
	      self.ignoreHover = false;
	    });
	    addEvent(dropdown, 'mouseenter', e => {
	      var target_match = parentMatch(e.target, '[data-selectable]', dropdown);
	      if (target_match) self.onOptionHover(e, target_match);
	    }, {
	      capture: true
	    }); // clicking on an option should select it

	    addEvent(dropdown, 'click', evt => {
	      const option = parentMatch(evt.target, '[data-selectable]');

	      if (option) {
	        self.onOptionSelect(evt, option);
	        preventDefault(evt, true);
	      }
	    });
	    addEvent(control, 'click', evt => {
	      var target_match = parentMatch(evt.target, '[data-ts-item]', control);

	      if (target_match && self.onItemSelect(evt, target_match)) {
	        preventDefault(evt, true);
	        return;
	      } // retain focus (see control_input mousedown)


	      if (control_input.value != '') {
	        return;
	      }

	      self.onClick();
	      preventDefault(evt, true);
	    }); // keydown on focus_node for arrow_down/arrow_up

	    addEvent(focus_node, 'keydown', e => self.onKeyDown(e)); // keypress and input/keyup

	    addEvent(control_input, 'keypress', e => self.onKeyPress(e));
	    addEvent(control_input, 'input', e => self.onInput(e));
	    addEvent(focus_node, 'blur', e => self.onBlur(e));
	    addEvent(focus_node, 'focus', e => self.onFocus(e));
	    addEvent(control_input, 'paste', e => self.onPaste(e));

	    const doc_mousedown = evt => {
	      // blur if target is outside of this instance
	      // dropdown is not always inside wrapper
	      const target = evt.composedPath()[0];

	      if (!wrapper.contains(target) && !dropdown.contains(target)) {
	        if (self.isFocused) {
	          self.blur();
	        }

	        self.inputState();
	        return;
	      } // retain focus by preventing native handling. if the
	      // event target is the input it should not be modified.
	      // otherwise, text selection within the input won't work.
	      // Fixes bug #212 which is no covered by tests


	      if (target == control_input && self.isOpen) {
	        evt.stopPropagation(); // clicking anywhere in the control should not blur the control_input (which would close the dropdown)
	      } else {
	        preventDefault(evt, true);
	      }
	    };

	    const win_scroll = () => {
	      if (self.isOpen) {
	        self.positionDropdown();
	      }
	    };

	    addEvent(document, 'mousedown', doc_mousedown);
	    addEvent(window, 'scroll', win_scroll, passive_event);
	    addEvent(window, 'resize', win_scroll, passive_event);

	    this._destroy = () => {
	      document.removeEventListener('mousedown', doc_mousedown);
	      window.removeEventListener('scroll', win_scroll);
	      window.removeEventListener('resize', win_scroll);
	      if (label) label.removeEventListener('click', label_click);
	    }; // store original html and tab index so that they can be
	    // restored when the destroy() method is called.


	    this.revertSettings = {
	      innerHTML: input.innerHTML,
	      tabIndex: input.tabIndex
	    };
	    input.tabIndex = -1;
	    input.insertAdjacentElement('afterend', self.wrapper);
	    self.sync(false);
	    settings.items = [];
	    delete settings.optgroups;
	    delete settings.options;
	    addEvent(input, 'invalid', () => {
	      if (self.isValid) {
	        self.isValid = false;
	        self.isInvalid = true;
	        self.refreshState();
	      }
	    });
	    self.updateOriginalInput();
	    self.refreshItems();
	    self.close(false);
	    self.inputState();
	    self.isSetup = true;

	    if (input.disabled) {
	      self.disable();
	    } else {
	      self.enable(); //sets tabIndex
	    }

	    self.on('change', this.onChange);
	    addClasses(input, 'tomselected', 'ts-hidden-accessible');
	    self.trigger('initialize'); // preload options

	    if (settings.preload === true) {
	      self.preload();
	    }
	  }
	  /**
	   * Register options and optgroups
	   *
	   */


	  setupOptions(options = [], optgroups = []) {
	    // build options table
	    this.addOptions(options); // build optgroup table

	    iterate$1(optgroups, optgroup => {
	      this.registerOptionGroup(optgroup);
	    });
	  }
	  /**
	   * Sets up default rendering functions.
	   */


	  setupTemplates() {
	    var self = this;
	    var field_label = self.settings.labelField;
	    var field_optgroup = self.settings.optgroupLabelField;
	    var templates = {
	      'optgroup': data => {
	        let optgroup = document.createElement('div');
	        optgroup.className = 'optgroup';
	        optgroup.appendChild(data.options);
	        return optgroup;
	      },
	      'optgroup_header': (data, escape) => {
	        return '<div class="optgroup-header">' + escape(data[field_optgroup]) + '</div>';
	      },
	      'option': (data, escape) => {
	        return '<div>' + escape(data[field_label]) + '</div>';
	      },
	      'item': (data, escape) => {
	        return '<div>' + escape(data[field_label]) + '</div>';
	      },
	      'option_create': (data, escape) => {
	        return '<div class="create">Add <strong>' + escape(data.input) + '</strong>&hellip;</div>';
	      },
	      'no_results': () => {
	        return '<div class="no-results">No results found</div>';
	      },
	      'loading': () => {
	        return '<div class="spinner"></div>';
	      },
	      'not_loading': () => {},
	      'dropdown': () => {
	        return '<div></div>';
	      }
	    };
	    self.settings.render = Object.assign({}, templates, self.settings.render);
	  }
	  /**
	   * Maps fired events to callbacks provided
	   * in the settings used when creating the control.
	   */


	  setupCallbacks() {
	    var key, fn;
	    var callbacks = {
	      'initialize': 'onInitialize',
	      'change': 'onChange',
	      'item_add': 'onItemAdd',
	      'item_remove': 'onItemRemove',
	      'item_select': 'onItemSelect',
	      'clear': 'onClear',
	      'option_add': 'onOptionAdd',
	      'option_remove': 'onOptionRemove',
	      'option_clear': 'onOptionClear',
	      'optgroup_add': 'onOptionGroupAdd',
	      'optgroup_remove': 'onOptionGroupRemove',
	      'optgroup_clear': 'onOptionGroupClear',
	      'dropdown_open': 'onDropdownOpen',
	      'dropdown_close': 'onDropdownClose',
	      'type': 'onType',
	      'load': 'onLoad',
	      'focus': 'onFocus',
	      'blur': 'onBlur'
	    };

	    for (key in callbacks) {
	      fn = this.settings[callbacks[key]];
	      if (fn) this.on(key, fn);
	    }
	  }
	  /**
	   * Sync the Tom Select instance with the original input or select
	   *
	   */


	  sync(get_settings = true) {
	    const self = this;
	    const settings = get_settings ? getSettings(self.input, {
	      delimiter: self.settings.delimiter
	    }) : self.settings;
	    self.setupOptions(settings.options, settings.optgroups);
	    self.setValue(settings.items || [], true); // silent prevents recursion

	    self.lastQuery = null; // so updated options will be displayed in dropdown
	  }
	  /**
	   * Triggered when the main control element
	   * has a click event.
	   *
	   */


	  onClick() {
	    var self = this;

	    if (self.activeItems.length > 0) {
	      self.clearActiveItems();
	      self.focus();
	      return;
	    }

	    if (self.isFocused && self.isOpen) {
	      self.blur();
	    } else {
	      self.focus();
	    }
	  }
	  /**
	   * @deprecated v1.7
	   *
	   */


	  onMouseDown() {}
	  /**
	   * Triggered when the value of the control has been changed.
	   * This should propagate the event to the original DOM
	   * input / select element.
	   */


	  onChange() {
	    triggerEvent(this.input, 'input');
	    triggerEvent(this.input, 'change');
	  }
	  /**
	   * Triggered on <input> paste.
	   *
	   */


	  onPaste(e) {
	    var self = this;

	    if (self.isInputHidden || self.isLocked) {
	      preventDefault(e);
	      return;
	    } // If a regex or string is included, this will split the pasted
	    // input and create Items for each separate value


	    if (!self.settings.splitOn) {
	      return;
	    } // Wait for pasted text to be recognized in value


	    setTimeout(() => {
	      var pastedText = self.inputValue();

	      if (!pastedText.match(self.settings.splitOn)) {
	        return;
	      }

	      var splitInput = pastedText.trim().split(self.settings.splitOn);
	      iterate$1(splitInput, piece => {
	        const hash = hash_key(piece);

	        if (hash) {
	          if (this.options[piece]) {
	            self.addItem(piece);
	          } else {
	            self.createItem(piece);
	          }
	        }
	      });
	    }, 0);
	  }
	  /**
	   * Triggered on <input> keypress.
	   *
	   */


	  onKeyPress(e) {
	    var self = this;

	    if (self.isLocked) {
	      preventDefault(e);
	      return;
	    }

	    var character = String.fromCharCode(e.keyCode || e.which);

	    if (self.settings.create && self.settings.mode === 'multi' && character === self.settings.delimiter) {
	      self.createItem();
	      preventDefault(e);
	      return;
	    }
	  }
	  /**
	   * Triggered on <input> keydown.
	   *
	   */


	  onKeyDown(e) {
	    var self = this;
	    self.ignoreHover = true;

	    if (self.isLocked) {
	      if (e.keyCode !== KEY_TAB) {
	        preventDefault(e);
	      }

	      return;
	    }

	    switch (e.keyCode) {
	      // ctrl+A: select all
	      case KEY_A:
	        if (isKeyDown(KEY_SHORTCUT, e)) {
	          if (self.control_input.value == '') {
	            preventDefault(e);
	            self.selectAll();
	            return;
	          }
	        }

	        break;
	      // esc: close dropdown

	      case KEY_ESC:
	        if (self.isOpen) {
	          preventDefault(e, true);
	          self.close();
	        }

	        self.clearActiveItems();
	        return;
	      // down: open dropdown or move selection down

	      case KEY_DOWN:
	        if (!self.isOpen && self.hasOptions) {
	          self.open();
	        } else if (self.activeOption) {
	          let next = self.getAdjacent(self.activeOption, 1);
	          if (next) self.setActiveOption(next);
	        }

	        preventDefault(e);
	        return;
	      // up: move selection up

	      case KEY_UP:
	        if (self.activeOption) {
	          let prev = self.getAdjacent(self.activeOption, -1);
	          if (prev) self.setActiveOption(prev);
	        }

	        preventDefault(e);
	        return;
	      // return: select active option

	      case KEY_RETURN:
	        if (self.canSelect(self.activeOption)) {
	          self.onOptionSelect(e, self.activeOption);
	          preventDefault(e); // if the option_create=null, the dropdown might be closed
	        } else if (self.settings.create && self.createItem()) {
	          preventDefault(e); // don't submit form when searching for a value
	        } else if (document.activeElement == self.control_input && self.isOpen) {
	          preventDefault(e);
	        }

	        return;
	      // left: modifiy item selection to the left

	      case KEY_LEFT:
	        self.advanceSelection(-1, e);
	        return;
	      // right: modifiy item selection to the right

	      case KEY_RIGHT:
	        self.advanceSelection(1, e);
	        return;
	      // tab: select active option and/or create item

	      case KEY_TAB:
	        if (self.settings.selectOnTab) {
	          if (self.canSelect(self.activeOption)) {
	            self.onOptionSelect(e, self.activeOption); // prevent default [tab] behaviour of jump to the next field
	            // if select isFull, then the dropdown won't be open and [tab] will work normally

	            preventDefault(e);
	          }

	          if (self.settings.create && self.createItem()) {
	            preventDefault(e);
	          }
	        }

	        return;
	      // delete|backspace: delete items

	      case KEY_BACKSPACE:
	      case KEY_DELETE:
	        self.deleteSelection(e);
	        return;
	    } // don't enter text in the control_input when active items are selected


	    if (self.isInputHidden && !isKeyDown(KEY_SHORTCUT, e)) {
	      preventDefault(e);
	    }
	  }
	  /**
	   * Triggered on <input> keyup.
	   *
	   */


	  onInput(e) {
	    var self = this;

	    if (self.isLocked) {
	      return;
	    }

	    var value = self.inputValue();

	    if (self.lastValue !== value) {
	      self.lastValue = value;

	      if (self.settings.shouldLoad.call(self, value)) {
	        self.load(value);
	      }

	      self.refreshOptions();
	      self.trigger('type', value);
	    }
	  }
	  /**
	   * Triggered when the user rolls over
	   * an option in the autocomplete dropdown menu.
	   *
	   */


	  onOptionHover(evt, option) {
	    if (this.ignoreHover) return;
	    this.setActiveOption(option, false);
	  }
	  /**
	   * Triggered on <input> focus.
	   *
	   */


	  onFocus(e) {
	    var self = this;
	    var wasFocused = self.isFocused;

	    if (self.isDisabled) {
	      self.blur();
	      preventDefault(e);
	      return;
	    }

	    if (self.ignoreFocus) return;
	    self.isFocused = true;
	    if (self.settings.preload === 'focus') self.preload();
	    if (!wasFocused) self.trigger('focus');

	    if (!self.activeItems.length) {
	      self.showInput();
	      self.refreshOptions(!!self.settings.openOnFocus);
	    }

	    self.refreshState();
	  }
	  /**
	   * Triggered on <input> blur.
	   *
	   */


	  onBlur(e) {
	    if (document.hasFocus() === false) return;
	    var self = this;
	    if (!self.isFocused) return;
	    self.isFocused = false;
	    self.ignoreFocus = false;

	    var deactivate = () => {
	      self.close();
	      self.setActiveItem();
	      self.setCaret(self.items.length);
	      self.trigger('blur');
	    };

	    if (self.settings.create && self.settings.createOnBlur) {
	      self.createItem(null, deactivate);
	    } else {
	      deactivate();
	    }
	  }
	  /**
	   * Triggered when the user clicks on an option
	   * in the autocomplete dropdown menu.
	   *
	   */


	  onOptionSelect(evt, option) {
	    var value,
	        self = this; // should not be possible to trigger a option under a disabled optgroup

	    if (option.parentElement && option.parentElement.matches('[data-disabled]')) {
	      return;
	    }

	    if (option.classList.contains('create')) {
	      self.createItem(null, () => {
	        if (self.settings.closeAfterSelect) {
	          self.close();
	        }
	      });
	    } else {
	      value = option.dataset.value;

	      if (typeof value !== 'undefined') {
	        self.lastQuery = null;
	        self.addItem(value);

	        if (self.settings.closeAfterSelect) {
	          self.close();
	        }

	        if (!self.settings.hideSelected && evt.type && /click/.test(evt.type)) {
	          self.setActiveOption(option);
	        }
	      }
	    }
	  }
	  /**
	   * Return true if the given option can be selected
	   *
	   */


	  canSelect(option) {
	    if (this.isOpen && option && this.dropdown_content.contains(option)) {
	      return true;
	    }

	    return false;
	  }
	  /**
	   * Triggered when the user clicks on an item
	   * that has been selected.
	   *
	   */


	  onItemSelect(evt, item) {
	    var self = this;

	    if (!self.isLocked && self.settings.mode === 'multi') {
	      preventDefault(evt);
	      self.setActiveItem(item, evt);
	      return true;
	    }

	    return false;
	  }
	  /**
	   * Determines whether or not to invoke
	   * the user-provided option provider / loader
	   *
	   * Note, there is a subtle difference between
	   * this.canLoad() and this.settings.shouldLoad();
	   *
	   *	- settings.shouldLoad() is a user-input validator.
	   *	When false is returned, the not_loading template
	   *	will be added to the dropdown
	   *
	   *	- canLoad() is lower level validator that checks
	   * 	the Tom Select instance. There is no inherent user
	   *	feedback when canLoad returns false
	   *
	   */


	  canLoad(value) {
	    if (!this.settings.load) return false;
	    if (this.loadedSearches.hasOwnProperty(value)) return false;
	    return true;
	  }
	  /**
	   * Invokes the user-provided option provider / loader.
	   *
	   */


	  load(value) {
	    const self = this;
	    if (!self.canLoad(value)) return;
	    addClasses(self.wrapper, self.settings.loadingClass);
	    self.loading++;
	    const callback = self.loadCallback.bind(self);
	    self.settings.load.call(self, value, callback);
	  }
	  /**
	   * Invoked by the user-provided option provider
	   *
	   */


	  loadCallback(options, optgroups) {
	    const self = this;
	    self.loading = Math.max(self.loading - 1, 0);
	    self.lastQuery = null;
	    self.clearActiveOption(); // when new results load, focus should be on first option

	    self.setupOptions(options, optgroups);
	    self.refreshOptions(self.isFocused && !self.isInputHidden);

	    if (!self.loading) {
	      removeClasses(self.wrapper, self.settings.loadingClass);
	    }

	    self.trigger('load', options, optgroups);
	  }

	  preload() {
	    var classList = this.wrapper.classList;
	    if (classList.contains('preloaded')) return;
	    classList.add('preloaded');
	    this.load('');
	  }
	  /**
	   * Sets the input field of the control to the specified value.
	   *
	   */


	  setTextboxValue(value = '') {
	    var input = this.control_input;
	    var changed = input.value !== value;

	    if (changed) {
	      input.value = value;
	      triggerEvent(input, 'update');
	      this.lastValue = value;
	    }
	  }
	  /**
	   * Returns the value of the control. If multiple items
	   * can be selected (e.g. <select multiple>), this returns
	   * an array. If only one item can be selected, this
	   * returns a string.
	   *
	   */


	  getValue() {
	    if (this.is_select_tag && this.input.hasAttribute('multiple')) {
	      return this.items;
	    }

	    return this.items.join(this.settings.delimiter);
	  }
	  /**
	   * Resets the selected items to the given value.
	   *
	   */


	  setValue(value, silent) {
	    var events = silent ? [] : ['change'];
	    debounce_events(this, events, () => {
	      this.clear(silent);
	      this.addItems(value, silent);
	    });
	  }
	  /**
	   * Resets the number of max items to the given value
	   *
	   */


	  setMaxItems(value) {
	    if (value === 0) value = null; //reset to unlimited items.

	    this.settings.maxItems = value;
	    this.refreshState();
	  }
	  /**
	   * Sets the selected item.
	   *
	   */


	  setActiveItem(item, e) {
	    var self = this;
	    var eventName;
	    var i, begin, end, swap;
	    var last;
	    if (self.settings.mode === 'single') return; // clear the active selection

	    if (!item) {
	      self.clearActiveItems();

	      if (self.isFocused) {
	        self.showInput();
	      }

	      return;
	    } // modify selection


	    eventName = e && e.type.toLowerCase();

	    if (eventName === 'click' && isKeyDown('shiftKey', e) && self.activeItems.length) {
	      last = self.getLastActive();
	      begin = Array.prototype.indexOf.call(self.control.children, last);
	      end = Array.prototype.indexOf.call(self.control.children, item);

	      if (begin > end) {
	        swap = begin;
	        begin = end;
	        end = swap;
	      }

	      for (i = begin; i <= end; i++) {
	        item = self.control.children[i];

	        if (self.activeItems.indexOf(item) === -1) {
	          self.setActiveItemClass(item);
	        }
	      }

	      preventDefault(e);
	    } else if (eventName === 'click' && isKeyDown(KEY_SHORTCUT, e) || eventName === 'keydown' && isKeyDown('shiftKey', e)) {
	      if (item.classList.contains('active')) {
	        self.removeActiveItem(item);
	      } else {
	        self.setActiveItemClass(item);
	      }
	    } else {
	      self.clearActiveItems();
	      self.setActiveItemClass(item);
	    } // ensure control has focus


	    self.hideInput();

	    if (!self.isFocused) {
	      self.focus();
	    }
	  }
	  /**
	   * Set the active and last-active classes
	   *
	   */


	  setActiveItemClass(item) {
	    const self = this;
	    const last_active = self.control.querySelector('.last-active');
	    if (last_active) removeClasses(last_active, 'last-active');
	    addClasses(item, 'active last-active');
	    self.trigger('item_select', item);

	    if (self.activeItems.indexOf(item) == -1) {
	      self.activeItems.push(item);
	    }
	  }
	  /**
	   * Remove active item
	   *
	   */


	  removeActiveItem(item) {
	    var idx = this.activeItems.indexOf(item);
	    this.activeItems.splice(idx, 1);
	    removeClasses(item, 'active');
	  }
	  /**
	   * Clears all the active items
	   *
	   */


	  clearActiveItems() {
	    removeClasses(this.activeItems, 'active');
	    this.activeItems = [];
	  }
	  /**
	   * Sets the selected item in the dropdown menu
	   * of available options.
	   *
	   */


	  setActiveOption(option, scroll = true) {
	    if (option === this.activeOption) {
	      return;
	    }

	    this.clearActiveOption();
	    if (!option) return;
	    this.activeOption = option;
	    setAttr(this.focus_node, {
	      'aria-activedescendant': option.getAttribute('id')
	    });
	    setAttr(option, {
	      'aria-selected': 'true'
	    });
	    addClasses(option, 'active');
	    if (scroll) this.scrollToOption(option);
	  }
	  /**
	   * Sets the dropdown_content scrollTop to display the option
	   *
	   */


	  scrollToOption(option, behavior) {
	    if (!option) return;
	    const content = this.dropdown_content;
	    const height_menu = content.clientHeight;
	    const scrollTop = content.scrollTop || 0;
	    const height_item = option.offsetHeight;
	    const y = option.getBoundingClientRect().top - content.getBoundingClientRect().top + scrollTop;

	    if (y + height_item > height_menu + scrollTop) {
	      this.scroll(y - height_menu + height_item, behavior);
	    } else if (y < scrollTop) {
	      this.scroll(y, behavior);
	    }
	  }
	  /**
	   * Scroll the dropdown to the given position
	   *
	   */


	  scroll(scrollTop, behavior) {
	    const content = this.dropdown_content;

	    if (behavior) {
	      content.style.scrollBehavior = behavior;
	    }

	    content.scrollTop = scrollTop;
	    content.style.scrollBehavior = '';
	  }
	  /**
	   * Clears the active option
	   *
	   */


	  clearActiveOption() {
	    if (this.activeOption) {
	      removeClasses(this.activeOption, 'active');
	      setAttr(this.activeOption, {
	        'aria-selected': null
	      });
	    }

	    this.activeOption = null;
	    setAttr(this.focus_node, {
	      'aria-activedescendant': null
	    });
	  }
	  /**
	   * Selects all items (CTRL + A).
	   */


	  selectAll() {
	    const self = this;
	    if (self.settings.mode === 'single') return;
	    const activeItems = self.controlChildren();
	    if (!activeItems.length) return;
	    self.hideInput();
	    self.close();
	    self.activeItems = activeItems;
	    iterate$1(activeItems, item => {
	      self.setActiveItemClass(item);
	    });
	  }
	  /**
	   * Determines if the control_input should be in a hidden or visible state
	   *
	   */


	  inputState() {
	    var self = this;
	    if (!self.control.contains(self.control_input)) return;
	    setAttr(self.control_input, {
	      placeholder: self.settings.placeholder
	    });

	    if (self.activeItems.length > 0 || !self.isFocused && self.settings.hidePlaceholder && self.items.length > 0) {
	      self.setTextboxValue();
	      self.isInputHidden = true;
	    } else {
	      if (self.settings.hidePlaceholder && self.items.length > 0) {
	        setAttr(self.control_input, {
	          placeholder: ''
	        });
	      }

	      self.isInputHidden = false;
	    }

	    self.wrapper.classList.toggle('input-hidden', self.isInputHidden);
	  }
	  /**
	   * Hides the input element out of view, while
	   * retaining its focus.
	   * @deprecated 1.3
	   */


	  hideInput() {
	    this.inputState();
	  }
	  /**
	   * Restores input visibility.
	   * @deprecated 1.3
	   */


	  showInput() {
	    this.inputState();
	  }
	  /**
	   * Get the input value
	   */


	  inputValue() {
	    return this.control_input.value.trim();
	  }
	  /**
	   * Gives the control focus.
	   */


	  focus() {
	    var self = this;
	    if (self.isDisabled) return;
	    self.ignoreFocus = true;

	    if (self.control_input.offsetWidth) {
	      self.control_input.focus();
	    } else {
	      self.focus_node.focus();
	    }

	    setTimeout(() => {
	      self.ignoreFocus = false;
	      self.onFocus();
	    }, 0);
	  }
	  /**
	   * Forces the control out of focus.
	   *
	   */


	  blur() {
	    this.focus_node.blur();
	    this.onBlur();
	  }
	  /**
	   * Returns a function that scores an object
	   * to show how good of a match it is to the
	   * provided query.
	   *
	   * @return {function}
	   */


	  getScoreFunction(query) {
	    return this.sifter.getScoreFunction(query, this.getSearchOptions());
	  }
	  /**
	   * Returns search options for sifter (the system
	   * for scoring and sorting results).
	   *
	   * @see https://github.com/orchidjs/sifter.js
	   * @return {object}
	   */


	  getSearchOptions() {
	    var settings = this.settings;
	    var sort = settings.sortField;

	    if (typeof settings.sortField === 'string') {
	      sort = [{
	        field: settings.sortField
	      }];
	    }

	    return {
	      fields: settings.searchField,
	      conjunction: settings.searchConjunction,
	      sort: sort,
	      nesting: settings.nesting
	    };
	  }
	  /**
	   * Searches through available options and returns
	   * a sorted array of matches.
	   *
	   */


	  search(query) {
	    var result, calculateScore;
	    var self = this;
	    var options = this.getSearchOptions(); // validate user-provided result scoring function

	    if (self.settings.score) {
	      calculateScore = self.settings.score.call(self, query);

	      if (typeof calculateScore !== 'function') {
	        throw new Error('Tom Select "score" setting must be a function that returns a function');
	      }
	    } // perform search


	    if (query !== self.lastQuery) {
	      self.lastQuery = query;
	      result = self.sifter.search(query, Object.assign(options, {
	        score: calculateScore
	      }));
	      self.currentResults = result;
	    } else {
	      result = Object.assign({}, self.currentResults);
	    } // filter out selected items


	    if (self.settings.hideSelected) {
	      result.items = result.items.filter(item => {
	        let hashed = hash_key(item.id);
	        return !(hashed && self.items.indexOf(hashed) !== -1);
	      });
	    }

	    return result;
	  }
	  /**
	   * Refreshes the list of available options shown
	   * in the autocomplete dropdown menu.
	   *
	   */


	  refreshOptions(triggerDropdown = true) {
	    var i, j, k, n, optgroup, optgroups, html, has_create_option, active_group;
	    var create;
	    const groups = {};
	    const groups_order = [];
	    var self = this;
	    var query = self.inputValue();
	    const same_query = query === self.lastQuery || query == '' && self.lastQuery == null;
	    var results = self.search(query);
	    var active_option = null;
	    var show_dropdown = self.settings.shouldOpen || false;
	    var dropdown_content = self.dropdown_content;

	    if (same_query) {
	      active_option = self.activeOption;

	      if (active_option) {
	        active_group = active_option.closest('[data-group]');
	      }
	    } // build markup


	    n = results.items.length;

	    if (typeof self.settings.maxOptions === 'number') {
	      n = Math.min(n, self.settings.maxOptions);
	    }

	    if (n > 0) {
	      show_dropdown = true;
	    } // render and group available options individually


	    for (i = 0; i < n; i++) {
	      // get option dom element
	      let item = results.items[i];
	      if (!item) continue;
	      let opt_value = item.id;
	      let option = self.options[opt_value];
	      if (option === undefined) continue;
	      let opt_hash = get_hash(opt_value);
	      let option_el = self.getOption(opt_hash, true); // toggle 'selected' class

	      if (!self.settings.hideSelected) {
	        option_el.classList.toggle('selected', self.items.includes(opt_hash));
	      }

	      optgroup = option[self.settings.optgroupField] || '';
	      optgroups = Array.isArray(optgroup) ? optgroup : [optgroup];

	      for (j = 0, k = optgroups && optgroups.length; j < k; j++) {
	        optgroup = optgroups[j];

	        if (!self.optgroups.hasOwnProperty(optgroup)) {
	          optgroup = '';
	        }

	        let group_fragment = groups[optgroup];

	        if (group_fragment === undefined) {
	          group_fragment = document.createDocumentFragment();
	          groups_order.push(optgroup);
	        } // nodes can only have one parent, so if the option is in mutple groups, we need a clone


	        if (j > 0) {
	          option_el = option_el.cloneNode(true);
	          setAttr(option_el, {
	            id: option.$id + '-clone-' + j,
	            'aria-selected': null
	          });
	          option_el.classList.add('ts-cloned');
	          removeClasses(option_el, 'active'); // make sure we keep the activeOption in the same group

	          if (self.activeOption && self.activeOption.dataset.value == opt_value) {
	            if (active_group && active_group.dataset.group === optgroup.toString()) {
	              active_option = option_el;
	            }
	          }
	        }

	        group_fragment.appendChild(option_el);
	        groups[optgroup] = group_fragment;
	      }
	    } // sort optgroups


	    if (self.settings.lockOptgroupOrder) {
	      groups_order.sort((a, b) => {
	        const grp_a = self.optgroups[a];
	        const grp_b = self.optgroups[b];
	        const a_order = grp_a && grp_a.$order || 0;
	        const b_order = grp_b && grp_b.$order || 0;
	        return a_order - b_order;
	      });
	    } // render optgroup headers & join groups


	    html = document.createDocumentFragment();
	    iterate$1(groups_order, optgroup => {
	      let group_fragment = groups[optgroup];
	      if (!group_fragment || !group_fragment.children.length) return;
	      let group_heading = self.optgroups[optgroup];

	      if (group_heading !== undefined) {
	        let group_options = document.createDocumentFragment();
	        let header = self.render('optgroup_header', group_heading);
	        append(group_options, header);
	        append(group_options, group_fragment);
	        let group_html = self.render('optgroup', {
	          group: group_heading,
	          options: group_options
	        });
	        append(html, group_html);
	      } else {
	        append(html, group_fragment);
	      }
	    });
	    dropdown_content.innerHTML = '';
	    append(dropdown_content, html); // highlight matching terms inline

	    if (self.settings.highlight) {
	      removeHighlight(dropdown_content);

	      if (results.query.length && results.tokens.length) {
	        iterate$1(results.tokens, tok => {
	          highlight(dropdown_content, tok.regex);
	        });
	      }
	    } // helper method for adding templates to dropdown


	    var add_template = template => {
	      let content = self.render(template, {
	        input: query
	      });

	      if (content) {
	        show_dropdown = true;
	        dropdown_content.insertBefore(content, dropdown_content.firstChild);
	      }

	      return content;
	    }; // add loading message


	    if (self.loading) {
	      add_template('loading'); // invalid query
	    } else if (!self.settings.shouldLoad.call(self, query)) {
	      add_template('not_loading'); // add no_results message
	    } else if (results.items.length === 0) {
	      add_template('no_results');
	    } // add create option


	    has_create_option = self.canCreate(query);

	    if (has_create_option) {
	      create = add_template('option_create');
	    } // activate


	    self.hasOptions = results.items.length > 0 || has_create_option;

	    if (show_dropdown) {
	      if (results.items.length > 0) {
	        if (!active_option && self.settings.mode === 'single' && self.items[0] != undefined) {
	          active_option = self.getOption(self.items[0]);
	        }

	        if (!dropdown_content.contains(active_option)) {
	          let active_index = 0;

	          if (create && !self.settings.addPrecedence) {
	            active_index = 1;
	          }

	          active_option = self.selectable()[active_index];
	        }
	      } else if (create) {
	        active_option = create;
	      }

	      if (triggerDropdown && !self.isOpen) {
	        self.open();
	        self.scrollToOption(active_option, 'auto');
	      }

	      self.setActiveOption(active_option);
	    } else {
	      self.clearActiveOption();

	      if (triggerDropdown && self.isOpen) {
	        self.close(false); // if create_option=null, we want the dropdown to close but not reset the textbox value
	      }
	    }
	  }
	  /**
	   * Return list of selectable options
	   *
	   */


	  selectable() {
	    return this.dropdown_content.querySelectorAll('[data-selectable]');
	  }
	  /**
	   * Adds an available option. If it already exists,
	   * nothing will happen. Note: this does not refresh
	   * the options list dropdown (use `refreshOptions`
	   * for that).
	   *
	   * Usage:
	   *
	   *   this.addOption(data)
	   *
	   */


	  addOption(data, user_created = false) {
	    const self = this; // @deprecated 1.7.7
	    // use addOptions( array, user_created ) for adding multiple options

	    if (Array.isArray(data)) {
	      self.addOptions(data, user_created);
	      return false;
	    }

	    const key = hash_key(data[self.settings.valueField]);

	    if (key === null || self.options.hasOwnProperty(key)) {
	      return false;
	    }

	    data.$order = data.$order || ++self.order;
	    data.$id = self.inputId + '-opt-' + data.$order;
	    self.options[key] = data;
	    self.lastQuery = null;

	    if (user_created) {
	      self.userOptions[key] = user_created;
	      self.trigger('option_add', key, data);
	    }

	    return key;
	  }
	  /**
	   * Add multiple options
	   *
	   */


	  addOptions(data, user_created = false) {
	    iterate$1(data, dat => {
	      this.addOption(dat, user_created);
	    });
	  }
	  /**
	   * @deprecated 1.7.7
	   */


	  registerOption(data) {
	    return this.addOption(data);
	  }
	  /**
	   * Registers an option group to the pool of option groups.
	   *
	   * @return {boolean|string}
	   */


	  registerOptionGroup(data) {
	    var key = hash_key(data[this.settings.optgroupValueField]);
	    if (key === null) return false;
	    data.$order = data.$order || ++this.order;
	    this.optgroups[key] = data;
	    return key;
	  }
	  /**
	   * Registers a new optgroup for options
	   * to be bucketed into.
	   *
	   */


	  addOptionGroup(id, data) {
	    var hashed_id;
	    data[this.settings.optgroupValueField] = id;

	    if (hashed_id = this.registerOptionGroup(data)) {
	      this.trigger('optgroup_add', hashed_id, data);
	    }
	  }
	  /**
	   * Removes an existing option group.
	   *
	   */


	  removeOptionGroup(id) {
	    if (this.optgroups.hasOwnProperty(id)) {
	      delete this.optgroups[id];
	      this.clearCache();
	      this.trigger('optgroup_remove', id);
	    }
	  }
	  /**
	   * Clears all existing option groups.
	   */


	  clearOptionGroups() {
	    this.optgroups = {};
	    this.clearCache();
	    this.trigger('optgroup_clear');
	  }
	  /**
	   * Updates an option available for selection. If
	   * it is visible in the selected items or options
	   * dropdown, it will be re-rendered automatically.
	   *
	   */


	  updateOption(value, data) {
	    const self = this;
	    var item_new;
	    var index_item;
	    const value_old = hash_key(value);
	    const value_new = hash_key(data[self.settings.valueField]); // sanity checks

	    if (value_old === null) return;
	    const data_old = self.options[value_old];
	    if (data_old == undefined) return;
	    if (typeof value_new !== 'string') throw new Error('Value must be set in option data');
	    const option = self.getOption(value_old);
	    const item = self.getItem(value_old);
	    data.$order = data.$order || data_old.$order;
	    delete self.options[value_old]; // invalidate render cache
	    // don't remove existing node yet, we'll remove it after replacing it

	    self.uncacheValue(value_new);
	    self.options[value_new] = data; // update the option if it's in the dropdown

	    if (option) {
	      if (self.dropdown_content.contains(option)) {
	        const option_new = self._render('option', data);

	        replaceNode(option, option_new);

	        if (self.activeOption === option) {
	          self.setActiveOption(option_new);
	        }
	      }

	      option.remove();
	    } // update the item if we have one


	    if (item) {
	      index_item = self.items.indexOf(value_old);

	      if (index_item !== -1) {
	        self.items.splice(index_item, 1, value_new);
	      }

	      item_new = self._render('item', data);
	      if (item.classList.contains('active')) addClasses(item_new, 'active');
	      replaceNode(item, item_new);
	    } // invalidate last query because we might have updated the sortField


	    self.lastQuery = null;
	  }
	  /**
	   * Removes a single option.
	   *
	   */


	  removeOption(value, silent) {
	    const self = this;
	    value = get_hash(value);
	    self.uncacheValue(value);
	    delete self.userOptions[value];
	    delete self.options[value];
	    self.lastQuery = null;
	    self.trigger('option_remove', value);
	    self.removeItem(value, silent);
	  }
	  /**
	   * Clears all options.
	   */


	  clearOptions(filter) {
	    const boundFilter = (filter || this.clearFilter).bind(this);
	    this.loadedSearches = {};
	    this.userOptions = {};
	    this.clearCache();
	    const selected = {};
	    iterate$1(this.options, (option, key) => {
	      if (boundFilter(option, key)) {
	        selected[key] = option;
	      }
	    });
	    this.options = this.sifter.items = selected;
	    this.lastQuery = null;
	    this.trigger('option_clear');
	  }
	  /**
	   * Used by clearOptions() to decide whether or not an option should be removed
	   * Return true to keep an option, false to remove
	   *
	   */


	  clearFilter(option, value) {
	    if (this.items.indexOf(value) >= 0) {
	      return true;
	    }

	    return false;
	  }
	  /**
	   * Returns the dom element of the option
	   * matching the given value.
	   *
	   */


	  getOption(value, create = false) {
	    const hashed = hash_key(value);
	    if (hashed === null) return null;
	    const option = this.options[hashed];

	    if (option != undefined) {
	      if (option.$div) {
	        return option.$div;
	      }

	      if (create) {
	        return this._render('option', option);
	      }
	    }

	    return null;
	  }
	  /**
	   * Returns the dom element of the next or previous dom element of the same type
	   * Note: adjacent options may not be adjacent DOM elements (optgroups)
	   *
	   */


	  getAdjacent(option, direction, type = 'option') {
	    var self = this,
	        all;

	    if (!option) {
	      return null;
	    }

	    if (type == 'item') {
	      all = self.controlChildren();
	    } else {
	      all = self.dropdown_content.querySelectorAll('[data-selectable]');
	    }

	    for (let i = 0; i < all.length; i++) {
	      if (all[i] != option) {
	        continue;
	      }

	      if (direction > 0) {
	        return all[i + 1];
	      }

	      return all[i - 1];
	    }

	    return null;
	  }
	  /**
	   * Returns the dom element of the item
	   * matching the given value.
	   *
	   */


	  getItem(item) {
	    if (typeof item == 'object') {
	      return item;
	    }

	    var value = hash_key(item);
	    return value !== null ? this.control.querySelector(`[data-value="${addSlashes(value)}"]`) : null;
	  }
	  /**
	   * "Selects" multiple items at once. Adds them to the list
	   * at the current caret position.
	   *
	   */


	  addItems(values, silent) {
	    var self = this;
	    var items = Array.isArray(values) ? values : [values];
	    items = items.filter(x => self.items.indexOf(x) === -1);
	    const last_item = items[items.length - 1];
	    items.forEach(item => {
	      self.isPending = item !== last_item;
	      self.addItem(item, silent);
	    });
	  }
	  /**
	   * "Selects" an item. Adds it to the list
	   * at the current caret position.
	   *
	   */


	  addItem(value, silent) {
	    var events = silent ? [] : ['change', 'dropdown_close'];
	    debounce_events(this, events, () => {
	      var item, wasFull;
	      const self = this;
	      const inputMode = self.settings.mode;
	      const hashed = hash_key(value);

	      if (hashed && self.items.indexOf(hashed) !== -1) {
	        if (inputMode === 'single') {
	          self.close();
	        }

	        if (inputMode === 'single' || !self.settings.duplicates) {
	          return;
	        }
	      }

	      if (hashed === null || !self.options.hasOwnProperty(hashed)) return;
	      if (inputMode === 'single') self.clear(silent);
	      if (inputMode === 'multi' && self.isFull()) return;
	      item = self._render('item', self.options[hashed]);

	      if (self.control.contains(item)) {
	        // duplicates
	        item = item.cloneNode(true);
	      }

	      wasFull = self.isFull();
	      self.items.splice(self.caretPos, 0, hashed);
	      self.insertAtCaret(item);

	      if (self.isSetup) {
	        // update menu / remove the option (if this is not one item being added as part of series)
	        if (!self.isPending && self.settings.hideSelected) {
	          let option = self.getOption(hashed);
	          let next = self.getAdjacent(option, 1);

	          if (next) {
	            self.setActiveOption(next);
	          }
	        } // refreshOptions after setActiveOption(),
	        // otherwise setActiveOption() will be called by refreshOptions() with the wrong value


	        if (!self.isPending && !self.settings.closeAfterSelect) {
	          self.refreshOptions(self.isFocused && inputMode !== 'single');
	        } // hide the menu if the maximum number of items have been selected or no options are left


	        if (self.settings.closeAfterSelect != false && self.isFull()) {
	          self.close();
	        } else if (!self.isPending) {
	          self.positionDropdown();
	        }

	        self.trigger('item_add', hashed, item);

	        if (!self.isPending) {
	          self.updateOriginalInput({
	            silent: silent
	          });
	        }
	      }

	      if (!self.isPending || !wasFull && self.isFull()) {
	        self.inputState();
	        self.refreshState();
	      }
	    });
	  }
	  /**
	   * Removes the selected item matching
	   * the provided value.
	   *
	   */


	  removeItem(item = null, silent) {
	    const self = this;
	    item = self.getItem(item);
	    if (!item) return;
	    var i, idx;
	    const value = item.dataset.value;
	    i = nodeIndex(item);
	    item.remove();

	    if (item.classList.contains('active')) {
	      idx = self.activeItems.indexOf(item);
	      self.activeItems.splice(idx, 1);
	      removeClasses(item, 'active');
	    }

	    self.items.splice(i, 1);
	    self.lastQuery = null;

	    if (!self.settings.persist && self.userOptions.hasOwnProperty(value)) {
	      self.removeOption(value, silent);
	    }

	    if (i < self.caretPos) {
	      self.setCaret(self.caretPos - 1);
	    }

	    self.updateOriginalInput({
	      silent: silent
	    });
	    self.refreshState();
	    self.positionDropdown();
	    self.trigger('item_remove', value, item);
	  }
	  /**
	   * Invokes the `create` method provided in the
	   * TomSelect options that should provide the data
	   * for the new item, given the user input.
	   *
	   * Once this completes, it will be added
	   * to the item list.
	   *
	   */


	  createItem(input = null, callback = () => {}) {
	    // triggerDropdown parameter @deprecated 2.1.1
	    if (arguments.length === 3) {
	      callback = arguments[2];
	    }

	    if (typeof callback != 'function') {
	      callback = () => {};
	    }

	    var self = this;
	    var caret = self.caretPos;
	    var output;
	    input = input || self.inputValue();

	    if (!self.canCreate(input)) {
	      callback();
	      return false;
	    }

	    self.lock();
	    var created = false;

	    var create = data => {
	      self.unlock();
	      if (!data || typeof data !== 'object') return callback();
	      var value = hash_key(data[self.settings.valueField]);

	      if (typeof value !== 'string') {
	        return callback();
	      }

	      self.setTextboxValue();
	      self.addOption(data, true);
	      self.setCaret(caret);
	      self.addItem(value);
	      callback(data);
	      created = true;
	    };

	    if (typeof self.settings.create === 'function') {
	      output = self.settings.create.call(this, input, create);
	    } else {
	      output = {
	        [self.settings.labelField]: input,
	        [self.settings.valueField]: input
	      };
	    }

	    if (!created) {
	      create(output);
	    }

	    return true;
	  }
	  /**
	   * Re-renders the selected item lists.
	   */


	  refreshItems() {
	    var self = this;
	    self.lastQuery = null;

	    if (self.isSetup) {
	      self.addItems(self.items);
	    }

	    self.updateOriginalInput();
	    self.refreshState();
	  }
	  /**
	   * Updates all state-dependent attributes
	   * and CSS classes.
	   */


	  refreshState() {
	    const self = this;
	    self.refreshValidityState();
	    const isFull = self.isFull();
	    const isLocked = self.isLocked;
	    self.wrapper.classList.toggle('rtl', self.rtl);
	    const wrap_classList = self.wrapper.classList;
	    wrap_classList.toggle('focus', self.isFocused);
	    wrap_classList.toggle('disabled', self.isDisabled);
	    wrap_classList.toggle('required', self.isRequired);
	    wrap_classList.toggle('invalid', !self.isValid);
	    wrap_classList.toggle('locked', isLocked);
	    wrap_classList.toggle('full', isFull);
	    wrap_classList.toggle('input-active', self.isFocused && !self.isInputHidden);
	    wrap_classList.toggle('dropdown-active', self.isOpen);
	    wrap_classList.toggle('has-options', isEmptyObject(self.options));
	    wrap_classList.toggle('has-items', self.items.length > 0);
	  }
	  /**
	   * Update the `required` attribute of both input and control input.
	   *
	   * The `required` property needs to be activated on the control input
	   * for the error to be displayed at the right place. `required` also
	   * needs to be temporarily deactivated on the input since the input is
	   * hidden and can't show errors.
	   */


	  refreshValidityState() {
	    var self = this;

	    if (!self.input.validity) {
	      return;
	    }

	    self.isValid = self.input.validity.valid;
	    self.isInvalid = !self.isValid;
	  }
	  /**
	   * Determines whether or not more items can be added
	   * to the control without exceeding the user-defined maximum.
	   *
	   * @returns {boolean}
	   */


	  isFull() {
	    return this.settings.maxItems !== null && this.items.length >= this.settings.maxItems;
	  }
	  /**
	   * Refreshes the original <select> or <input>
	   * element to reflect the current state.
	   *
	   */


	  updateOriginalInput(opts = {}) {
	    const self = this;
	    var option, label;
	    const empty_option = self.input.querySelector('option[value=""]');

	    if (self.is_select_tag) {
	      const selected = [];
	      const has_selected = self.input.querySelectorAll('option:checked').length;

	      function AddSelected(option_el, value, label) {
	        if (!option_el) {
	          option_el = getDom('<option value="' + escape_html(value) + '">' + escape_html(label) + '</option>');
	        } // don't move empty option from top of list
	        // fixes bug in firefox https://bugzilla.mozilla.org/show_bug.cgi?id=1725293


	        if (option_el != empty_option) {
	          self.input.append(option_el);
	        }

	        selected.push(option_el); // marking empty option as selected can break validation
	        // fixes https://github.com/orchidjs/tom-select/issues/303

	        if (option_el != empty_option || has_selected > 0) {
	          option_el.selected = true;
	        }

	        return option_el;
	      } // unselect all selected options


	      self.input.querySelectorAll('option:checked').forEach(option_el => {
	        option_el.selected = false;
	      }); // nothing selected?

	      if (self.items.length == 0 && self.settings.mode == 'single') {
	        AddSelected(empty_option, "", ""); // order selected <option> tags for values in self.items
	      } else {
	        self.items.forEach(value => {
	          option = self.options[value];
	          label = option[self.settings.labelField] || '';

	          if (selected.includes(option.$option)) {
	            const reuse_opt = self.input.querySelector(`option[value="${addSlashes(value)}"]:not(:checked)`);
	            AddSelected(reuse_opt, value, label);
	          } else {
	            option.$option = AddSelected(option.$option, value, label);
	          }
	        });
	      }
	    } else {
	      self.input.value = self.getValue();
	    }

	    if (self.isSetup) {
	      if (!opts.silent) {
	        self.trigger('change', self.getValue());
	      }
	    }
	  }
	  /**
	   * Shows the autocomplete dropdown containing
	   * the available options.
	   */


	  open() {
	    var self = this;
	    if (self.isLocked || self.isOpen || self.settings.mode === 'multi' && self.isFull()) return;
	    self.isOpen = true;
	    setAttr(self.focus_node, {
	      'aria-expanded': 'true'
	    });
	    self.refreshState();
	    applyCSS(self.dropdown, {
	      visibility: 'hidden',
	      display: 'block'
	    });
	    self.positionDropdown();
	    applyCSS(self.dropdown, {
	      visibility: 'visible',
	      display: 'block'
	    });
	    self.focus();
	    self.trigger('dropdown_open', self.dropdown);
	  }
	  /**
	   * Closes the autocomplete dropdown menu.
	   */


	  close(setTextboxValue = true) {
	    var self = this;
	    var trigger = self.isOpen;

	    if (setTextboxValue) {
	      // before blur() to prevent form onchange event
	      self.setTextboxValue();

	      if (self.settings.mode === 'single' && self.items.length) {
	        self.hideInput();
	      }
	    }

	    self.isOpen = false;
	    setAttr(self.focus_node, {
	      'aria-expanded': 'false'
	    });
	    applyCSS(self.dropdown, {
	      display: 'none'
	    });

	    if (self.settings.hideSelected) {
	      self.clearActiveOption();
	    }

	    self.refreshState();
	    if (trigger) self.trigger('dropdown_close', self.dropdown);
	  }
	  /**
	   * Calculates and applies the appropriate
	   * position of the dropdown if dropdownParent = 'body'.
	   * Otherwise, position is determined by css
	   */


	  positionDropdown() {
	    if (this.settings.dropdownParent !== 'body') {
	      return;
	    }

	    var context = this.control;
	    var rect = context.getBoundingClientRect();
	    var top = context.offsetHeight + rect.top + window.scrollY;
	    var left = rect.left + window.scrollX;
	    applyCSS(this.dropdown, {
	      width: rect.width + 'px',
	      top: top + 'px',
	      left: left + 'px'
	    });
	  }
	  /**
	   * Resets / clears all selected items
	   * from the control.
	   *
	   */


	  clear(silent) {
	    var self = this;
	    if (!self.items.length) return;
	    var items = self.controlChildren();
	    iterate$1(items, item => {
	      self.removeItem(item, true);
	    });
	    self.showInput();
	    if (!silent) self.updateOriginalInput();
	    self.trigger('clear');
	  }
	  /**
	   * A helper method for inserting an element
	   * at the current caret position.
	   *
	   */


	  insertAtCaret(el) {
	    const self = this;
	    const caret = self.caretPos;
	    const target = self.control;
	    target.insertBefore(el, target.children[caret] || null);
	    self.setCaret(caret + 1);
	  }
	  /**
	   * Removes the current selected item(s).
	   *
	   */


	  deleteSelection(e) {
	    var direction, selection, caret, tail;
	    var self = this;
	    direction = e && e.keyCode === KEY_BACKSPACE ? -1 : 1;
	    selection = getSelection(self.control_input); // determine items that will be removed

	    const rm_items = [];

	    if (self.activeItems.length) {
	      tail = getTail(self.activeItems, direction);
	      caret = nodeIndex(tail);

	      if (direction > 0) {
	        caret++;
	      }

	      iterate$1(self.activeItems, item => rm_items.push(item));
	    } else if ((self.isFocused || self.settings.mode === 'single') && self.items.length) {
	      const items = self.controlChildren();
	      let rm_item;

	      if (direction < 0 && selection.start === 0 && selection.length === 0) {
	        rm_item = items[self.caretPos - 1];
	      } else if (direction > 0 && selection.start === self.inputValue().length) {
	        rm_item = items[self.caretPos];
	      }

	      if (rm_item !== undefined) {
	        rm_items.push(rm_item);
	      }
	    }

	    if (!self.shouldDelete(rm_items, e)) {
	      return false;
	    }

	    preventDefault(e, true); // perform removal

	    if (typeof caret !== 'undefined') {
	      self.setCaret(caret);
	    }

	    while (rm_items.length) {
	      self.removeItem(rm_items.pop());
	    }

	    self.showInput();
	    self.positionDropdown();
	    self.refreshOptions(false);
	    return true;
	  }
	  /**
	   * Return true if the items should be deleted
	   */


	  shouldDelete(items, evt) {
	    const values = items.map(item => item.dataset.value); // allow the callback to abort

	    if (!values.length || typeof this.settings.onDelete === 'function' && this.settings.onDelete(values, evt) === false) {
	      return false;
	    }

	    return true;
	  }
	  /**
	   * Selects the previous / next item (depending on the `direction` argument).
	   *
	   * > 0 - right
	   * < 0 - left
	   *
	   */


	  advanceSelection(direction, e) {
	    var last_active,
	        adjacent,
	        self = this;
	    if (self.rtl) direction *= -1;
	    if (self.inputValue().length) return; // add or remove to active items

	    if (isKeyDown(KEY_SHORTCUT, e) || isKeyDown('shiftKey', e)) {
	      last_active = self.getLastActive(direction);

	      if (last_active) {
	        if (!last_active.classList.contains('active')) {
	          adjacent = last_active;
	        } else {
	          adjacent = self.getAdjacent(last_active, direction, 'item');
	        } // if no active item, get items adjacent to the control input

	      } else if (direction > 0) {
	        adjacent = self.control_input.nextElementSibling;
	      } else {
	        adjacent = self.control_input.previousElementSibling;
	      }

	      if (adjacent) {
	        if (adjacent.classList.contains('active')) {
	          self.removeActiveItem(last_active);
	        }

	        self.setActiveItemClass(adjacent); // mark as last_active !! after removeActiveItem() on last_active
	      } // move caret to the left or right

	    } else {
	      self.moveCaret(direction);
	    }
	  }

	  moveCaret(direction) {}
	  /**
	   * Get the last active item
	   *
	   */


	  getLastActive(direction) {
	    let last_active = this.control.querySelector('.last-active');

	    if (last_active) {
	      return last_active;
	    }

	    var result = this.control.querySelectorAll('.active');

	    if (result) {
	      return getTail(result, direction);
	    }
	  }
	  /**
	   * Moves the caret to the specified index.
	   *
	   * The input must be moved by leaving it in place and moving the
	   * siblings, due to the fact that focus cannot be restored once lost
	   * on mobile webkit devices
	   *
	   */


	  setCaret(new_pos) {
	    this.caretPos = this.items.length;
	  }
	  /**
	   * Return list of item dom elements
	   *
	   */


	  controlChildren() {
	    return Array.from(this.control.querySelectorAll('[data-ts-item]'));
	  }
	  /**
	   * Disables user input on the control. Used while
	   * items are being asynchronously created.
	   */


	  lock() {
	    this.isLocked = true;
	    this.refreshState();
	  }
	  /**
	   * Re-enables user input on the control.
	   */


	  unlock() {
	    this.isLocked = false;
	    this.refreshState();
	  }
	  /**
	   * Disables user input on the control completely.
	   * While disabled, it cannot receive focus.
	   */


	  disable() {
	    var self = this;
	    self.input.disabled = true;
	    self.control_input.disabled = true;
	    self.focus_node.tabIndex = -1;
	    self.isDisabled = true;
	    this.close();
	    self.lock();
	  }
	  /**
	   * Enables the control so that it can respond
	   * to focus and user input.
	   */


	  enable() {
	    var self = this;
	    self.input.disabled = false;
	    self.control_input.disabled = false;
	    self.focus_node.tabIndex = self.tabIndex;
	    self.isDisabled = false;
	    self.unlock();
	  }
	  /**
	   * Completely destroys the control and
	   * unbinds all event listeners so that it can
	   * be garbage collected.
	   */


	  destroy() {
	    var self = this;
	    var revertSettings = self.revertSettings;
	    self.trigger('destroy');
	    self.off();
	    self.wrapper.remove();
	    self.dropdown.remove();
	    self.input.innerHTML = revertSettings.innerHTML;
	    self.input.tabIndex = revertSettings.tabIndex;
	    removeClasses(self.input, 'tomselected', 'ts-hidden-accessible');

	    self._destroy();

	    delete self.input.tomselect;
	  }
	  /**
	   * A helper method for rendering "item" and
	   * "option" templates, given the data.
	   *
	   */


	  render(templateName, data) {
	    var id, html;
	    const self = this;

	    if (typeof this.settings.render[templateName] !== 'function') {
	      return null;
	    } // render markup


	    html = self.settings.render[templateName].call(this, data, escape_html);

	    if (!html) {
	      return null;
	    }

	    html = getDom(html); // add mandatory attributes

	    if (templateName === 'option' || templateName === 'option_create') {
	      if (data[self.settings.disabledField]) {
	        setAttr(html, {
	          'aria-disabled': 'true'
	        });
	      } else {
	        setAttr(html, {
	          'data-selectable': ''
	        });
	      }
	    } else if (templateName === 'optgroup') {
	      id = data.group[self.settings.optgroupValueField];
	      setAttr(html, {
	        'data-group': id
	      });

	      if (data.group[self.settings.disabledField]) {
	        setAttr(html, {
	          'data-disabled': ''
	        });
	      }
	    }

	    if (templateName === 'option' || templateName === 'item') {
	      const value = get_hash(data[self.settings.valueField]);
	      setAttr(html, {
	        'data-value': value
	      }); // make sure we have some classes if a template is overwritten

	      if (templateName === 'item') {
	        addClasses(html, self.settings.itemClass);
	        setAttr(html, {
	          'data-ts-item': ''
	        });
	      } else {
	        addClasses(html, self.settings.optionClass);
	        setAttr(html, {
	          role: 'option',
	          id: data.$id
	        }); // update cache

	        data.$div = html;
	        self.options[value] = data;
	      }
	    }

	    return html;
	  }
	  /**
	   * Type guarded rendering
	   *
	   */


	  _render(templateName, data) {
	    const html = this.render(templateName, data);

	    if (html == null) {
	      throw 'HTMLElement expected';
	    }

	    return html;
	  }
	  /**
	   * Clears the render cache for a template. If
	   * no template is given, clears all render
	   * caches.
	   *
	   */


	  clearCache() {
	    iterate$1(this.options, option => {
	      if (option.$div) {
	        option.$div.remove();
	        delete option.$div;
	      }
	    });
	  }
	  /**
	   * Removes a value from item and option caches
	   *
	   */


	  uncacheValue(value) {
	    const option_el = this.getOption(value);
	    if (option_el) option_el.remove();
	  }
	  /**
	   * Determines whether or not to display the
	   * create item prompt, given a user input.
	   *
	   */


	  canCreate(input) {
	    return this.settings.create && input.length > 0 && this.settings.createFilter.call(this, input);
	  }
	  /**
	   * Wraps this.`method` so that `new_fn` can be invoked 'before', 'after', or 'instead' of the original method
	   *
	   * this.hook('instead','onKeyDown',function( arg1, arg2 ...){
	   *
	   * });
	   */


	  hook(when, method, new_fn) {
	    var self = this;
	    var orig_method = self[method];

	    self[method] = function () {
	      var result, result_new;

	      if (when === 'after') {
	        result = orig_method.apply(self, arguments);
	      }

	      result_new = new_fn.apply(self, arguments);

	      if (when === 'instead') {
	        return result_new;
	      }

	      if (when === 'before') {
	        result = orig_method.apply(self, arguments);
	      }

	      return result;
	    };
	  }

	}

	/**
	 * Plugin: "change_listener" (Tom Select)
	 * Copyright (c) contributors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
	 * file except in compliance with the License. You may obtain a copy of the License at:
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under
	 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
	 * ANY KIND, either express or implied. See the License for the specific language
	 * governing permissions and limitations under the License.
	 *
	 */
	function change_listener () {
	  addEvent(this.input, 'change', () => {
	    this.sync();
	  });
	}

	/**
	 * Plugin: "restore_on_backspace" (Tom Select)
	 * Copyright (c) contributors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
	 * file except in compliance with the License. You may obtain a copy of the License at:
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under
	 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
	 * ANY KIND, either express or implied. See the License for the specific language
	 * governing permissions and limitations under the License.
	 *
	 */
	function checkbox_options () {
	  var self = this;
	  var orig_onOptionSelect = self.onOptionSelect;
	  self.settings.hideSelected = false; // update the checkbox for an option

	  var UpdateCheckbox = function UpdateCheckbox(option) {
	    setTimeout(() => {
	      var checkbox = option.querySelector('input');

	      if (checkbox instanceof HTMLInputElement) {
	        if (option.classList.contains('selected')) {
	          checkbox.checked = true;
	        } else {
	          checkbox.checked = false;
	        }
	      }
	    }, 1);
	  }; // add checkbox to option template


	  self.hook('after', 'setupTemplates', () => {
	    var orig_render_option = self.settings.render.option;

	    self.settings.render.option = (data, escape_html) => {
	      var rendered = getDom(orig_render_option.call(self, data, escape_html));
	      var checkbox = document.createElement('input');
	      checkbox.addEventListener('click', function (evt) {
	        preventDefault(evt);
	      });
	      checkbox.type = 'checkbox';
	      const hashed = hash_key(data[self.settings.valueField]);

	      if (hashed && self.items.indexOf(hashed) > -1) {
	        checkbox.checked = true;
	      }

	      rendered.prepend(checkbox);
	      return rendered;
	    };
	  }); // uncheck when item removed

	  self.on('item_remove', value => {
	    var option = self.getOption(value);

	    if (option) {
	      // if dropdown hasn't been opened yet, the option won't exist
	      option.classList.remove('selected'); // selected class won't be removed yet

	      UpdateCheckbox(option);
	    }
	  }); // check when item added

	  self.on('item_add', value => {
	    var option = self.getOption(value);

	    if (option) {
	      // if dropdown hasn't been opened yet, the option won't exist
	      UpdateCheckbox(option);
	    }
	  }); // remove items when selected option is clicked

	  self.hook('instead', 'onOptionSelect', (evt, option) => {
	    if (option.classList.contains('selected')) {
	      option.classList.remove('selected');
	      self.removeItem(option.dataset.value);
	      self.refreshOptions();
	      preventDefault(evt, true);
	      return;
	    }

	    orig_onOptionSelect.call(self, evt, option);
	    UpdateCheckbox(option);
	  });
	}

	/**
	 * Plugin: "dropdown_header" (Tom Select)
	 * Copyright (c) contributors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
	 * file except in compliance with the License. You may obtain a copy of the License at:
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under
	 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
	 * ANY KIND, either express or implied. See the License for the specific language
	 * governing permissions and limitations under the License.
	 *
	 */
	function clear_button (userOptions) {
	  const self = this;
	  const options = Object.assign({
	    className: 'clear-button',
	    title: 'Clear All',
	    html: data => {
	      return `<div class="${data.className}" title="${data.title}">&#10799;</div>`;
	    }
	  }, userOptions);
	  self.on('initialize', () => {
	    var button = getDom(options.html(options));
	    button.addEventListener('click', evt => {
	      if (self.isDisabled) {
	        return;
	      }

	      self.clear();

	      if (self.settings.mode === 'single' && self.settings.allowEmptyOption) {
	        self.addItem('');
	      }

	      evt.preventDefault();
	      evt.stopPropagation();
	    });
	    self.control.appendChild(button);
	  });
	}

	/**
	 * Plugin: "drag_drop" (Tom Select)
	 * Copyright (c) contributors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
	 * file except in compliance with the License. You may obtain a copy of the License at:
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under
	 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
	 * ANY KIND, either express or implied. See the License for the specific language
	 * governing permissions and limitations under the License.
	 *
	 */
	function drag_drop () {
	  var self = this;
	  if (!$.fn.sortable) throw new Error('The "drag_drop" plugin requires jQuery UI "sortable".');
	  if (self.settings.mode !== 'multi') return;
	  var orig_lock = self.lock;
	  var orig_unlock = self.unlock;
	  self.hook('instead', 'lock', () => {
	    var sortable = $(self.control).data('sortable');
	    if (sortable) sortable.disable();
	    return orig_lock.call(self);
	  });
	  self.hook('instead', 'unlock', () => {
	    var sortable = $(self.control).data('sortable');
	    if (sortable) sortable.enable();
	    return orig_unlock.call(self);
	  });
	  self.on('initialize', () => {
	    var $control = $(self.control).sortable({
	      items: '[data-value]',
	      forcePlaceholderSize: true,
	      disabled: self.isLocked,
	      start: (e, ui) => {
	        ui.placeholder.css('width', ui.helper.css('width'));
	        $control.css({
	          overflow: 'visible'
	        });
	      },
	      stop: () => {
	        $control.css({
	          overflow: 'hidden'
	        });
	        var values = [];
	        $control.children('[data-value]').each(function () {
	          if (this.dataset.value) values.push(this.dataset.value);
	        });
	        self.setValue(values);
	      }
	    });
	  });
	}

	/**
	 * Plugin: "dropdown_header" (Tom Select)
	 * Copyright (c) contributors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
	 * file except in compliance with the License. You may obtain a copy of the License at:
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under
	 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
	 * ANY KIND, either express or implied. See the License for the specific language
	 * governing permissions and limitations under the License.
	 *
	 */
	function dropdown_header (userOptions) {
	  const self = this;
	  const options = Object.assign({
	    title: 'Untitled',
	    headerClass: 'dropdown-header',
	    titleRowClass: 'dropdown-header-title',
	    labelClass: 'dropdown-header-label',
	    closeClass: 'dropdown-header-close',
	    html: data => {
	      return '<div class="' + data.headerClass + '">' + '<div class="' + data.titleRowClass + '">' + '<span class="' + data.labelClass + '">' + data.title + '</span>' + '<a class="' + data.closeClass + '">&times;</a>' + '</div>' + '</div>';
	    }
	  }, userOptions);
	  self.on('initialize', () => {
	    var header = getDom(options.html(options));
	    var close_link = header.querySelector('.' + options.closeClass);

	    if (close_link) {
	      close_link.addEventListener('click', evt => {
	        preventDefault(evt, true);
	        self.close();
	      });
	    }

	    self.dropdown.insertBefore(header, self.dropdown.firstChild);
	  });
	}

	/**
	 * Plugin: "dropdown_input" (Tom Select)
	 * Copyright (c) contributors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
	 * file except in compliance with the License. You may obtain a copy of the License at:
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under
	 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
	 * ANY KIND, either express or implied. See the License for the specific language
	 * governing permissions and limitations under the License.
	 *
	 */
	function caret_position () {
	  var self = this;
	  /**
	   * Moves the caret to the specified index.
	   *
	   * The input must be moved by leaving it in place and moving the
	   * siblings, due to the fact that focus cannot be restored once lost
	   * on mobile webkit devices
	   *
	   */

	  self.hook('instead', 'setCaret', new_pos => {
	    if (self.settings.mode === 'single' || !self.control.contains(self.control_input)) {
	      new_pos = self.items.length;
	    } else {
	      new_pos = Math.max(0, Math.min(self.items.length, new_pos));

	      if (new_pos != self.caretPos && !self.isPending) {
	        self.controlChildren().forEach((child, j) => {
	          if (j < new_pos) {
	            self.control_input.insertAdjacentElement('beforebegin', child);
	          } else {
	            self.control.appendChild(child);
	          }
	        });
	      }
	    }

	    self.caretPos = new_pos;
	  });
	  self.hook('instead', 'moveCaret', direction => {
	    if (!self.isFocused) return; // move caret before or after selected items

	    const last_active = self.getLastActive(direction);

	    if (last_active) {
	      const idx = nodeIndex(last_active);
	      self.setCaret(direction > 0 ? idx + 1 : idx);
	      self.setActiveItem();
	      removeClasses(last_active, 'last-active'); // move caret left or right of current position
	    } else {
	      self.setCaret(self.caretPos + direction);
	    }
	  });
	}

	/**
	 * Plugin: "dropdown_input" (Tom Select)
	 * Copyright (c) contributors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
	 * file except in compliance with the License. You may obtain a copy of the License at:
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under
	 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
	 * ANY KIND, either express or implied. See the License for the specific language
	 * governing permissions and limitations under the License.
	 *
	 */
	function dropdown_input () {
	  const self = this;
	  self.settings.shouldOpen = true; // make sure the input is shown even if there are no options to display in the dropdown

	  self.hook('before', 'setup', () => {
	    self.focus_node = self.control;
	    addClasses(self.control_input, 'dropdown-input');
	    const div = getDom('<div class="dropdown-input-wrap">');
	    div.append(self.control_input);
	    self.dropdown.insertBefore(div, self.dropdown.firstChild); // set a placeholder in the select control

	    const placeholder = getDom('<input class="items-placeholder" tabindex="-1" />');
	    placeholder.placeholder = self.settings.placeholder || '';
	    self.control.append(placeholder);
	  });
	  self.on('initialize', () => {
	    // set tabIndex on control to -1, otherwise [shift+tab] will put focus right back on control_input
	    self.control_input.addEventListener('keydown', evt => {
	      //addEvent(self.control_input,'keydown' as const,(evt:KeyboardEvent) =>{
	      switch (evt.keyCode) {
	        case KEY_ESC:
	          if (self.isOpen) {
	            preventDefault(evt, true);
	            self.close();
	          }

	          self.clearActiveItems();
	          return;

	        case KEY_TAB:
	          self.focus_node.tabIndex = -1;
	          break;
	      }

	      return self.onKeyDown.call(self, evt);
	    });
	    self.on('blur', () => {
	      self.focus_node.tabIndex = self.isDisabled ? -1 : self.tabIndex;
	    }); // give the control_input focus when the dropdown is open

	    self.on('dropdown_open', () => {
	      self.control_input.focus();
	    }); // prevent onBlur from closing when focus is on the control_input

	    const orig_onBlur = self.onBlur;
	    self.hook('instead', 'onBlur', evt => {
	      if (evt && evt.relatedTarget == self.control_input) return;
	      return orig_onBlur.call(self);
	    });
	    addEvent(self.control_input, 'blur', () => self.onBlur()); // return focus to control to allow further keyboard input

	    self.hook('before', 'close', () => {
	      if (!self.isOpen) return;
	      self.focus_node.focus({
	        preventScroll: true
	      });
	    });
	  });
	}

	/**
	 * Plugin: "input_autogrow" (Tom Select)
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
	 * file except in compliance with the License. You may obtain a copy of the License at:
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under
	 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
	 * ANY KIND, either express or implied. See the License for the specific language
	 * governing permissions and limitations under the License.
	 *
	 */
	function input_autogrow () {
	  var self = this;
	  self.on('initialize', () => {
	    var test_input = document.createElement('span');
	    var control = self.control_input;
	    test_input.style.cssText = 'position:absolute; top:-99999px; left:-99999px; width:auto; padding:0; white-space:pre; ';
	    self.wrapper.appendChild(test_input);
	    var transfer_styles = ['letterSpacing', 'fontSize', 'fontFamily', 'fontWeight', 'textTransform'];

	    for (const style_name of transfer_styles) {
	      // @ts-ignore TS7015 https://stackoverflow.com/a/50506154/697576
	      test_input.style[style_name] = control.style[style_name];
	    }
	    /**
	     * Set the control width
	     *
	     */


	    var resize = () => {
	      test_input.textContent = control.value;
	      control.style.width = test_input.clientWidth + 'px';
	    };

	    resize();
	    self.on('update item_add item_remove', resize);
	    addEvent(control, 'input', resize);
	    addEvent(control, 'keyup', resize);
	    addEvent(control, 'blur', resize);
	    addEvent(control, 'update', resize);
	  });
	}

	/**
	 * Plugin: "input_autogrow" (Tom Select)
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
	 * file except in compliance with the License. You may obtain a copy of the License at:
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under
	 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
	 * ANY KIND, either express or implied. See the License for the specific language
	 * governing permissions and limitations under the License.
	 *
	 */
	function no_backspace_delete () {
	  var self = this;
	  var orig_deleteSelection = self.deleteSelection;
	  this.hook('instead', 'deleteSelection', evt => {
	    if (self.activeItems.length) {
	      return orig_deleteSelection.call(self, evt);
	    }

	    return false;
	  });
	}

	/**
	 * Plugin: "no_active_items" (Tom Select)
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
	 * file except in compliance with the License. You may obtain a copy of the License at:
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under
	 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
	 * ANY KIND, either express or implied. See the License for the specific language
	 * governing permissions and limitations under the License.
	 *
	 */
	function no_active_items () {
	  this.hook('instead', 'setActiveItem', () => {});
	  this.hook('instead', 'selectAll', () => {});
	}

	/**
	 * Plugin: "optgroup_columns" (Tom Select.js)
	 * Copyright (c) contributors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
	 * file except in compliance with the License. You may obtain a copy of the License at:
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under
	 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
	 * ANY KIND, either express or implied. See the License for the specific language
	 * governing permissions and limitations under the License.
	 *
	 */
	function optgroup_columns () {
	  var self = this;
	  var orig_keydown = self.onKeyDown;
	  self.hook('instead', 'onKeyDown', evt => {
	    var index, option, options, optgroup;

	    if (!self.isOpen || !(evt.keyCode === KEY_LEFT || evt.keyCode === KEY_RIGHT)) {
	      return orig_keydown.call(self, evt);
	    }

	    self.ignoreHover = true;
	    optgroup = parentMatch(self.activeOption, '[data-group]');
	    index = nodeIndex(self.activeOption, '[data-selectable]');

	    if (!optgroup) {
	      return;
	    }

	    if (evt.keyCode === KEY_LEFT) {
	      optgroup = optgroup.previousSibling;
	    } else {
	      optgroup = optgroup.nextSibling;
	    }

	    if (!optgroup) {
	      return;
	    }

	    options = optgroup.querySelectorAll('[data-selectable]');
	    option = options[Math.min(options.length - 1, index)];

	    if (option) {
	      self.setActiveOption(option);
	    }
	  });
	}

	/**
	 * Plugin: "remove_button" (Tom Select)
	 * Copyright (c) contributors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
	 * file except in compliance with the License. You may obtain a copy of the License at:
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under
	 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
	 * ANY KIND, either express or implied. See the License for the specific language
	 * governing permissions and limitations under the License.
	 *
	 */
	function remove_button (userOptions) {
	  const options = Object.assign({
	    label: '&times;',
	    title: 'Remove',
	    className: 'remove',
	    append: true
	  }, userOptions); //options.className = 'remove-single';

	  var self = this; // override the render method to add remove button to each item

	  if (!options.append) {
	    return;
	  }

	  var html = '<a href="javascript:void(0)" class="' + options.className + '" tabindex="-1" title="' + escape_html(options.title) + '">' + options.label + '</a>';
	  self.hook('after', 'setupTemplates', () => {
	    var orig_render_item = self.settings.render.item;

	    self.settings.render.item = (data, escape) => {
	      var item = getDom(orig_render_item.call(self, data, escape));
	      var close_button = getDom(html);
	      item.appendChild(close_button);
	      addEvent(close_button, 'mousedown', evt => {
	        preventDefault(evt, true);
	      });
	      addEvent(close_button, 'click', evt => {
	        // propagating will trigger the dropdown to show for single mode
	        preventDefault(evt, true);
	        if (self.isLocked) return;
	        if (!self.shouldDelete([item], evt)) return;
	        self.removeItem(item);
	        self.refreshOptions(false);
	        self.inputState();
	      });
	      return item;
	    };
	  });
	}

	/**
	 * Plugin: "restore_on_backspace" (Tom Select)
	 * Copyright (c) contributors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
	 * file except in compliance with the License. You may obtain a copy of the License at:
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under
	 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
	 * ANY KIND, either express or implied. See the License for the specific language
	 * governing permissions and limitations under the License.
	 *
	 */
	function restore_on_backspace (userOptions) {
	  const self = this;
	  const options = Object.assign({
	    text: option => {
	      return option[self.settings.labelField];
	    }
	  }, userOptions);
	  self.on('item_remove', function (value) {
	    if (!self.isFocused) {
	      return;
	    }

	    if (self.control_input.value.trim() === '') {
	      var option = self.options[value];

	      if (option) {
	        self.setTextboxValue(options.text.call(self, option));
	      }
	    }
	  });
	}

	/**
	 * Plugin: "restore_on_backspace" (Tom Select)
	 * Copyright (c) contributors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
	 * file except in compliance with the License. You may obtain a copy of the License at:
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software distributed under
	 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
	 * ANY KIND, either express or implied. See the License for the specific language
	 * governing permissions and limitations under the License.
	 *
	 */
	function virtual_scroll () {
	  const self = this;
	  const orig_canLoad = self.canLoad;
	  const orig_clearActiveOption = self.clearActiveOption;
	  const orig_loadCallback = self.loadCallback;
	  var pagination = {};
	  var dropdown_content;
	  var loading_more = false;
	  var load_more_opt;
	  var default_values = [];

	  if (!self.settings.shouldLoadMore) {
	    // return true if additional results should be loaded
	    self.settings.shouldLoadMore = () => {
	      const scroll_percent = dropdown_content.clientHeight / (dropdown_content.scrollHeight - dropdown_content.scrollTop);

	      if (scroll_percent > 0.9) {
	        return true;
	      }

	      if (self.activeOption) {
	        var selectable = self.selectable();
	        var index = Array.from(selectable).indexOf(self.activeOption);

	        if (index >= selectable.length - 2) {
	          return true;
	        }
	      }

	      return false;
	    };
	  }

	  if (!self.settings.firstUrl) {
	    throw 'virtual_scroll plugin requires a firstUrl() method';
	  } // in order for virtual scrolling to work,
	  // options need to be ordered the same way they're returned from the remote data source


	  self.settings.sortField = [{
	    field: '$order'
	  }, {
	    field: '$score'
	  }]; // can we load more results for given query?

	  const canLoadMore = query => {
	    if (typeof self.settings.maxOptions === 'number' && dropdown_content.children.length >= self.settings.maxOptions) {
	      return false;
	    }

	    if (query in pagination && pagination[query]) {
	      return true;
	    }

	    return false;
	  };

	  const clearFilter = (option, value) => {
	    if (self.items.indexOf(value) >= 0 || default_values.indexOf(value) >= 0) {
	      return true;
	    }

	    return false;
	  }; // set the next url that will be


	  self.setNextUrl = (value, next_url) => {
	    pagination[value] = next_url;
	  }; // getUrl() to be used in settings.load()


	  self.getUrl = query => {
	    if (query in pagination) {
	      const next_url = pagination[query];
	      pagination[query] = false;
	      return next_url;
	    } // if the user goes back to a previous query
	    // we need to load the first page again


	    pagination = {};
	    return self.settings.firstUrl.call(self, query);
	  }; // don't clear the active option (and cause unwanted dropdown scroll)
	  // while loading more results


	  self.hook('instead', 'clearActiveOption', () => {
	    if (loading_more) {
	      return;
	    }

	    return orig_clearActiveOption.call(self);
	  }); // override the canLoad method

	  self.hook('instead', 'canLoad', query => {
	    // first time the query has been seen
	    if (!(query in pagination)) {
	      return orig_canLoad.call(self, query);
	    }

	    return canLoadMore(query);
	  }); // wrap the load

	  self.hook('instead', 'loadCallback', (options, optgroups) => {
	    if (!loading_more) {
	      self.clearOptions(clearFilter);
	    } else if (load_more_opt) {
	      const first_option = options[0];

	      if (first_option !== undefined) {
	        load_more_opt.dataset.value = first_option[self.settings.valueField];
	      }
	    }

	    orig_loadCallback.call(self, options, optgroups);
	    loading_more = false;
	  }); // add templates to dropdown
	  //	loading_more if we have another url in the queue
	  //	no_more_results if we don't have another url in the queue

	  self.hook('after', 'refreshOptions', () => {
	    const query = self.lastValue;
	    var option;

	    if (canLoadMore(query)) {
	      option = self.render('loading_more', {
	        query: query
	      });

	      if (option) {
	        option.setAttribute('data-selectable', ''); // so that navigating dropdown with [down] keypresses can navigate to this node

	        load_more_opt = option;
	      }
	    } else if (query in pagination && !dropdown_content.querySelector('.no-results')) {
	      option = self.render('no_more_results', {
	        query: query
	      });
	    }

	    if (option) {
	      addClasses(option, self.settings.optionClass);
	      dropdown_content.append(option);
	    }
	  }); // add scroll listener and default templates

	  self.on('initialize', () => {
	    default_values = Object.keys(self.options);
	    dropdown_content = self.dropdown_content; // default templates

	    self.settings.render = Object.assign({}, {
	      loading_more: () => {
	        return `<div class="loading-more-results">Loading more results ... </div>`;
	      },
	      no_more_results: () => {
	        return `<div class="no-more-results">No more results</div>`;
	      }
	    }, self.settings.render); // watch dropdown content scroll position

	    dropdown_content.addEventListener('scroll', () => {
	      if (!self.settings.shouldLoadMore.call(self)) {
	        return;
	      } // !important: this will get checked again in load() but we still need to check here otherwise loading_more will be set to true


	      if (!canLoadMore(self.lastValue)) {
	        return;
	      } // don't call load() too much


	      if (loading_more) return;
	      loading_more = true;
	      self.load.call(self, self.lastValue);
	    });
	  });
	}

	TomSelect.define('change_listener', change_listener);
	TomSelect.define('checkbox_options', checkbox_options);
	TomSelect.define('clear_button', clear_button);
	TomSelect.define('drag_drop', drag_drop);
	TomSelect.define('dropdown_header', dropdown_header);
	TomSelect.define('caret_position', caret_position);
	TomSelect.define('dropdown_input', dropdown_input);
	TomSelect.define('input_autogrow', input_autogrow);
	TomSelect.define('no_backspace_delete', no_backspace_delete);
	TomSelect.define('no_active_items', no_active_items);
	TomSelect.define('optgroup_columns', optgroup_columns);
	TomSelect.define('remove_button', remove_button);
	TomSelect.define('restore_on_backspace', restore_on_backspace);
	TomSelect.define('virtual_scroll', virtual_scroll);

	return TomSelect;

}));
var tomSelect=function(el,opts){return new TomSelect(el,opts);} 
//# sourceMappingURL=tom-select.complete.js.map


/***/ }),

/***/ "./node_modules/luxon/src/datetime.js":
/*!********************************************!*\
  !*** ./node_modules/luxon/src/datetime.js ***!
  \********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ DateTime; },
/* harmony export */   friendlyDateTime: function() { return /* binding */ friendlyDateTime; }
/* harmony export */ });
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./duration.js */ "./node_modules/luxon/src/duration.js");
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./interval.js */ "./node_modules/luxon/src/interval.js");
/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./settings.js */ "./node_modules/luxon/src/settings.js");
/* harmony import */ var _info_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./info.js */ "./node_modules/luxon/src/info.js");
/* harmony import */ var _impl_formatter_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./impl/formatter.js */ "./node_modules/luxon/src/impl/formatter.js");
/* harmony import */ var _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./zones/fixedOffsetZone.js */ "./node_modules/luxon/src/zones/fixedOffsetZone.js");
/* harmony import */ var _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./impl/locale.js */ "./node_modules/luxon/src/impl/locale.js");
/* harmony import */ var _impl_util_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./impl/util.js */ "./node_modules/luxon/src/impl/util.js");
/* harmony import */ var _impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./impl/zoneUtil.js */ "./node_modules/luxon/src/impl/zoneUtil.js");
/* harmony import */ var _impl_diff_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./impl/diff.js */ "./node_modules/luxon/src/impl/diff.js");
/* harmony import */ var _impl_regexParser_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./impl/regexParser.js */ "./node_modules/luxon/src/impl/regexParser.js");
/* harmony import */ var _impl_tokenParser_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./impl/tokenParser.js */ "./node_modules/luxon/src/impl/tokenParser.js");
/* harmony import */ var _impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./impl/conversions.js */ "./node_modules/luxon/src/impl/conversions.js");
/* harmony import */ var _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./impl/formats.js */ "./node_modules/luxon/src/impl/formats.js");
/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./errors.js */ "./node_modules/luxon/src/errors.js");
/* harmony import */ var _impl_invalid_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./impl/invalid.js */ "./node_modules/luxon/src/impl/invalid.js");

















const INVALID = "Invalid DateTime";
const MAX_DATE = 8.64e15;

function unsupportedZone(zone) {
  return new _impl_invalid_js__WEBPACK_IMPORTED_MODULE_15__["default"]("unsupported zone", `the zone "${zone.name}" is not supported`);
}

// we cache week data on the DT object and this intermediates the cache
function possiblyCachedWeekData(dt) {
  if (dt.weekData === null) {
    dt.weekData = (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.gregorianToWeek)(dt.c);
  }
  return dt.weekData;
}

// clone really means, "make a new object with these modifications". all "setters" really use this
// to create a new object while only changing some of the properties
function clone(inst, alts) {
  const current = {
    ts: inst.ts,
    zone: inst.zone,
    c: inst.c,
    o: inst.o,
    loc: inst.loc,
    invalid: inst.invalid,
  };
  return new DateTime({ ...current, ...alts, old: current });
}

// find the right offset a given local time. The o input is our guess, which determines which
// offset we'll pick in ambiguous cases (e.g. there are two 3 AMs b/c Fallback DST)
function fixOffset(localTS, o, tz) {
  // Our UTC time is just a guess because our offset is just a guess
  let utcGuess = localTS - o * 60 * 1000;

  // Test whether the zone matches the offset for this ts
  const o2 = tz.offset(utcGuess);

  // If so, offset didn't change and we're done
  if (o === o2) {
    return [utcGuess, o];
  }

  // If not, change the ts by the difference in the offset
  utcGuess -= (o2 - o) * 60 * 1000;

  // If that gives us the local time we want, we're done
  const o3 = tz.offset(utcGuess);
  if (o2 === o3) {
    return [utcGuess, o2];
  }

  // If it's different, we're in a hole time. The offset has changed, but the we don't adjust the time
  return [localTS - Math.min(o2, o3) * 60 * 1000, Math.max(o2, o3)];
}

// convert an epoch timestamp into a calendar object with the given offset
function tsToObj(ts, offset) {
  ts += offset * 60 * 1000;

  const d = new Date(ts);

  return {
    year: d.getUTCFullYear(),
    month: d.getUTCMonth() + 1,
    day: d.getUTCDate(),
    hour: d.getUTCHours(),
    minute: d.getUTCMinutes(),
    second: d.getUTCSeconds(),
    millisecond: d.getUTCMilliseconds(),
  };
}

// convert a calendar object to a epoch timestamp
function objToTS(obj, offset, zone) {
  return fixOffset((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.objToLocalTS)(obj), offset, zone);
}

// create a new DT instance by adding a duration, adjusting for DSTs
function adjustTime(inst, dur) {
  const oPre = inst.o,
    year = inst.c.year + Math.trunc(dur.years),
    month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3,
    c = {
      ...inst.c,
      year,
      month,
      day:
        Math.min(inst.c.day, (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.daysInMonth)(year, month)) +
        Math.trunc(dur.days) +
        Math.trunc(dur.weeks) * 7,
    },
    millisToAdd = _duration_js__WEBPACK_IMPORTED_MODULE_0__["default"].fromObject({
      years: dur.years - Math.trunc(dur.years),
      quarters: dur.quarters - Math.trunc(dur.quarters),
      months: dur.months - Math.trunc(dur.months),
      weeks: dur.weeks - Math.trunc(dur.weeks),
      days: dur.days - Math.trunc(dur.days),
      hours: dur.hours,
      minutes: dur.minutes,
      seconds: dur.seconds,
      milliseconds: dur.milliseconds,
    }).as("milliseconds"),
    localTS = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.objToLocalTS)(c);

  let [ts, o] = fixOffset(localTS, oPre, inst.zone);

  if (millisToAdd !== 0) {
    ts += millisToAdd;
    // that could have changed the offset by going over a DST, but we want to keep the ts the same
    o = inst.zone.offset(ts);
  }

  return { ts, o };
}

// helper useful in turning the results of parsing into real dates
// by handling the zone options
function parseDataToDateTime(parsed, parsedZone, opts, format, text, specificOffset) {
  const { setZone, zone } = opts;
  if ((parsed && Object.keys(parsed).length !== 0) || parsedZone) {
    const interpretationZone = parsedZone || zone,
      inst = DateTime.fromObject(parsed, {
        ...opts,
        zone: interpretationZone,
        specificOffset,
      });
    return setZone ? inst : inst.setZone(zone);
  } else {
    return DateTime.invalid(
      new _impl_invalid_js__WEBPACK_IMPORTED_MODULE_15__["default"]("unparsable", `the input "${text}" can't be parsed as ${format}`)
    );
  }
}

// if you want to output a technical format (e.g. RFC 2822), this helper
// helps handle the details
function toTechFormat(dt, format, allowZ = true) {
  return dt.isValid
    ? _impl_formatter_js__WEBPACK_IMPORTED_MODULE_4__["default"].create(_impl_locale_js__WEBPACK_IMPORTED_MODULE_6__["default"].create("en-US"), {
        allowZ,
        forceSimple: true,
      }).formatDateTimeFromString(dt, format)
    : null;
}

function toISODate(o, extended) {
  const longFormat = o.c.year > 9999 || o.c.year < 0;
  let c = "";
  if (longFormat && o.c.year >= 0) c += "+";
  c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(o.c.year, longFormat ? 6 : 4);

  if (extended) {
    c += "-";
    c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(o.c.month);
    c += "-";
    c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(o.c.day);
  } else {
    c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(o.c.month);
    c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(o.c.day);
  }
  return c;
}

function toISOTime(
  o,
  extended,
  suppressSeconds,
  suppressMilliseconds,
  includeOffset,
  extendedZone
) {
  let c = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(o.c.hour);
  if (extended) {
    c += ":";
    c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(o.c.minute);
    if (o.c.millisecond !== 0 || o.c.second !== 0 || !suppressSeconds) {
      c += ":";
    }
  } else {
    c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(o.c.minute);
  }

  if (o.c.millisecond !== 0 || o.c.second !== 0 || !suppressSeconds) {
    c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(o.c.second);

    if (o.c.millisecond !== 0 || !suppressMilliseconds) {
      c += ".";
      c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(o.c.millisecond, 3);
    }
  }

  if (includeOffset) {
    if (o.isOffsetFixed && o.offset === 0 && !extendedZone) {
      c += "Z";
    } else if (o.o < 0) {
      c += "-";
      c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(Math.trunc(-o.o / 60));
      c += ":";
      c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(Math.trunc(-o.o % 60));
    } else {
      c += "+";
      c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(Math.trunc(o.o / 60));
      c += ":";
      c += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.padStart)(Math.trunc(o.o % 60));
    }
  }

  if (extendedZone) {
    c += "[" + o.zone.ianaName + "]";
  }
  return c;
}

// defaults for unspecified units in the supported calendars
const defaultUnitValues = {
    month: 1,
    day: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0,
  },
  defaultWeekUnitValues = {
    weekNumber: 1,
    weekday: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0,
  },
  defaultOrdinalUnitValues = {
    ordinal: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0,
  };

// Units in the supported calendars, sorted by bigness
const orderedUnits = ["year", "month", "day", "hour", "minute", "second", "millisecond"],
  orderedWeekUnits = [
    "weekYear",
    "weekNumber",
    "weekday",
    "hour",
    "minute",
    "second",
    "millisecond",
  ],
  orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];

// standardize case and plurality in units
function normalizeUnit(unit) {
  const normalized = {
    year: "year",
    years: "year",
    month: "month",
    months: "month",
    day: "day",
    days: "day",
    hour: "hour",
    hours: "hour",
    minute: "minute",
    minutes: "minute",
    quarter: "quarter",
    quarters: "quarter",
    second: "second",
    seconds: "second",
    millisecond: "millisecond",
    milliseconds: "millisecond",
    weekday: "weekday",
    weekdays: "weekday",
    weeknumber: "weekNumber",
    weeksnumber: "weekNumber",
    weeknumbers: "weekNumber",
    weekyear: "weekYear",
    weekyears: "weekYear",
    ordinal: "ordinal",
  }[unit.toLowerCase()];

  if (!normalized) throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidUnitError(unit);

  return normalized;
}

// this is a dumbed down version of fromObject() that runs about 60% faster
// but doesn't do any validation, makes a bunch of assumptions about what units
// are present, and so on.
function quickDT(obj, opts) {
  const zone = (0,_impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_8__.normalizeZone)(opts.zone, _settings_js__WEBPACK_IMPORTED_MODULE_2__["default"].defaultZone),
    loc = _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__["default"].fromObject(opts),
    tsNow = _settings_js__WEBPACK_IMPORTED_MODULE_2__["default"].now();

  let ts, o;

  // assume we have the higher-order units
  if (!(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(obj.year)) {
    for (const u of orderedUnits) {
      if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(obj[u])) {
        obj[u] = defaultUnitValues[u];
      }
    }

    const invalid = (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.hasInvalidGregorianData)(obj) || (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.hasInvalidTimeData)(obj);
    if (invalid) {
      return DateTime.invalid(invalid);
    }

    const offsetProvis = zone.offset(tsNow);
    [ts, o] = objToTS(obj, offsetProvis, zone);
  } else {
    ts = tsNow;
  }

  return new DateTime({ ts, zone, loc, o });
}

function diffRelative(start, end, opts) {
  const round = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(opts.round) ? true : opts.round,
    format = (c, unit) => {
      c = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.roundTo)(c, round || opts.calendary ? 0 : 2, true);
      const formatter = end.loc.clone(opts).relFormatter(opts);
      return formatter.format(c, unit);
    },
    differ = (unit) => {
      if (opts.calendary) {
        if (!end.hasSame(start, unit)) {
          return end.startOf(unit).diff(start.startOf(unit), unit).get(unit);
        } else return 0;
      } else {
        return end.diff(start, unit).get(unit);
      }
    };

  if (opts.unit) {
    return format(differ(opts.unit), opts.unit);
  }

  for (const unit of opts.units) {
    const count = differ(unit);
    if (Math.abs(count) >= 1) {
      return format(count, unit);
    }
  }
  return format(start > end ? -0 : 0, opts.units[opts.units.length - 1]);
}

function lastOpts(argList) {
  let opts = {},
    args;
  if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
    opts = argList[argList.length - 1];
    args = Array.from(argList).slice(0, argList.length - 1);
  } else {
    args = Array.from(argList);
  }
  return [opts, args];
}

/**
 * A DateTime is an immutable data structure representing a specific date and time and accompanying methods. It contains class and instance methods for creating, parsing, interrogating, transforming, and formatting them.
 *
 * A DateTime comprises of:
 * * A timestamp. Each DateTime instance refers to a specific millisecond of the Unix epoch.
 * * A time zone. Each instance is considered in the context of a specific zone (by default the local system's zone).
 * * Configuration properties that effect how output strings are formatted, such as `locale`, `numberingSystem`, and `outputCalendar`.
 *
 * Here is a brief overview of the most commonly used functionality it provides:
 *
 * * **Creation**: To create a DateTime from its components, use one of its factory class methods: {@link DateTime.local}, {@link DateTime.utc}, and (most flexibly) {@link DateTime.fromObject}. To create one from a standard string format, use {@link DateTime.fromISO}, {@link DateTime.fromHTTP}, and {@link DateTime.fromRFC2822}. To create one from a custom string format, use {@link DateTime.fromFormat}. To create one from a native JS date, use {@link DateTime.fromJSDate}.
 * * **Gregorian calendar and time**: To examine the Gregorian properties of a DateTime individually (i.e as opposed to collectively through {@link DateTime#toObject}), use the {@link DateTime#year}, {@link DateTime#month},
 * {@link DateTime#day}, {@link DateTime#hour}, {@link DateTime#minute}, {@link DateTime#second}, {@link DateTime#millisecond} accessors.
 * * **Week calendar**: For ISO week calendar attributes, see the {@link DateTime#weekYear}, {@link DateTime#weekNumber}, and {@link DateTime#weekday} accessors.
 * * **Configuration** See the {@link DateTime#locale} and {@link DateTime#numberingSystem} accessors.
 * * **Transformation**: To transform the DateTime into other DateTimes, use {@link DateTime#set}, {@link DateTime#reconfigure}, {@link DateTime#setZone}, {@link DateTime#setLocale}, {@link DateTime.plus}, {@link DateTime#minus}, {@link DateTime#endOf}, {@link DateTime#startOf}, {@link DateTime#toUTC}, and {@link DateTime#toLocal}.
 * * **Output**: To convert the DateTime to other representations, use the {@link DateTime#toRelative}, {@link DateTime#toRelativeCalendar}, {@link DateTime#toJSON}, {@link DateTime#toISO}, {@link DateTime#toHTTP}, {@link DateTime#toObject}, {@link DateTime#toRFC2822}, {@link DateTime#toString}, {@link DateTime#toLocaleString}, {@link DateTime#toFormat}, {@link DateTime#toMillis} and {@link DateTime#toJSDate}.
 *
 * There's plenty others documented below. In addition, for more information on subtler topics like internationalization, time zones, alternative calendars, validity, and so on, see the external documentation.
 */
class DateTime {
  /**
   * @access private
   */
  constructor(config) {
    const zone = config.zone || _settings_js__WEBPACK_IMPORTED_MODULE_2__["default"].defaultZone;

    let invalid =
      config.invalid ||
      (Number.isNaN(config.ts) ? new _impl_invalid_js__WEBPACK_IMPORTED_MODULE_15__["default"]("invalid input") : null) ||
      (!zone.isValid ? unsupportedZone(zone) : null);
    /**
     * @access private
     */
    this.ts = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(config.ts) ? _settings_js__WEBPACK_IMPORTED_MODULE_2__["default"].now() : config.ts;

    let c = null,
      o = null;
    if (!invalid) {
      const unchanged = config.old && config.old.ts === this.ts && config.old.zone.equals(zone);

      if (unchanged) {
        [c, o] = [config.old.c, config.old.o];
      } else {
        const ot = zone.offset(this.ts);
        c = tsToObj(this.ts, ot);
        invalid = Number.isNaN(c.year) ? new _impl_invalid_js__WEBPACK_IMPORTED_MODULE_15__["default"]("invalid input") : null;
        c = invalid ? null : c;
        o = invalid ? null : ot;
      }
    }

    /**
     * @access private
     */
    this._zone = zone;
    /**
     * @access private
     */
    this.loc = config.loc || _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__["default"].create();
    /**
     * @access private
     */
    this.invalid = invalid;
    /**
     * @access private
     */
    this.weekData = null;
    /**
     * @access private
     */
    this.c = c;
    /**
     * @access private
     */
    this.o = o;
    /**
     * @access private
     */
    this.isLuxonDateTime = true;
  }

  // CONSTRUCT

  /**
   * Create a DateTime for the current instant, in the system's time zone.
   *
   * Use Settings to override these default values if needed.
   * @example DateTime.now().toISO() //~> now in the ISO format
   * @return {DateTime}
   */
  static now() {
    return new DateTime({});
  }

  /**
   * Create a local DateTime
   * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month, 1-indexed
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @example DateTime.local()                                  //~> now
   * @example DateTime.local({ zone: "America/New_York" })      //~> now, in US east coast time
   * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00
   * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00
   * @example DateTime.local(2017, 3, 12, { locale: "fr" })     //~> 2017-03-12T00:00:00, with a French locale
   * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00
   * @example DateTime.local(2017, 3, 12, 5, { zone: "utc" })   //~> 2017-03-12T05:00:00, in UTC
   * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00
   * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10
   * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765
   * @return {DateTime}
   */
  static local() {
    const [opts, args] = lastOpts(arguments),
      [year, month, day, hour, minute, second, millisecond] = args;
    return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
  }

  /**
   * Create a DateTime in UTC
   * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @param {Object} options - configuration options for the DateTime
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @example DateTime.utc()                                              //~> now
   * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z
   * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z
   * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: "fr" })          //~> 2017-03-12T05:45:00Z with a French locale
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: "fr" }) //~> 2017-03-12T05:45:10.765Z with a French locale
   * @return {DateTime}
   */
  static utc() {
    const [opts, args] = lastOpts(arguments),
      [year, month, day, hour, minute, second, millisecond] = args;

    opts.zone = _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_5__["default"].utcInstance;
    return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
  }

  /**
   * Create a DateTime from a JavaScript Date object. Uses the default zone.
   * @param {Date} date - a JavaScript Date object
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @return {DateTime}
   */
  static fromJSDate(date, options = {}) {
    const ts = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isDate)(date) ? date.valueOf() : NaN;
    if (Number.isNaN(ts)) {
      return DateTime.invalid("invalid input");
    }

    const zoneToUse = (0,_impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_8__.normalizeZone)(options.zone, _settings_js__WEBPACK_IMPORTED_MODULE_2__["default"].defaultZone);
    if (!zoneToUse.isValid) {
      return DateTime.invalid(unsupportedZone(zoneToUse));
    }

    return new DateTime({
      ts: ts,
      zone: zoneToUse,
      loc: _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__["default"].fromObject(options),
    });
  }

  /**
   * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} milliseconds - a number of milliseconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromMillis(milliseconds, options = {}) {
    if (!(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isNumber)(milliseconds)) {
      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidArgumentError(
        `fromMillis requires a numerical input, but received a ${typeof milliseconds} with value ${milliseconds}`
      );
    } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
      // this isn't perfect because because we can still end up out of range because of additional shifting, but it's a start
      return DateTime.invalid("Timestamp out of range");
    } else {
      return new DateTime({
        ts: milliseconds,
        zone: (0,_impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_8__.normalizeZone)(options.zone, _settings_js__WEBPACK_IMPORTED_MODULE_2__["default"].defaultZone),
        loc: _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__["default"].fromObject(options),
      });
    }
  }

  /**
   * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} seconds - a number of seconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromSeconds(seconds, options = {}) {
    if (!(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isNumber)(seconds)) {
      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidArgumentError("fromSeconds requires a numerical input");
    } else {
      return new DateTime({
        ts: seconds * 1000,
        zone: (0,_impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_8__.normalizeZone)(options.zone, _settings_js__WEBPACK_IMPORTED_MODULE_2__["default"].defaultZone),
        loc: _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__["default"].fromObject(options),
      });
    }
  }

  /**
   * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.year - a year, such as 1987
   * @param {number} obj.month - a month, 1-12
   * @param {number} obj.day - a day of the month, 1-31, depending on the month
   * @param {number} obj.ordinal - day of the year, 1-365 or 366
   * @param {number} obj.weekYear - an ISO week year
   * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
   * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
   * @param {number} obj.hour - hour of the day, 0-23
   * @param {number} obj.minute - minute of the hour, 0-59
   * @param {number} obj.second - second of the minute, 0-59
   * @param {number} obj.millisecond - millisecond of the second, 0-999
   * @param {Object} opts - options for creating this DateTime
   * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
   * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })
   * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
   * @return {DateTime}
   */
  static fromObject(obj, opts = {}) {
    obj = obj || {};
    const zoneToUse = (0,_impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_8__.normalizeZone)(opts.zone, _settings_js__WEBPACK_IMPORTED_MODULE_2__["default"].defaultZone);
    if (!zoneToUse.isValid) {
      return DateTime.invalid(unsupportedZone(zoneToUse));
    }

    const tsNow = _settings_js__WEBPACK_IMPORTED_MODULE_2__["default"].now(),
      offsetProvis = !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(opts.specificOffset)
        ? opts.specificOffset
        : zoneToUse.offset(tsNow),
      normalized = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.normalizeObject)(obj, normalizeUnit),
      containsOrdinal = !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.ordinal),
      containsGregorYear = !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.year),
      containsGregorMD = !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.month) || !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.day),
      containsGregor = containsGregorYear || containsGregorMD,
      definiteWeekDef = normalized.weekYear || normalized.weekNumber,
      loc = _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__["default"].fromObject(opts);

    // cases:
    // just a weekday -> this week's instance of that weekday, no worries
    // (gregorian data or ordinal) + (weekYear or weekNumber) -> error
    // (gregorian month or day) + ordinal -> error
    // otherwise just use weeks or ordinals or gregorian, depending on what's specified

    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.ConflictingSpecificationError(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    }

    if (containsGregorMD && containsOrdinal) {
      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }

    const useWeekData = definiteWeekDef || (normalized.weekday && !containsGregor);

    // configure ourselves to deal with gregorian dates or week stuff
    let units,
      defaultValues,
      objNow = tsToObj(tsNow, offsetProvis);
    if (useWeekData) {
      units = orderedWeekUnits;
      defaultValues = defaultWeekUnitValues;
      objNow = (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.gregorianToWeek)(objNow);
    } else if (containsOrdinal) {
      units = orderedOrdinalUnits;
      defaultValues = defaultOrdinalUnitValues;
      objNow = (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.gregorianToOrdinal)(objNow);
    } else {
      units = orderedUnits;
      defaultValues = defaultUnitValues;
    }

    // set default values for missing stuff
    let foundFirst = false;
    for (const u of units) {
      const v = normalized[u];
      if (!(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(v)) {
        foundFirst = true;
      } else if (foundFirst) {
        normalized[u] = defaultValues[u];
      } else {
        normalized[u] = objNow[u];
      }
    }

    // make sure the values we have are in range
    const higherOrderInvalid = useWeekData
        ? (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.hasInvalidWeekData)(normalized)
        : containsOrdinal
        ? (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.hasInvalidOrdinalData)(normalized)
        : (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.hasInvalidGregorianData)(normalized),
      invalid = higherOrderInvalid || (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.hasInvalidTimeData)(normalized);

    if (invalid) {
      return DateTime.invalid(invalid);
    }

    // compute the actual time
    const gregorian = useWeekData
        ? (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.weekToGregorian)(normalized)
        : containsOrdinal
        ? (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.ordinalToGregorian)(normalized)
        : normalized,
      [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse),
      inst = new DateTime({
        ts: tsFinal,
        zone: zoneToUse,
        o: offsetFinal,
        loc,
      });

    // gregorian data + weekday serves only to validate
    if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
      return DateTime.invalid(
        "mismatched weekday",
        `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`
      );
    }

    return inst;
  }

  /**
   * Create a DateTime from an ISO 8601 string
   * @param {string} text - the ISO string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromISO('2016-05-25T09:08:34.123')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
   * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
   * @example DateTime.fromISO('2016-W05-4')
   * @return {DateTime}
   */
  static fromISO(text, opts = {}) {
    const [vals, parsedZone] = (0,_impl_regexParser_js__WEBPACK_IMPORTED_MODULE_10__.parseISODate)(text);
    return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text);
  }

  /**
   * Create a DateTime from an RFC 2822 string
   * @param {string} text - the RFC 2822 string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
   * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
   * @return {DateTime}
   */
  static fromRFC2822(text, opts = {}) {
    const [vals, parsedZone] = (0,_impl_regexParser_js__WEBPACK_IMPORTED_MODULE_10__.parseRFC2822Date)(text);
    return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text);
  }

  /**
   * Create a DateTime from an HTTP header date
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @param {string} text - the HTTP header date
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
   * @return {DateTime}
   */
  static fromHTTP(text, opts = {}) {
    const [vals, parsedZone] = (0,_impl_regexParser_js__WEBPACK_IMPORTED_MODULE_10__.parseHTTPDate)(text);
    return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
  }

  /**
   * Create a DateTime from an input string and format string.
   * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromFormat(text, fmt, opts = {}) {
    if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(text) || (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(fmt)) {
      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidArgumentError("fromFormat requires an input string and a format");
    }

    const { locale = null, numberingSystem = null } = opts,
      localeToUse = _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__["default"].fromOpts({
        locale,
        numberingSystem,
        defaultToEN: true,
      }),
      [vals, parsedZone, specificOffset, invalid] = (0,_impl_tokenParser_js__WEBPACK_IMPORTED_MODULE_11__.parseFromTokens)(localeToUse, text, fmt);
    if (invalid) {
      return DateTime.invalid(invalid);
    } else {
      return parseDataToDateTime(vals, parsedZone, opts, `format ${fmt}`, text, specificOffset);
    }
  }

  /**
   * @deprecated use fromFormat instead
   */
  static fromString(text, fmt, opts = {}) {
    return DateTime.fromFormat(text, fmt, opts);
  }

  /**
   * Create a DateTime from a SQL date, time, or datetime
   * Defaults to en-US if no locale has been specified, regardless of the system's locale
   * @param {string} text - the string to parse
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @example DateTime.fromSQL('2017-05-15')
   * @example DateTime.fromSQL('2017-05-15 09:12:34')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
   * @example DateTime.fromSQL('09:12:34.342')
   * @return {DateTime}
   */
  static fromSQL(text, opts = {}) {
    const [vals, parsedZone] = (0,_impl_regexParser_js__WEBPACK_IMPORTED_MODULE_10__.parseSQL)(text);
    return parseDataToDateTime(vals, parsedZone, opts, "SQL", text);
  }

  /**
   * Create an invalid DateTime.
   * @param {string} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent.
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {DateTime}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidArgumentError("need to specify a reason the DateTime is invalid");
    }

    const invalid = reason instanceof _impl_invalid_js__WEBPACK_IMPORTED_MODULE_15__["default"] ? reason : new _impl_invalid_js__WEBPACK_IMPORTED_MODULE_15__["default"](reason, explanation);

    if (_settings_js__WEBPACK_IMPORTED_MODULE_2__["default"].throwOnInvalid) {
      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidDateTimeError(invalid);
    } else {
      return new DateTime({ invalid });
    }
  }

  /**
   * Check if an object is an instance of DateTime. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDateTime(o) {
    return (o && o.isLuxonDateTime) || false;
  }

  /**
   * Produce the format string for a set of options
   * @param formatOpts
   * @param localeOpts
   * @returns {string}
   */
  static parseFormatForOpts(formatOpts, localeOpts = {}) {
    const tokenList = (0,_impl_tokenParser_js__WEBPACK_IMPORTED_MODULE_11__.formatOptsToTokens)(formatOpts, _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__["default"].fromObject(localeOpts));
    return !tokenList ? null : tokenList.map((t) => (t ? t.val : null)).join("");
  }

  /**
   * Produce the the fully expanded format token for the locale
   * Does NOT quote characters, so quoted tokens will not round trip correctly
   * @param fmt
   * @param localeOpts
   * @returns {string}
   */
  static expandFormat(fmt, localeOpts = {}) {
    const expanded = (0,_impl_tokenParser_js__WEBPACK_IMPORTED_MODULE_11__.expandMacroTokens)(_impl_formatter_js__WEBPACK_IMPORTED_MODULE_4__["default"].parseFormat(fmt), _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__["default"].fromObject(localeOpts));
    return expanded.map((t) => t.val).join("");
  }

  // INFO

  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
   * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
   * @return {number}
   */
  get(unit) {
    return this[unit];
  }

  /**
   * Returns whether the DateTime is valid. Invalid DateTimes occur when:
   * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
   * * The DateTime was created by an operation on another invalid date
   * @type {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }

  /**
   * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }

  /**
   * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }

  /**
   * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
   *
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }

  /**
   * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }

  /**
   * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
   *
   * @type {string}
   */
  get outputCalendar() {
    return this.isValid ? this.loc.outputCalendar : null;
  }

  /**
   * Get the time zone associated with this DateTime.
   * @type {Zone}
   */
  get zone() {
    return this._zone;
  }

  /**
   * Get the name of the time zone.
   * @type {string}
   */
  get zoneName() {
    return this.isValid ? this.zone.name : null;
  }

  /**
   * Get the year
   * @example DateTime.local(2017, 5, 25).year //=> 2017
   * @type {number}
   */
  get year() {
    return this.isValid ? this.c.year : NaN;
  }

  /**
   * Get the quarter
   * @example DateTime.local(2017, 5, 25).quarter //=> 2
   * @type {number}
   */
  get quarter() {
    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
  }

  /**
   * Get the month (1-12).
   * @example DateTime.local(2017, 5, 25).month //=> 5
   * @type {number}
   */
  get month() {
    return this.isValid ? this.c.month : NaN;
  }

  /**
   * Get the day of the month (1-30ish).
   * @example DateTime.local(2017, 5, 25).day //=> 25
   * @type {number}
   */
  get day() {
    return this.isValid ? this.c.day : NaN;
  }

  /**
   * Get the hour of the day (0-23).
   * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
   * @type {number}
   */
  get hour() {
    return this.isValid ? this.c.hour : NaN;
  }

  /**
   * Get the minute of the hour (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
   * @type {number}
   */
  get minute() {
    return this.isValid ? this.c.minute : NaN;
  }

  /**
   * Get the second of the minute (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
   * @type {number}
   */
  get second() {
    return this.isValid ? this.c.second : NaN;
  }

  /**
   * Get the millisecond of the second (0-999).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
   * @type {number}
   */
  get millisecond() {
    return this.isValid ? this.c.millisecond : NaN;
  }

  /**
   * Get the week year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
   * @type {number}
   */
  get weekYear() {
    return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
  }

  /**
   * Get the week number of the week year (1-52ish).
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
   * @type {number}
   */
  get weekNumber() {
    return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
  }

  /**
   * Get the day of the week.
   * 1 is Monday and 7 is Sunday
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 11, 31).weekday //=> 4
   * @type {number}
   */
  get weekday() {
    return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
  }

  /**
   * Get the ordinal (meaning the day of the year)
   * @example DateTime.local(2017, 5, 25).ordinal //=> 145
   * @type {number|DateTime}
   */
  get ordinal() {
    return this.isValid ? (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.gregorianToOrdinal)(this.c).ordinal : NaN;
  }

  /**
   * Get the human readable short month name, such as 'Oct'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
   * @type {string}
   */
  get monthShort() {
    return this.isValid ? _info_js__WEBPACK_IMPORTED_MODULE_3__["default"].months("short", { locObj: this.loc })[this.month - 1] : null;
  }

  /**
   * Get the human readable long month name, such as 'October'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthLong //=> October
   * @type {string}
   */
  get monthLong() {
    return this.isValid ? _info_js__WEBPACK_IMPORTED_MODULE_3__["default"].months("long", { locObj: this.loc })[this.month - 1] : null;
  }

  /**
   * Get the human readable short weekday, such as 'Mon'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
   * @type {string}
   */
  get weekdayShort() {
    return this.isValid ? _info_js__WEBPACK_IMPORTED_MODULE_3__["default"].weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
  }

  /**
   * Get the human readable long weekday, such as 'Monday'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
   * @type {string}
   */
  get weekdayLong() {
    return this.isValid ? _info_js__WEBPACK_IMPORTED_MODULE_3__["default"].weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
  }

  /**
   * Get the UTC offset of this DateTime in minutes
   * @example DateTime.now().offset //=> -240
   * @example DateTime.utc().offset //=> 0
   * @type {number}
   */
  get offset() {
    return this.isValid ? +this.o : NaN;
  }

  /**
   * Get the short human name for the zone's current offset, for example "EST" or "EDT".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameShort() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "short",
        locale: this.locale,
      });
    } else {
      return null;
    }
  }

  /**
   * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameLong() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "long",
        locale: this.locale,
      });
    } else {
      return null;
    }
  }

  /**
   * Get whether this zone's offset ever changes, as in a DST.
   * @type {boolean}
   */
  get isOffsetFixed() {
    return this.isValid ? this.zone.isUniversal : null;
  }

  /**
   * Get whether the DateTime is in a DST.
   * @type {boolean}
   */
  get isInDST() {
    if (this.isOffsetFixed) {
      return false;
    } else {
      return (
        this.offset > this.set({ month: 1, day: 1 }).offset ||
        this.offset > this.set({ month: 5 }).offset
      );
    }
  }

  /**
   * Get those DateTimes which have the same local time as this DateTime, but a different offset from UTC
   * in this DateTime's zone. During DST changes local time can be ambiguous, for example
   * `2023-10-29T02:30:00` in `Europe/Berlin` can have offset `+01:00` or `+02:00`.
   * This method will return both possible DateTimes if this DateTime's local time is ambiguous.
   * @returns {DateTime[]}
   */
  getPossibleOffsets() {
    if (!this.isValid || this.isOffsetFixed) {
      return [this];
    }
    const dayMs = 86400000;
    const minuteMs = 60000;
    const localTS = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.objToLocalTS)(this.c);
    const oEarlier = this.zone.offset(localTS - dayMs);
    const oLater = this.zone.offset(localTS + dayMs);

    const o1 = this.zone.offset(localTS - oEarlier * minuteMs);
    const o2 = this.zone.offset(localTS - oLater * minuteMs);
    if (o1 === o2) {
      return [this];
    }
    const ts1 = localTS - o1 * minuteMs;
    const ts2 = localTS - o2 * minuteMs;
    const c1 = tsToObj(ts1, o1);
    const c2 = tsToObj(ts2, o2);
    if (
      c1.hour === c2.hour &&
      c1.minute === c2.minute &&
      c1.second === c2.second &&
      c1.millisecond === c2.millisecond
    ) {
      return [clone(this, { ts: ts1 }), clone(this, { ts: ts2 })];
    }
    return [this];
  }

  /**
   * Returns true if this DateTime is in a leap year, false otherwise
   * @example DateTime.local(2016).isInLeapYear //=> true
   * @example DateTime.local(2013).isInLeapYear //=> false
   * @type {boolean}
   */
  get isInLeapYear() {
    return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isLeapYear)(this.year);
  }

  /**
   * Returns the number of days in this DateTime's month
   * @example DateTime.local(2016, 2).daysInMonth //=> 29
   * @example DateTime.local(2016, 3).daysInMonth //=> 31
   * @type {number}
   */
  get daysInMonth() {
    return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.daysInMonth)(this.year, this.month);
  }

  /**
   * Returns the number of days in this DateTime's year
   * @example DateTime.local(2016).daysInYear //=> 366
   * @example DateTime.local(2013).daysInYear //=> 365
   * @type {number}
   */
  get daysInYear() {
    return this.isValid ? (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.daysInYear)(this.year) : NaN;
  }

  /**
   * Returns the number of weeks in this DateTime's year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2004).weeksInWeekYear //=> 53
   * @example DateTime.local(2013).weeksInWeekYear //=> 52
   * @type {number}
   */
  get weeksInWeekYear() {
    return this.isValid ? (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.weeksInWeekYear)(this.weekYear) : NaN;
  }

  /**
   * Returns the resolved Intl options for this DateTime.
   * This is useful in understanding the behavior of formatting methods
   * @param {Object} opts - the same options as toLocaleString
   * @return {Object}
   */
  resolvedLocaleOptions(opts = {}) {
    const { locale, numberingSystem, calendar } = _impl_formatter_js__WEBPACK_IMPORTED_MODULE_4__["default"].create(
      this.loc.clone(opts),
      opts
    ).resolvedOptions(this);
    return { locale, numberingSystem, outputCalendar: calendar };
  }

  // TRANSFORM

  /**
   * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
   *
   * Equivalent to {@link DateTime#setZone}('utc')
   * @param {number} [offset=0] - optionally, an offset from UTC in minutes
   * @param {Object} [opts={}] - options to pass to `setZone()`
   * @return {DateTime}
   */
  toUTC(offset = 0, opts = {}) {
    return this.setZone(_zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_5__["default"].instance(offset), opts);
  }

  /**
   * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
   *
   * Equivalent to `setZone('local')`
   * @return {DateTime}
   */
  toLocal() {
    return this.setZone(_settings_js__WEBPACK_IMPORTED_MODULE_2__["default"].defaultZone);
  }

  /**
   * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
   *
   * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.
   * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.
   * @param {Object} opts - options
   * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
   * @return {DateTime}
   */
  setZone(zone, { keepLocalTime = false, keepCalendarTime = false } = {}) {
    zone = (0,_impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_8__.normalizeZone)(zone, _settings_js__WEBPACK_IMPORTED_MODULE_2__["default"].defaultZone);
    if (zone.equals(this.zone)) {
      return this;
    } else if (!zone.isValid) {
      return DateTime.invalid(unsupportedZone(zone));
    } else {
      let newTS = this.ts;
      if (keepLocalTime || keepCalendarTime) {
        const offsetGuess = zone.offset(this.ts);
        const asObj = this.toObject();
        [newTS] = objToTS(asObj, offsetGuess, zone);
      }
      return clone(this, { ts: newTS, zone });
    }
  }

  /**
   * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
   * @param {Object} properties - the properties to set
   * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
   * @return {DateTime}
   */
  reconfigure({ locale, numberingSystem, outputCalendar } = {}) {
    const loc = this.loc.clone({ locale, numberingSystem, outputCalendar });
    return clone(this, { loc });
  }

  /**
   * "Set" the locale. Returns a newly-constructed DateTime.
   * Just a convenient alias for reconfigure({ locale })
   * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
   * @return {DateTime}
   */
  setLocale(locale) {
    return this.reconfigure({ locale });
  }

  /**
   * "Set" the values of specified units. Returns a newly-constructed DateTime.
   * You can only set units with this method; for "setting" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.
   * @param {Object} values - a mapping of units to numbers
   * @example dt.set({ year: 2017 })
   * @example dt.set({ hour: 8, minute: 30 })
   * @example dt.set({ weekday: 5 })
   * @example dt.set({ year: 2005, ordinal: 234 })
   * @return {DateTime}
   */
  set(values) {
    if (!this.isValid) return this;

    const normalized = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.normalizeObject)(values, normalizeUnit),
      settingWeekStuff =
        !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.weekYear) ||
        !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.weekNumber) ||
        !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.weekday),
      containsOrdinal = !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.ordinal),
      containsGregorYear = !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.year),
      containsGregorMD = !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.month) || !(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.day),
      containsGregor = containsGregorYear || containsGregorMD,
      definiteWeekDef = normalized.weekYear || normalized.weekNumber;

    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.ConflictingSpecificationError(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    }

    if (containsGregorMD && containsOrdinal) {
      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }

    let mixed;
    if (settingWeekStuff) {
      mixed = (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.weekToGregorian)({ ...(0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.gregorianToWeek)(this.c), ...normalized });
    } else if (!(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.ordinal)) {
      mixed = (0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.ordinalToGregorian)({ ...(0,_impl_conversions_js__WEBPACK_IMPORTED_MODULE_12__.gregorianToOrdinal)(this.c), ...normalized });
    } else {
      mixed = { ...this.toObject(), ...normalized };

      // if we didn't set the day but we ended up on an overflow date,
      // use the last day of the right month
      if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined)(normalized.day)) {
        mixed.day = Math.min((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.daysInMonth)(mixed.year, mixed.month), mixed.day);
      }
    }

    const [ts, o] = objToTS(mixed, this.o, this.zone);
    return clone(this, { ts, o });
  }

  /**
   * Add a period of time to this DateTime and return the resulting DateTime
   *
   * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @example DateTime.now().plus(123) //~> in 123 milliseconds
   * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes
   * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow
   * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday
   * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
   * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
   * @return {DateTime}
   */
  plus(duration) {
    if (!this.isValid) return this;
    const dur = _duration_js__WEBPACK_IMPORTED_MODULE_0__["default"].fromDurationLike(duration);
    return clone(this, adjustTime(this, dur));
  }

  /**
   * Subtract a period of time to this DateTime and return the resulting DateTime
   * See {@link DateTime#plus}
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   @return {DateTime}
   */
  minus(duration) {
    if (!this.isValid) return this;
    const dur = _duration_js__WEBPACK_IMPORTED_MODULE_0__["default"].fromDurationLike(duration).negate();
    return clone(this, adjustTime(this, dur));
  }

  /**
   * "Set" this DateTime to the beginning of a unit of time.
   * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
   * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
   * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
   * @return {DateTime}
   */
  startOf(unit) {
    if (!this.isValid) return this;
    const o = {},
      normalizedUnit = _duration_js__WEBPACK_IMPORTED_MODULE_0__["default"].normalizeUnit(unit);
    switch (normalizedUnit) {
      case "years":
        o.month = 1;
      // falls through
      case "quarters":
      case "months":
        o.day = 1;
      // falls through
      case "weeks":
      case "days":
        o.hour = 0;
      // falls through
      case "hours":
        o.minute = 0;
      // falls through
      case "minutes":
        o.second = 0;
      // falls through
      case "seconds":
        o.millisecond = 0;
        break;
      case "milliseconds":
        break;
      // no default, invalid units throw in normalizeUnit()
    }

    if (normalizedUnit === "weeks") {
      o.weekday = 1;
    }

    if (normalizedUnit === "quarters") {
      const q = Math.ceil(this.month / 3);
      o.month = (q - 1) * 3 + 1;
    }

    return this.set(o);
  }

  /**
   * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
   * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
   * @return {DateTime}
   */
  endOf(unit) {
    return this.isValid
      ? this.plus({ [unit]: 1 })
          .startOf(unit)
          .minus(1)
      : this;
  }

  // OUTPUT

  /**
   * Returns a string representation of this DateTime formatted according to the specified format string.
   * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).
   * Defaults to en-US if no locale has been specified, regardless of the system's locale.
   * @param {string} fmt - the format string
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
   * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
   * @example DateTime.now().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
   * @example DateTime.now().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
   * @return {string}
   */
  toFormat(fmt, opts = {}) {
    return this.isValid
      ? _impl_formatter_js__WEBPACK_IMPORTED_MODULE_4__["default"].create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt)
      : INVALID;
  }

  /**
   * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
   * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
   * of the DateTime in the assigned locale.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toLocaleString(); //=> 4/20/2017
   * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL, { locale: 'fr' }); //=> '28 août 2022'
   * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
   * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
   * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
   * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
   * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'
   * @return {string}
   */
  toLocaleString(formatOpts = _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATE_SHORT, opts = {}) {
    return this.isValid
      ? _impl_formatter_js__WEBPACK_IMPORTED_MODULE_4__["default"].create(this.loc.clone(opts), formatOpts).formatDateTime(this)
      : INVALID;
  }

  /**
   * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
   * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
   * @example DateTime.now().toLocaleParts(); //=> [
   *                                   //=>   { type: 'day', value: '25' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'month', value: '05' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'year', value: '1982' }
   *                                   //=> ]
   */
  toLocaleParts(opts = {}) {
    return this.isValid
      ? _impl_formatter_js__WEBPACK_IMPORTED_MODULE_4__["default"].create(this.loc.clone(opts), opts).formatDateTimeParts(this)
      : [];
  }

  /**
   * Returns an ISO 8601-compliant string representation of this DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=false] - add the time zone format extension
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
   * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'
   * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
   * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
   * @return {string}
   */
  toISO({
    format = "extended",
    suppressSeconds = false,
    suppressMilliseconds = false,
    includeOffset = true,
    extendedZone = false,
  } = {}) {
    if (!this.isValid) {
      return null;
    }

    const ext = format === "extended";

    let c = toISODate(this, ext);
    c += "T";
    c += toISOTime(this, ext, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
    return c;
  }

  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's date component
   * @param {Object} opts - options
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
   * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
   * @return {string}
   */
  toISODate({ format = "extended" } = {}) {
    if (!this.isValid) {
      return null;
    }

    return toISODate(this, format === "extended");
  }

  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's week date
   * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
   * @return {string}
   */
  toISOWeekDate() {
    return toTechFormat(this, "kkkk-'W'WW-c");
  }

  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's time component
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=true] - add the time zone format extension
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'
   * @return {string}
   */
  toISOTime({
    suppressMilliseconds = false,
    suppressSeconds = false,
    includeOffset = true,
    includePrefix = false,
    extendedZone = false,
    format = "extended",
  } = {}) {
    if (!this.isValid) {
      return null;
    }

    let c = includePrefix ? "T" : "";
    return (
      c +
      toISOTime(
        this,
        format === "extended",
        suppressSeconds,
        suppressMilliseconds,
        includeOffset,
        extendedZone
      )
    );
  }

  /**
   * Returns an RFC 2822-compatible string representation of this DateTime
   * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
   * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
   * @return {string}
   */
  toRFC2822() {
    return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
  }

  /**
   * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.
   * Specifically, the string conforms to RFC 1123.
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
   * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
   * @return {string}
   */
  toHTTP() {
    return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  }

  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Date
   * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
   * @return {string}
   */
  toSQLDate() {
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, true);
  }

  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Time
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc().toSQL() //=> '05:15:16.345'
   * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'
   * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'
   * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
   * @return {string}
   */
  toSQLTime({ includeOffset = true, includeZone = false, includeOffsetSpace = true } = {}) {
    let fmt = "HH:mm:ss.SSS";

    if (includeZone || includeOffset) {
      if (includeOffsetSpace) {
        fmt += " ";
      }
      if (includeZone) {
        fmt += "z";
      } else if (includeOffset) {
        fmt += "ZZ";
      }
    }

    return toTechFormat(this, fmt, true);
  }

  /**
   * Returns a string representation of this DateTime appropriate for use in SQL DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
   * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
   * @return {string}
   */
  toSQL(opts = {}) {
    if (!this.isValid) {
      return null;
    }

    return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;
  }

  /**
   * Returns a string representation of this DateTime appropriate for debugging
   * @return {string}
   */
  toString() {
    return this.isValid ? this.toISO() : INVALID;
  }

  /**
   * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }

  /**
   * Returns the epoch milliseconds of this DateTime.
   * @return {number}
   */
  toMillis() {
    return this.isValid ? this.ts : NaN;
  }

  /**
   * Returns the epoch seconds of this DateTime.
   * @return {number}
   */
  toSeconds() {
    return this.isValid ? this.ts / 1000 : NaN;
  }

  /**
   * Returns the epoch seconds (as a whole number) of this DateTime.
   * @return {number}
   */
  toUnixInteger() {
    return this.isValid ? Math.floor(this.ts / 1000) : NaN;
  }

  /**
   * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }

  /**
   * Returns a BSON serializable equivalent to this DateTime.
   * @return {Date}
   */
  toBSON() {
    return this.toJSDate();
  }

  /**
   * Returns a JavaScript object with this DateTime's year, month, day, and so on.
   * @param opts - options for generating the object
   * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
   * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
   * @return {Object}
   */
  toObject(opts = {}) {
    if (!this.isValid) return {};

    const base = { ...this.c };

    if (opts.includeConfig) {
      base.outputCalendar = this.outputCalendar;
      base.numberingSystem = this.loc.numberingSystem;
      base.locale = this.loc.locale;
    }
    return base;
  }

  /**
   * Returns a JavaScript Date equivalent to this DateTime.
   * @return {Date}
   */
  toJSDate() {
    return new Date(this.isValid ? this.ts : NaN);
  }

  // COMPARE

  /**
   * Return the difference between two DateTimes as a Duration.
   * @param {DateTime} otherDateTime - the DateTime to compare this one to
   * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example
   * var i1 = DateTime.fromISO('1982-05-25T09:45'),
   *     i2 = DateTime.fromISO('1983-10-14T10:30');
   * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
   * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
   * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
   * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
   * @return {Duration}
   */
  diff(otherDateTime, unit = "milliseconds", opts = {}) {
    if (!this.isValid || !otherDateTime.isValid) {
      return _duration_js__WEBPACK_IMPORTED_MODULE_0__["default"].invalid("created by diffing an invalid DateTime");
    }

    const durOpts = { locale: this.locale, numberingSystem: this.numberingSystem, ...opts };

    const units = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.maybeArray)(unit).map(_duration_js__WEBPACK_IMPORTED_MODULE_0__["default"].normalizeUnit),
      otherIsLater = otherDateTime.valueOf() > this.valueOf(),
      earlier = otherIsLater ? this : otherDateTime,
      later = otherIsLater ? otherDateTime : this,
      diffed = (0,_impl_diff_js__WEBPACK_IMPORTED_MODULE_9__["default"])(earlier, later, units, durOpts);

    return otherIsLater ? diffed.negate() : diffed;
  }

  /**
   * Return the difference between this DateTime and right now.
   * See {@link DateTime#diff}
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  diffNow(unit = "milliseconds", opts = {}) {
    return this.diff(DateTime.now(), unit, opts);
  }

  /**
   * Return an Interval spanning between this DateTime and another DateTime
   * @param {DateTime} otherDateTime - the other end point of the Interval
   * @return {Interval}
   */
  until(otherDateTime) {
    return this.isValid ? _interval_js__WEBPACK_IMPORTED_MODULE_1__["default"].fromDateTimes(this, otherDateTime) : this;
  }

  /**
   * Return whether this DateTime is in the same unit of time as another DateTime.
   * Higher-order units must also be identical for this function to return `true`.
   * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.
   * @param {DateTime} otherDateTime - the other DateTime
   * @param {string} unit - the unit of time to check sameness on
   * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day
   * @return {boolean}
   */
  hasSame(otherDateTime, unit) {
    if (!this.isValid) return false;

    const inputMs = otherDateTime.valueOf();
    const adjustedToZone = this.setZone(otherDateTime.zone, { keepLocalTime: true });
    return adjustedToZone.startOf(unit) <= inputMs && inputMs <= adjustedToZone.endOf(unit);
  }

  /**
   * Equality check
   * Two DateTimes are equal if and only if they represent the same millisecond, have the same zone and location, and are both valid.
   * To compare just the millisecond values, use `+dt1 === +dt2`.
   * @param {DateTime} other - the other DateTime
   * @return {boolean}
   */
  equals(other) {
    return (
      this.isValid &&
      other.isValid &&
      this.valueOf() === other.valueOf() &&
      this.zone.equals(other.zone) &&
      this.loc.equals(other.loc)
    );
  }

  /**
   * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
   * platform supports Intl.RelativeTimeFormat. Rounds down by default.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
   * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
   * @param {boolean} [options.round=true] - whether to round the numbers in the output.
   * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelative() //=> "in 1 day"
   * @example DateTime.now().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 día"
   * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
   * @example DateTime.now().minus({ days: 2 }).toRelative() //=> "2 days ago"
   * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
   * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
   */
  toRelative(options = {}) {
    if (!this.isValid) return null;
    const base = options.base || DateTime.fromObject({}, { zone: this.zone }),
      padding = options.padding ? (this < base ? -options.padding : options.padding) : 0;
    let units = ["years", "months", "days", "hours", "minutes", "seconds"];
    let unit = options.unit;
    if (Array.isArray(options.unit)) {
      units = options.unit;
      unit = undefined;
    }
    return diffRelative(base, this.plus(padding), {
      ...options,
      numeric: "always",
      units,
      unit,
    });
  }

  /**
   * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
   * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
   * @example DateTime.now().setLocale("es").plus({ days: 1 }).toRelative() //=> ""mañana"
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
   * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
   */
  toRelativeCalendar(options = {}) {
    if (!this.isValid) return null;

    return diffRelative(options.base || DateTime.fromObject({}, { zone: this.zone }), this, {
      ...options,
      numeric: "auto",
      units: ["years", "months", "days"],
      calendary: true,
    });
  }

  /**
   * Return the min of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
   * @return {DateTime} the min DateTime, or undefined if called with no argument
   */
  static min(...dateTimes) {
    if (!dateTimes.every(DateTime.isDateTime)) {
      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidArgumentError("min requires all arguments be DateTimes");
    }
    return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.bestBy)(dateTimes, (i) => i.valueOf(), Math.min);
  }

  /**
   * Return the max of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
   * @return {DateTime} the max DateTime, or undefined if called with no argument
   */
  static max(...dateTimes) {
    if (!dateTimes.every(DateTime.isDateTime)) {
      throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidArgumentError("max requires all arguments be DateTimes");
    }
    return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.bestBy)(dateTimes, (i) => i.valueOf(), Math.max);
  }

  // MISC

  /**
   * Explain how a string would be parsed by fromFormat()
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see description)
   * @param {Object} options - options taken by fromFormat()
   * @return {Object}
   */
  static fromFormatExplain(text, fmt, options = {}) {
    const { locale = null, numberingSystem = null } = options,
      localeToUse = _impl_locale_js__WEBPACK_IMPORTED_MODULE_6__["default"].fromOpts({
        locale,
        numberingSystem,
        defaultToEN: true,
      });
    return (0,_impl_tokenParser_js__WEBPACK_IMPORTED_MODULE_11__.explainFromTokens)(localeToUse, text, fmt);
  }

  /**
   * @deprecated use fromFormatExplain instead
   */
  static fromStringExplain(text, fmt, options = {}) {
    return DateTime.fromFormatExplain(text, fmt, options);
  }

  // FORMAT PRESETS

  /**
   * {@link DateTime#toLocaleString} format like 10/14/1983
   * @type {Object}
   */
  static get DATE_SHORT() {
    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATE_SHORT;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED() {
    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATE_MED;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED_WITH_WEEKDAY() {
    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATE_MED_WITH_WEEKDAY;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983'
   * @type {Object}
   */
  static get DATE_FULL() {
    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATE_FULL;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'
   * @type {Object}
   */
  static get DATE_HUGE() {
    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATE_HUGE;
  }

  /**
   * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_SIMPLE() {
    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.TIME_SIMPLE;
  }

  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SECONDS() {
    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.TIME_WITH_SECONDS;
  }

  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SHORT_OFFSET() {
    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.TIME_WITH_SHORT_OFFSET;
  }

  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_LONG_OFFSET() {
    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.TIME_WITH_LONG_OFFSET;
  }

  /**
   * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_SIMPLE() {
    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.TIME_24_SIMPLE;
  }

  /**
   * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SECONDS() {
    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.TIME_24_WITH_SECONDS;
  }

  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SHORT_OFFSET() {
    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.TIME_24_WITH_SHORT_OFFSET;
  }

  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_LONG_OFFSET() {
    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.TIME_24_WITH_LONG_OFFSET;
  }

  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT() {
    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_SHORT;
  }

  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT_WITH_SECONDS() {
    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_SHORT_WITH_SECONDS;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED() {
    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_MED;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_SECONDS() {
    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_MED_WITH_SECONDS;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_WEEKDAY() {
    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_MED_WITH_WEEKDAY;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL() {
    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_FULL;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL_WITH_SECONDS() {
    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_FULL_WITH_SECONDS;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE() {
    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_HUGE;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE_WITH_SECONDS() {
    return _impl_formats_js__WEBPACK_IMPORTED_MODULE_13__.DATETIME_HUGE_WITH_SECONDS;
  }
}

/**
 * @private
 */
function friendlyDateTime(dateTimeish) {
  if (DateTime.isDateTime(dateTimeish)) {
    return dateTimeish;
  } else if (dateTimeish && dateTimeish.valueOf && (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_7__.isNumber)(dateTimeish.valueOf())) {
    return DateTime.fromJSDate(dateTimeish);
  } else if (dateTimeish && typeof dateTimeish === "object") {
    return DateTime.fromObject(dateTimeish);
  } else {
    throw new _errors_js__WEBPACK_IMPORTED_MODULE_14__.InvalidArgumentError(
      `Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`
    );
  }
}


/***/ }),

/***/ "./node_modules/luxon/src/duration.js":
/*!********************************************!*\
  !*** ./node_modules/luxon/src/duration.js ***!
  \********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   accurateMatrix: function() { return /* binding */ accurateMatrix; },
/* harmony export */   casualMatrix: function() { return /* binding */ casualMatrix; },
/* harmony export */   daysInMonthAccurate: function() { return /* binding */ daysInMonthAccurate; },
/* harmony export */   daysInYearAccurate: function() { return /* binding */ daysInYearAccurate; },
/* harmony export */   "default": function() { return /* binding */ Duration; },
/* harmony export */   lowOrderMatrix: function() { return /* binding */ lowOrderMatrix; }
/* harmony export */ });
/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ "./node_modules/luxon/src/errors.js");
/* harmony import */ var _impl_formatter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./impl/formatter.js */ "./node_modules/luxon/src/impl/formatter.js");
/* harmony import */ var _impl_invalid_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./impl/invalid.js */ "./node_modules/luxon/src/impl/invalid.js");
/* harmony import */ var _impl_locale_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./impl/locale.js */ "./node_modules/luxon/src/impl/locale.js");
/* harmony import */ var _impl_regexParser_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./impl/regexParser.js */ "./node_modules/luxon/src/impl/regexParser.js");
/* harmony import */ var _impl_util_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./impl/util.js */ "./node_modules/luxon/src/impl/util.js");
/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./settings.js */ "./node_modules/luxon/src/settings.js");
/* harmony import */ var _datetime_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./datetime.js */ "./node_modules/luxon/src/datetime.js");









const INVALID = "Invalid Duration";

// unit conversion constants
const lowOrderMatrix = {
    weeks: {
      days: 7,
      hours: 7 * 24,
      minutes: 7 * 24 * 60,
      seconds: 7 * 24 * 60 * 60,
      milliseconds: 7 * 24 * 60 * 60 * 1000,
    },
    days: {
      hours: 24,
      minutes: 24 * 60,
      seconds: 24 * 60 * 60,
      milliseconds: 24 * 60 * 60 * 1000,
    },
    hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1000 },
    minutes: { seconds: 60, milliseconds: 60 * 1000 },
    seconds: { milliseconds: 1000 },
  },
  casualMatrix = {
    years: {
      quarters: 4,
      months: 12,
      weeks: 52,
      days: 365,
      hours: 365 * 24,
      minutes: 365 * 24 * 60,
      seconds: 365 * 24 * 60 * 60,
      milliseconds: 365 * 24 * 60 * 60 * 1000,
    },
    quarters: {
      months: 3,
      weeks: 13,
      days: 91,
      hours: 91 * 24,
      minutes: 91 * 24 * 60,
      seconds: 91 * 24 * 60 * 60,
      milliseconds: 91 * 24 * 60 * 60 * 1000,
    },
    months: {
      weeks: 4,
      days: 30,
      hours: 30 * 24,
      minutes: 30 * 24 * 60,
      seconds: 30 * 24 * 60 * 60,
      milliseconds: 30 * 24 * 60 * 60 * 1000,
    },

    ...lowOrderMatrix,
  },
  daysInYearAccurate = 146097.0 / 400,
  daysInMonthAccurate = 146097.0 / 4800,
  accurateMatrix = {
    years: {
      quarters: 4,
      months: 12,
      weeks: daysInYearAccurate / 7,
      days: daysInYearAccurate,
      hours: daysInYearAccurate * 24,
      minutes: daysInYearAccurate * 24 * 60,
      seconds: daysInYearAccurate * 24 * 60 * 60,
      milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1000,
    },
    quarters: {
      months: 3,
      weeks: daysInYearAccurate / 28,
      days: daysInYearAccurate / 4,
      hours: (daysInYearAccurate * 24) / 4,
      minutes: (daysInYearAccurate * 24 * 60) / 4,
      seconds: (daysInYearAccurate * 24 * 60 * 60) / 4,
      milliseconds: (daysInYearAccurate * 24 * 60 * 60 * 1000) / 4,
    },
    months: {
      weeks: daysInMonthAccurate / 7,
      days: daysInMonthAccurate,
      hours: daysInMonthAccurate * 24,
      minutes: daysInMonthAccurate * 24 * 60,
      seconds: daysInMonthAccurate * 24 * 60 * 60,
      milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1000,
    },
    ...lowOrderMatrix,
  };

// units ordered by size
const orderedUnits = [
  "years",
  "quarters",
  "months",
  "weeks",
  "days",
  "hours",
  "minutes",
  "seconds",
  "milliseconds",
];

const reverseUnits = orderedUnits.slice(0).reverse();

// clone really means "create another instance just like this one, but with these changes"
function clone(dur, alts, clear = false) {
  // deep merge for vals
  const conf = {
    values: clear ? alts.values : { ...dur.values, ...(alts.values || {}) },
    loc: dur.loc.clone(alts.loc),
    conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,
    matrix: alts.matrix || dur.matrix,
  };
  return new Duration(conf);
}

function durationToMillis(matrix, vals) {
  let sum = vals.milliseconds ?? 0;
  for (const unit of reverseUnits.slice(1)) {
    if (vals[unit]) {
      sum += vals[unit] * matrix[unit]["milliseconds"];
    }
  }
  return sum;
}

// NB: mutates parameters
function normalizeValues(matrix, vals) {
  // the logic below assumes the overall value of the duration is positive
  // if this is not the case, factor is used to make it so
  const factor = durationToMillis(matrix, vals) < 0 ? -1 : 1;

  orderedUnits.reduceRight((previous, current) => {
    if (!(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.isUndefined)(vals[current])) {
      if (previous) {
        const previousVal = vals[previous] * factor;
        const conv = matrix[current][previous];

        // if (previousVal < 0):
        // lower order unit is negative (e.g. { years: 2, days: -2 })
        // normalize this by reducing the higher order unit by the appropriate amount
        // and increasing the lower order unit
        // this can never make the higher order unit negative, because this function only operates
        // on positive durations, so the amount of time represented by the lower order unit cannot
        // be larger than the higher order unit
        // else:
        // lower order unit is positive (e.g. { years: 2, days: 450 } or { years: -2, days: 450 })
        // in this case we attempt to convert as much as possible from the lower order unit into
        // the higher order one
        //
        // Math.floor takes care of both of these cases, rounding away from 0
        // if previousVal < 0 it makes the absolute value larger
        // if previousVal >= it makes the absolute value smaller
        const rollUp = Math.floor(previousVal / conv);
        vals[current] += rollUp * factor;
        vals[previous] -= rollUp * conv * factor;
      }
      return current;
    } else {
      return previous;
    }
  }, null);

  // try to convert any decimals into smaller units if possible
  // for example for { years: 2.5, days: 0, seconds: 0 } we want to get { years: 2, days: 182, hours: 12 }
  orderedUnits.reduce((previous, current) => {
    if (!(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.isUndefined)(vals[current])) {
      if (previous) {
        const fraction = vals[previous] % 1;
        vals[previous] -= fraction;
        vals[current] += fraction * matrix[previous][current];
      }
      return current;
    } else {
      return previous;
    }
  }, null);
}

// Remove all properties with a value of 0 from an object
function removeZeroes(vals) {
  const newVals = {};
  for (const [key, value] of Object.entries(vals)) {
    if (value !== 0) {
      newVals[key] = value;
    }
  }
  return newVals;
}

/**
 * A Duration object represents a period of time, like "2 months" or "1 day, 1 hour". Conceptually, it's just a map of units to their quantities, accompanied by some additional configuration and methods for creating, parsing, interrogating, transforming, and formatting them. They can be used on their own or in conjunction with other Luxon types; for example, you can use {@link DateTime#plus} to add a Duration object to a DateTime, producing another DateTime.
 *
 * Here is a brief overview of commonly used methods and getters in Duration:
 *
 * * **Creation** To create a Duration, use {@link Duration.fromMillis}, {@link Duration.fromObject}, or {@link Duration.fromISO}.
 * * **Unit values** See the {@link Duration#years}, {@link Duration#months}, {@link Duration#weeks}, {@link Duration#days}, {@link Duration#hours}, {@link Duration#minutes}, {@link Duration#seconds}, {@link Duration#milliseconds} accessors.
 * * **Configuration** See  {@link Duration#locale} and {@link Duration#numberingSystem} accessors.
 * * **Transformation** To create new Durations out of old ones use {@link Duration#plus}, {@link Duration#minus}, {@link Duration#normalize}, {@link Duration#set}, {@link Duration#reconfigure}, {@link Duration#shiftTo}, and {@link Duration#negate}.
 * * **Output** To convert the Duration into other representations, see {@link Duration#as}, {@link Duration#toISO}, {@link Duration#toFormat}, and {@link Duration#toJSON}
 *
 * There's are more methods documented below. In addition, for more information on subtler topics like internationalization and validity, see the external documentation.
 */
class Duration {
  /**
   * @private
   */
  constructor(config) {
    const accurate = config.conversionAccuracy === "longterm" || false;
    let matrix = accurate ? accurateMatrix : casualMatrix;

    if (config.matrix) {
      matrix = config.matrix;
    }

    /**
     * @access private
     */
    this.values = config.values;
    /**
     * @access private
     */
    this.loc = config.loc || _impl_locale_js__WEBPACK_IMPORTED_MODULE_3__["default"].create();
    /**
     * @access private
     */
    this.conversionAccuracy = accurate ? "longterm" : "casual";
    /**
     * @access private
     */
    this.invalid = config.invalid || null;
    /**
     * @access private
     */
    this.matrix = matrix;
    /**
     * @access private
     */
    this.isLuxonDuration = true;
  }

  /**
   * Create Duration from a number of milliseconds.
   * @param {number} count of milliseconds
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  static fromMillis(count, opts) {
    return Duration.fromObject({ milliseconds: count }, opts);
  }

  /**
   * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
   * If this object is empty then a zero milliseconds duration is returned.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.years
   * @param {number} obj.quarters
   * @param {number} obj.months
   * @param {number} obj.weeks
   * @param {number} obj.days
   * @param {number} obj.hours
   * @param {number} obj.minutes
   * @param {number} obj.seconds
   * @param {number} obj.milliseconds
   * @param {Object} [opts=[]] - options for creating this Duration
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the custom conversion system to use
   * @return {Duration}
   */
  static fromObject(obj, opts = {}) {
    if (obj == null || typeof obj !== "object") {
      throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.InvalidArgumentError(
        `Duration.fromObject: argument expected to be an object, got ${
          obj === null ? "null" : typeof obj
        }`
      );
    }

    return new Duration({
      values: (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.normalizeObject)(obj, Duration.normalizeUnit),
      loc: _impl_locale_js__WEBPACK_IMPORTED_MODULE_3__["default"].fromObject(opts),
      conversionAccuracy: opts.conversionAccuracy,
      matrix: opts.matrix,
    });
  }

  /**
   * Create a Duration from DurationLike.
   *
   * @param {Object | number | Duration} durationLike
   * One of:
   * - object with keys like 'years' and 'hours'.
   * - number representing milliseconds
   * - Duration instance
   * @return {Duration}
   */
  static fromDurationLike(durationLike) {
    if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.isNumber)(durationLike)) {
      return Duration.fromMillis(durationLike);
    } else if (Duration.isDuration(durationLike)) {
      return durationLike;
    } else if (typeof durationLike === "object") {
      return Duration.fromObject(durationLike);
    } else {
      throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.InvalidArgumentError(
        `Unknown duration argument ${durationLike} of type ${typeof durationLike}`
      );
    }
  }

  /**
   * Create a Duration from an ISO 8601 duration string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the preset conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
   * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
   * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
   * @return {Duration}
   */
  static fromISO(text, opts) {
    const [parsed] = (0,_impl_regexParser_js__WEBPACK_IMPORTED_MODULE_4__.parseISODuration)(text);
    if (parsed) {
      return Duration.fromObject(parsed, opts);
    } else {
      return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
    }
  }

  /**
   * Create a Duration from an ISO 8601 time string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
   * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @return {Duration}
   */
  static fromISOTime(text, opts) {
    const [parsed] = (0,_impl_regexParser_js__WEBPACK_IMPORTED_MODULE_4__.parseISOTimeOnly)(text);
    if (parsed) {
      return Duration.fromObject(parsed, opts);
    } else {
      return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
    }
  }

  /**
   * Create an invalid Duration.
   * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Duration}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.InvalidArgumentError("need to specify a reason the Duration is invalid");
    }

    const invalid = reason instanceof _impl_invalid_js__WEBPACK_IMPORTED_MODULE_2__["default"] ? reason : new _impl_invalid_js__WEBPACK_IMPORTED_MODULE_2__["default"](reason, explanation);

    if (_settings_js__WEBPACK_IMPORTED_MODULE_6__["default"].throwOnInvalid) {
      throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.InvalidDurationError(invalid);
    } else {
      return new Duration({ invalid });
    }
  }

  /**
   * @private
   */
  static normalizeUnit(unit) {
    const normalized = {
      year: "years",
      years: "years",
      quarter: "quarters",
      quarters: "quarters",
      month: "months",
      months: "months",
      week: "weeks",
      weeks: "weeks",
      day: "days",
      days: "days",
      hour: "hours",
      hours: "hours",
      minute: "minutes",
      minutes: "minutes",
      second: "seconds",
      seconds: "seconds",
      millisecond: "milliseconds",
      milliseconds: "milliseconds",
    }[unit ? unit.toLowerCase() : unit];

    if (!normalized) throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.InvalidUnitError(unit);

    return normalized;
  }

  /**
   * Check if an object is a Duration. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDuration(o) {
    return (o && o.isLuxonDuration) || false;
  }

  /**
   * Get  the locale of a Duration, such 'en-GB'
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }

  /**
   * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }

  /**
   * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
   * * `S` for milliseconds
   * * `s` for seconds
   * * `m` for minutes
   * * `h` for hours
   * * `d` for days
   * * `w` for weeks
   * * `M` for months
   * * `y` for years
   * Notes:
   * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
   * * Tokens can be escaped by wrapping with single quotes.
   * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.
   * @param {string} fmt - the format string
   * @param {Object} opts - options
   * @param {boolean} [opts.floor=true] - floor numerical values
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
   * @return {string}
   */
  toFormat(fmt, opts = {}) {
    // reverse-compat since 1.2; we always round down now, never up, and we do it by default
    const fmtOpts = {
      ...opts,
      floor: opts.round !== false && opts.floor !== false,
    };
    return this.isValid
      ? _impl_formatter_js__WEBPACK_IMPORTED_MODULE_1__["default"].create(this.loc, fmtOpts).formatDurationFromString(this, fmt)
      : INVALID;
  }

  /**
   * Returns a string representation of a Duration with all units included.
   * To modify its behavior use the `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat
   * @param opts - On option object to override the formatting. Accepts the same keys as the options parameter of the native `Int.NumberFormat` constructor, as well as `listStyle`.
   * @example
   * ```js
   * var dur = Duration.fromObject({ days: 1, hours: 5, minutes: 6 })
   * dur.toHuman() //=> '1 day, 5 hours, 6 minutes'
   * dur.toHuman({ listStyle: "long" }) //=> '1 day, 5 hours, and 6 minutes'
   * dur.toHuman({ unitDisplay: "short" }) //=> '1 day, 5 hr, 6 min'
   * ```
   */
  toHuman(opts = {}) {
    if (!this.isValid) return INVALID;

    const l = orderedUnits
      .map((unit) => {
        const val = this.values[unit];
        if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.isUndefined)(val)) {
          return null;
        }
        return this.loc
          .numberFormatter({ style: "unit", unitDisplay: "long", ...opts, unit: unit.slice(0, -1) })
          .format(val);
      })
      .filter((n) => n);

    return this.loc
      .listFormatter({ type: "conjunction", style: opts.listStyle || "narrow", ...opts })
      .format(l);
  }

  /**
   * Returns a JavaScript object with this Duration's values.
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
   * @return {Object}
   */
  toObject() {
    if (!this.isValid) return {};
    return { ...this.values };
  }

  /**
   * Returns an ISO 8601-compliant string representation of this Duration.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
   * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
   * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
   * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
   * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
   * @return {string}
   */
  toISO() {
    // we could use the formatter, but this is an easier way to get the minimum string
    if (!this.isValid) return null;

    let s = "P";
    if (this.years !== 0) s += this.years + "Y";
    if (this.months !== 0 || this.quarters !== 0) s += this.months + this.quarters * 3 + "M";
    if (this.weeks !== 0) s += this.weeks + "W";
    if (this.days !== 0) s += this.days + "D";
    if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)
      s += "T";
    if (this.hours !== 0) s += this.hours + "H";
    if (this.minutes !== 0) s += this.minutes + "M";
    if (this.seconds !== 0 || this.milliseconds !== 0)
      // this will handle "floating point madness" by removing extra decimal places
      // https://stackoverflow.com/questions/588004/is-floating-point-math-broken
      s += (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.roundTo)(this.seconds + this.milliseconds / 1000, 3) + "S";
    if (s === "P") s += "T0S";
    return s;
  }

  /**
   * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
   * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
   * @return {string}
   */
  toISOTime(opts = {}) {
    if (!this.isValid) return null;

    const millis = this.toMillis();
    if (millis < 0 || millis >= 86400000) return null;

    opts = {
      suppressMilliseconds: false,
      suppressSeconds: false,
      includePrefix: false,
      format: "extended",
      ...opts,
      includeOffset: false,
    };

    const dateTime = _datetime_js__WEBPACK_IMPORTED_MODULE_7__["default"].fromMillis(millis, { zone: "UTC" });
    return dateTime.toISOTime(opts);
  }

  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }

  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
   * @return {string}
   */
  toString() {
    return this.toISO();
  }

  /**
   * Returns an milliseconds value of this Duration.
   * @return {number}
   */
  toMillis() {
    if (!this.isValid) return NaN;

    return durationToMillis(this.matrix, this.values);
  }

  /**
   * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }

  /**
   * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  plus(duration) {
    if (!this.isValid) return this;

    const dur = Duration.fromDurationLike(duration),
      result = {};

    for (const k of orderedUnits) {
      if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.hasOwnProperty)(dur.values, k) || (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.hasOwnProperty)(this.values, k)) {
        result[k] = dur.get(k) + this.get(k);
      }
    }

    return clone(this, { values: result }, true);
  }

  /**
   * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  minus(duration) {
    if (!this.isValid) return this;

    const dur = Duration.fromDurationLike(duration);
    return this.plus(dur.negate());
  }

  /**
   * Scale this Duration by the specified amount. Return a newly-constructed Duration.
   * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hours" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
   * @return {Duration}
   */
  mapUnits(fn) {
    if (!this.isValid) return this;
    const result = {};
    for (const k of Object.keys(this.values)) {
      result[k] = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.asNumber)(fn(this.values[k], k));
    }
    return clone(this, { values: result }, true);
  }

  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
   * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
   * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
   * @return {number}
   */
  get(unit) {
    return this[Duration.normalizeUnit(unit)];
  }

  /**
   * "Set" the values of specified units. Return a newly-constructed Duration.
   * @param {Object} values - a mapping of units to numbers
   * @example dur.set({ years: 2017 })
   * @example dur.set({ hours: 8, minutes: 30 })
   * @return {Duration}
   */
  set(values) {
    if (!this.isValid) return this;

    const mixed = { ...this.values, ...(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.normalizeObject)(values, Duration.normalizeUnit) };
    return clone(this, { values: mixed });
  }

  /**
   * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
   * @example dur.reconfigure({ locale: 'en-GB' })
   * @return {Duration}
   */
  reconfigure({ locale, numberingSystem, conversionAccuracy, matrix } = {}) {
    const loc = this.loc.clone({ locale, numberingSystem });
    const opts = { loc, matrix, conversionAccuracy };
    return clone(this, opts);
  }

  /**
   * Return the length of the duration in the specified unit.
   * @param {string} unit - a unit such as 'minutes' or 'days'
   * @example Duration.fromObject({years: 1}).as('days') //=> 365
   * @example Duration.fromObject({years: 1}).as('months') //=> 12
   * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
   * @return {number}
   */
  as(unit) {
    return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
  }

  /**
   * Reduce this Duration to its canonical representation in its current units.
   * Assuming the overall value of the Duration is positive, this means:
   * - excessive values for lower-order units are converted to higher-order units (if possible, see first and second example)
   * - negative lower-order units are converted to higher order units (there must be such a higher order unit, otherwise
   *   the overall value would be negative, see second example)
   * - fractional values for higher-order units are converted to lower-order units (if possible, see fourth example)
   *
   * If the overall value is negative, the result of this method is equivalent to `this.negate().normalize().negate()`.
   * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
   * @example Duration.fromObject({ days: 5000 }).normalize().toObject() //=> { days: 5000 }
   * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
   * @example Duration.fromObject({ years: 2.5, days: 0, hours: 0 }).normalize().toObject() //=> { years: 2, days: 182, hours: 12 }
   * @return {Duration}
   */
  normalize() {
    if (!this.isValid) return this;
    const vals = this.toObject();
    normalizeValues(this.matrix, vals);
    return clone(this, { values: vals }, true);
  }

  /**
   * Rescale units to its largest representation
   * @example Duration.fromObject({ milliseconds: 90000 }).rescale().toObject() //=> { minutes: 1, seconds: 30 }
   * @return {Duration}
   */
  rescale() {
    if (!this.isValid) return this;
    const vals = removeZeroes(this.normalize().shiftToAll().toObject());
    return clone(this, { values: vals }, true);
  }

  /**
   * Convert this Duration into its representation in a different set of units.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
   * @return {Duration}
   */
  shiftTo(...units) {
    if (!this.isValid) return this;

    if (units.length === 0) {
      return this;
    }

    units = units.map((u) => Duration.normalizeUnit(u));

    const built = {},
      accumulated = {},
      vals = this.toObject();
    let lastUnit;

    for (const k of orderedUnits) {
      if (units.indexOf(k) >= 0) {
        lastUnit = k;

        let own = 0;

        // anything we haven't boiled down yet should get boiled to this unit
        for (const ak in accumulated) {
          own += this.matrix[ak][k] * accumulated[ak];
          accumulated[ak] = 0;
        }

        // plus anything that's already in this unit
        if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.isNumber)(vals[k])) {
          own += vals[k];
        }

        // only keep the integer part for now in the hopes of putting any decimal part
        // into a smaller unit later
        const i = Math.trunc(own);
        built[k] = i;
        accumulated[k] = (own * 1000 - i * 1000) / 1000;

        // otherwise, keep it in the wings to boil it later
      } else if ((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.isNumber)(vals[k])) {
        accumulated[k] = vals[k];
      }
    }

    // anything leftover becomes the decimal for the last unit
    // lastUnit must be defined since units is not empty
    for (const key in accumulated) {
      if (accumulated[key] !== 0) {
        built[lastUnit] +=
          key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
      }
    }

    normalizeValues(this.matrix, built);
    return clone(this, { values: built }, true);
  }

  /**
   * Shift this Duration to all available units.
   * Same as shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds")
   * @return {Duration}
   */
  shiftToAll() {
    if (!this.isValid) return this;
    return this.shiftTo(
      "years",
      "months",
      "weeks",
      "days",
      "hours",
      "minutes",
      "seconds",
      "milliseconds"
    );
  }

  /**
   * Return the negative of this Duration.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
   * @return {Duration}
   */
  negate() {
    if (!this.isValid) return this;
    const negated = {};
    for (const k of Object.keys(this.values)) {
      negated[k] = this.values[k] === 0 ? 0 : -this.values[k];
    }
    return clone(this, { values: negated }, true);
  }

  /**
   * Get the years.
   * @type {number}
   */
  get years() {
    return this.isValid ? this.values.years || 0 : NaN;
  }

  /**
   * Get the quarters.
   * @type {number}
   */
  get quarters() {
    return this.isValid ? this.values.quarters || 0 : NaN;
  }

  /**
   * Get the months.
   * @type {number}
   */
  get months() {
    return this.isValid ? this.values.months || 0 : NaN;
  }

  /**
   * Get the weeks
   * @type {number}
   */
  get weeks() {
    return this.isValid ? this.values.weeks || 0 : NaN;
  }

  /**
   * Get the days.
   * @type {number}
   */
  get days() {
    return this.isValid ? this.values.days || 0 : NaN;
  }

  /**
   * Get the hours.
   * @type {number}
   */
  get hours() {
    return this.isValid ? this.values.hours || 0 : NaN;
  }

  /**
   * Get the minutes.
   * @type {number}
   */
  get minutes() {
    return this.isValid ? this.values.minutes || 0 : NaN;
  }

  /**
   * Get the seconds.
   * @return {number}
   */
  get seconds() {
    return this.isValid ? this.values.seconds || 0 : NaN;
  }

  /**
   * Get the milliseconds.
   * @return {number}
   */
  get milliseconds() {
    return this.isValid ? this.values.milliseconds || 0 : NaN;
  }

  /**
   * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
   * on invalid DateTimes or Intervals.
   * @return {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }

  /**
   * Returns an error code if this Duration became invalid, or null if the Duration is valid
   * @return {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }

  /**
   * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }

  /**
   * Equality check
   * Two Durations are equal iff they have the same units and the same values for each unit.
   * @param {Duration} other
   * @return {boolean}
   */
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }

    if (!this.loc.equals(other.loc)) {
      return false;
    }

    function eq(v1, v2) {
      // Consider 0 and undefined as equal
      if (v1 === undefined || v1 === 0) return v2 === undefined || v2 === 0;
      return v1 === v2;
    }

    for (const u of orderedUnits) {
      if (!eq(this.values[u], other.values[u])) {
        return false;
      }
    }
    return true;
  }
}


/***/ }),

/***/ "./node_modules/luxon/src/errors.js":
/*!******************************************!*\
  !*** ./node_modules/luxon/src/errors.js ***!
  \******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ConflictingSpecificationError: function() { return /* binding */ ConflictingSpecificationError; },
/* harmony export */   InvalidArgumentError: function() { return /* binding */ InvalidArgumentError; },
/* harmony export */   InvalidDateTimeError: function() { return /* binding */ InvalidDateTimeError; },
/* harmony export */   InvalidDurationError: function() { return /* binding */ InvalidDurationError; },
/* harmony export */   InvalidIntervalError: function() { return /* binding */ InvalidIntervalError; },
/* harmony export */   InvalidUnitError: function() { return /* binding */ InvalidUnitError; },
/* harmony export */   ZoneIsAbstractError: function() { return /* binding */ ZoneIsAbstractError; }
/* harmony export */ });
// these aren't really private, but nor are they really useful to document

/**
 * @private
 */
class LuxonError extends Error {}

/**
 * @private
 */
class InvalidDateTimeError extends LuxonError {
  constructor(reason) {
    super(`Invalid DateTime: ${reason.toMessage()}`);
  }
}

/**
 * @private
 */
class InvalidIntervalError extends LuxonError {
  constructor(reason) {
    super(`Invalid Interval: ${reason.toMessage()}`);
  }
}

/**
 * @private
 */
class InvalidDurationError extends LuxonError {
  constructor(reason) {
    super(`Invalid Duration: ${reason.toMessage()}`);
  }
}

/**
 * @private
 */
class ConflictingSpecificationError extends LuxonError {}

/**
 * @private
 */
class InvalidUnitError extends LuxonError {
  constructor(unit) {
    super(`Invalid unit ${unit}`);
  }
}

/**
 * @private
 */
class InvalidArgumentError extends LuxonError {}

/**
 * @private
 */
class ZoneIsAbstractError extends LuxonError {
  constructor() {
    super("Zone is an abstract class");
  }
}


/***/ }),

/***/ "./node_modules/luxon/src/impl/conversions.js":
/*!****************************************************!*\
  !*** ./node_modules/luxon/src/impl/conversions.js ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   gregorianToOrdinal: function() { return /* binding */ gregorianToOrdinal; },
/* harmony export */   gregorianToWeek: function() { return /* binding */ gregorianToWeek; },
/* harmony export */   hasInvalidGregorianData: function() { return /* binding */ hasInvalidGregorianData; },
/* harmony export */   hasInvalidOrdinalData: function() { return /* binding */ hasInvalidOrdinalData; },
/* harmony export */   hasInvalidTimeData: function() { return /* binding */ hasInvalidTimeData; },
/* harmony export */   hasInvalidWeekData: function() { return /* binding */ hasInvalidWeekData; },
/* harmony export */   ordinalToGregorian: function() { return /* binding */ ordinalToGregorian; },
/* harmony export */   weekToGregorian: function() { return /* binding */ weekToGregorian; }
/* harmony export */ });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ "./node_modules/luxon/src/impl/util.js");
/* harmony import */ var _invalid_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./invalid.js */ "./node_modules/luxon/src/impl/invalid.js");



const nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334],
  leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];

function unitOutOfRange(unit, value) {
  return new _invalid_js__WEBPACK_IMPORTED_MODULE_1__["default"](
    "unit out of range",
    `you specified ${value} (of type ${typeof value}) as a ${unit}, which is invalid`
  );
}

function dayOfWeek(year, month, day) {
  const d = new Date(Date.UTC(year, month - 1, day));

  if (year < 100 && year >= 0) {
    d.setUTCFullYear(d.getUTCFullYear() - 1900);
  }

  const js = d.getUTCDay();

  return js === 0 ? 7 : js;
}

function computeOrdinal(year, month, day) {
  return day + ((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isLeapYear)(year) ? leapLadder : nonLeapLadder)[month - 1];
}

function uncomputeOrdinal(year, ordinal) {
  const table = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isLeapYear)(year) ? leapLadder : nonLeapLadder,
    month0 = table.findIndex((i) => i < ordinal),
    day = ordinal - table[month0];
  return { month: month0 + 1, day };
}

/**
 * @private
 */

function gregorianToWeek(gregObj) {
  const { year, month, day } = gregObj,
    ordinal = computeOrdinal(year, month, day),
    weekday = dayOfWeek(year, month, day);

  let weekNumber = Math.floor((ordinal - weekday + 10) / 7),
    weekYear;

  if (weekNumber < 1) {
    weekYear = year - 1;
    weekNumber = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.weeksInWeekYear)(weekYear);
  } else if (weekNumber > (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.weeksInWeekYear)(year)) {
    weekYear = year + 1;
    weekNumber = 1;
  } else {
    weekYear = year;
  }

  return { weekYear, weekNumber, weekday, ...(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.timeObject)(gregObj) };
}

function weekToGregorian(weekData) {
  const { weekYear, weekNumber, weekday } = weekData,
    weekdayOfJan4 = dayOfWeek(weekYear, 1, 4),
    yearInDays = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.daysInYear)(weekYear);

  let ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 3,
    year;

  if (ordinal < 1) {
    year = weekYear - 1;
    ordinal += (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.daysInYear)(year);
  } else if (ordinal > yearInDays) {
    year = weekYear + 1;
    ordinal -= (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.daysInYear)(weekYear);
  } else {
    year = weekYear;
  }

  const { month, day } = uncomputeOrdinal(year, ordinal);
  return { year, month, day, ...(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.timeObject)(weekData) };
}

function gregorianToOrdinal(gregData) {
  const { year, month, day } = gregData;
  const ordinal = computeOrdinal(year, month, day);
  return { year, ordinal, ...(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.timeObject)(gregData) };
}

function ordinalToGregorian(ordinalData) {
  const { year, ordinal } = ordinalData;
  const { month, day } = uncomputeOrdinal(year, ordinal);
  return { year, month, day, ...(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.timeObject)(ordinalData) };
}

function hasInvalidWeekData(obj) {
  const validYear = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isInteger)(obj.weekYear),
    validWeek = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.integerBetween)(obj.weekNumber, 1, (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.weeksInWeekYear)(obj.weekYear)),
    validWeekday = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.integerBetween)(obj.weekday, 1, 7);

  if (!validYear) {
    return unitOutOfRange("weekYear", obj.weekYear);
  } else if (!validWeek) {
    return unitOutOfRange("week", obj.week);
  } else if (!validWeekday) {
    return unitOutOfRange("weekday", obj.weekday);
  } else return false;
}

function hasInvalidOrdinalData(obj) {
  const validYear = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isInteger)(obj.year),
    validOrdinal = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.integerBetween)(obj.ordinal, 1, (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.daysInYear)(obj.year));

  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validOrdinal) {
    return unitOutOfRange("ordinal", obj.ordinal);
  } else return false;
}

function hasInvalidGregorianData(obj) {
  const validYear = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isInteger)(obj.year),
    validMonth = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.integerBetween)(obj.month, 1, 12),
    validDay = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.integerBetween)(obj.day, 1, (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.daysInMonth)(obj.year, obj.month));

  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validMonth) {
    return unitOutOfRange("month", obj.month);
  } else if (!validDay) {
    return unitOutOfRange("day", obj.day);
  } else return false;
}

function hasInvalidTimeData(obj) {
  const { hour, minute, second, millisecond } = obj;
  const validHour =
      (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.integerBetween)(hour, 0, 23) ||
      (hour === 24 && minute === 0 && second === 0 && millisecond === 0),
    validMinute = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.integerBetween)(minute, 0, 59),
    validSecond = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.integerBetween)(second, 0, 59),
    validMillisecond = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.integerBetween)(millisecond, 0, 999);

  if (!validHour) {
    return unitOutOfRange("hour", hour);
  } else if (!validMinute) {
    return unitOutOfRange("minute", minute);
  } else if (!validSecond) {
    return unitOutOfRange("second", second);
  } else if (!validMillisecond) {
    return unitOutOfRange("millisecond", millisecond);
  } else return false;
}


/***/ }),

/***/ "./node_modules/luxon/src/impl/diff.js":
/*!*********************************************!*\
  !*** ./node_modules/luxon/src/impl/diff.js ***!
  \*********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../duration.js */ "./node_modules/luxon/src/duration.js");


function dayDiff(earlier, later) {
  const utcDayStart = (dt) => dt.toUTC(0, { keepLocalTime: true }).startOf("day").valueOf(),
    ms = utcDayStart(later) - utcDayStart(earlier);
  return Math.floor(_duration_js__WEBPACK_IMPORTED_MODULE_0__["default"].fromMillis(ms).as("days"));
}

function highOrderDiffs(cursor, later, units) {
  const differs = [
    ["years", (a, b) => b.year - a.year],
    ["quarters", (a, b) => b.quarter - a.quarter + (b.year - a.year) * 4],
    ["months", (a, b) => b.month - a.month + (b.year - a.year) * 12],
    [
      "weeks",
      (a, b) => {
        const days = dayDiff(a, b);
        return (days - (days % 7)) / 7;
      },
    ],
    ["days", dayDiff],
  ];

  const results = {};
  const earlier = cursor;
  let lowestOrder, highWater;

  /* This loop tries to diff using larger units first.
     If we overshoot, we backtrack and try the next smaller unit.
     "cursor" starts out at the earlier timestamp and moves closer and closer to "later"
     as we use smaller and smaller units.
     highWater keeps track of where we would be if we added one more of the smallest unit,
     this is used later to potentially convert any difference smaller than the smallest higher order unit
     into a fraction of that smallest higher order unit
  */
  for (const [unit, differ] of differs) {
    if (units.indexOf(unit) >= 0) {
      lowestOrder = unit;

      results[unit] = differ(cursor, later);
      highWater = earlier.plus(results);

      if (highWater > later) {
        // we overshot the end point, backtrack cursor by 1
        results[unit]--;
        cursor = earlier.plus(results);

        // if we are still overshooting now, we need to backtrack again
        // this happens in certain situations when diffing times in different zones,
        // because this calculation ignores time zones
        if (cursor > later) {
          // keep the "overshot by 1" around as highWater
          highWater = cursor;
          // backtrack cursor by 1
          results[unit]--;
          cursor = earlier.plus(results);
        }
      } else {
        cursor = highWater;
      }
    }
  }

  return [cursor, results, highWater, lowestOrder];
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(earlier, later, units, opts) {
  let [cursor, results, highWater, lowestOrder] = highOrderDiffs(earlier, later, units);

  const remainingMillis = later - cursor;

  const lowerOrderUnits = units.filter(
    (u) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(u) >= 0
  );

  if (lowerOrderUnits.length === 0) {
    if (highWater < later) {
      highWater = cursor.plus({ [lowestOrder]: 1 });
    }

    if (highWater !== cursor) {
      results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
    }
  }

  const duration = _duration_js__WEBPACK_IMPORTED_MODULE_0__["default"].fromObject(results, opts);

  if (lowerOrderUnits.length > 0) {
    return _duration_js__WEBPACK_IMPORTED_MODULE_0__["default"].fromMillis(remainingMillis, opts)
      .shiftTo(...lowerOrderUnits)
      .plus(duration);
  } else {
    return duration;
  }
}


/***/ }),

/***/ "./node_modules/luxon/src/impl/digits.js":
/*!***********************************************!*\
  !*** ./node_modules/luxon/src/impl/digits.js ***!
  \***********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   digitRegex: function() { return /* binding */ digitRegex; },
/* harmony export */   parseDigits: function() { return /* binding */ parseDigits; }
/* harmony export */ });
const numberingSystems = {
  arab: "[\u0660-\u0669]",
  arabext: "[\u06F0-\u06F9]",
  bali: "[\u1B50-\u1B59]",
  beng: "[\u09E6-\u09EF]",
  deva: "[\u0966-\u096F]",
  fullwide: "[\uFF10-\uFF19]",
  gujr: "[\u0AE6-\u0AEF]",
  hanidec: "[〇|一|二|三|四|五|六|七|八|九]",
  khmr: "[\u17E0-\u17E9]",
  knda: "[\u0CE6-\u0CEF]",
  laoo: "[\u0ED0-\u0ED9]",
  limb: "[\u1946-\u194F]",
  mlym: "[\u0D66-\u0D6F]",
  mong: "[\u1810-\u1819]",
  mymr: "[\u1040-\u1049]",
  orya: "[\u0B66-\u0B6F]",
  tamldec: "[\u0BE6-\u0BEF]",
  telu: "[\u0C66-\u0C6F]",
  thai: "[\u0E50-\u0E59]",
  tibt: "[\u0F20-\u0F29]",
  latn: "\\d",
};

const numberingSystemsUTF16 = {
  arab: [1632, 1641],
  arabext: [1776, 1785],
  bali: [6992, 7001],
  beng: [2534, 2543],
  deva: [2406, 2415],
  fullwide: [65296, 65303],
  gujr: [2790, 2799],
  khmr: [6112, 6121],
  knda: [3302, 3311],
  laoo: [3792, 3801],
  limb: [6470, 6479],
  mlym: [3430, 3439],
  mong: [6160, 6169],
  mymr: [4160, 4169],
  orya: [2918, 2927],
  tamldec: [3046, 3055],
  telu: [3174, 3183],
  thai: [3664, 3673],
  tibt: [3872, 3881],
};

const hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");

function parseDigits(str) {
  let value = parseInt(str, 10);
  if (isNaN(value)) {
    value = "";
    for (let i = 0; i < str.length; i++) {
      const code = str.charCodeAt(i);

      if (str[i].search(numberingSystems.hanidec) !== -1) {
        value += hanidecChars.indexOf(str[i]);
      } else {
        for (const key in numberingSystemsUTF16) {
          const [min, max] = numberingSystemsUTF16[key];
          if (code >= min && code <= max) {
            value += code - min;
          }
        }
      }
    }
    return parseInt(value, 10);
  } else {
    return value;
  }
}

function digitRegex({ numberingSystem }, append = "") {
  return new RegExp(`${numberingSystems[numberingSystem || "latn"]}${append}`);
}


/***/ }),

/***/ "./node_modules/luxon/src/impl/english.js":
/*!************************************************!*\
  !*** ./node_modules/luxon/src/impl/english.js ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   eraForDateTime: function() { return /* binding */ eraForDateTime; },
/* harmony export */   eras: function() { return /* binding */ eras; },
/* harmony export */   erasLong: function() { return /* binding */ erasLong; },
/* harmony export */   erasNarrow: function() { return /* binding */ erasNarrow; },
/* harmony export */   erasShort: function() { return /* binding */ erasShort; },
/* harmony export */   formatRelativeTime: function() { return /* binding */ formatRelativeTime; },
/* harmony export */   formatString: function() { return /* binding */ formatString; },
/* harmony export */   meridiemForDateTime: function() { return /* binding */ meridiemForDateTime; },
/* harmony export */   meridiems: function() { return /* binding */ meridiems; },
/* harmony export */   monthForDateTime: function() { return /* binding */ monthForDateTime; },
/* harmony export */   months: function() { return /* binding */ months; },
/* harmony export */   monthsLong: function() { return /* binding */ monthsLong; },
/* harmony export */   monthsNarrow: function() { return /* binding */ monthsNarrow; },
/* harmony export */   monthsShort: function() { return /* binding */ monthsShort; },
/* harmony export */   weekdayForDateTime: function() { return /* binding */ weekdayForDateTime; },
/* harmony export */   weekdays: function() { return /* binding */ weekdays; },
/* harmony export */   weekdaysLong: function() { return /* binding */ weekdaysLong; },
/* harmony export */   weekdaysNarrow: function() { return /* binding */ weekdaysNarrow; },
/* harmony export */   weekdaysShort: function() { return /* binding */ weekdaysShort; }
/* harmony export */ });
/* harmony import */ var _formats_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formats.js */ "./node_modules/luxon/src/impl/formats.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.js */ "./node_modules/luxon/src/impl/util.js");



function stringify(obj) {
  return JSON.stringify(obj, Object.keys(obj).sort());
}

/**
 * @private
 */

const monthsLong = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December",
];

const monthsShort = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec",
];

const monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];

function months(length) {
  switch (length) {
    case "narrow":
      return [...monthsNarrow];
    case "short":
      return [...monthsShort];
    case "long":
      return [...monthsLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
    case "2-digit":
      return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
    default:
      return null;
  }
}

const weekdaysLong = [
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday",
  "Sunday",
];

const weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];

const weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];

function weekdays(length) {
  switch (length) {
    case "narrow":
      return [...weekdaysNarrow];
    case "short":
      return [...weekdaysShort];
    case "long":
      return [...weekdaysLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7"];
    default:
      return null;
  }
}

const meridiems = ["AM", "PM"];

const erasLong = ["Before Christ", "Anno Domini"];

const erasShort = ["BC", "AD"];

const erasNarrow = ["B", "A"];

function eras(length) {
  switch (length) {
    case "narrow":
      return [...erasNarrow];
    case "short":
      return [...erasShort];
    case "long":
      return [...erasLong];
    default:
      return null;
  }
}

function meridiemForDateTime(dt) {
  return meridiems[dt.hour < 12 ? 0 : 1];
}

function weekdayForDateTime(dt, length) {
  return weekdays(length)[dt.weekday - 1];
}

function monthForDateTime(dt, length) {
  return months(length)[dt.month - 1];
}

function eraForDateTime(dt, length) {
  return eras(length)[dt.year < 0 ? 0 : 1];
}

function formatRelativeTime(unit, count, numeric = "always", narrow = false) {
  const units = {
    years: ["year", "yr."],
    quarters: ["quarter", "qtr."],
    months: ["month", "mo."],
    weeks: ["week", "wk."],
    days: ["day", "day", "days"],
    hours: ["hour", "hr."],
    minutes: ["minute", "min."],
    seconds: ["second", "sec."],
  };

  const lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;

  if (numeric === "auto" && lastable) {
    const isDay = unit === "days";
    switch (count) {
      case 1:
        return isDay ? "tomorrow" : `next ${units[unit][0]}`;
      case -1:
        return isDay ? "yesterday" : `last ${units[unit][0]}`;
      case 0:
        return isDay ? "today" : `this ${units[unit][0]}`;
      default: // fall through
    }
  }

  const isInPast = Object.is(count, -0) || count < 0,
    fmtValue = Math.abs(count),
    singular = fmtValue === 1,
    lilUnits = units[unit],
    fmtUnit = narrow
      ? singular
        ? lilUnits[1]
        : lilUnits[2] || lilUnits[1]
      : singular
      ? units[unit][0]
      : unit;
  return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;
}

function formatString(knownFormat) {
  // these all have the offsets removed because we don't have access to them
  // without all the intl stuff this is backfilling
  const filtered = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.pick)(knownFormat, [
      "weekday",
      "era",
      "year",
      "month",
      "day",
      "hour",
      "minute",
      "second",
      "timeZoneName",
      "hourCycle",
    ]),
    key = stringify(filtered),
    dateTimeHuge = "EEEE, LLLL d, yyyy, h:mm a";
  switch (key) {
    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATE_SHORT):
      return "M/d/yyyy";
    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATE_MED):
      return "LLL d, yyyy";
    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATE_MED_WITH_WEEKDAY):
      return "EEE, LLL d, yyyy";
    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATE_FULL):
      return "LLLL d, yyyy";
    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATE_HUGE):
      return "EEEE, LLLL d, yyyy";
    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.TIME_SIMPLE):
      return "h:mm a";
    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.TIME_WITH_SECONDS):
      return "h:mm:ss a";
    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.TIME_WITH_SHORT_OFFSET):
      return "h:mm a";
    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.TIME_WITH_LONG_OFFSET):
      return "h:mm a";
    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.TIME_24_SIMPLE):
      return "HH:mm";
    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.TIME_24_WITH_SECONDS):
      return "HH:mm:ss";
    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.TIME_24_WITH_SHORT_OFFSET):
      return "HH:mm";
    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.TIME_24_WITH_LONG_OFFSET):
      return "HH:mm";
    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_SHORT):
      return "M/d/yyyy, h:mm a";
    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_MED):
      return "LLL d, yyyy, h:mm a";
    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_FULL):
      return "LLLL d, yyyy, h:mm a";
    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_HUGE):
      return dateTimeHuge;
    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_SHORT_WITH_SECONDS):
      return "M/d/yyyy, h:mm:ss a";
    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_MED_WITH_SECONDS):
      return "LLL d, yyyy, h:mm:ss a";
    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_MED_WITH_WEEKDAY):
      return "EEE, d LLL yyyy, h:mm a";
    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_FULL_WITH_SECONDS):
      return "LLLL d, yyyy, h:mm:ss a";
    case stringify(_formats_js__WEBPACK_IMPORTED_MODULE_0__.DATETIME_HUGE_WITH_SECONDS):
      return "EEEE, LLLL d, yyyy, h:mm:ss a";
    default:
      return dateTimeHuge;
  }
}


/***/ }),

/***/ "./node_modules/luxon/src/impl/formats.js":
/*!************************************************!*\
  !*** ./node_modules/luxon/src/impl/formats.js ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DATETIME_FULL: function() { return /* binding */ DATETIME_FULL; },
/* harmony export */   DATETIME_FULL_WITH_SECONDS: function() { return /* binding */ DATETIME_FULL_WITH_SECONDS; },
/* harmony export */   DATETIME_HUGE: function() { return /* binding */ DATETIME_HUGE; },
/* harmony export */   DATETIME_HUGE_WITH_SECONDS: function() { return /* binding */ DATETIME_HUGE_WITH_SECONDS; },
/* harmony export */   DATETIME_MED: function() { return /* binding */ DATETIME_MED; },
/* harmony export */   DATETIME_MED_WITH_SECONDS: function() { return /* binding */ DATETIME_MED_WITH_SECONDS; },
/* harmony export */   DATETIME_MED_WITH_WEEKDAY: function() { return /* binding */ DATETIME_MED_WITH_WEEKDAY; },
/* harmony export */   DATETIME_SHORT: function() { return /* binding */ DATETIME_SHORT; },
/* harmony export */   DATETIME_SHORT_WITH_SECONDS: function() { return /* binding */ DATETIME_SHORT_WITH_SECONDS; },
/* harmony export */   DATE_FULL: function() { return /* binding */ DATE_FULL; },
/* harmony export */   DATE_HUGE: function() { return /* binding */ DATE_HUGE; },
/* harmony export */   DATE_MED: function() { return /* binding */ DATE_MED; },
/* harmony export */   DATE_MED_WITH_WEEKDAY: function() { return /* binding */ DATE_MED_WITH_WEEKDAY; },
/* harmony export */   DATE_SHORT: function() { return /* binding */ DATE_SHORT; },
/* harmony export */   TIME_24_SIMPLE: function() { return /* binding */ TIME_24_SIMPLE; },
/* harmony export */   TIME_24_WITH_LONG_OFFSET: function() { return /* binding */ TIME_24_WITH_LONG_OFFSET; },
/* harmony export */   TIME_24_WITH_SECONDS: function() { return /* binding */ TIME_24_WITH_SECONDS; },
/* harmony export */   TIME_24_WITH_SHORT_OFFSET: function() { return /* binding */ TIME_24_WITH_SHORT_OFFSET; },
/* harmony export */   TIME_SIMPLE: function() { return /* binding */ TIME_SIMPLE; },
/* harmony export */   TIME_WITH_LONG_OFFSET: function() { return /* binding */ TIME_WITH_LONG_OFFSET; },
/* harmony export */   TIME_WITH_SECONDS: function() { return /* binding */ TIME_WITH_SECONDS; },
/* harmony export */   TIME_WITH_SHORT_OFFSET: function() { return /* binding */ TIME_WITH_SHORT_OFFSET; }
/* harmony export */ });
/**
 * @private
 */

const n = "numeric",
  s = "short",
  l = "long";

const DATE_SHORT = {
  year: n,
  month: n,
  day: n,
};

const DATE_MED = {
  year: n,
  month: s,
  day: n,
};

const DATE_MED_WITH_WEEKDAY = {
  year: n,
  month: s,
  day: n,
  weekday: s,
};

const DATE_FULL = {
  year: n,
  month: l,
  day: n,
};

const DATE_HUGE = {
  year: n,
  month: l,
  day: n,
  weekday: l,
};

const TIME_SIMPLE = {
  hour: n,
  minute: n,
};

const TIME_WITH_SECONDS = {
  hour: n,
  minute: n,
  second: n,
};

const TIME_WITH_SHORT_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  timeZoneName: s,
};

const TIME_WITH_LONG_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  timeZoneName: l,
};

const TIME_24_SIMPLE = {
  hour: n,
  minute: n,
  hourCycle: "h23",
};

const TIME_24_WITH_SECONDS = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23",
};

const TIME_24_WITH_SHORT_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23",
  timeZoneName: s,
};

const TIME_24_WITH_LONG_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23",
  timeZoneName: l,
};

const DATETIME_SHORT = {
  year: n,
  month: n,
  day: n,
  hour: n,
  minute: n,
};

const DATETIME_SHORT_WITH_SECONDS = {
  year: n,
  month: n,
  day: n,
  hour: n,
  minute: n,
  second: n,
};

const DATETIME_MED = {
  year: n,
  month: s,
  day: n,
  hour: n,
  minute: n,
};

const DATETIME_MED_WITH_SECONDS = {
  year: n,
  month: s,
  day: n,
  hour: n,
  minute: n,
  second: n,
};

const DATETIME_MED_WITH_WEEKDAY = {
  year: n,
  month: s,
  day: n,
  weekday: s,
  hour: n,
  minute: n,
};

const DATETIME_FULL = {
  year: n,
  month: l,
  day: n,
  hour: n,
  minute: n,
  timeZoneName: s,
};

const DATETIME_FULL_WITH_SECONDS = {
  year: n,
  month: l,
  day: n,
  hour: n,
  minute: n,
  second: n,
  timeZoneName: s,
};

const DATETIME_HUGE = {
  year: n,
  month: l,
  day: n,
  weekday: l,
  hour: n,
  minute: n,
  timeZoneName: l,
};

const DATETIME_HUGE_WITH_SECONDS = {
  year: n,
  month: l,
  day: n,
  weekday: l,
  hour: n,
  minute: n,
  second: n,
  timeZoneName: l,
};


/***/ }),

/***/ "./node_modules/luxon/src/impl/formatter.js":
/*!**************************************************!*\
  !*** ./node_modules/luxon/src/impl/formatter.js ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ Formatter; }
/* harmony export */ });
/* harmony import */ var _english_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./english.js */ "./node_modules/luxon/src/impl/english.js");
/* harmony import */ var _formats_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./formats.js */ "./node_modules/luxon/src/impl/formats.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util.js */ "./node_modules/luxon/src/impl/util.js");




function stringifyTokens(splits, tokenToString) {
  let s = "";
  for (const token of splits) {
    if (token.literal) {
      s += token.val;
    } else {
      s += tokenToString(token.val);
    }
  }
  return s;
}

const macroTokenToFormatOpts = {
  D: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATE_SHORT,
  DD: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATE_MED,
  DDD: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATE_FULL,
  DDDD: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATE_HUGE,
  t: _formats_js__WEBPACK_IMPORTED_MODULE_1__.TIME_SIMPLE,
  tt: _formats_js__WEBPACK_IMPORTED_MODULE_1__.TIME_WITH_SECONDS,
  ttt: _formats_js__WEBPACK_IMPORTED_MODULE_1__.TIME_WITH_SHORT_OFFSET,
  tttt: _formats_js__WEBPACK_IMPORTED_MODULE_1__.TIME_WITH_LONG_OFFSET,
  T: _formats_js__WEBPACK_IMPORTED_MODULE_1__.TIME_24_SIMPLE,
  TT: _formats_js__WEBPACK_IMPORTED_MODULE_1__.TIME_24_WITH_SECONDS,
  TTT: _formats_js__WEBPACK_IMPORTED_MODULE_1__.TIME_24_WITH_SHORT_OFFSET,
  TTTT: _formats_js__WEBPACK_IMPORTED_MODULE_1__.TIME_24_WITH_LONG_OFFSET,
  f: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATETIME_SHORT,
  ff: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATETIME_MED,
  fff: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATETIME_FULL,
  ffff: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATETIME_HUGE,
  F: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATETIME_SHORT_WITH_SECONDS,
  FF: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATETIME_MED_WITH_SECONDS,
  FFF: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATETIME_FULL_WITH_SECONDS,
  FFFF: _formats_js__WEBPACK_IMPORTED_MODULE_1__.DATETIME_HUGE_WITH_SECONDS,
};

/**
 * @private
 */

class Formatter {
  static create(locale, opts = {}) {
    return new Formatter(locale, opts);
  }

  static parseFormat(fmt) {
    // white-space is always considered a literal in user-provided formats
    // the " " token has a special meaning (see unitForToken)

    let current = null,
      currentFull = "",
      bracketed = false;
    const splits = [];
    for (let i = 0; i < fmt.length; i++) {
      const c = fmt.charAt(i);
      if (c === "'") {
        if (currentFull.length > 0) {
          splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
        }
        current = null;
        currentFull = "";
        bracketed = !bracketed;
      } else if (bracketed) {
        currentFull += c;
      } else if (c === current) {
        currentFull += c;
      } else {
        if (currentFull.length > 0) {
          splits.push({ literal: /^\s+$/.test(currentFull), val: currentFull });
        }
        currentFull = c;
        current = c;
      }
    }

    if (currentFull.length > 0) {
      splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
    }

    return splits;
  }

  static macroTokenToFormatOpts(token) {
    return macroTokenToFormatOpts[token];
  }

  constructor(locale, formatOpts) {
    this.opts = formatOpts;
    this.loc = locale;
    this.systemLoc = null;
  }

  formatWithSystemDefault(dt, opts) {
    if (this.systemLoc === null) {
      this.systemLoc = this.loc.redefaultToSystem();
    }
    const df = this.systemLoc.dtFormatter(dt, { ...this.opts, ...opts });
    return df.format();
  }

  dtFormatter(dt, opts = {}) {
    return this.loc.dtFormatter(dt, { ...this.opts, ...opts });
  }

  formatDateTime(dt, opts) {
    return this.dtFormatter(dt, opts).format();
  }

  formatDateTimeParts(dt, opts) {
    return this.dtFormatter(dt, opts).formatToParts();
  }

  formatInterval(interval, opts) {
    const df = this.dtFormatter(interval.start, opts);
    return df.dtf.formatRange(interval.start.toJSDate(), interval.end.toJSDate());
  }

  resolvedOptions(dt, opts) {
    return this.dtFormatter(dt, opts).resolvedOptions();
  }

  num(n, p = 0) {
    // we get some perf out of doing this here, annoyingly
    if (this.opts.forceSimple) {
      return (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.padStart)(n, p);
    }

    const opts = { ...this.opts };

    if (p > 0) {
      opts.padTo = p;
    }

    return this.loc.numberFormatter(opts).format(n);
  }

  formatDateTimeFromString(dt, fmt) {
    const knownEnglish = this.loc.listingMode() === "en",
      useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory",
      string = (opts, extract) => this.loc.extract(dt, opts, extract),
      formatOffset = (opts) => {
        if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
          return "Z";
        }

        return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
      },
      meridiem = () =>
        knownEnglish
          ? _english_js__WEBPACK_IMPORTED_MODULE_0__.meridiemForDateTime(dt)
          : string({ hour: "numeric", hourCycle: "h12" }, "dayperiod"),
      month = (length, standalone) =>
        knownEnglish
          ? _english_js__WEBPACK_IMPORTED_MODULE_0__.monthForDateTime(dt, length)
          : string(standalone ? { month: length } : { month: length, day: "numeric" }, "month"),
      weekday = (length, standalone) =>
        knownEnglish
          ? _english_js__WEBPACK_IMPORTED_MODULE_0__.weekdayForDateTime(dt, length)
          : string(
              standalone ? { weekday: length } : { weekday: length, month: "long", day: "numeric" },
              "weekday"
            ),
      maybeMacro = (token) => {
        const formatOpts = Formatter.macroTokenToFormatOpts(token);
        if (formatOpts) {
          return this.formatWithSystemDefault(dt, formatOpts);
        } else {
          return token;
        }
      },
      era = (length) =>
        knownEnglish ? _english_js__WEBPACK_IMPORTED_MODULE_0__.eraForDateTime(dt, length) : string({ era: length }, "era"),
      tokenToString = (token) => {
        // Where possible: https://cldr.unicode.org/translation/date-time/date-time-symbols
        switch (token) {
          // ms
          case "S":
            return this.num(dt.millisecond);
          case "u":
          // falls through
          case "SSS":
            return this.num(dt.millisecond, 3);
          // seconds
          case "s":
            return this.num(dt.second);
          case "ss":
            return this.num(dt.second, 2);
          // fractional seconds
          case "uu":
            return this.num(Math.floor(dt.millisecond / 10), 2);
          case "uuu":
            return this.num(Math.floor(dt.millisecond / 100));
          // minutes
          case "m":
            return this.num(dt.minute);
          case "mm":
            return this.num(dt.minute, 2);
          // hours
          case "h":
            return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
          case "hh":
            return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
          case "H":
            return this.num(dt.hour);
          case "HH":
            return this.num(dt.hour, 2);
          // offset
          case "Z":
            // like +6
            return formatOffset({ format: "narrow", allowZ: this.opts.allowZ });
          case "ZZ":
            // like +06:00
            return formatOffset({ format: "short", allowZ: this.opts.allowZ });
          case "ZZZ":
            // like +0600
            return formatOffset({ format: "techie", allowZ: this.opts.allowZ });
          case "ZZZZ":
            // like EST
            return dt.zone.offsetName(dt.ts, { format: "short", locale: this.loc.locale });
          case "ZZZZZ":
            // like Eastern Standard Time
            return dt.zone.offsetName(dt.ts, { format: "long", locale: this.loc.locale });
          // zone
          case "z":
            // like America/New_York
            return dt.zoneName;
          // meridiems
          case "a":
            return meridiem();
          // dates
          case "d":
            return useDateTimeFormatter ? string({ day: "numeric" }, "day") : this.num(dt.day);
          case "dd":
            return useDateTimeFormatter ? string({ day: "2-digit" }, "day") : this.num(dt.day, 2);
          // weekdays - standalone
          case "c":
            // like 1
            return this.num(dt.weekday);
          case "ccc":
            // like 'Tues'
            return weekday("short", true);
          case "cccc":
            // like 'Tuesday'
            return weekday("long", true);
          case "ccccc":
            // like 'T'
            return weekday("narrow", true);
          // weekdays - format
          case "E":
            // like 1
            return this.num(dt.weekday);
          case "EEE":
            // like 'Tues'
            return weekday("short", false);
          case "EEEE":
            // like 'Tuesday'
            return weekday("long", false);
          case "EEEEE":
            // like 'T'
            return weekday("narrow", false);
          // months - standalone
          case "L":
            // like 1
            return useDateTimeFormatter
              ? string({ month: "numeric", day: "numeric" }, "month")
              : this.num(dt.month);
          case "LL":
            // like 01, doesn't seem to work
            return useDateTimeFormatter
              ? string({ month: "2-digit", day: "numeric" }, "month")
              : this.num(dt.month, 2);
          case "LLL":
            // like Jan
            return month("short", true);
          case "LLLL":
            // like January
            return month("long", true);
          case "LLLLL":
            // like J
            return month("narrow", true);
          // months - format
          case "M":
            // like 1
            return useDateTimeFormatter
              ? string({ month: "numeric" }, "month")
              : this.num(dt.month);
          case "MM":
            // like 01
            return useDateTimeFormatter
              ? string({ month: "2-digit" }, "month")
              : this.num(dt.month, 2);
          case "MMM":
            // like Jan
            return month("short", false);
          case "MMMM":
            // like January
            return month("long", false);
          case "MMMMM":
            // like J
            return month("narrow", false);
          // years
          case "y":
            // like 2014
            return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year);
          case "yy":
            // like 14
            return useDateTimeFormatter
              ? string({ year: "2-digit" }, "year")
              : this.num(dt.year.toString().slice(-2), 2);
          case "yyyy":
            // like 0012
            return useDateTimeFormatter
              ? string({ year: "numeric" }, "year")
              : this.num(dt.year, 4);
          case "yyyyyy":
            // like 000012
            return useDateTimeFormatter
              ? string({ year: "numeric" }, "year")
              : this.num(dt.year, 6);
          // eras
          case "G":
            // like AD
            return era("short");
          case "GG":
            // like Anno Domini
            return era("long");
          case "GGGGG":
            return era("narrow");
          case "kk":
            return this.num(dt.weekYear.toString().slice(-2), 2);
          case "kkkk":
            return this.num(dt.weekYear, 4);
          case "W":
            return this.num(dt.weekNumber);
          case "WW":
            return this.num(dt.weekNumber, 2);
          case "o":
            return this.num(dt.ordinal);
          case "ooo":
            return this.num(dt.ordinal, 3);
          case "q":
            // like 1
            return this.num(dt.quarter);
          case "qq":
            // like 01
            return this.num(dt.quarter, 2);
          case "X":
            return this.num(Math.floor(dt.ts / 1000));
          case "x":
            return this.num(dt.ts);
          default:
            return maybeMacro(token);
        }
      };

    return stringifyTokens(Formatter.parseFormat(fmt), tokenToString);
  }

  formatDurationFromString(dur, fmt) {
    const tokenToField = (token) => {
        switch (token[0]) {
          case "S":
            return "millisecond";
          case "s":
            return "second";
          case "m":
            return "minute";
          case "h":
            return "hour";
          case "d":
            return "day";
          case "w":
            return "week";
          case "M":
            return "month";
          case "y":
            return "year";
          default:
            return null;
        }
      },
      tokenToString = (lildur) => (token) => {
        const mapped = tokenToField(token);
        if (mapped) {
          return this.num(lildur.get(mapped), token.length);
        } else {
          return token;
        }
      },
      tokens = Formatter.parseFormat(fmt),
      realTokens = tokens.reduce(
        (found, { literal, val }) => (literal ? found : found.concat(val)),
        []
      ),
      collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter((t) => t));
    return stringifyTokens(tokens, tokenToString(collapsed));
  }
}


/***/ }),

/***/ "./node_modules/luxon/src/impl/invalid.js":
/*!************************************************!*\
  !*** ./node_modules/luxon/src/impl/invalid.js ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ Invalid; }
/* harmony export */ });
class Invalid {
  constructor(reason, explanation) {
    this.reason = reason;
    this.explanation = explanation;
  }

  toMessage() {
    if (this.explanation) {
      return `${this.reason}: ${this.explanation}`;
    } else {
      return this.reason;
    }
  }
}


/***/ }),

/***/ "./node_modules/luxon/src/impl/locale.js":
/*!***********************************************!*\
  !*** ./node_modules/luxon/src/impl/locale.js ***!
  \***********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ Locale; }
/* harmony export */ });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ "./node_modules/luxon/src/impl/util.js");
/* harmony import */ var _english_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./english.js */ "./node_modules/luxon/src/impl/english.js");
/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../settings.js */ "./node_modules/luxon/src/settings.js");
/* harmony import */ var _datetime_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../datetime.js */ "./node_modules/luxon/src/datetime.js");
/* harmony import */ var _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../zones/IANAZone.js */ "./node_modules/luxon/src/zones/IANAZone.js");






// todo - remap caching

let intlLFCache = {};
function getCachedLF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlLFCache[key];
  if (!dtf) {
    dtf = new Intl.ListFormat(locString, opts);
    intlLFCache[key] = dtf;
  }
  return dtf;
}

let intlDTCache = {};
function getCachedDTF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlDTCache[key];
  if (!dtf) {
    dtf = new Intl.DateTimeFormat(locString, opts);
    intlDTCache[key] = dtf;
  }
  return dtf;
}

let intlNumCache = {};
function getCachedINF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let inf = intlNumCache[key];
  if (!inf) {
    inf = new Intl.NumberFormat(locString, opts);
    intlNumCache[key] = inf;
  }
  return inf;
}

let intlRelCache = {};
function getCachedRTF(locString, opts = {}) {
  const { base, ...cacheKeyOpts } = opts; // exclude `base` from the options
  const key = JSON.stringify([locString, cacheKeyOpts]);
  let inf = intlRelCache[key];
  if (!inf) {
    inf = new Intl.RelativeTimeFormat(locString, opts);
    intlRelCache[key] = inf;
  }
  return inf;
}

let sysLocaleCache = null;
function systemLocale() {
  if (sysLocaleCache) {
    return sysLocaleCache;
  } else {
    sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;
    return sysLocaleCache;
  }
}

function parseLocaleString(localeStr) {
  // I really want to avoid writing a BCP 47 parser
  // see, e.g. https://github.com/wooorm/bcp-47
  // Instead, we'll do this:

  // a) if the string has no -u extensions, just leave it alone
  // b) if it does, use Intl to resolve everything
  // c) if Intl fails, try again without the -u

  // private subtags and unicode subtags have ordering requirements,
  // and we're not properly parsing this, so just strip out the
  // private ones if they exist.
  const xIndex = localeStr.indexOf("-x-");
  if (xIndex !== -1) {
    localeStr = localeStr.substring(0, xIndex);
  }

  const uIndex = localeStr.indexOf("-u-");
  if (uIndex === -1) {
    return [localeStr];
  } else {
    let options;
    let selectedStr;
    try {
      options = getCachedDTF(localeStr).resolvedOptions();
      selectedStr = localeStr;
    } catch (e) {
      const smaller = localeStr.substring(0, uIndex);
      options = getCachedDTF(smaller).resolvedOptions();
      selectedStr = smaller;
    }

    const { numberingSystem, calendar } = options;
    return [selectedStr, numberingSystem, calendar];
  }
}

function intlConfigString(localeStr, numberingSystem, outputCalendar) {
  if (outputCalendar || numberingSystem) {
    if (!localeStr.includes("-u-")) {
      localeStr += "-u";
    }

    if (outputCalendar) {
      localeStr += `-ca-${outputCalendar}`;
    }

    if (numberingSystem) {
      localeStr += `-nu-${numberingSystem}`;
    }
    return localeStr;
  } else {
    return localeStr;
  }
}

function mapMonths(f) {
  const ms = [];
  for (let i = 1; i <= 12; i++) {
    const dt = _datetime_js__WEBPACK_IMPORTED_MODULE_3__["default"].utc(2009, i, 1);
    ms.push(f(dt));
  }
  return ms;
}

function mapWeekdays(f) {
  const ms = [];
  for (let i = 1; i <= 7; i++) {
    const dt = _datetime_js__WEBPACK_IMPORTED_MODULE_3__["default"].utc(2016, 11, 13 + i);
    ms.push(f(dt));
  }
  return ms;
}

function listStuff(loc, length, englishFn, intlFn) {
  const mode = loc.listingMode();

  if (mode === "error") {
    return null;
  } else if (mode === "en") {
    return englishFn(length);
  } else {
    return intlFn(length);
  }
}

function supportsFastNumbers(loc) {
  if (loc.numberingSystem && loc.numberingSystem !== "latn") {
    return false;
  } else {
    return (
      loc.numberingSystem === "latn" ||
      !loc.locale ||
      loc.locale.startsWith("en") ||
      new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn"
    );
  }
}

/**
 * @private
 */

class PolyNumberFormatter {
  constructor(intl, forceSimple, opts) {
    this.padTo = opts.padTo || 0;
    this.floor = opts.floor || false;

    const { padTo, floor, ...otherOpts } = opts;

    if (!forceSimple || Object.keys(otherOpts).length > 0) {
      const intlOpts = { useGrouping: false, ...opts };
      if (opts.padTo > 0) intlOpts.minimumIntegerDigits = opts.padTo;
      this.inf = getCachedINF(intl, intlOpts);
    }
  }

  format(i) {
    if (this.inf) {
      const fixed = this.floor ? Math.floor(i) : i;
      return this.inf.format(fixed);
    } else {
      // to match the browser's numberformatter defaults
      const fixed = this.floor ? Math.floor(i) : (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.roundTo)(i, 3);
      return (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.padStart)(fixed, this.padTo);
    }
  }
}

/**
 * @private
 */

class PolyDateFormatter {
  constructor(dt, intl, opts) {
    this.opts = opts;
    this.originalZone = undefined;

    let z = undefined;
    if (this.opts.timeZone) {
      // Don't apply any workarounds if a timeZone is explicitly provided in opts
      this.dt = dt;
    } else if (dt.zone.type === "fixed") {
      // UTC-8 or Etc/UTC-8 are not part of tzdata, only Etc/GMT+8 and the like.
      // That is why fixed-offset TZ is set to that unless it is:
      // 1. Representing offset 0 when UTC is used to maintain previous behavior and does not become GMT.
      // 2. Unsupported by the browser:
      //    - some do not support Etc/
      //    - < Etc/GMT-14, > Etc/GMT+12, and 30-minute or 45-minute offsets are not part of tzdata
      const gmtOffset = -1 * (dt.offset / 60);
      const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;
      if (dt.offset !== 0 && _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_4__["default"].create(offsetZ).valid) {
        z = offsetZ;
        this.dt = dt;
      } else {
        // Not all fixed-offset zones like Etc/+4:30 are present in tzdata so
        // we manually apply the offset and substitute the zone as needed.
        z = "UTC";
        this.dt = dt.offset === 0 ? dt : dt.setZone("UTC").plus({ minutes: dt.offset });
        this.originalZone = dt.zone;
      }
    } else if (dt.zone.type === "system") {
      this.dt = dt;
    } else if (dt.zone.type === "iana") {
      this.dt = dt;
      z = dt.zone.name;
    } else {
      // Custom zones can have any offset / offsetName so we just manually
      // apply the offset and substitute the zone as needed.
      z = "UTC";
      this.dt = dt.setZone("UTC").plus({ minutes: dt.offset });
      this.originalZone = dt.zone;
    }

    const intlOpts = { ...this.opts };
    intlOpts.timeZone = intlOpts.timeZone || z;
    this.dtf = getCachedDTF(intl, intlOpts);
  }

  format() {
    if (this.originalZone) {
      // If we have to substitute in the actual zone name, we have to use
      // formatToParts so that the timezone can be replaced.
      return this.formatToParts()
        .map(({ value }) => value)
        .join("");
    }
    return this.dtf.format(this.dt.toJSDate());
  }

  formatToParts() {
    const parts = this.dtf.formatToParts(this.dt.toJSDate());
    if (this.originalZone) {
      return parts.map((part) => {
        if (part.type === "timeZoneName") {
          const offsetName = this.originalZone.offsetName(this.dt.ts, {
            locale: this.dt.locale,
            format: this.opts.timeZoneName,
          });
          return {
            ...part,
            value: offsetName,
          };
        } else {
          return part;
        }
      });
    }
    return parts;
  }

  resolvedOptions() {
    return this.dtf.resolvedOptions();
  }
}

/**
 * @private
 */
class PolyRelFormatter {
  constructor(intl, isEnglish, opts) {
    this.opts = { style: "long", ...opts };
    if (!isEnglish && (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.hasRelative)()) {
      this.rtf = getCachedRTF(intl, opts);
    }
  }

  format(count, unit) {
    if (this.rtf) {
      return this.rtf.format(count, unit);
    } else {
      return _english_js__WEBPACK_IMPORTED_MODULE_1__.formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== "long");
    }
  }

  formatToParts(count, unit) {
    if (this.rtf) {
      return this.rtf.formatToParts(count, unit);
    } else {
      return [];
    }
  }
}

/**
 * @private
 */

class Locale {
  static fromOpts(opts) {
    return Locale.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.defaultToEN);
  }

  static create(locale, numberingSystem, outputCalendar, defaultToEN = false) {
    const specifiedLocale = locale || _settings_js__WEBPACK_IMPORTED_MODULE_2__["default"].defaultLocale;
    // the system locale is useful for human readable strings but annoying for parsing/formatting known formats
    const localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale());
    const numberingSystemR = numberingSystem || _settings_js__WEBPACK_IMPORTED_MODULE_2__["default"].defaultNumberingSystem;
    const outputCalendarR = outputCalendar || _settings_js__WEBPACK_IMPORTED_MODULE_2__["default"].defaultOutputCalendar;
    return new Locale(localeR, numberingSystemR, outputCalendarR, specifiedLocale);
  }

  static resetCache() {
    sysLocaleCache = null;
    intlDTCache = {};
    intlNumCache = {};
    intlRelCache = {};
  }

  static fromObject({ locale, numberingSystem, outputCalendar } = {}) {
    return Locale.create(locale, numberingSystem, outputCalendar);
  }

  constructor(locale, numbering, outputCalendar, specifiedLocale) {
    const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);

    this.locale = parsedLocale;
    this.numberingSystem = numbering || parsedNumberingSystem || null;
    this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
    this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);

    this.weekdaysCache = { format: {}, standalone: {} };
    this.monthsCache = { format: {}, standalone: {} };
    this.meridiemCache = null;
    this.eraCache = {};

    this.specifiedLocale = specifiedLocale;
    this.fastNumbersCached = null;
  }

  get fastNumbers() {
    if (this.fastNumbersCached == null) {
      this.fastNumbersCached = supportsFastNumbers(this);
    }

    return this.fastNumbersCached;
  }

  listingMode() {
    const isActuallyEn = this.isEnglish();
    const hasNoWeirdness =
      (this.numberingSystem === null || this.numberingSystem === "latn") &&
      (this.outputCalendar === null || this.outputCalendar === "gregory");
    return isActuallyEn && hasNoWeirdness ? "en" : "intl";
  }

  clone(alts) {
    if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
      return this;
    } else {
      return Locale.create(
        alts.locale || this.specifiedLocale,
        alts.numberingSystem || this.numberingSystem,
        alts.outputCalendar || this.outputCalendar,
        alts.defaultToEN || false
      );
    }
  }

  redefaultToEN(alts = {}) {
    return this.clone({ ...alts, defaultToEN: true });
  }

  redefaultToSystem(alts = {}) {
    return this.clone({ ...alts, defaultToEN: false });
  }

  months(length, format = false) {
    return listStuff(this, length, _english_js__WEBPACK_IMPORTED_MODULE_1__.months, () => {
      const intl = format ? { month: length, day: "numeric" } : { month: length },
        formatStr = format ? "format" : "standalone";
      if (!this.monthsCache[formatStr][length]) {
        this.monthsCache[formatStr][length] = mapMonths((dt) => this.extract(dt, intl, "month"));
      }
      return this.monthsCache[formatStr][length];
    });
  }

  weekdays(length, format = false) {
    return listStuff(this, length, _english_js__WEBPACK_IMPORTED_MODULE_1__.weekdays, () => {
      const intl = format
          ? { weekday: length, year: "numeric", month: "long", day: "numeric" }
          : { weekday: length },
        formatStr = format ? "format" : "standalone";
      if (!this.weekdaysCache[formatStr][length]) {
        this.weekdaysCache[formatStr][length] = mapWeekdays((dt) =>
          this.extract(dt, intl, "weekday")
        );
      }
      return this.weekdaysCache[formatStr][length];
    });
  }

  meridiems() {
    return listStuff(
      this,
      undefined,
      () => _english_js__WEBPACK_IMPORTED_MODULE_1__.meridiems,
      () => {
        // In theory there could be aribitrary day periods. We're gonna assume there are exactly two
        // for AM and PM. This is probably wrong, but it's makes parsing way easier.
        if (!this.meridiemCache) {
          const intl = { hour: "numeric", hourCycle: "h12" };
          this.meridiemCache = [_datetime_js__WEBPACK_IMPORTED_MODULE_3__["default"].utc(2016, 11, 13, 9), _datetime_js__WEBPACK_IMPORTED_MODULE_3__["default"].utc(2016, 11, 13, 19)].map(
            (dt) => this.extract(dt, intl, "dayperiod")
          );
        }

        return this.meridiemCache;
      }
    );
  }

  eras(length) {
    return listStuff(this, length, _english_js__WEBPACK_IMPORTED_MODULE_1__.eras, () => {
      const intl = { era: length };

      // This is problematic. Different calendars are going to define eras totally differently. What I need is the minimum set of dates
      // to definitely enumerate them.
      if (!this.eraCache[length]) {
        this.eraCache[length] = [_datetime_js__WEBPACK_IMPORTED_MODULE_3__["default"].utc(-40, 1, 1), _datetime_js__WEBPACK_IMPORTED_MODULE_3__["default"].utc(2017, 1, 1)].map((dt) =>
          this.extract(dt, intl, "era")
        );
      }

      return this.eraCache[length];
    });
  }

  extract(dt, intlOpts, field) {
    const df = this.dtFormatter(dt, intlOpts),
      results = df.formatToParts(),
      matching = results.find((m) => m.type.toLowerCase() === field);
    return matching ? matching.value : null;
  }

  numberFormatter(opts = {}) {
    // this forcesimple option is never used (the only caller short-circuits on it, but it seems safer to leave)
    // (in contrast, the rest of the condition is used heavily)
    return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
  }

  dtFormatter(dt, intlOpts = {}) {
    return new PolyDateFormatter(dt, this.intl, intlOpts);
  }

  relFormatter(opts = {}) {
    return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
  }

  listFormatter(opts = {}) {
    return getCachedLF(this.intl, opts);
  }

  isEnglish() {
    return (
      this.locale === "en" ||
      this.locale.toLowerCase() === "en-us" ||
      new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us")
    );
  }

  equals(other) {
    return (
      this.locale === other.locale &&
      this.numberingSystem === other.numberingSystem &&
      this.outputCalendar === other.outputCalendar
    );
  }
}


/***/ }),

/***/ "./node_modules/luxon/src/impl/regexParser.js":
/*!****************************************************!*\
  !*** ./node_modules/luxon/src/impl/regexParser.js ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseHTTPDate: function() { return /* binding */ parseHTTPDate; },
/* harmony export */   parseISODate: function() { return /* binding */ parseISODate; },
/* harmony export */   parseISODuration: function() { return /* binding */ parseISODuration; },
/* harmony export */   parseISOTimeOnly: function() { return /* binding */ parseISOTimeOnly; },
/* harmony export */   parseRFC2822Date: function() { return /* binding */ parseRFC2822Date; },
/* harmony export */   parseSQL: function() { return /* binding */ parseSQL; }
/* harmony export */ });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ "./node_modules/luxon/src/impl/util.js");
/* harmony import */ var _english_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./english.js */ "./node_modules/luxon/src/impl/english.js");
/* harmony import */ var _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../zones/fixedOffsetZone.js */ "./node_modules/luxon/src/zones/fixedOffsetZone.js");
/* harmony import */ var _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../zones/IANAZone.js */ "./node_modules/luxon/src/zones/IANAZone.js");





/*
 * This file handles parsing for well-specified formats. Here's how it works:
 * Two things go into parsing: a regex to match with and an extractor to take apart the groups in the match.
 * An extractor is just a function that takes a regex match array and returns a { year: ..., month: ... } object
 * parse() does the work of executing the regex and applying the extractor. It takes multiple regex/extractor pairs to try in sequence.
 * Extractors can take a "cursor" representing the offset in the match to look at. This makes it easy to combine extractors.
 * combineExtractors() does the work of combining them, keeping track of the cursor through multiple extractions.
 * Some extractions are super dumb and simpleParse and fromStrings help DRY them.
 */

const ianaRegex = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;

function combineRegexes(...regexes) {
  const full = regexes.reduce((f, r) => f + r.source, "");
  return RegExp(`^${full}$`);
}

function combineExtractors(...extractors) {
  return (m) =>
    extractors
      .reduce(
        ([mergedVals, mergedZone, cursor], ex) => {
          const [val, zone, next] = ex(m, cursor);
          return [{ ...mergedVals, ...val }, zone || mergedZone, next];
        },
        [{}, null, 1]
      )
      .slice(0, 2);
}

function parse(s, ...patterns) {
  if (s == null) {
    return [null, null];
  }

  for (const [regex, extractor] of patterns) {
    const m = regex.exec(s);
    if (m) {
      return extractor(m);
    }
  }
  return [null, null];
}

function simpleParse(...keys) {
  return (match, cursor) => {
    const ret = {};
    let i;

    for (i = 0; i < keys.length; i++) {
      ret[keys[i]] = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(match[cursor + i]);
    }
    return [ret, null, cursor + i];
  };
}

// ISO and SQL parsing
const offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/;
const isoExtendedZone = `(?:${offsetRegex.source}?(?:\\[(${ianaRegex.source})\\])?)?`;
const isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
const isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${isoExtendedZone}`);
const isoTimeExtensionRegex = RegExp(`(?:T${isoTimeRegex.source})?`);
const isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
const isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
const isoOrdinalRegex = /(\d{4})-?(\d{3})/;
const extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay");
const extractISOOrdinalData = simpleParse("year", "ordinal");
const sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/; // dumbed-down version of the ISO one
const sqlTimeRegex = RegExp(
  `${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`
);
const sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);

function int(match, pos, fallback) {
  const m = match[pos];
  return (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(m) ? fallback : (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(m);
}

function extractISOYmd(match, cursor) {
  const item = {
    year: int(match, cursor),
    month: int(match, cursor + 1, 1),
    day: int(match, cursor + 2, 1),
  };

  return [item, null, cursor + 3];
}

function extractISOTime(match, cursor) {
  const item = {
    hours: int(match, cursor, 0),
    minutes: int(match, cursor + 1, 0),
    seconds: int(match, cursor + 2, 0),
    milliseconds: (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseMillis)(match[cursor + 3]),
  };

  return [item, null, cursor + 4];
}

function extractISOOffset(match, cursor) {
  const local = !match[cursor] && !match[cursor + 1],
    fullOffset = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.signedOffset)(match[cursor + 1], match[cursor + 2]),
    zone = local ? null : _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__["default"].instance(fullOffset);
  return [{}, zone, cursor + 3];
}

function extractIANAZone(match, cursor) {
  const zone = match[cursor] ? _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_3__["default"].create(match[cursor]) : null;
  return [{}, zone, cursor + 1];
}

// ISO time parsing

const isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}$`);

// ISO duration parsing

const isoDuration =
  /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;

function extractISODuration(match) {
  const [s, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] =
    match;

  const hasNegativePrefix = s[0] === "-";
  const negativeSeconds = secondStr && secondStr[0] === "-";

  const maybeNegate = (num, force = false) =>
    num !== undefined && (force || (num && hasNegativePrefix)) ? -num : num;

  return [
    {
      years: maybeNegate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseFloating)(yearStr)),
      months: maybeNegate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseFloating)(monthStr)),
      weeks: maybeNegate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseFloating)(weekStr)),
      days: maybeNegate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseFloating)(dayStr)),
      hours: maybeNegate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseFloating)(hourStr)),
      minutes: maybeNegate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseFloating)(minuteStr)),
      seconds: maybeNegate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseFloating)(secondStr), secondStr === "-0"),
      milliseconds: maybeNegate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseMillis)(millisecondsStr), negativeSeconds),
    },
  ];
}

// These are a little braindead. EDT *should* tell us that we're in, say, America/New_York
// and not just that we're in -240 *right now*. But since I don't think these are used that often
// I'm just going to ignore that
const obsOffsets = {
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60,
};

function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
  const result = {
    year: yearStr.length === 2 ? (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.untruncateYear)((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(yearStr)) : (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(yearStr),
    month: _english_js__WEBPACK_IMPORTED_MODULE_1__.monthsShort.indexOf(monthStr) + 1,
    day: (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(dayStr),
    hour: (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(hourStr),
    minute: (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(minuteStr),
  };

  if (secondStr) result.second = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseInteger)(secondStr);
  if (weekdayStr) {
    result.weekday =
      weekdayStr.length > 3
        ? _english_js__WEBPACK_IMPORTED_MODULE_1__.weekdaysLong.indexOf(weekdayStr) + 1
        : _english_js__WEBPACK_IMPORTED_MODULE_1__.weekdaysShort.indexOf(weekdayStr) + 1;
  }

  return result;
}

// RFC 2822/5322
const rfc2822 =
  /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;

function extractRFC2822(match) {
  const [
      ,
      weekdayStr,
      dayStr,
      monthStr,
      yearStr,
      hourStr,
      minuteStr,
      secondStr,
      obsOffset,
      milOffset,
      offHourStr,
      offMinuteStr,
    ] = match,
    result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);

  let offset;
  if (obsOffset) {
    offset = obsOffsets[obsOffset];
  } else if (milOffset) {
    offset = 0;
  } else {
    offset = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.signedOffset)(offHourStr, offMinuteStr);
  }

  return [result, new _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__["default"](offset)];
}

function preprocessRFC2822(s) {
  // Remove comments and folding whitespace and replace multiple-spaces with a single space
  return s
    .replace(/\([^()]*\)|[\n\t]/g, " ")
    .replace(/(\s\s+)/g, " ")
    .trim();
}

// http date

const rfc1123 =
    /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/,
  rfc850 =
    /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/,
  ascii =
    /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;

function extractRFC1123Or850(match) {
  const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match,
    result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__["default"].utcInstance];
}

function extractASCII(match) {
  const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match,
    result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__["default"].utcInstance];
}

const isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
const isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
const isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
const isoTimeCombinedRegex = combineRegexes(isoTimeRegex);

const extractISOYmdTimeAndOffset = combineExtractors(
  extractISOYmd,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
const extractISOWeekTimeAndOffset = combineExtractors(
  extractISOWeekData,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
const extractISOOrdinalDateAndTime = combineExtractors(
  extractISOOrdinalData,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
const extractISOTimeAndOffset = combineExtractors(
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);

/*
 * @private
 */

function parseISODate(s) {
  return parse(
    s,
    [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
    [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset],
    [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime],
    [isoTimeCombinedRegex, extractISOTimeAndOffset]
  );
}

function parseRFC2822Date(s) {
  return parse(preprocessRFC2822(s), [rfc2822, extractRFC2822]);
}

function parseHTTPDate(s) {
  return parse(
    s,
    [rfc1123, extractRFC1123Or850],
    [rfc850, extractRFC1123Or850],
    [ascii, extractASCII]
  );
}

function parseISODuration(s) {
  return parse(s, [isoDuration, extractISODuration]);
}

const extractISOTimeOnly = combineExtractors(extractISOTime);

function parseISOTimeOnly(s) {
  return parse(s, [isoTimeOnly, extractISOTimeOnly]);
}

const sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
const sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);

const extractISOTimeOffsetAndIANAZone = combineExtractors(
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);

function parseSQL(s) {
  return parse(
    s,
    [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
    [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]
  );
}


/***/ }),

/***/ "./node_modules/luxon/src/impl/tokenParser.js":
/*!****************************************************!*\
  !*** ./node_modules/luxon/src/impl/tokenParser.js ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   expandMacroTokens: function() { return /* binding */ expandMacroTokens; },
/* harmony export */   explainFromTokens: function() { return /* binding */ explainFromTokens; },
/* harmony export */   formatOptsToTokens: function() { return /* binding */ formatOptsToTokens; },
/* harmony export */   parseFromTokens: function() { return /* binding */ parseFromTokens; }
/* harmony export */ });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ "./node_modules/luxon/src/impl/util.js");
/* harmony import */ var _formatter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./formatter.js */ "./node_modules/luxon/src/impl/formatter.js");
/* harmony import */ var _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../zones/fixedOffsetZone.js */ "./node_modules/luxon/src/zones/fixedOffsetZone.js");
/* harmony import */ var _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../zones/IANAZone.js */ "./node_modules/luxon/src/zones/IANAZone.js");
/* harmony import */ var _datetime_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../datetime.js */ "./node_modules/luxon/src/datetime.js");
/* harmony import */ var _digits_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./digits.js */ "./node_modules/luxon/src/impl/digits.js");
/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../errors.js */ "./node_modules/luxon/src/errors.js");








const MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";

function intUnit(regex, post = (i) => i) {
  return { regex, deser: ([s]) => post((0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.parseDigits)(s)) };
}

const NBSP = String.fromCharCode(160);
const spaceOrNBSP = `[ ${NBSP}]`;
const spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");

function fixListRegex(s) {
  // make dots optional and also make them literal
  // make space and non breakable space characters interchangeable
  return s.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
}

function stripInsensitivities(s) {
  return s
    .replace(/\./g, "") // ignore dots that were made optional
    .replace(spaceOrNBSPRegExp, " ") // interchange space and nbsp
    .toLowerCase();
}

function oneOf(strings, startIndex) {
  if (strings === null) {
    return null;
  } else {
    return {
      regex: RegExp(strings.map(fixListRegex).join("|")),
      deser: ([s]) =>
        strings.findIndex((i) => stripInsensitivities(s) === stripInsensitivities(i)) + startIndex,
    };
  }
}

function offset(regex, groups) {
  return { regex, deser: ([, h, m]) => (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.signedOffset)(h, m), groups };
}

function simple(regex) {
  return { regex, deser: ([s]) => s };
}

function escapeToken(value) {
  return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}

/**
 * @param token
 * @param {Locale} loc
 */
function unitForToken(token, loc) {
  const one = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc),
    two = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc, "{2}"),
    three = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc, "{3}"),
    four = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc, "{4}"),
    six = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc, "{6}"),
    oneOrTwo = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc, "{1,2}"),
    oneToThree = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc, "{1,3}"),
    oneToSix = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc, "{1,6}"),
    oneToNine = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc, "{1,9}"),
    twoToFour = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc, "{2,4}"),
    fourToSix = (0,_digits_js__WEBPACK_IMPORTED_MODULE_5__.digitRegex)(loc, "{4,6}"),
    literal = (t) => ({ regex: RegExp(escapeToken(t.val)), deser: ([s]) => s, literal: true }),
    unitate = (t) => {
      if (token.literal) {
        return literal(t);
      }
      switch (t.val) {
        // era
        case "G":
          return oneOf(loc.eras("short"), 0);
        case "GG":
          return oneOf(loc.eras("long"), 0);
        // years
        case "y":
          return intUnit(oneToSix);
        case "yy":
          return intUnit(twoToFour, _util_js__WEBPACK_IMPORTED_MODULE_0__.untruncateYear);
        case "yyyy":
          return intUnit(four);
        case "yyyyy":
          return intUnit(fourToSix);
        case "yyyyyy":
          return intUnit(six);
        // months
        case "M":
          return intUnit(oneOrTwo);
        case "MM":
          return intUnit(two);
        case "MMM":
          return oneOf(loc.months("short", true), 1);
        case "MMMM":
          return oneOf(loc.months("long", true), 1);
        case "L":
          return intUnit(oneOrTwo);
        case "LL":
          return intUnit(two);
        case "LLL":
          return oneOf(loc.months("short", false), 1);
        case "LLLL":
          return oneOf(loc.months("long", false), 1);
        // dates
        case "d":
          return intUnit(oneOrTwo);
        case "dd":
          return intUnit(two);
        // ordinals
        case "o":
          return intUnit(oneToThree);
        case "ooo":
          return intUnit(three);
        // time
        case "HH":
          return intUnit(two);
        case "H":
          return intUnit(oneOrTwo);
        case "hh":
          return intUnit(two);
        case "h":
          return intUnit(oneOrTwo);
        case "mm":
          return intUnit(two);
        case "m":
          return intUnit(oneOrTwo);
        case "q":
          return intUnit(oneOrTwo);
        case "qq":
          return intUnit(two);
        case "s":
          return intUnit(oneOrTwo);
        case "ss":
          return intUnit(two);
        case "S":
          return intUnit(oneToThree);
        case "SSS":
          return intUnit(three);
        case "u":
          return simple(oneToNine);
        case "uu":
          return simple(oneOrTwo);
        case "uuu":
          return intUnit(one);
        // meridiem
        case "a":
          return oneOf(loc.meridiems(), 0);
        // weekYear (k)
        case "kkkk":
          return intUnit(four);
        case "kk":
          return intUnit(twoToFour, _util_js__WEBPACK_IMPORTED_MODULE_0__.untruncateYear);
        // weekNumber (W)
        case "W":
          return intUnit(oneOrTwo);
        case "WW":
          return intUnit(two);
        // weekdays
        case "E":
        case "c":
          return intUnit(one);
        case "EEE":
          return oneOf(loc.weekdays("short", false), 1);
        case "EEEE":
          return oneOf(loc.weekdays("long", false), 1);
        case "ccc":
          return oneOf(loc.weekdays("short", true), 1);
        case "cccc":
          return oneOf(loc.weekdays("long", true), 1);
        // offset/zone
        case "Z":
        case "ZZ":
          return offset(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);
        case "ZZZ":
          return offset(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);
        // we don't support ZZZZ (PST) or ZZZZZ (Pacific Standard Time) in parsing
        // because we don't have any way to figure out what they are
        case "z":
          return simple(/[a-z_+-/]{1,256}?/i);
        // this special-case "token" represents a place where a macro-token expanded into a white-space literal
        // in this case we accept any non-newline white-space
        case " ":
          return simple(/[^\S\n\r]/);
        default:
          return literal(t);
      }
    };

  const unit = unitate(token) || {
    invalidReason: MISSING_FTP,
  };

  unit.token = token;

  return unit;
}

const partTypeStyleToTokenVal = {
  year: {
    "2-digit": "yy",
    numeric: "yyyyy",
  },
  month: {
    numeric: "M",
    "2-digit": "MM",
    short: "MMM",
    long: "MMMM",
  },
  day: {
    numeric: "d",
    "2-digit": "dd",
  },
  weekday: {
    short: "EEE",
    long: "EEEE",
  },
  dayperiod: "a",
  dayPeriod: "a",
  hour12: {
    numeric: "h",
    "2-digit": "hh",
  },
  hour24: {
    numeric: "H",
    "2-digit": "HH",
  },
  minute: {
    numeric: "m",
    "2-digit": "mm",
  },
  second: {
    numeric: "s",
    "2-digit": "ss",
  },
  timeZoneName: {
    long: "ZZZZZ",
    short: "ZZZ",
  },
};

function tokenForPart(part, formatOpts, resolvedOpts) {
  const { type, value } = part;

  if (type === "literal") {
    const isSpace = /^\s+$/.test(value);
    return {
      literal: !isSpace,
      val: isSpace ? " " : value,
    };
  }

  const style = formatOpts[type];

  // The user might have explicitly specified hour12 or hourCycle
  // if so, respect their decision
  // if not, refer back to the resolvedOpts, which are based on the locale
  let actualType = type;
  if (type === "hour") {
    if (formatOpts.hour12 != null) {
      actualType = formatOpts.hour12 ? "hour12" : "hour24";
    } else if (formatOpts.hourCycle != null) {
      if (formatOpts.hourCycle === "h11" || formatOpts.hourCycle === "h12") {
        actualType = "hour12";
      } else {
        actualType = "hour24";
      }
    } else {
      // tokens only differentiate between 24 hours or not,
      // so we do not need to check hourCycle here, which is less supported anyways
      actualType = resolvedOpts.hour12 ? "hour12" : "hour24";
    }
  }
  let val = partTypeStyleToTokenVal[actualType];
  if (typeof val === "object") {
    val = val[style];
  }

  if (val) {
    return {
      literal: false,
      val,
    };
  }

  return undefined;
}

function buildRegex(units) {
  const re = units.map((u) => u.regex).reduce((f, r) => `${f}(${r.source})`, "");
  return [`^${re}$`, units];
}

function match(input, regex, handlers) {
  const matches = input.match(regex);

  if (matches) {
    const all = {};
    let matchIndex = 1;
    for (const i in handlers) {
      if ((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(handlers, i)) {
        const h = handlers[i],
          groups = h.groups ? h.groups + 1 : 1;
        if (!h.literal && h.token) {
          all[h.token.val[0]] = h.deser(matches.slice(matchIndex, matchIndex + groups));
        }
        matchIndex += groups;
      }
    }
    return [matches, all];
  } else {
    return [matches, {}];
  }
}

function dateTimeFromMatches(matches) {
  const toField = (token) => {
    switch (token) {
      case "S":
        return "millisecond";
      case "s":
        return "second";
      case "m":
        return "minute";
      case "h":
      case "H":
        return "hour";
      case "d":
        return "day";
      case "o":
        return "ordinal";
      case "L":
      case "M":
        return "month";
      case "y":
        return "year";
      case "E":
      case "c":
        return "weekday";
      case "W":
        return "weekNumber";
      case "k":
        return "weekYear";
      case "q":
        return "quarter";
      default:
        return null;
    }
  };

  let zone = null;
  let specificOffset;
  if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(matches.z)) {
    zone = _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_3__["default"].create(matches.z);
  }

  if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(matches.Z)) {
    if (!zone) {
      zone = new _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__["default"](matches.Z);
    }
    specificOffset = matches.Z;
  }

  if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(matches.q)) {
    matches.M = (matches.q - 1) * 3 + 1;
  }

  if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(matches.h)) {
    if (matches.h < 12 && matches.a === 1) {
      matches.h += 12;
    } else if (matches.h === 12 && matches.a === 0) {
      matches.h = 0;
    }
  }

  if (matches.G === 0 && matches.y) {
    matches.y = -matches.y;
  }

  if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(matches.u)) {
    matches.S = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseMillis)(matches.u);
  }

  const vals = Object.keys(matches).reduce((r, k) => {
    const f = toField(k);
    if (f) {
      r[f] = matches[k];
    }

    return r;
  }, {});

  return [vals, zone, specificOffset];
}

let dummyDateTimeCache = null;

function getDummyDateTime() {
  if (!dummyDateTimeCache) {
    dummyDateTimeCache = _datetime_js__WEBPACK_IMPORTED_MODULE_4__["default"].fromMillis(1555555555555);
  }

  return dummyDateTimeCache;
}

function maybeExpandMacroToken(token, locale) {
  if (token.literal) {
    return token;
  }

  const formatOpts = _formatter_js__WEBPACK_IMPORTED_MODULE_1__["default"].macroTokenToFormatOpts(token.val);
  const tokens = formatOptsToTokens(formatOpts, locale);

  if (tokens == null || tokens.includes(undefined)) {
    return token;
  }

  return tokens;
}

function expandMacroTokens(tokens, locale) {
  return Array.prototype.concat(...tokens.map((t) => maybeExpandMacroToken(t, locale)));
}

/**
 * @private
 */

function explainFromTokens(locale, input, format) {
  const tokens = expandMacroTokens(_formatter_js__WEBPACK_IMPORTED_MODULE_1__["default"].parseFormat(format), locale),
    units = tokens.map((t) => unitForToken(t, locale)),
    disqualifyingUnit = units.find((t) => t.invalidReason);

  if (disqualifyingUnit) {
    return { input, tokens, invalidReason: disqualifyingUnit.invalidReason };
  } else {
    const [regexString, handlers] = buildRegex(units),
      regex = RegExp(regexString, "i"),
      [rawMatches, matches] = match(input, regex, handlers),
      [result, zone, specificOffset] = matches
        ? dateTimeFromMatches(matches)
        : [null, null, undefined];
    if ((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(matches, "a") && (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(matches, "H")) {
      throw new _errors_js__WEBPACK_IMPORTED_MODULE_6__.ConflictingSpecificationError(
        "Can't include meridiem when specifying 24-hour format"
      );
    }
    return { input, tokens, regex, rawMatches, matches, result, zone, specificOffset };
  }
}

function parseFromTokens(locale, input, format) {
  const { result, zone, specificOffset, invalidReason } = explainFromTokens(locale, input, format);
  return [result, zone, specificOffset, invalidReason];
}

function formatOptsToTokens(formatOpts, locale) {
  if (!formatOpts) {
    return null;
  }

  const formatter = _formatter_js__WEBPACK_IMPORTED_MODULE_1__["default"].create(locale, formatOpts);
  const df = formatter.dtFormatter(getDummyDateTime());
  const parts = df.formatToParts();
  const resolvedOpts = df.resolvedOptions();
  return parts.map((p) => tokenForPart(p, formatOpts, resolvedOpts));
}


/***/ }),

/***/ "./node_modules/luxon/src/impl/util.js":
/*!*********************************************!*\
  !*** ./node_modules/luxon/src/impl/util.js ***!
  \*********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   asNumber: function() { return /* binding */ asNumber; },
/* harmony export */   bestBy: function() { return /* binding */ bestBy; },
/* harmony export */   daysInMonth: function() { return /* binding */ daysInMonth; },
/* harmony export */   daysInYear: function() { return /* binding */ daysInYear; },
/* harmony export */   floorMod: function() { return /* binding */ floorMod; },
/* harmony export */   formatOffset: function() { return /* binding */ formatOffset; },
/* harmony export */   hasOwnProperty: function() { return /* binding */ hasOwnProperty; },
/* harmony export */   hasRelative: function() { return /* binding */ hasRelative; },
/* harmony export */   integerBetween: function() { return /* binding */ integerBetween; },
/* harmony export */   isDate: function() { return /* binding */ isDate; },
/* harmony export */   isInteger: function() { return /* binding */ isInteger; },
/* harmony export */   isLeapYear: function() { return /* binding */ isLeapYear; },
/* harmony export */   isNumber: function() { return /* binding */ isNumber; },
/* harmony export */   isString: function() { return /* binding */ isString; },
/* harmony export */   isUndefined: function() { return /* binding */ isUndefined; },
/* harmony export */   maybeArray: function() { return /* binding */ maybeArray; },
/* harmony export */   normalizeObject: function() { return /* binding */ normalizeObject; },
/* harmony export */   objToLocalTS: function() { return /* binding */ objToLocalTS; },
/* harmony export */   padStart: function() { return /* binding */ padStart; },
/* harmony export */   parseFloating: function() { return /* binding */ parseFloating; },
/* harmony export */   parseInteger: function() { return /* binding */ parseInteger; },
/* harmony export */   parseMillis: function() { return /* binding */ parseMillis; },
/* harmony export */   parseZoneInfo: function() { return /* binding */ parseZoneInfo; },
/* harmony export */   pick: function() { return /* binding */ pick; },
/* harmony export */   roundTo: function() { return /* binding */ roundTo; },
/* harmony export */   signedOffset: function() { return /* binding */ signedOffset; },
/* harmony export */   timeObject: function() { return /* binding */ timeObject; },
/* harmony export */   untruncateYear: function() { return /* binding */ untruncateYear; },
/* harmony export */   weeksInWeekYear: function() { return /* binding */ weeksInWeekYear; }
/* harmony export */ });
/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../errors.js */ "./node_modules/luxon/src/errors.js");
/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../settings.js */ "./node_modules/luxon/src/settings.js");
/*
  This is just a junk drawer, containing anything used across multiple classes.
  Because Luxon is small(ish), this should stay small and we won't worry about splitting
  it up into, say, parsingUtil.js and basicUtil.js and so on. But they are divided up by feature area.
*/




/**
 * @private
 */

// TYPES

function isUndefined(o) {
  return typeof o === "undefined";
}

function isNumber(o) {
  return typeof o === "number";
}

function isInteger(o) {
  return typeof o === "number" && o % 1 === 0;
}

function isString(o) {
  return typeof o === "string";
}

function isDate(o) {
  return Object.prototype.toString.call(o) === "[object Date]";
}

// CAPABILITIES

function hasRelative() {
  try {
    return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
  } catch (e) {
    return false;
  }
}

// OBJECTS AND ARRAYS

function maybeArray(thing) {
  return Array.isArray(thing) ? thing : [thing];
}

function bestBy(arr, by, compare) {
  if (arr.length === 0) {
    return undefined;
  }
  return arr.reduce((best, next) => {
    const pair = [by(next), next];
    if (!best) {
      return pair;
    } else if (compare(best[0], pair[0]) === best[0]) {
      return best;
    } else {
      return pair;
    }
  }, null)[1];
}

function pick(obj, keys) {
  return keys.reduce((a, k) => {
    a[k] = obj[k];
    return a;
  }, {});
}

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

// NUMBERS AND STRINGS

function integerBetween(thing, bottom, top) {
  return isInteger(thing) && thing >= bottom && thing <= top;
}

// x % n but takes the sign of n instead of x
function floorMod(x, n) {
  return x - n * Math.floor(x / n);
}

function padStart(input, n = 2) {
  const isNeg = input < 0;
  let padded;
  if (isNeg) {
    padded = "-" + ("" + -input).padStart(n, "0");
  } else {
    padded = ("" + input).padStart(n, "0");
  }
  return padded;
}

function parseInteger(string) {
  if (isUndefined(string) || string === null || string === "") {
    return undefined;
  } else {
    return parseInt(string, 10);
  }
}

function parseFloating(string) {
  if (isUndefined(string) || string === null || string === "") {
    return undefined;
  } else {
    return parseFloat(string);
  }
}

function parseMillis(fraction) {
  // Return undefined (instead of 0) in these cases, where fraction is not set
  if (isUndefined(fraction) || fraction === null || fraction === "") {
    return undefined;
  } else {
    const f = parseFloat("0." + fraction) * 1000;
    return Math.floor(f);
  }
}

function roundTo(number, digits, towardZero = false) {
  const factor = 10 ** digits,
    rounder = towardZero ? Math.trunc : Math.round;
  return rounder(number * factor) / factor;
}

// DATE BASICS

function isLeapYear(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}

function daysInYear(year) {
  return isLeapYear(year) ? 366 : 365;
}

function daysInMonth(year, month) {
  const modMonth = floorMod(month - 1, 12) + 1,
    modYear = year + (month - modMonth) / 12;

  if (modMonth === 2) {
    return isLeapYear(modYear) ? 29 : 28;
  } else {
    return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
  }
}

// convert a calendar object to a local timestamp (epoch, but with the offset baked in)
function objToLocalTS(obj) {
  let d = Date.UTC(
    obj.year,
    obj.month - 1,
    obj.day,
    obj.hour,
    obj.minute,
    obj.second,
    obj.millisecond
  );

  // for legacy reasons, years between 0 and 99 are interpreted as 19XX; revert that
  if (obj.year < 100 && obj.year >= 0) {
    d = new Date(d);
    // set the month and day again, this is necessary because year 2000 is a leap year, but year 100 is not
    // so if obj.year is in 99, but obj.day makes it roll over into year 100,
    // the calculations done by Date.UTC are using year 2000 - which is incorrect
    d.setUTCFullYear(obj.year, obj.month - 1, obj.day);
  }
  return +d;
}

function weeksInWeekYear(weekYear) {
  const p1 =
      (weekYear +
        Math.floor(weekYear / 4) -
        Math.floor(weekYear / 100) +
        Math.floor(weekYear / 400)) %
      7,
    last = weekYear - 1,
    p2 = (last + Math.floor(last / 4) - Math.floor(last / 100) + Math.floor(last / 400)) % 7;
  return p1 === 4 || p2 === 3 ? 53 : 52;
}

function untruncateYear(year) {
  if (year > 99) {
    return year;
  } else return year > _settings_js__WEBPACK_IMPORTED_MODULE_1__["default"].twoDigitCutoffYear ? 1900 + year : 2000 + year;
}

// PARSING

function parseZoneInfo(ts, offsetFormat, locale, timeZone = null) {
  const date = new Date(ts),
    intlOpts = {
      hourCycle: "h23",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
    };

  if (timeZone) {
    intlOpts.timeZone = timeZone;
  }

  const modified = { timeZoneName: offsetFormat, ...intlOpts };

  const parsed = new Intl.DateTimeFormat(locale, modified)
    .formatToParts(date)
    .find((m) => m.type.toLowerCase() === "timezonename");
  return parsed ? parsed.value : null;
}

// signedOffset('-5', '30') -> -330
function signedOffset(offHourStr, offMinuteStr) {
  let offHour = parseInt(offHourStr, 10);

  // don't || this because we want to preserve -0
  if (Number.isNaN(offHour)) {
    offHour = 0;
  }

  const offMin = parseInt(offMinuteStr, 10) || 0,
    offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
  return offHour * 60 + offMinSigned;
}

// COERCION

function asNumber(value) {
  const numericValue = Number(value);
  if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue))
    throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.InvalidArgumentError(`Invalid unit value ${value}`);
  return numericValue;
}

function normalizeObject(obj, normalizer) {
  const normalized = {};
  for (const u in obj) {
    if (hasOwnProperty(obj, u)) {
      const v = obj[u];
      if (v === undefined || v === null) continue;
      normalized[normalizer(u)] = asNumber(v);
    }
  }
  return normalized;
}

function formatOffset(offset, format) {
  const hours = Math.trunc(Math.abs(offset / 60)),
    minutes = Math.trunc(Math.abs(offset % 60)),
    sign = offset >= 0 ? "+" : "-";

  switch (format) {
    case "short":
      return `${sign}${padStart(hours, 2)}:${padStart(minutes, 2)}`;
    case "narrow":
      return `${sign}${hours}${minutes > 0 ? `:${minutes}` : ""}`;
    case "techie":
      return `${sign}${padStart(hours, 2)}${padStart(minutes, 2)}`;
    default:
      throw new RangeError(`Value format ${format} is out of range for property format`);
  }
}

function timeObject(obj) {
  return pick(obj, ["hour", "minute", "second", "millisecond"]);
}


/***/ }),

/***/ "./node_modules/luxon/src/impl/zoneUtil.js":
/*!*************************************************!*\
  !*** ./node_modules/luxon/src/impl/zoneUtil.js ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   normalizeZone: function() { return /* binding */ normalizeZone; }
/* harmony export */ });
/* harmony import */ var _zone_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../zone.js */ "./node_modules/luxon/src/zone.js");
/* harmony import */ var _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../zones/IANAZone.js */ "./node_modules/luxon/src/zones/IANAZone.js");
/* harmony import */ var _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../zones/fixedOffsetZone.js */ "./node_modules/luxon/src/zones/fixedOffsetZone.js");
/* harmony import */ var _zones_invalidZone_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../zones/invalidZone.js */ "./node_modules/luxon/src/zones/invalidZone.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./util.js */ "./node_modules/luxon/src/impl/util.js");
/* harmony import */ var _zones_systemZone_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../zones/systemZone.js */ "./node_modules/luxon/src/zones/systemZone.js");
/**
 * @private
 */









function normalizeZone(input, defaultZone) {
  let offset;
  if ((0,_util_js__WEBPACK_IMPORTED_MODULE_4__.isUndefined)(input) || input === null) {
    return defaultZone;
  } else if (input instanceof _zone_js__WEBPACK_IMPORTED_MODULE_0__["default"]) {
    return input;
  } else if ((0,_util_js__WEBPACK_IMPORTED_MODULE_4__.isString)(input)) {
    const lowered = input.toLowerCase();
    if (lowered === "default") return defaultZone;
    else if (lowered === "local" || lowered === "system") return _zones_systemZone_js__WEBPACK_IMPORTED_MODULE_5__["default"].instance;
    else if (lowered === "utc" || lowered === "gmt") return _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__["default"].utcInstance;
    else return _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__["default"].parseSpecifier(lowered) || _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_1__["default"].create(input);
  } else if ((0,_util_js__WEBPACK_IMPORTED_MODULE_4__.isNumber)(input)) {
    return _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_2__["default"].instance(input);
  } else if (typeof input === "object" && "offset" in input && typeof input.offset === "function") {
    // This is dumb, but the instanceof check above doesn't seem to really work
    // so we're duck checking it
    return input;
  } else {
    return new _zones_invalidZone_js__WEBPACK_IMPORTED_MODULE_3__["default"](input);
  }
}


/***/ }),

/***/ "./node_modules/luxon/src/info.js":
/*!****************************************!*\
  !*** ./node_modules/luxon/src/info.js ***!
  \****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ Info; }
/* harmony export */ });
/* harmony import */ var _datetime_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./datetime.js */ "./node_modules/luxon/src/datetime.js");
/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./settings.js */ "./node_modules/luxon/src/settings.js");
/* harmony import */ var _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./impl/locale.js */ "./node_modules/luxon/src/impl/locale.js");
/* harmony import */ var _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./zones/IANAZone.js */ "./node_modules/luxon/src/zones/IANAZone.js");
/* harmony import */ var _impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./impl/zoneUtil.js */ "./node_modules/luxon/src/impl/zoneUtil.js");
/* harmony import */ var _impl_util_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./impl/util.js */ "./node_modules/luxon/src/impl/util.js");








/**
 * The Info class contains static methods for retrieving general time and date related data. For example, it has methods for finding out if a time zone has a DST, for listing the months in any supported locale, and for discovering which of Luxon features are available in the current environment.
 */
class Info {
  /**
   * Return whether the specified zone contains a DST.
   * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
   * @return {boolean}
   */
  static hasDST(zone = _settings_js__WEBPACK_IMPORTED_MODULE_1__["default"].defaultZone) {
    const proto = _datetime_js__WEBPACK_IMPORTED_MODULE_0__["default"].now().setZone(zone).set({ month: 12 });

    return !zone.isUniversal && proto.offset !== proto.set({ month: 6 }).offset;
  }

  /**
   * Return whether the specified zone is a valid IANA specifier.
   * @param {string} zone - Zone to check
   * @return {boolean}
   */
  static isValidIANAZone(zone) {
    return _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_3__["default"].isValidZone(zone);
  }

  /**
   * Converts the input into a {@link Zone} instance.
   *
   * * If `input` is already a Zone instance, it is returned unchanged.
   * * If `input` is a string containing a valid time zone name, a Zone instance
   *   with that name is returned.
   * * If `input` is a string that doesn't refer to a known time zone, a Zone
   *   instance with {@link Zone#isValid} == false is returned.
   * * If `input is a number, a Zone instance with the specified fixed offset
   *   in minutes is returned.
   * * If `input` is `null` or `undefined`, the default zone is returned.
   * @param {string|Zone|number} [input] - the value to be converted
   * @return {Zone}
   */
  static normalizeZone(input) {
    return (0,_impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_4__.normalizeZone)(input, _settings_js__WEBPACK_IMPORTED_MODULE_1__["default"].defaultZone);
  }

  /**
   * Return an array of standalone month names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @example Info.months()[0] //=> 'January'
   * @example Info.months('short')[0] //=> 'Jan'
   * @example Info.months('numeric')[0] //=> '1'
   * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
   * @example Info.months('numeric', { locale: 'ar' })[0] //=> '١'
   * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabiʻ I'
   * @return {Array}
   */
  static months(
    length = "long",
    { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}
  ) {
    return (locObj || _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__["default"].create(locale, numberingSystem, outputCalendar)).months(length);
  }

  /**
   * Return an array of format month names.
   * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
   * changes the string.
   * See {@link Info#months}
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @return {Array}
   */
  static monthsFormat(
    length = "long",
    { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}
  ) {
    return (locObj || _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__["default"].create(locale, numberingSystem, outputCalendar)).months(length, true);
  }

  /**
   * Return an array of standalone week names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @example Info.weekdays()[0] //=> 'Monday'
   * @example Info.weekdays('short')[0] //=> 'Mon'
   * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
   * @example Info.weekdays('short', { locale: 'ar' })[0] //=> 'الاثنين'
   * @return {Array}
   */
  static weekdays(length = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
    return (locObj || _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__["default"].create(locale, numberingSystem, null)).weekdays(length);
  }

  /**
   * Return an array of format week names.
   * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
   * changes the string.
   * See {@link Info#weekdays}
   * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale=null] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @return {Array}
   */
  static weekdaysFormat(
    length = "long",
    { locale = null, numberingSystem = null, locObj = null } = {}
  ) {
    return (locObj || _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__["default"].create(locale, numberingSystem, null)).weekdays(length, true);
  }

  /**
   * Return an array of meridiems.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.meridiems() //=> [ 'AM', 'PM' ]
   * @example Info.meridiems({ locale: 'my' }) //=> [ 'နံနက်', 'ညနေ' ]
   * @return {Array}
   */
  static meridiems({ locale = null } = {}) {
    return _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__["default"].create(locale).meridiems();
  }

  /**
   * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
   * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.eras() //=> [ 'BC', 'AD' ]
   * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
   * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jésus-Christ', 'après Jésus-Christ' ]
   * @return {Array}
   */
  static eras(length = "short", { locale = null } = {}) {
    return _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__["default"].create(locale, null, "gregory").eras(length);
  }

  /**
   * Return the set of available features in this environment.
   * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.
   * Keys:
   * * `relative`: whether this environment supports relative time formatting
   * @example Info.features() //=> { relative: false }
   * @return {Object}
   */
  static features() {
    return { relative: (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_5__.hasRelative)() };
  }
}


/***/ }),

/***/ "./node_modules/luxon/src/interval.js":
/*!********************************************!*\
  !*** ./node_modules/luxon/src/interval.js ***!
  \********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ Interval; }
/* harmony export */ });
/* harmony import */ var _datetime_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./datetime.js */ "./node_modules/luxon/src/datetime.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "./node_modules/luxon/src/duration.js");
/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./settings.js */ "./node_modules/luxon/src/settings.js");
/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./errors.js */ "./node_modules/luxon/src/errors.js");
/* harmony import */ var _impl_invalid_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./impl/invalid.js */ "./node_modules/luxon/src/impl/invalid.js");
/* harmony import */ var _impl_formatter_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./impl/formatter.js */ "./node_modules/luxon/src/impl/formatter.js");
/* harmony import */ var _impl_formats_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./impl/formats.js */ "./node_modules/luxon/src/impl/formats.js");








const INVALID = "Invalid Interval";

// checks if the start is equal to or before the end
function validateStartEnd(start, end) {
  if (!start || !start.isValid) {
    return Interval.invalid("missing or invalid start");
  } else if (!end || !end.isValid) {
    return Interval.invalid("missing or invalid end");
  } else if (end < start) {
    return Interval.invalid(
      "end before start",
      `The end of an interval must be after its start, but you had start=${start.toISO()} and end=${end.toISO()}`
    );
  } else {
    return null;
  }
}

/**
 * An Interval object represents a half-open interval of time, where each endpoint is a {@link DateTime}. Conceptually, it's a container for those two endpoints, accompanied by methods for creating, parsing, interrogating, comparing, transforming, and formatting them.
 *
 * Here is a brief overview of the most commonly used methods and getters in Interval:
 *
 * * **Creation** To create an Interval, use {@link Interval.fromDateTimes}, {@link Interval.after}, {@link Interval.before}, or {@link Interval.fromISO}.
 * * **Accessors** Use {@link Interval#start} and {@link Interval#end} to get the start and end.
 * * **Interrogation** To analyze the Interval, use {@link Interval#count}, {@link Interval#length}, {@link Interval#hasSame}, {@link Interval#contains}, {@link Interval#isAfter}, or {@link Interval#isBefore}.
 * * **Transformation** To create other Intervals out of this one, use {@link Interval#set}, {@link Interval#splitAt}, {@link Interval#splitBy}, {@link Interval#divideEqually}, {@link Interval.merge}, {@link Interval.xor}, {@link Interval#union}, {@link Interval#intersection}, or {@link Interval#difference}.
 * * **Comparison** To compare this Interval to another one, use {@link Interval#equals}, {@link Interval#overlaps}, {@link Interval#abutsStart}, {@link Interval#abutsEnd}, {@link Interval#engulfs}
 * * **Output** To convert the Interval into other representations, see {@link Interval#toString}, {@link Interval#toLocaleString}, {@link Interval#toISO}, {@link Interval#toISODate}, {@link Interval#toISOTime}, {@link Interval#toFormat}, and {@link Interval#toDuration}.
 */
class Interval {
  /**
   * @private
   */
  constructor(config) {
    /**
     * @access private
     */
    this.s = config.start;
    /**
     * @access private
     */
    this.e = config.end;
    /**
     * @access private
     */
    this.invalid = config.invalid || null;
    /**
     * @access private
     */
    this.isLuxonInterval = true;
  }

  /**
   * Create an invalid Interval.
   * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Interval}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new _errors_js__WEBPACK_IMPORTED_MODULE_3__.InvalidArgumentError("need to specify a reason the Interval is invalid");
    }

    const invalid = reason instanceof _impl_invalid_js__WEBPACK_IMPORTED_MODULE_4__["default"] ? reason : new _impl_invalid_js__WEBPACK_IMPORTED_MODULE_4__["default"](reason, explanation);

    if (_settings_js__WEBPACK_IMPORTED_MODULE_2__["default"].throwOnInvalid) {
      throw new _errors_js__WEBPACK_IMPORTED_MODULE_3__.InvalidIntervalError(invalid);
    } else {
      return new Interval({ invalid });
    }
  }

  /**
   * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
   * @param {DateTime|Date|Object} start
   * @param {DateTime|Date|Object} end
   * @return {Interval}
   */
  static fromDateTimes(start, end) {
    const builtStart = (0,_datetime_js__WEBPACK_IMPORTED_MODULE_0__.friendlyDateTime)(start),
      builtEnd = (0,_datetime_js__WEBPACK_IMPORTED_MODULE_0__.friendlyDateTime)(end);

    const validateError = validateStartEnd(builtStart, builtEnd);

    if (validateError == null) {
      return new Interval({
        start: builtStart,
        end: builtEnd,
      });
    } else {
      return validateError;
    }
  }

  /**
   * Create an Interval from a start DateTime and a Duration to extend to.
   * @param {DateTime|Date|Object} start
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static after(start, duration) {
    const dur = _duration_js__WEBPACK_IMPORTED_MODULE_1__["default"].fromDurationLike(duration),
      dt = (0,_datetime_js__WEBPACK_IMPORTED_MODULE_0__.friendlyDateTime)(start);
    return Interval.fromDateTimes(dt, dt.plus(dur));
  }

  /**
   * Create an Interval from an end DateTime and a Duration to extend backwards to.
   * @param {DateTime|Date|Object} end
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static before(end, duration) {
    const dur = _duration_js__WEBPACK_IMPORTED_MODULE_1__["default"].fromDurationLike(duration),
      dt = (0,_datetime_js__WEBPACK_IMPORTED_MODULE_0__.friendlyDateTime)(end);
    return Interval.fromDateTimes(dt.minus(dur), dt);
  }

  /**
   * Create an Interval from an ISO 8601 string.
   * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
   * @param {string} text - the ISO string to parse
   * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {Interval}
   */
  static fromISO(text, opts) {
    const [s, e] = (text || "").split("/", 2);
    if (s && e) {
      let start, startIsValid;
      try {
        start = _datetime_js__WEBPACK_IMPORTED_MODULE_0__["default"].fromISO(s, opts);
        startIsValid = start.isValid;
      } catch (e) {
        startIsValid = false;
      }

      let end, endIsValid;
      try {
        end = _datetime_js__WEBPACK_IMPORTED_MODULE_0__["default"].fromISO(e, opts);
        endIsValid = end.isValid;
      } catch (e) {
        endIsValid = false;
      }

      if (startIsValid && endIsValid) {
        return Interval.fromDateTimes(start, end);
      }

      if (startIsValid) {
        const dur = _duration_js__WEBPACK_IMPORTED_MODULE_1__["default"].fromISO(e, opts);
        if (dur.isValid) {
          return Interval.after(start, dur);
        }
      } else if (endIsValid) {
        const dur = _duration_js__WEBPACK_IMPORTED_MODULE_1__["default"].fromISO(s, opts);
        if (dur.isValid) {
          return Interval.before(end, dur);
        }
      }
    }
    return Interval.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
  }

  /**
   * Check if an object is an Interval. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isInterval(o) {
    return (o && o.isLuxonInterval) || false;
  }

  /**
   * Returns the start of the Interval
   * @type {DateTime}
   */
  get start() {
    return this.isValid ? this.s : null;
  }

  /**
   * Returns the end of the Interval
   * @type {DateTime}
   */
  get end() {
    return this.isValid ? this.e : null;
  }

  /**
   * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
   * @type {boolean}
   */
  get isValid() {
    return this.invalidReason === null;
  }

  /**
   * Returns an error code if this Interval is invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }

  /**
   * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }

  /**
   * Returns the length of the Interval in the specified unit.
   * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
   * @return {number}
   */
  length(unit = "milliseconds") {
    return this.isValid ? this.toDuration(...[unit]).get(unit) : NaN;
  }

  /**
   * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
   * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
   * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
   * @param {string} [unit='milliseconds'] - the unit of time to count.
   * @return {number}
   */
  count(unit = "milliseconds") {
    if (!this.isValid) return NaN;
    const start = this.start.startOf(unit),
      end = this.end.startOf(unit);
    return Math.floor(end.diff(start, unit).get(unit)) + (end.valueOf() !== this.end.valueOf());
  }

  /**
   * Returns whether this Interval's start and end are both in the same unit of time
   * @param {string} unit - the unit of time to check sameness on
   * @return {boolean}
   */
  hasSame(unit) {
    return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
  }

  /**
   * Return whether this Interval has the same start and end DateTimes.
   * @return {boolean}
   */
  isEmpty() {
    return this.s.valueOf() === this.e.valueOf();
  }

  /**
   * Return whether this Interval's start is after the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isAfter(dateTime) {
    if (!this.isValid) return false;
    return this.s > dateTime;
  }

  /**
   * Return whether this Interval's end is before the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isBefore(dateTime) {
    if (!this.isValid) return false;
    return this.e <= dateTime;
  }

  /**
   * Return whether this Interval contains the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  contains(dateTime) {
    if (!this.isValid) return false;
    return this.s <= dateTime && this.e > dateTime;
  }

  /**
   * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
   * @param {Object} values - the values to set
   * @param {DateTime} values.start - the starting DateTime
   * @param {DateTime} values.end - the ending DateTime
   * @return {Interval}
   */
  set({ start, end } = {}) {
    if (!this.isValid) return this;
    return Interval.fromDateTimes(start || this.s, end || this.e);
  }

  /**
   * Split this Interval at each of the specified DateTimes
   * @param {...DateTime} dateTimes - the unit of time to count.
   * @return {Array}
   */
  splitAt(...dateTimes) {
    if (!this.isValid) return [];
    const sorted = dateTimes
        .map(_datetime_js__WEBPACK_IMPORTED_MODULE_0__.friendlyDateTime)
        .filter((d) => this.contains(d))
        .sort(),
      results = [];
    let { s } = this,
      i = 0;

    while (s < this.e) {
      const added = sorted[i] || this.e,
        next = +added > +this.e ? this.e : added;
      results.push(Interval.fromDateTimes(s, next));
      s = next;
      i += 1;
    }

    return results;
  }

  /**
   * Split this Interval into smaller Intervals, each of the specified length.
   * Left over time is grouped into a smaller interval
   * @param {Duration|Object|number} duration - The length of each resulting interval.
   * @return {Array}
   */
  splitBy(duration) {
    const dur = _duration_js__WEBPACK_IMPORTED_MODULE_1__["default"].fromDurationLike(duration);

    if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
      return [];
    }

    let { s } = this,
      idx = 1,
      next;

    const results = [];
    while (s < this.e) {
      const added = this.start.plus(dur.mapUnits((x) => x * idx));
      next = +added > +this.e ? this.e : added;
      results.push(Interval.fromDateTimes(s, next));
      s = next;
      idx += 1;
    }

    return results;
  }

  /**
   * Split this Interval into the specified number of smaller intervals.
   * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
   * @return {Array}
   */
  divideEqually(numberOfParts) {
    if (!this.isValid) return [];
    return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
  }

  /**
   * Return whether this Interval overlaps with the specified Interval
   * @param {Interval} other
   * @return {boolean}
   */
  overlaps(other) {
    return this.e > other.s && this.s < other.e;
  }

  /**
   * Return whether this Interval's end is adjacent to the specified Interval's start.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsStart(other) {
    if (!this.isValid) return false;
    return +this.e === +other.s;
  }

  /**
   * Return whether this Interval's start is adjacent to the specified Interval's end.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsEnd(other) {
    if (!this.isValid) return false;
    return +other.e === +this.s;
  }

  /**
   * Return whether this Interval engulfs the start and end of the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  engulfs(other) {
    if (!this.isValid) return false;
    return this.s <= other.s && this.e >= other.e;
  }

  /**
   * Return whether this Interval has the same start and end as the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }

    return this.s.equals(other.s) && this.e.equals(other.e);
  }

  /**
   * Return an Interval representing the intersection of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
   * Returns null if the intersection is empty, meaning, the intervals don't intersect.
   * @param {Interval} other
   * @return {Interval}
   */
  intersection(other) {
    if (!this.isValid) return this;
    const s = this.s > other.s ? this.s : other.s,
      e = this.e < other.e ? this.e : other.e;

    if (s >= e) {
      return null;
    } else {
      return Interval.fromDateTimes(s, e);
    }
  }

  /**
   * Return an Interval representing the union of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
   * @param {Interval} other
   * @return {Interval}
   */
  union(other) {
    if (!this.isValid) return this;
    const s = this.s < other.s ? this.s : other.s,
      e = this.e > other.e ? this.e : other.e;
    return Interval.fromDateTimes(s, e);
  }

  /**
   * Merge an array of Intervals into a equivalent minimal set of Intervals.
   * Combines overlapping and adjacent Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static merge(intervals) {
    const [found, final] = intervals
      .sort((a, b) => a.s - b.s)
      .reduce(
        ([sofar, current], item) => {
          if (!current) {
            return [sofar, item];
          } else if (current.overlaps(item) || current.abutsStart(item)) {
            return [sofar, current.union(item)];
          } else {
            return [sofar.concat([current]), item];
          }
        },
        [[], null]
      );
    if (final) {
      found.push(final);
    }
    return found;
  }

  /**
   * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static xor(intervals) {
    let start = null,
      currentCount = 0;
    const results = [],
      ends = intervals.map((i) => [
        { time: i.s, type: "s" },
        { time: i.e, type: "e" },
      ]),
      flattened = Array.prototype.concat(...ends),
      arr = flattened.sort((a, b) => a.time - b.time);

    for (const i of arr) {
      currentCount += i.type === "s" ? 1 : -1;

      if (currentCount === 1) {
        start = i.time;
      } else {
        if (start && +start !== +i.time) {
          results.push(Interval.fromDateTimes(start, i.time));
        }

        start = null;
      }
    }

    return Interval.merge(results);
  }

  /**
   * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
   * @param {...Interval} intervals
   * @return {Array}
   */
  difference(...intervals) {
    return Interval.xor([this].concat(intervals))
      .map((i) => this.intersection(i))
      .filter((i) => i && !i.isEmpty());
  }

  /**
   * Returns a string representation of this Interval appropriate for debugging.
   * @return {string}
   */
  toString() {
    if (!this.isValid) return INVALID;
    return `[${this.s.toISO()} – ${this.e.toISO()})`;
  }

  /**
   * Returns a localized string representing this Interval. Accepts the same options as the
   * Intl.DateTimeFormat constructor and any presets defined by Luxon, such as
   * {@link DateTime.DATE_FULL} or {@link DateTime.TIME_SIMPLE}. The exact behavior of this method
   * is browser-specific, but in general it will return an appropriate representation of the
   * Interval in the assigned locale. Defaults to the system's locale if no locale has been
   * specified.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {Object} [formatOpts=DateTime.DATE_SHORT] - Either a DateTime preset or
   * Intl.DateTimeFormat constructor options.
   * @param {Object} opts - Options to override the configuration of the start DateTime.
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(); //=> 11/7/2022 – 11/8/2022
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL); //=> November 7 – 8, 2022
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL, { locale: 'fr-FR' }); //=> 7–8 novembre 2022
   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString(DateTime.TIME_SIMPLE); //=> 6:00 – 8:00 PM
   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> Mon, Nov 07, 6:00 – 8:00 p
   * @return {string}
   */
  toLocaleString(formatOpts = _impl_formats_js__WEBPACK_IMPORTED_MODULE_6__.DATE_SHORT, opts = {}) {
    return this.isValid
      ? _impl_formatter_js__WEBPACK_IMPORTED_MODULE_5__["default"].create(this.s.loc.clone(opts), formatOpts).formatInterval(this)
      : INVALID;
  }

  /**
   * Returns an ISO 8601-compliant string representation of this Interval.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISO(opts) {
    if (!this.isValid) return INVALID;
    return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;
  }

  /**
   * Returns an ISO 8601-compliant string representation of date of this Interval.
   * The time components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {string}
   */
  toISODate() {
    if (!this.isValid) return INVALID;
    return `${this.s.toISODate()}/${this.e.toISODate()}`;
  }

  /**
   * Returns an ISO 8601-compliant string representation of time of this Interval.
   * The date components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISOTime(opts) {
    if (!this.isValid) return INVALID;
    return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;
  }

  /**
   * Returns a string representation of this Interval formatted according to the specified format
   * string. **You may not want this.** See {@link Interval#toLocaleString} for a more flexible
   * formatting tool.
   * @param {string} dateFormat - The format string. This string formats the start and end time.
   * See {@link DateTime#toFormat} for details.
   * @param {Object} opts - Options.
   * @param {string} [opts.separator =  ' – '] - A separator to place between the start and end
   * representations.
   * @return {string}
   */
  toFormat(dateFormat, { separator = " – " } = {}) {
    if (!this.isValid) return INVALID;
    return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;
  }

  /**
   * Return a Duration representing the time spanned by this interval.
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
   * @return {Duration}
   */
  toDuration(unit, opts) {
    if (!this.isValid) {
      return _duration_js__WEBPACK_IMPORTED_MODULE_1__["default"].invalid(this.invalidReason);
    }
    return this.e.diff(this.s, unit, opts);
  }

  /**
   * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
   * @param {function} mapFn
   * @return {Interval}
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
   */
  mapEndpoints(mapFn) {
    return Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
  }
}


/***/ }),

/***/ "./node_modules/luxon/src/luxon.js":
/*!*****************************************!*\
  !*** ./node_modules/luxon/src/luxon.js ***!
  \*****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DateTime: function() { return /* reexport safe */ _datetime_js__WEBPACK_IMPORTED_MODULE_0__["default"]; },
/* harmony export */   Duration: function() { return /* reexport safe */ _duration_js__WEBPACK_IMPORTED_MODULE_1__["default"]; },
/* harmony export */   FixedOffsetZone: function() { return /* reexport safe */ _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_5__["default"]; },
/* harmony export */   IANAZone: function() { return /* reexport safe */ _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_6__["default"]; },
/* harmony export */   Info: function() { return /* reexport safe */ _info_js__WEBPACK_IMPORTED_MODULE_3__["default"]; },
/* harmony export */   Interval: function() { return /* reexport safe */ _interval_js__WEBPACK_IMPORTED_MODULE_2__["default"]; },
/* harmony export */   InvalidZone: function() { return /* reexport safe */ _zones_invalidZone_js__WEBPACK_IMPORTED_MODULE_7__["default"]; },
/* harmony export */   Settings: function() { return /* reexport safe */ _settings_js__WEBPACK_IMPORTED_MODULE_9__["default"]; },
/* harmony export */   SystemZone: function() { return /* reexport safe */ _zones_systemZone_js__WEBPACK_IMPORTED_MODULE_8__["default"]; },
/* harmony export */   VERSION: function() { return /* binding */ VERSION; },
/* harmony export */   Zone: function() { return /* reexport safe */ _zone_js__WEBPACK_IMPORTED_MODULE_4__["default"]; }
/* harmony export */ });
/* harmony import */ var _datetime_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./datetime.js */ "./node_modules/luxon/src/datetime.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "./node_modules/luxon/src/duration.js");
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./interval.js */ "./node_modules/luxon/src/interval.js");
/* harmony import */ var _info_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./info.js */ "./node_modules/luxon/src/info.js");
/* harmony import */ var _zone_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./zone.js */ "./node_modules/luxon/src/zone.js");
/* harmony import */ var _zones_fixedOffsetZone_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./zones/fixedOffsetZone.js */ "./node_modules/luxon/src/zones/fixedOffsetZone.js");
/* harmony import */ var _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./zones/IANAZone.js */ "./node_modules/luxon/src/zones/IANAZone.js");
/* harmony import */ var _zones_invalidZone_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./zones/invalidZone.js */ "./node_modules/luxon/src/zones/invalidZone.js");
/* harmony import */ var _zones_systemZone_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./zones/systemZone.js */ "./node_modules/luxon/src/zones/systemZone.js");
/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./settings.js */ "./node_modules/luxon/src/settings.js");











const VERSION = "3.4.3";




/***/ }),

/***/ "./node_modules/luxon/src/settings.js":
/*!********************************************!*\
  !*** ./node_modules/luxon/src/settings.js ***!
  \********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ Settings; }
/* harmony export */ });
/* harmony import */ var _zones_systemZone_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./zones/systemZone.js */ "./node_modules/luxon/src/zones/systemZone.js");
/* harmony import */ var _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zones/IANAZone.js */ "./node_modules/luxon/src/zones/IANAZone.js");
/* harmony import */ var _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./impl/locale.js */ "./node_modules/luxon/src/impl/locale.js");
/* harmony import */ var _impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./impl/zoneUtil.js */ "./node_modules/luxon/src/impl/zoneUtil.js");






let now = () => Date.now(),
  defaultZone = "system",
  defaultLocale = null,
  defaultNumberingSystem = null,
  defaultOutputCalendar = null,
  twoDigitCutoffYear = 60,
  throwOnInvalid;

/**
 * Settings contains static getters and setters that control Luxon's overall behavior. Luxon is a simple library with few options, but the ones it does have live here.
 */
class Settings {
  /**
   * Get the callback for returning the current timestamp.
   * @type {function}
   */
  static get now() {
    return now;
  }

  /**
   * Set the callback for returning the current timestamp.
   * The function should return a number, which will be interpreted as an Epoch millisecond count
   * @type {function}
   * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
   * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
   */
  static set now(n) {
    now = n;
  }

  /**
   * Set the default time zone to create DateTimes in. Does not affect existing instances.
   * Use the value "system" to reset this value to the system's time zone.
   * @type {string}
   */
  static set defaultZone(zone) {
    defaultZone = zone;
  }

  /**
   * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.
   * The default value is the system's time zone (the one set on the machine that runs this code).
   * @type {Zone}
   */
  static get defaultZone() {
    return (0,_impl_zoneUtil_js__WEBPACK_IMPORTED_MODULE_3__.normalizeZone)(defaultZone, _zones_systemZone_js__WEBPACK_IMPORTED_MODULE_0__["default"].instance);
  }

  /**
   * Get the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultLocale() {
    return defaultLocale;
  }

  /**
   * Set the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultLocale(locale) {
    defaultLocale = locale;
  }

  /**
   * Get the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultNumberingSystem() {
    return defaultNumberingSystem;
  }

  /**
   * Set the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultNumberingSystem(numberingSystem) {
    defaultNumberingSystem = numberingSystem;
  }

  /**
   * Get the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultOutputCalendar() {
    return defaultOutputCalendar;
  }

  /**
   * Set the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultOutputCalendar(outputCalendar) {
    defaultOutputCalendar = outputCalendar;
  }

  /**
   * Get the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
   * @type {number}
   */
  static get twoDigitCutoffYear() {
    return twoDigitCutoffYear;
  }

  /**
   * Set the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
   * @type {number}
   * @example Settings.twoDigitCutoffYear = 0 // cut-off year is 0, so all 'yy' are interpreted as current century
   * @example Settings.twoDigitCutoffYear = 50 // '49' -> 1949; '50' -> 2050
   * @example Settings.twoDigitCutoffYear = 1950 // interpreted as 50
   * @example Settings.twoDigitCutoffYear = 2050 // ALSO interpreted as 50
   */
  static set twoDigitCutoffYear(cutoffYear) {
    twoDigitCutoffYear = cutoffYear % 100;
  }

  /**
   * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static get throwOnInvalid() {
    return throwOnInvalid;
  }

  /**
   * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static set throwOnInvalid(t) {
    throwOnInvalid = t;
  }

  /**
   * Reset Luxon's global caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCaches() {
    _impl_locale_js__WEBPACK_IMPORTED_MODULE_2__["default"].resetCache();
    _zones_IANAZone_js__WEBPACK_IMPORTED_MODULE_1__["default"].resetCache();
  }
}


/***/ }),

/***/ "./node_modules/luxon/src/zone.js":
/*!****************************************!*\
  !*** ./node_modules/luxon/src/zone.js ***!
  \****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ Zone; }
/* harmony export */ });
/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ "./node_modules/luxon/src/errors.js");


/**
 * @interface
 */
class Zone {
  /**
   * The type of zone
   * @abstract
   * @type {string}
   */
  get type() {
    throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.ZoneIsAbstractError();
  }

  /**
   * The name of this zone.
   * @abstract
   * @type {string}
   */
  get name() {
    throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.ZoneIsAbstractError();
  }

  get ianaName() {
    return this.name;
  }

  /**
   * Returns whether the offset is known to be fixed for the whole year.
   * @abstract
   * @type {boolean}
   */
  get isUniversal() {
    throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.ZoneIsAbstractError();
  }

  /**
   * Returns the offset's common name (such as EST) at the specified timestamp
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the name
   * @param {Object} opts - Options to affect the format
   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
   * @param {string} opts.locale - What locale to return the offset name in.
   * @return {string}
   */
  offsetName(ts, opts) {
    throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.ZoneIsAbstractError();
  }

  /**
   * Returns the offset's value as a string
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(ts, format) {
    throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.ZoneIsAbstractError();
  }

  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to compute the offset
   * @return {number}
   */
  offset(ts) {
    throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.ZoneIsAbstractError();
  }

  /**
   * Return whether this Zone is equal to another zone
   * @abstract
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(otherZone) {
    throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.ZoneIsAbstractError();
  }

  /**
   * Return whether this Zone is valid.
   * @abstract
   * @type {boolean}
   */
  get isValid() {
    throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.ZoneIsAbstractError();
  }
}


/***/ }),

/***/ "./node_modules/luxon/src/zones/IANAZone.js":
/*!**************************************************!*\
  !*** ./node_modules/luxon/src/zones/IANAZone.js ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ IANAZone; }
/* harmony export */ });
/* harmony import */ var _impl_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../impl/util.js */ "./node_modules/luxon/src/impl/util.js");
/* harmony import */ var _zone_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../zone.js */ "./node_modules/luxon/src/zone.js");



let dtfCache = {};
function makeDTF(zone) {
  if (!dtfCache[zone]) {
    dtfCache[zone] = new Intl.DateTimeFormat("en-US", {
      hour12: false,
      timeZone: zone,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      era: "short",
    });
  }
  return dtfCache[zone];
}

const typeToPos = {
  year: 0,
  month: 1,
  day: 2,
  era: 3,
  hour: 4,
  minute: 5,
  second: 6,
};

function hackyOffset(dtf, date) {
  const formatted = dtf.format(date).replace(/\u200E/g, ""),
    parsed = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(formatted),
    [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;
  return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];
}

function partsOffset(dtf, date) {
  const formatted = dtf.formatToParts(date);
  const filled = [];
  for (let i = 0; i < formatted.length; i++) {
    const { type, value } = formatted[i];
    const pos = typeToPos[type];

    if (type === "era") {
      filled[pos] = value;
    } else if (!(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(pos)) {
      filled[pos] = parseInt(value, 10);
    }
  }
  return filled;
}

let ianaZoneCache = {};
/**
 * A zone identified by an IANA identifier, like America/New_York
 * @implements {Zone}
 */
class IANAZone extends _zone_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * @param {string} name - Zone name
   * @return {IANAZone}
   */
  static create(name) {
    if (!ianaZoneCache[name]) {
      ianaZoneCache[name] = new IANAZone(name);
    }
    return ianaZoneCache[name];
  }

  /**
   * Reset local caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCache() {
    ianaZoneCache = {};
    dtfCache = {};
  }

  /**
   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
   * @param {string} s - The string to check validity on
   * @example IANAZone.isValidSpecifier("America/New_York") //=> true
   * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
   * @deprecated This method returns false for some valid IANA names. Use isValidZone instead.
   * @return {boolean}
   */
  static isValidSpecifier(s) {
    return this.isValidZone(s);
  }

  /**
   * Returns whether the provided string identifies a real zone
   * @param {string} zone - The string to check
   * @example IANAZone.isValidZone("America/New_York") //=> true
   * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
   * @example IANAZone.isValidZone("Sport~~blorp") //=> false
   * @return {boolean}
   */
  static isValidZone(zone) {
    if (!zone) {
      return false;
    }
    try {
      new Intl.DateTimeFormat("en-US", { timeZone: zone }).format();
      return true;
    } catch (e) {
      return false;
    }
  }

  constructor(name) {
    super();
    /** @private **/
    this.zoneName = name;
    /** @private **/
    this.valid = IANAZone.isValidZone(name);
  }

  /** @override **/
  get type() {
    return "iana";
  }

  /** @override **/
  get name() {
    return this.zoneName;
  }

  /** @override **/
  get isUniversal() {
    return false;
  }

  /** @override **/
  offsetName(ts, { format, locale }) {
    return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.parseZoneInfo)(ts, format, locale, this.name);
  }

  /** @override **/
  formatOffset(ts, format) {
    return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.formatOffset)(this.offset(ts), format);
  }

  /** @override **/
  offset(ts) {
    const date = new Date(ts);

    if (isNaN(date)) return NaN;

    const dtf = makeDTF(this.name);
    let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts
      ? partsOffset(dtf, date)
      : hackyOffset(dtf, date);

    if (adOrBc === "BC") {
      year = -Math.abs(year) + 1;
    }

    // because we're using hour12 and https://bugs.chromium.org/p/chromium/issues/detail?id=1025564&can=2&q=%2224%3A00%22%20datetimeformat
    const adjustedHour = hour === 24 ? 0 : hour;

    const asUTC = (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.objToLocalTS)({
      year,
      month,
      day,
      hour: adjustedHour,
      minute,
      second,
      millisecond: 0,
    });

    let asTS = +date;
    const over = asTS % 1000;
    asTS -= over >= 0 ? over : 1000 + over;
    return (asUTC - asTS) / (60 * 1000);
  }

  /** @override **/
  equals(otherZone) {
    return otherZone.type === "iana" && otherZone.name === this.name;
  }

  /** @override **/
  get isValid() {
    return this.valid;
  }
}


/***/ }),

/***/ "./node_modules/luxon/src/zones/fixedOffsetZone.js":
/*!*********************************************************!*\
  !*** ./node_modules/luxon/src/zones/fixedOffsetZone.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ FixedOffsetZone; }
/* harmony export */ });
/* harmony import */ var _impl_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../impl/util.js */ "./node_modules/luxon/src/impl/util.js");
/* harmony import */ var _zone_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../zone.js */ "./node_modules/luxon/src/zone.js");



let singleton = null;

/**
 * A zone with a fixed offset (meaning no DST)
 * @implements {Zone}
 */
class FixedOffsetZone extends _zone_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * Get a singleton instance of UTC
   * @return {FixedOffsetZone}
   */
  static get utcInstance() {
    if (singleton === null) {
      singleton = new FixedOffsetZone(0);
    }
    return singleton;
  }

  /**
   * Get an instance with a specified offset
   * @param {number} offset - The offset in minutes
   * @return {FixedOffsetZone}
   */
  static instance(offset) {
    return offset === 0 ? FixedOffsetZone.utcInstance : new FixedOffsetZone(offset);
  }

  /**
   * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
   * @param {string} s - The offset string to parse
   * @example FixedOffsetZone.parseSpecifier("UTC+6")
   * @example FixedOffsetZone.parseSpecifier("UTC+06")
   * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
   * @return {FixedOffsetZone}
   */
  static parseSpecifier(s) {
    if (s) {
      const r = s.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
      if (r) {
        return new FixedOffsetZone((0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.signedOffset)(r[1], r[2]));
      }
    }
    return null;
  }

  constructor(offset) {
    super();
    /** @private **/
    this.fixed = offset;
  }

  /** @override **/
  get type() {
    return "fixed";
  }

  /** @override **/
  get name() {
    return this.fixed === 0 ? "UTC" : `UTC${(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.formatOffset)(this.fixed, "narrow")}`;
  }

  get ianaName() {
    if (this.fixed === 0) {
      return "Etc/UTC";
    } else {
      return `Etc/GMT${(0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.formatOffset)(-this.fixed, "narrow")}`;
    }
  }

  /** @override **/
  offsetName() {
    return this.name;
  }

  /** @override **/
  formatOffset(ts, format) {
    return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.formatOffset)(this.fixed, format);
  }

  /** @override **/
  get isUniversal() {
    return true;
  }

  /** @override **/
  offset() {
    return this.fixed;
  }

  /** @override **/
  equals(otherZone) {
    return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
  }

  /** @override **/
  get isValid() {
    return true;
  }
}


/***/ }),

/***/ "./node_modules/luxon/src/zones/invalidZone.js":
/*!*****************************************************!*\
  !*** ./node_modules/luxon/src/zones/invalidZone.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ InvalidZone; }
/* harmony export */ });
/* harmony import */ var _zone_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../zone.js */ "./node_modules/luxon/src/zone.js");


/**
 * A zone that failed to parse. You should never need to instantiate this.
 * @implements {Zone}
 */
class InvalidZone extends _zone_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(zoneName) {
    super();
    /**  @private */
    this.zoneName = zoneName;
  }

  /** @override **/
  get type() {
    return "invalid";
  }

  /** @override **/
  get name() {
    return this.zoneName;
  }

  /** @override **/
  get isUniversal() {
    return false;
  }

  /** @override **/
  offsetName() {
    return null;
  }

  /** @override **/
  formatOffset() {
    return "";
  }

  /** @override **/
  offset() {
    return NaN;
  }

  /** @override **/
  equals() {
    return false;
  }

  /** @override **/
  get isValid() {
    return false;
  }
}


/***/ }),

/***/ "./node_modules/luxon/src/zones/systemZone.js":
/*!****************************************************!*\
  !*** ./node_modules/luxon/src/zones/systemZone.js ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ SystemZone; }
/* harmony export */ });
/* harmony import */ var _impl_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../impl/util.js */ "./node_modules/luxon/src/impl/util.js");
/* harmony import */ var _zone_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../zone.js */ "./node_modules/luxon/src/zone.js");



let singleton = null;

/**
 * Represents the local zone for this JavaScript environment.
 * @implements {Zone}
 */
class SystemZone extends _zone_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * Get a singleton instance of the local zone
   * @return {SystemZone}
   */
  static get instance() {
    if (singleton === null) {
      singleton = new SystemZone();
    }
    return singleton;
  }

  /** @override **/
  get type() {
    return "system";
  }

  /** @override **/
  get name() {
    return new Intl.DateTimeFormat().resolvedOptions().timeZone;
  }

  /** @override **/
  get isUniversal() {
    return false;
  }

  /** @override **/
  offsetName(ts, { format, locale }) {
    return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.parseZoneInfo)(ts, format, locale);
  }

  /** @override **/
  formatOffset(ts, format) {
    return (0,_impl_util_js__WEBPACK_IMPORTED_MODULE_0__.formatOffset)(this.offset(ts), format);
  }

  /** @override **/
  offset(ts) {
    return -new Date(ts).getTimezoneOffset();
  }

  /** @override **/
  equals(otherZone) {
    return otherZone.type === "system";
  }

  /** @override **/
  get isValid() {
    return true;
  }
}


/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ var __webpack_exports__ = (__webpack_exec__("./assets/app.js"));
/******/ }
]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLE1BQU07QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxPQUFPO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsV0FBVztBQUNuQztBQUNBLDRCQUE0QixZQUFZO0FBQ3hDLDhCQUE4QixZQUFZO0FBQzFDLDRCQUE0QixZQUFZO0FBQ3hDLGdDQUFnQyxZQUFZO0FBQzVDLHVDQUF1QyxZQUFZLEVBQUUsZUFBZTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxxQkFBcUIsR0FBRyxvQkFBb0I7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHFCQUFxQjtBQUNyRDtBQUNBLHdDQUF3QywwQkFBMEI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsaURBQWlEO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxPQUFPO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixXQUFXO0FBQ25DLGtDQUFrQyxZQUFZO0FBQzlDLHdDQUF3QyxZQUFZO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCw2Q0FBNkM7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixXQUFXO0FBQ25DO0FBQ0E7QUFDQSw0QkFBNEIsWUFBWTtBQUN4QywrQ0FBK0MsWUFBWTtBQUMzRCxnQ0FBZ0MsWUFBWTtBQUM1Qyw0QkFBNEIsWUFBWTtBQUN4Qyw4QkFBOEIsWUFBWTtBQUMxQyxnQ0FBZ0MsWUFBWTtBQUM1Qyw0Q0FBNEMsWUFBWTtBQUN4RCxvREFBb0QsWUFBWTtBQUNoRSxrREFBa0QsWUFBWTtBQUM5RCx1Q0FBdUMsWUFBWSxFQUFFLGVBQWU7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZUFBZTtBQUN4RDtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZUFBZTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsV0FBVztBQUNuQztBQUNBLHFDQUFxQyxZQUFZLEVBQUUsZUFBZTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsWUFBWTtBQUN4Qyw4QkFBOEIsWUFBWTtBQUMxQyw0QkFBNEIsWUFBWTtBQUN4Qyw2Q0FBNkMsWUFBWTtBQUN6RCxnQ0FBZ0MsWUFBWTtBQUM1Qyw4QkFBOEIsWUFBWTtBQUMxQyx1Q0FBdUMsWUFBWSxFQUFFLGVBQWU7QUFDcEUsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUlBQXVJO0FBQ3ZJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSwyQ0FBTTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHdEQUFtQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQix1RUFBdUU7OztBQUd2RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxRQUFRO0FBQ1IsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFFBQVE7QUFDUjs7QUFFQTs7QUFFQSw4Q0FBOEM7O0FBRTlDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQzs7QUFFbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0EsK0RBQStEO0FBQy9ELHNEQUFzRDtBQUN0RCxnREFBZ0Q7QUFDaEQscURBQXFEO0FBQ3JELDREQUE0RDtBQUM1RCxxREFBcUQ7QUFDckQsZ0RBQWdEO0FBQ2hELDJEQUEyRDtBQUMzRCxxREFBcUQ7QUFDckQsZ0RBQWdEO0FBQ2hELHdEQUF3RDtBQUN4RCxrREFBa0Q7QUFDbEQsZ0RBQWdEO0FBQ2hELHdEQUF3RDtBQUN4RCx3REFBd0Q7QUFDeEQsbURBQW1EO0FBQ25ELHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUMsc0JBQXNCLHNCQUFzQix3QkFBd0I7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDLGVBQWU7O0FBRWpEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDZCQUE2Qjs7QUFFN0I7QUFDQSx3REFBd0Q7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0EsTUFBTSxHQUFHOztBQUVUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVFQUF1RTs7QUFFdkU7QUFDQSxzREFBc0Q7O0FBRXREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLE9BQU87OztBQUdQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTSxHQUFHOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sR0FBRzs7QUFFVCw4REFBOEQ7O0FBRTlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsZ0NBQWdDO0FBQ2hDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7O0FBRS9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0Esb0NBQW9DOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDs7QUFFbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPOzs7QUFHUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixVQUFVO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7O0FBR0E7QUFDQTtBQUNBLFdBQVc7OztBQUdYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUM7QUFDbkM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBLFFBQVEsR0FBRzs7QUFFWDtBQUNBLDRDQUE0QztBQUM1QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUVBQXlFLGtCQUFrQjtBQUMzRjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7O0FBRW5EOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLDJEQUEyRDs7QUFFM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQzs7QUFFM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXOztBQUVYLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRDQUE0QztBQUM1QyxTQUFTOztBQUVULE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87OztBQUdQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFNBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEdBQUc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxHQUFHOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSSxHQUFHOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7OztBQUdBO0FBQ0E7QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxHQUFHOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLEdBQUc7O0FBRVA7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLEdBQUc7QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0EscURBQXFEOztBQUVyRDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLEdBQUc7O0FBRVA7QUFDQTtBQUNBLCtDQUErQzs7QUFFL0MsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTSx5QkFBeUI7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBLFNBQVM7OztBQUdUO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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LFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsMEJBQTBCLHlFQUFrQjtBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsMEJBQTBCLGdEQUFJLG1CQUFtQixr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QUFDQSxtQkFBbUIsbUVBQWtDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4T0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvS3dDO0FBQ0E7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QVcsNERBQWE7QUFDeEI7O0FBRUE7QUFDQTtBQUNBLFdBQVcsMkRBQVk7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2tpbWFpMi8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvY3JlYXRlUG9wcGVyLmpzIiwid2VicGFjazovL2tpbWFpMi8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2NvbnRhaW5zLmpzIiwid2VicGFjazovL2tpbWFpMi8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qcyIsIndlYnBhY2s6Ly9raW1haTIvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRDbGlwcGluZ1JlY3QuanMiLCJ3ZWJwYWNrOi8va2ltYWkyLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q29tcG9zaXRlUmVjdC5qcyIsIndlYnBhY2s6Ly9raW1haTIvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRDb21wdXRlZFN0eWxlLmpzIiwid2VicGFjazovL2tpbWFpMi8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldERvY3VtZW50RWxlbWVudC5qcyIsIndlYnBhY2s6Ly9raW1haTIvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXREb2N1bWVudFJlY3QuanMiLCJ3ZWJwYWNrOi8va2ltYWkyLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0SFRNTEVsZW1lbnRTY3JvbGwuanMiLCJ3ZWJwYWNrOi8va2ltYWkyLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qcyIsIndlYnBhY2s6Ly9raW1haTIvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXROb2RlTmFtZS5qcyIsIndlYnBhY2s6Ly9raW1haTIvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXROb2RlU2Nyb2xsLmpzIiwid2VicGFjazovL2tpbWFpMi8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qcyIsIndlYnBhY2s6Ly9raW1haTIvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRQYXJlbnROb2RlLmpzIiwid2VicGFjazovL2tpbWFpMi8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFNjcm9sbFBhcmVudC5qcyIsIndlYnBhY2s6Ly9raW1haTIvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRWaWV3cG9ydFJlY3QuanMiLCJ3ZWJwYWNrOi8va2ltYWkyLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93LmpzIiwid2VicGFjazovL2tpbWFpMi8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFdpbmRvd1Njcm9sbC5qcyIsIndlYnBhY2s6Ly9raW1haTIvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzIiwid2VicGFjazovL2tpbWFpMi8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2luc3RhbmNlT2YuanMiLCJ3ZWJwYWNrOi8va2ltYWkyLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaXNMYXlvdXRWaWV3cG9ydC5qcyIsIndlYnBhY2s6Ly9raW1haTIvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pc1Njcm9sbFBhcmVudC5qcyIsIndlYnBhY2s6Ly9raW1haTIvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pc1RhYmxlRWxlbWVudC5qcyIsIndlYnBhY2s6Ly9raW1haTIvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9saXN0U2Nyb2xsUGFyZW50cy5qcyIsIndlYnBhY2s6Ly9raW1haTIvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2VudW1zLmpzIiwid2VicGFjazovL2tpbWFpMi8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8va2ltYWkyLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvYXBwbHlTdHlsZXMuanMiLCJ3ZWJwYWNrOi8va2ltYWkyLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvYXJyb3cuanMiLCJ3ZWJwYWNrOi8va2ltYWkyLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvY29tcHV0ZVN0eWxlcy5qcyIsIndlYnBhY2s6Ly9raW1haTIvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9ldmVudExpc3RlbmVycy5qcyIsIndlYnBhY2s6Ly9raW1haTIvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9mbGlwLmpzIiwid2VicGFjazovL2tpbWFpMi8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2hpZGUuanMiLCJ3ZWJwYWNrOi8va2ltYWkyLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8va2ltYWkyLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvb2Zmc2V0LmpzIiwid2VicGFjazovL2tpbWFpMi8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL3BvcHBlck9mZnNldHMuanMiLCJ3ZWJwYWNrOi8va2ltYWkyLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvcHJldmVudE92ZXJmbG93LmpzIiwid2VicGFjazovL2tpbWFpMi8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvcG9wcGVyLWxpdGUuanMiLCJ3ZWJwYWNrOi8va2ltYWkyLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9wb3BwZXIuanMiLCJ3ZWJwYWNrOi8va2ltYWkyLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9jb21wdXRlQXV0b1BsYWNlbWVudC5qcyIsIndlYnBhY2s6Ly9raW1haTIvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2NvbXB1dGVPZmZzZXRzLmpzIiwid2VicGFjazovL2tpbWFpMi8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZGVib3VuY2UuanMiLCJ3ZWJwYWNrOi8va2ltYWkyLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9kZXRlY3RPdmVyZmxvdy5qcyIsIndlYnBhY2s6Ly9raW1haTIvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2V4cGFuZFRvSGFzaE1hcC5qcyIsIndlYnBhY2s6Ly9raW1haTIvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEFsdEF4aXMuanMiLCJ3ZWJwYWNrOi8va2ltYWkyLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzIiwid2VicGFjazovL2tpbWFpMi8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0RnJlc2hTaWRlT2JqZWN0LmpzIiwid2VicGFjazovL2tpbWFpMi8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzIiwid2VicGFjazovL2tpbWFpMi8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0T3Bwb3NpdGVQbGFjZW1lbnQuanMiLCJ3ZWJwYWNrOi8va2ltYWkyLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudC5qcyIsIndlYnBhY2s6Ly9raW1haTIvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldFZhcmlhdGlvbi5qcyIsIndlYnBhY2s6Ly9raW1haTIvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL21hdGguanMiLCJ3ZWJwYWNrOi8va2ltYWkyLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9tZXJnZUJ5TmFtZS5qcyIsIndlYnBhY2s6Ly9raW1haTIvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL21lcmdlUGFkZGluZ09iamVjdC5qcyIsIndlYnBhY2s6Ly9raW1haTIvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL29yZGVyTW9kaWZpZXJzLmpzIiwid2VicGFjazovL2tpbWFpMi8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvcmVjdFRvQ2xpZW50UmVjdC5qcyIsIndlYnBhY2s6Ly9raW1haTIvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3VzZXJBZ2VudC5qcyIsIndlYnBhY2s6Ly9raW1haTIvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3dpdGhpbi5qcyIsIndlYnBhY2s6Ly9raW1haTIvLi9hc3NldHMvYXBwLmpzIiwid2VicGFjazovL2tpbWFpMi8uL2Fzc2V0cy9qcy9LaW1haUNvbmZpZ3VyYXRpb24uanMiLCJ3ZWJwYWNrOi8va2ltYWkyLy4vYXNzZXRzL2pzL0tpbWFpQ29udGFpbmVyLmpzIiwid2VicGFjazovL2tpbWFpMi8uL2Fzc2V0cy9qcy9LaW1haUxvYWRlci5qcyIsIndlYnBhY2s6Ly9raW1haTIvLi9hc3NldHMvanMvS2ltYWlQbHVnaW4uanMiLCJ3ZWJwYWNrOi8va2ltYWkyLy4vYXNzZXRzL2pzL0tpbWFpVHJhbnNsYXRpb24uanMiLCJ3ZWJwYWNrOi8va2ltYWkyLy4vYXNzZXRzL2pzL0tpbWFpV2ViTG9hZGVyLmpzIiwid2VicGFjazovL2tpbWFpMi8uL2Fzc2V0cy9qcy9mb3Jtcy9LaW1haUF1dG9jb21wbGV0ZS5qcyIsIndlYnBhY2s6Ly9raW1haTIvLi9hc3NldHMvanMvZm9ybXMvS2ltYWlDb3B5RGF0YUZvcm0uanMiLCJ3ZWJwYWNrOi8va2ltYWkyLy4vYXNzZXRzL2pzL2Zvcm1zL0tpbWFpRGF0ZU5vd0Zvcm0uanMiLCJ3ZWJwYWNrOi8va2ltYWkyLy4vYXNzZXRzL2pzL2Zvcm1zL0tpbWFpRGF0ZVBpY2tlci5qcyIsIndlYnBhY2s6Ly9raW1haTIvLi9hc3NldHMvanMvZm9ybXMvS2ltYWlEYXRlUmFuZ2VQaWNrZXIuanMiLCJ3ZWJwYWNrOi8va2ltYWkyLy4vYXNzZXRzL2pzL2Zvcm1zL0tpbWFpRm9ybVBsdWdpbi5qcyIsIndlYnBhY2s6Ly9raW1haTIvLi9hc3NldHMvanMvZm9ybXMvS2ltYWlGb3JtU2VsZWN0LmpzIiwid2VicGFjazovL2tpbWFpMi8uL2Fzc2V0cy9qcy9mb3Jtcy9LaW1haVRlYW1Gb3JtLmpzIiwid2VicGFjazovL2tpbWFpMi8uL2Fzc2V0cy9qcy9mb3Jtcy9LaW1haVRpbWVzaGVldEZvcm0uanMiLCJ3ZWJwYWNrOi8va2ltYWkyLy4vYXNzZXRzL2pzL3BsdWdpbnMvS2ltYWlBUEkuanMiLCJ3ZWJwYWNrOi8va2ltYWkyLy4vYXNzZXRzL2pzL3BsdWdpbnMvS2ltYWlBUElMaW5rLmpzIiwid2VicGFjazovL2tpbWFpMi8uL2Fzc2V0cy9qcy9wbHVnaW5zL0tpbWFpQWN0aXZlUmVjb3Jkcy5qcyIsIndlYnBhY2s6Ly9raW1haTIvLi9hc3NldHMvanMvcGx1Z2lucy9LaW1haUFqYXhNb2RhbEZvcm0uanMiLCJ3ZWJwYWNrOi8va2ltYWkyLy4vYXNzZXRzL2pzL3BsdWdpbnMvS2ltYWlBbGVydC5qcyIsIndlYnBhY2s6Ly9raW1haTIvLi9hc3NldHMvanMvcGx1Z2lucy9LaW1haUFsdGVybmF0aXZlTGlua3MuanMiLCJ3ZWJwYWNrOi8va2ltYWkyLy4vYXNzZXRzL2pzL3BsdWdpbnMvS2ltYWlDb25maXJtYXRpb25MaW5rLmpzIiwid2VicGFjazovL2tpbWFpMi8uL2Fzc2V0cy9qcy9wbHVnaW5zL0tpbWFpRGF0YXRhYmxlLmpzIiwid2VicGFjazovL2tpbWFpMi8uL2Fzc2V0cy9qcy9wbHVnaW5zL0tpbWFpRGF0YXRhYmxlQ29sdW1uVmlldy5qcyIsIndlYnBhY2s6Ly9raW1haTIvLi9hc3NldHMvanMvcGx1Z2lucy9LaW1haURhdGVVdGlscy5qcyIsIndlYnBhY2s6Ly9raW1haTIvLi9hc3NldHMvanMvcGx1Z2lucy9LaW1haUVzY2FwZS5qcyIsIndlYnBhY2s6Ly9raW1haTIvLi9hc3NldHMvanMvcGx1Z2lucy9LaW1haUV2ZW50LmpzIiwid2VicGFjazovL2tpbWFpMi8uL2Fzc2V0cy9qcy9wbHVnaW5zL0tpbWFpRmV0Y2guanMiLCJ3ZWJwYWNrOi8va2ltYWkyLy4vYXNzZXRzL2pzL3BsdWdpbnMvS2ltYWlGb3JtLmpzIiwid2VicGFjazovL2tpbWFpMi8uL2Fzc2V0cy9qcy9wbHVnaW5zL0tpbWFpSG90a2V5cy5qcyIsIndlYnBhY2s6Ly9raW1haTIvLi9hc3NldHMvanMvcGx1Z2lucy9LaW1haU11bHRpVXBkYXRlVGFibGUuanMiLCJ3ZWJwYWNrOi8va2ltYWkyLy4vYXNzZXRzL2pzL3BsdWdpbnMvS2ltYWlOb3RpZmljYXRpb24uanMiLCJ3ZWJwYWNrOi8va2ltYWkyLy4vYXNzZXRzL2pzL3BsdWdpbnMvS2ltYWlSZWR1Y2VkQ2xpY2tIYW5kbGVyLmpzIiwid2VicGFjazovL2tpbWFpMi8uL2Fzc2V0cy9qcy9wbHVnaW5zL0tpbWFpUmVtb3RlTW9kYWwuanMiLCJ3ZWJwYWNrOi8va2ltYWkyLy4vYXNzZXRzL2pzL3BsdWdpbnMvS2ltYWlUaGVtZUluaXRpYWxpemVyLmpzIiwid2VicGFjazovL2tpbWFpMi8uL2Fzc2V0cy9qcy9wbHVnaW5zL0tpbWFpVG9vbGJhci5qcyIsIndlYnBhY2s6Ly9raW1haTIvLi9hc3NldHMvanMvcGx1Z2lucy9LaW1haVVzZXIuanMiLCJ3ZWJwYWNrOi8va2ltYWkyLy4vYXNzZXRzL2pzL3dpZGdldHMvS2ltYWlDb2xvci5qcyIsIndlYnBhY2s6Ly9raW1haTIvLi9hc3NldHMvanMvd2lkZ2V0cy9LaW1haUNvbnRleHRNZW51LmpzIiwid2VicGFjazovL2tpbWFpMi8uL2Fzc2V0cy9qcy93aWRnZXRzL0tpbWFpUGFnaW5hdGVkQm94V2lkZ2V0LmpzIiwid2VicGFjazovL2tpbWFpMi8uL2Fzc2V0cy9qcy93aWRnZXRzL0tpbWFpUmVsb2FkUGFnZVdpZGdldC5qcyIsIndlYnBhY2s6Ly9raW1haTIvLi9hc3NldHMvanMvd2lkZ2V0cy9LaW1haVN0b3JhZ2UuanMiLCJ3ZWJwYWNrOi8va2ltYWkyLy4vbm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9kaXN0L2pzL2Jvb3RzdHJhcC5lc20uanMiLCJ3ZWJwYWNrOi8va2ltYWkyLy4vbm9kZV9tb2R1bGVzL2xpdGVwaWNrZXIvZGlzdC9saXRlcGlja2VyLnVtZC5qcyIsIndlYnBhY2s6Ly9raW1haTIvLi9ub2RlX21vZHVsZXMvbGl0ZXBpY2tlci9kaXN0L3BsdWdpbnMvbW9iaWxlZnJpZW5kbHkuanMiLCJ3ZWJwYWNrOi8va2ltYWkyLy4vYXNzZXRzL3Nhc3MvX2FwcC5zY3NzIiwid2VicGFjazovL2tpbWFpMi8uL25vZGVfbW9kdWxlcy90b20tc2VsZWN0L2Rpc3QvanMvdG9tLXNlbGVjdC5jb21wbGV0ZS5qcyIsIndlYnBhY2s6Ly9raW1haTIvLi9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2RhdGV0aW1lLmpzIiwid2VicGFjazovL2tpbWFpMi8uL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvZHVyYXRpb24uanMiLCJ3ZWJwYWNrOi8va2ltYWkyLy4vbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9lcnJvcnMuanMiLCJ3ZWJwYWNrOi8va2ltYWkyLy4vbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL2NvbnZlcnNpb25zLmpzIiwid2VicGFjazovL2tpbWFpMi8uL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9kaWZmLmpzIiwid2VicGFjazovL2tpbWFpMi8uL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9kaWdpdHMuanMiLCJ3ZWJwYWNrOi8va2ltYWkyLy4vbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL2VuZ2xpc2guanMiLCJ3ZWJwYWNrOi8va2ltYWkyLy4vbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL2Zvcm1hdHMuanMiLCJ3ZWJwYWNrOi8va2ltYWkyLy4vbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL2Zvcm1hdHRlci5qcyIsIndlYnBhY2s6Ly9raW1haTIvLi9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvaW52YWxpZC5qcyIsIndlYnBhY2s6Ly9raW1haTIvLi9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvbG9jYWxlLmpzIiwid2VicGFjazovL2tpbWFpMi8uL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9yZWdleFBhcnNlci5qcyIsIndlYnBhY2s6Ly9raW1haTIvLi9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvdG9rZW5QYXJzZXIuanMiLCJ3ZWJwYWNrOi8va2ltYWkyLy4vbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL3V0aWwuanMiLCJ3ZWJwYWNrOi8va2ltYWkyLy4vbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL3pvbmVVdGlsLmpzIiwid2VicGFjazovL2tpbWFpMi8uL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW5mby5qcyIsIndlYnBhY2s6Ly9raW1haTIvLi9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ludGVydmFsLmpzIiwid2VicGFjazovL2tpbWFpMi8uL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvbHV4b24uanMiLCJ3ZWJwYWNrOi8va2ltYWkyLy4vbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9zZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly9raW1haTIvLi9ub2RlX21vZHVsZXMvbHV4b24vc3JjL3pvbmUuanMiLCJ3ZWJwYWNrOi8va2ltYWkyLy4vbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy96b25lcy9JQU5BWm9uZS5qcyIsIndlYnBhY2s6Ly9raW1haTIvLi9ub2RlX21vZHVsZXMvbHV4b24vc3JjL3pvbmVzL2ZpeGVkT2Zmc2V0Wm9uZS5qcyIsIndlYnBhY2s6Ly9raW1haTIvLi9ub2RlX21vZHVsZXMvbHV4b24vc3JjL3pvbmVzL2ludmFsaWRab25lLmpzIiwid2VicGFjazovL2tpbWFpMi8uL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvem9uZXMvc3lzdGVtWm9uZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZ2V0Q29tcG9zaXRlUmVjdCBmcm9tIFwiLi9kb20tdXRpbHMvZ2V0Q29tcG9zaXRlUmVjdC5qc1wiO1xuaW1wb3J0IGdldExheW91dFJlY3QgZnJvbSBcIi4vZG9tLXV0aWxzL2dldExheW91dFJlY3QuanNcIjtcbmltcG9ydCBsaXN0U2Nyb2xsUGFyZW50cyBmcm9tIFwiLi9kb20tdXRpbHMvbGlzdFNjcm9sbFBhcmVudHMuanNcIjtcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSBcIi4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qc1wiO1xuaW1wb3J0IG9yZGVyTW9kaWZpZXJzIGZyb20gXCIuL3V0aWxzL29yZGVyTW9kaWZpZXJzLmpzXCI7XG5pbXBvcnQgZGVib3VuY2UgZnJvbSBcIi4vdXRpbHMvZGVib3VuY2UuanNcIjtcbmltcG9ydCBtZXJnZUJ5TmFtZSBmcm9tIFwiLi91dGlscy9tZXJnZUJ5TmFtZS5qc1wiO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gXCIuL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzXCI7XG5pbXBvcnQgeyBpc0VsZW1lbnQgfSBmcm9tIFwiLi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qc1wiO1xudmFyIERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgcGxhY2VtZW50OiAnYm90dG9tJyxcbiAgbW9kaWZpZXJzOiBbXSxcbiAgc3RyYXRlZ3k6ICdhYnNvbHV0ZSdcbn07XG5cbmZ1bmN0aW9uIGFyZVZhbGlkRWxlbWVudHMoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gIWFyZ3Muc29tZShmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHJldHVybiAhKGVsZW1lbnQgJiYgdHlwZW9mIGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID09PSAnZnVuY3Rpb24nKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb3BwZXJHZW5lcmF0b3IoZ2VuZXJhdG9yT3B0aW9ucykge1xuICBpZiAoZ2VuZXJhdG9yT3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgZ2VuZXJhdG9yT3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIF9nZW5lcmF0b3JPcHRpb25zID0gZ2VuZXJhdG9yT3B0aW9ucyxcbiAgICAgIF9nZW5lcmF0b3JPcHRpb25zJGRlZiA9IF9nZW5lcmF0b3JPcHRpb25zLmRlZmF1bHRNb2RpZmllcnMsXG4gICAgICBkZWZhdWx0TW9kaWZpZXJzID0gX2dlbmVyYXRvck9wdGlvbnMkZGVmID09PSB2b2lkIDAgPyBbXSA6IF9nZW5lcmF0b3JPcHRpb25zJGRlZixcbiAgICAgIF9nZW5lcmF0b3JPcHRpb25zJGRlZjIgPSBfZ2VuZXJhdG9yT3B0aW9ucy5kZWZhdWx0T3B0aW9ucyxcbiAgICAgIGRlZmF1bHRPcHRpb25zID0gX2dlbmVyYXRvck9wdGlvbnMkZGVmMiA9PT0gdm9pZCAwID8gREVGQVVMVF9PUFRJT05TIDogX2dlbmVyYXRvck9wdGlvbnMkZGVmMjtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZVBvcHBlcihyZWZlcmVuY2UsIHBvcHBlciwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcbiAgICB9XG5cbiAgICB2YXIgc3RhdGUgPSB7XG4gICAgICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuICAgICAgb3JkZXJlZE1vZGlmaWVyczogW10sXG4gICAgICBvcHRpb25zOiBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIGRlZmF1bHRPcHRpb25zKSxcbiAgICAgIG1vZGlmaWVyc0RhdGE6IHt9LFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgcmVmZXJlbmNlOiByZWZlcmVuY2UsXG4gICAgICAgIHBvcHBlcjogcG9wcGVyXG4gICAgICB9LFxuICAgICAgYXR0cmlidXRlczoge30sXG4gICAgICBzdHlsZXM6IHt9XG4gICAgfTtcbiAgICB2YXIgZWZmZWN0Q2xlYW51cEZucyA9IFtdO1xuICAgIHZhciBpc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHZhciBpbnN0YW5jZSA9IHtcbiAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgIHNldE9wdGlvbnM6IGZ1bmN0aW9uIHNldE9wdGlvbnMoc2V0T3B0aW9uc0FjdGlvbikge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHR5cGVvZiBzZXRPcHRpb25zQWN0aW9uID09PSAnZnVuY3Rpb24nID8gc2V0T3B0aW9uc0FjdGlvbihzdGF0ZS5vcHRpb25zKSA6IHNldE9wdGlvbnNBY3Rpb247XG4gICAgICAgIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKTtcbiAgICAgICAgc3RhdGUub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBzdGF0ZS5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgc3RhdGUuc2Nyb2xsUGFyZW50cyA9IHtcbiAgICAgICAgICByZWZlcmVuY2U6IGlzRWxlbWVudChyZWZlcmVuY2UpID8gbGlzdFNjcm9sbFBhcmVudHMocmVmZXJlbmNlKSA6IHJlZmVyZW5jZS5jb250ZXh0RWxlbWVudCA/IGxpc3RTY3JvbGxQYXJlbnRzKHJlZmVyZW5jZS5jb250ZXh0RWxlbWVudCkgOiBbXSxcbiAgICAgICAgICBwb3BwZXI6IGxpc3RTY3JvbGxQYXJlbnRzKHBvcHBlcilcbiAgICAgICAgfTsgLy8gT3JkZXJzIHRoZSBtb2RpZmllcnMgYmFzZWQgb24gdGhlaXIgZGVwZW5kZW5jaWVzIGFuZCBgcGhhc2VgXG4gICAgICAgIC8vIHByb3BlcnRpZXNcblxuICAgICAgICB2YXIgb3JkZXJlZE1vZGlmaWVycyA9IG9yZGVyTW9kaWZpZXJzKG1lcmdlQnlOYW1lKFtdLmNvbmNhdChkZWZhdWx0TW9kaWZpZXJzLCBzdGF0ZS5vcHRpb25zLm1vZGlmaWVycykpKTsgLy8gU3RyaXAgb3V0IGRpc2FibGVkIG1vZGlmaWVyc1xuXG4gICAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMgPSBvcmRlcmVkTW9kaWZpZXJzLmZpbHRlcihmdW5jdGlvbiAobSkge1xuICAgICAgICAgIHJldHVybiBtLmVuYWJsZWQ7XG4gICAgICAgIH0pO1xuICAgICAgICBydW5Nb2RpZmllckVmZmVjdHMoKTtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLnVwZGF0ZSgpO1xuICAgICAgfSxcbiAgICAgIC8vIFN5bmMgdXBkYXRlIOKAkyBpdCB3aWxsIGFsd2F5cyBiZSBleGVjdXRlZCwgZXZlbiBpZiBub3QgbmVjZXNzYXJ5LiBUaGlzXG4gICAgICAvLyBpcyB1c2VmdWwgZm9yIGxvdyBmcmVxdWVuY3kgdXBkYXRlcyB3aGVyZSBzeW5jIGJlaGF2aW9yIHNpbXBsaWZpZXMgdGhlXG4gICAgICAvLyBsb2dpYy5cbiAgICAgIC8vIEZvciBoaWdoIGZyZXF1ZW5jeSB1cGRhdGVzIChlLmcuIGByZXNpemVgIGFuZCBgc2Nyb2xsYCBldmVudHMpLCBhbHdheXNcbiAgICAgIC8vIHByZWZlciB0aGUgYXN5bmMgUG9wcGVyI3VwZGF0ZSBtZXRob2RcbiAgICAgIGZvcmNlVXBkYXRlOiBmdW5jdGlvbiBmb3JjZVVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKGlzRGVzdHJveWVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9zdGF0ZSRlbGVtZW50cyA9IHN0YXRlLmVsZW1lbnRzLFxuICAgICAgICAgICAgcmVmZXJlbmNlID0gX3N0YXRlJGVsZW1lbnRzLnJlZmVyZW5jZSxcbiAgICAgICAgICAgIHBvcHBlciA9IF9zdGF0ZSRlbGVtZW50cy5wb3BwZXI7IC8vIERvbid0IHByb2NlZWQgaWYgYHJlZmVyZW5jZWAgb3IgYHBvcHBlcmAgYXJlIG5vdCB2YWxpZCBlbGVtZW50c1xuICAgICAgICAvLyBhbnltb3JlXG5cbiAgICAgICAgaWYgKCFhcmVWYWxpZEVsZW1lbnRzKHJlZmVyZW5jZSwgcG9wcGVyKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBTdG9yZSB0aGUgcmVmZXJlbmNlIGFuZCBwb3BwZXIgcmVjdHMgdG8gYmUgcmVhZCBieSBtb2RpZmllcnNcblxuXG4gICAgICAgIHN0YXRlLnJlY3RzID0ge1xuICAgICAgICAgIHJlZmVyZW5jZTogZ2V0Q29tcG9zaXRlUmVjdChyZWZlcmVuY2UsIGdldE9mZnNldFBhcmVudChwb3BwZXIpLCBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5ID09PSAnZml4ZWQnKSxcbiAgICAgICAgICBwb3BwZXI6IGdldExheW91dFJlY3QocG9wcGVyKVxuICAgICAgICB9OyAvLyBNb2RpZmllcnMgaGF2ZSB0aGUgYWJpbGl0eSB0byByZXNldCB0aGUgY3VycmVudCB1cGRhdGUgY3ljbGUuIFRoZVxuICAgICAgICAvLyBtb3N0IGNvbW1vbiB1c2UgY2FzZSBmb3IgdGhpcyBpcyB0aGUgYGZsaXBgIG1vZGlmaWVyIGNoYW5naW5nIHRoZVxuICAgICAgICAvLyBwbGFjZW1lbnQsIHdoaWNoIHRoZW4gbmVlZHMgdG8gcmUtcnVuIGFsbCB0aGUgbW9kaWZpZXJzLCBiZWNhdXNlIHRoZVxuICAgICAgICAvLyBsb2dpYyB3YXMgcHJldmlvdXNseSByYW4gZm9yIHRoZSBwcmV2aW91cyBwbGFjZW1lbnQgYW5kIGlzIHRoZXJlZm9yZVxuICAgICAgICAvLyBzdGFsZS9pbmNvcnJlY3RcblxuICAgICAgICBzdGF0ZS5yZXNldCA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5wbGFjZW1lbnQgPSBzdGF0ZS5vcHRpb25zLnBsYWNlbWVudDsgLy8gT24gZWFjaCB1cGRhdGUgY3ljbGUsIHRoZSBgbW9kaWZpZXJzRGF0YWAgcHJvcGVydHkgZm9yIGVhY2ggbW9kaWZpZXJcbiAgICAgICAgLy8gaXMgZmlsbGVkIHdpdGggdGhlIGluaXRpYWwgZGF0YSBzcGVjaWZpZWQgYnkgdGhlIG1vZGlmaWVyLiBUaGlzIG1lYW5zXG4gICAgICAgIC8vIGl0IGRvZXNuJ3QgcGVyc2lzdCBhbmQgaXMgZnJlc2ggb24gZWFjaCB1cGRhdGUuXG4gICAgICAgIC8vIFRvIGVuc3VyZSBwZXJzaXN0ZW50IGRhdGEsIHVzZSBgJHtuYW1lfSNwZXJzaXN0ZW50YFxuXG4gICAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICAgICAgICByZXR1cm4gc3RhdGUubW9kaWZpZXJzRGF0YVttb2RpZmllci5uYW1lXSA9IE9iamVjdC5hc3NpZ24oe30sIG1vZGlmaWVyLmRhdGEpO1xuICAgICAgICB9KTtcblxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgc3RhdGUub3JkZXJlZE1vZGlmaWVycy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICBpZiAoc3RhdGUucmVzZXQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHN0YXRlLnJlc2V0ID0gZmFsc2U7XG4gICAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9zdGF0ZSRvcmRlcmVkTW9kaWZpZSA9IHN0YXRlLm9yZGVyZWRNb2RpZmllcnNbaW5kZXhdLFxuICAgICAgICAgICAgICBmbiA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZS5mbixcbiAgICAgICAgICAgICAgX3N0YXRlJG9yZGVyZWRNb2RpZmllMiA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZS5vcHRpb25zLFxuICAgICAgICAgICAgICBfb3B0aW9ucyA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIgPT09IHZvaWQgMCA/IHt9IDogX3N0YXRlJG9yZGVyZWRNb2RpZmllMixcbiAgICAgICAgICAgICAgbmFtZSA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZS5uYW1lO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc3RhdGUgPSBmbih7XG4gICAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgICAgb3B0aW9uczogX29wdGlvbnMsXG4gICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgIGluc3RhbmNlOiBpbnN0YW5jZVxuICAgICAgICAgICAgfSkgfHwgc3RhdGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gQXN5bmMgYW5kIG9wdGltaXN0aWNhbGx5IG9wdGltaXplZCB1cGRhdGUg4oCTIGl0IHdpbGwgbm90IGJlIGV4ZWN1dGVkIGlmXG4gICAgICAvLyBub3QgbmVjZXNzYXJ5IChkZWJvdW5jZWQgdG8gcnVuIGF0IG1vc3Qgb25jZS1wZXItdGljaylcbiAgICAgIHVwZGF0ZTogZGVib3VuY2UoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICBpbnN0YW5jZS5mb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgIHJlc29sdmUoc3RhdGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pLFxuICAgICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgY2xlYW51cE1vZGlmaWVyRWZmZWN0cygpO1xuICAgICAgICBpc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmICghYXJlVmFsaWRFbGVtZW50cyhyZWZlcmVuY2UsIHBvcHBlcikpIHtcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG5cbiAgICBpbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICBpZiAoIWlzRGVzdHJveWVkICYmIG9wdGlvbnMub25GaXJzdFVwZGF0ZSkge1xuICAgICAgICBvcHRpb25zLm9uRmlyc3RVcGRhdGUoc3RhdGUpO1xuICAgICAgfVxuICAgIH0pOyAvLyBNb2RpZmllcnMgaGF2ZSB0aGUgYWJpbGl0eSB0byBleGVjdXRlIGFyYml0cmFyeSBjb2RlIGJlZm9yZSB0aGUgZmlyc3RcbiAgICAvLyB1cGRhdGUgY3ljbGUgcnVucy4gVGhleSB3aWxsIGJlIGV4ZWN1dGVkIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZSB1cGRhdGVcbiAgICAvLyBjeWNsZS4gVGhpcyBpcyB1c2VmdWwgd2hlbiBhIG1vZGlmaWVyIGFkZHMgc29tZSBwZXJzaXN0ZW50IGRhdGEgdGhhdFxuICAgIC8vIG90aGVyIG1vZGlmaWVycyBuZWVkIHRvIHVzZSwgYnV0IHRoZSBtb2RpZmllciBpcyBydW4gYWZ0ZXIgdGhlIGRlcGVuZGVudFxuICAgIC8vIG9uZS5cblxuICAgIGZ1bmN0aW9uIHJ1bk1vZGlmaWVyRWZmZWN0cygpIHtcbiAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICB2YXIgbmFtZSA9IF9yZWYubmFtZSxcbiAgICAgICAgICAgIF9yZWYkb3B0aW9ucyA9IF9yZWYub3B0aW9ucyxcbiAgICAgICAgICAgIG9wdGlvbnMgPSBfcmVmJG9wdGlvbnMgPT09IHZvaWQgMCA/IHt9IDogX3JlZiRvcHRpb25zLFxuICAgICAgICAgICAgZWZmZWN0ID0gX3JlZi5lZmZlY3Q7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlZmZlY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YXIgY2xlYW51cEZuID0gZWZmZWN0KHtcbiAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2UsXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgbm9vcEZuID0gZnVuY3Rpb24gbm9vcEZuKCkge307XG5cbiAgICAgICAgICBlZmZlY3RDbGVhbnVwRm5zLnB1c2goY2xlYW51cEZuIHx8IG5vb3BGbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKSB7XG4gICAgICBlZmZlY3RDbGVhbnVwRm5zLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiBmbigpO1xuICAgICAgfSk7XG4gICAgICBlZmZlY3RDbGVhbnVwRm5zID0gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xufVxuZXhwb3J0IHZhciBjcmVhdGVQb3BwZXIgPSAvKiNfX1BVUkVfXyovcG9wcGVyR2VuZXJhdG9yKCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IHsgZGV0ZWN0T3ZlcmZsb3cgfTsiLCJpbXBvcnQgeyBpc1NoYWRvd1Jvb3QgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb250YWlucyhwYXJlbnQsIGNoaWxkKSB7XG4gIHZhciByb290Tm9kZSA9IGNoaWxkLmdldFJvb3ROb2RlICYmIGNoaWxkLmdldFJvb3ROb2RlKCk7IC8vIEZpcnN0LCBhdHRlbXB0IHdpdGggZmFzdGVyIG5hdGl2ZSBtZXRob2RcblxuICBpZiAocGFyZW50LmNvbnRhaW5zKGNoaWxkKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIHRoZW4gZmFsbGJhY2sgdG8gY3VzdG9tIGltcGxlbWVudGF0aW9uIHdpdGggU2hhZG93IERPTSBzdXBwb3J0XG4gIGVsc2UgaWYgKHJvb3ROb2RlICYmIGlzU2hhZG93Um9vdChyb290Tm9kZSkpIHtcbiAgICAgIHZhciBuZXh0ID0gY2hpbGQ7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKG5leHQgJiYgcGFyZW50LmlzU2FtZU5vZGUobmV4dCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ106IG5lZWQgYSBiZXR0ZXIgd2F5IHRvIGhhbmRsZSB0aGlzLi4uXG5cblxuICAgICAgICBuZXh0ID0gbmV4dC5wYXJlbnROb2RlIHx8IG5leHQuaG9zdDtcbiAgICAgIH0gd2hpbGUgKG5leHQpO1xuICAgIH0gLy8gR2l2ZSB1cCwgdGhlIHJlc3VsdCBpcyBmYWxzZVxuXG5cbiAgcmV0dXJuIGZhbHNlO1xufSIsImltcG9ydCB7IGlzRWxlbWVudCwgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCB7IHJvdW5kIH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjtcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgaXNMYXlvdXRWaWV3cG9ydCBmcm9tIFwiLi9pc0xheW91dFZpZXdwb3J0LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgaW5jbHVkZVNjYWxlLCBpc0ZpeGVkU3RyYXRlZ3kpIHtcbiAgaWYgKGluY2x1ZGVTY2FsZSA9PT0gdm9pZCAwKSB7XG4gICAgaW5jbHVkZVNjYWxlID0gZmFsc2U7XG4gIH1cblxuICBpZiAoaXNGaXhlZFN0cmF0ZWd5ID09PSB2b2lkIDApIHtcbiAgICBpc0ZpeGVkU3RyYXRlZ3kgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBjbGllbnRSZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHNjYWxlWCA9IDE7XG4gIHZhciBzY2FsZVkgPSAxO1xuXG4gIGlmIChpbmNsdWRlU2NhbGUgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSkge1xuICAgIHNjYWxlWCA9IGVsZW1lbnQub2Zmc2V0V2lkdGggPiAwID8gcm91bmQoY2xpZW50UmVjdC53aWR0aCkgLyBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDEgOiAxO1xuICAgIHNjYWxlWSA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0ID4gMCA/IHJvdW5kKGNsaWVudFJlY3QuaGVpZ2h0KSAvIGVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IDEgOiAxO1xuICB9XG5cbiAgdmFyIF9yZWYgPSBpc0VsZW1lbnQoZWxlbWVudCkgPyBnZXRXaW5kb3coZWxlbWVudCkgOiB3aW5kb3csXG4gICAgICB2aXN1YWxWaWV3cG9ydCA9IF9yZWYudmlzdWFsVmlld3BvcnQ7XG5cbiAgdmFyIGFkZFZpc3VhbE9mZnNldHMgPSAhaXNMYXlvdXRWaWV3cG9ydCgpICYmIGlzRml4ZWRTdHJhdGVneTtcbiAgdmFyIHggPSAoY2xpZW50UmVjdC5sZWZ0ICsgKGFkZFZpc3VhbE9mZnNldHMgJiYgdmlzdWFsVmlld3BvcnQgPyB2aXN1YWxWaWV3cG9ydC5vZmZzZXRMZWZ0IDogMCkpIC8gc2NhbGVYO1xuICB2YXIgeSA9IChjbGllbnRSZWN0LnRvcCArIChhZGRWaXN1YWxPZmZzZXRzICYmIHZpc3VhbFZpZXdwb3J0ID8gdmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wIDogMCkpIC8gc2NhbGVZO1xuICB2YXIgd2lkdGggPSBjbGllbnRSZWN0LndpZHRoIC8gc2NhbGVYO1xuICB2YXIgaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQgLyBzY2FsZVk7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHRvcDogeSxcbiAgICByaWdodDogeCArIHdpZHRoLFxuICAgIGJvdHRvbTogeSArIGhlaWdodCxcbiAgICBsZWZ0OiB4LFxuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xufSIsImltcG9ydCB7IHZpZXdwb3J0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZ2V0Vmlld3BvcnRSZWN0IGZyb20gXCIuL2dldFZpZXdwb3J0UmVjdC5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50UmVjdCBmcm9tIFwiLi9nZXREb2N1bWVudFJlY3QuanNcIjtcbmltcG9ydCBsaXN0U2Nyb2xsUGFyZW50cyBmcm9tIFwiLi9saXN0U2Nyb2xsUGFyZW50cy5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgeyBpc0VsZW1lbnQsIGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IGdldFBhcmVudE5vZGUgZnJvbSBcIi4vZ2V0UGFyZW50Tm9kZS5qc1wiO1xuaW1wb3J0IGNvbnRhaW5zIGZyb20gXCIuL2NvbnRhaW5zLmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCByZWN0VG9DbGllbnRSZWN0IGZyb20gXCIuLi91dGlscy9yZWN0VG9DbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgeyBtYXgsIG1pbiB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7XG5cbmZ1bmN0aW9uIGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSB7XG4gIHZhciByZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIGZhbHNlLCBzdHJhdGVneSA9PT0gJ2ZpeGVkJyk7XG4gIHJlY3QudG9wID0gcmVjdC50b3AgKyBlbGVtZW50LmNsaWVudFRvcDtcbiAgcmVjdC5sZWZ0ID0gcmVjdC5sZWZ0ICsgZWxlbWVudC5jbGllbnRMZWZ0O1xuICByZWN0LmJvdHRvbSA9IHJlY3QudG9wICsgZWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gIHJlY3QucmlnaHQgPSByZWN0LmxlZnQgKyBlbGVtZW50LmNsaWVudFdpZHRoO1xuICByZWN0LndpZHRoID0gZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgcmVjdC5oZWlnaHQgPSBlbGVtZW50LmNsaWVudEhlaWdodDtcbiAgcmVjdC54ID0gcmVjdC5sZWZ0O1xuICByZWN0LnkgPSByZWN0LnRvcDtcbiAgcmV0dXJuIHJlY3Q7XG59XG5cbmZ1bmN0aW9uIGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGNsaXBwaW5nUGFyZW50LCBzdHJhdGVneSkge1xuICByZXR1cm4gY2xpcHBpbmdQYXJlbnQgPT09IHZpZXdwb3J0ID8gcmVjdFRvQ2xpZW50UmVjdChnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpKSA6IGlzRWxlbWVudChjbGlwcGluZ1BhcmVudCkgPyBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChjbGlwcGluZ1BhcmVudCwgc3RyYXRlZ3kpIDogcmVjdFRvQ2xpZW50UmVjdChnZXREb2N1bWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKSk7XG59IC8vIEEgXCJjbGlwcGluZyBwYXJlbnRcIiBpcyBhbiBvdmVyZmxvd2FibGUgY29udGFpbmVyIHdpdGggdGhlIGNoYXJhY3RlcmlzdGljIG9mXG4vLyBjbGlwcGluZyAob3IgaGlkaW5nKSBvdmVyZmxvd2luZyBlbGVtZW50cyB3aXRoIGEgcG9zaXRpb24gZGlmZmVyZW50IGZyb21cbi8vIGBpbml0aWFsYFxuXG5cbmZ1bmN0aW9uIGdldENsaXBwaW5nUGFyZW50cyhlbGVtZW50KSB7XG4gIHZhciBjbGlwcGluZ1BhcmVudHMgPSBsaXN0U2Nyb2xsUGFyZW50cyhnZXRQYXJlbnROb2RlKGVsZW1lbnQpKTtcbiAgdmFyIGNhbkVzY2FwZUNsaXBwaW5nID0gWydhYnNvbHV0ZScsICdmaXhlZCddLmluZGV4T2YoZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbikgPj0gMDtcbiAgdmFyIGNsaXBwZXJFbGVtZW50ID0gY2FuRXNjYXBlQ2xpcHBpbmcgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSA/IGdldE9mZnNldFBhcmVudChlbGVtZW50KSA6IGVsZW1lbnQ7XG5cbiAgaWYgKCFpc0VsZW1lbnQoY2xpcHBlckVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8xNDE0XG5cblxuICByZXR1cm4gY2xpcHBpbmdQYXJlbnRzLmZpbHRlcihmdW5jdGlvbiAoY2xpcHBpbmdQYXJlbnQpIHtcbiAgICByZXR1cm4gaXNFbGVtZW50KGNsaXBwaW5nUGFyZW50KSAmJiBjb250YWlucyhjbGlwcGluZ1BhcmVudCwgY2xpcHBlckVsZW1lbnQpICYmIGdldE5vZGVOYW1lKGNsaXBwaW5nUGFyZW50KSAhPT0gJ2JvZHknO1xuICB9KTtcbn0gLy8gR2V0cyB0aGUgbWF4aW11bSBhcmVhIHRoYXQgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBpbiBkdWUgdG8gYW55IG51bWJlciBvZlxuLy8gY2xpcHBpbmcgcGFyZW50c1xuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENsaXBwaW5nUmVjdChlbGVtZW50LCBib3VuZGFyeSwgcm9vdEJvdW5kYXJ5LCBzdHJhdGVneSkge1xuICB2YXIgbWFpbkNsaXBwaW5nUGFyZW50cyA9IGJvdW5kYXJ5ID09PSAnY2xpcHBpbmdQYXJlbnRzJyA/IGdldENsaXBwaW5nUGFyZW50cyhlbGVtZW50KSA6IFtdLmNvbmNhdChib3VuZGFyeSk7XG4gIHZhciBjbGlwcGluZ1BhcmVudHMgPSBbXS5jb25jYXQobWFpbkNsaXBwaW5nUGFyZW50cywgW3Jvb3RCb3VuZGFyeV0pO1xuICB2YXIgZmlyc3RDbGlwcGluZ1BhcmVudCA9IGNsaXBwaW5nUGFyZW50c1swXTtcbiAgdmFyIGNsaXBwaW5nUmVjdCA9IGNsaXBwaW5nUGFyZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjY1JlY3QsIGNsaXBwaW5nUGFyZW50KSB7XG4gICAgdmFyIHJlY3QgPSBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBjbGlwcGluZ1BhcmVudCwgc3RyYXRlZ3kpO1xuICAgIGFjY1JlY3QudG9wID0gbWF4KHJlY3QudG9wLCBhY2NSZWN0LnRvcCk7XG4gICAgYWNjUmVjdC5yaWdodCA9IG1pbihyZWN0LnJpZ2h0LCBhY2NSZWN0LnJpZ2h0KTtcbiAgICBhY2NSZWN0LmJvdHRvbSA9IG1pbihyZWN0LmJvdHRvbSwgYWNjUmVjdC5ib3R0b20pO1xuICAgIGFjY1JlY3QubGVmdCA9IG1heChyZWN0LmxlZnQsIGFjY1JlY3QubGVmdCk7XG4gICAgcmV0dXJuIGFjY1JlY3Q7XG4gIH0sIGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGZpcnN0Q2xpcHBpbmdQYXJlbnQsIHN0cmF0ZWd5KSk7XG4gIGNsaXBwaW5nUmVjdC53aWR0aCA9IGNsaXBwaW5nUmVjdC5yaWdodCAtIGNsaXBwaW5nUmVjdC5sZWZ0O1xuICBjbGlwcGluZ1JlY3QuaGVpZ2h0ID0gY2xpcHBpbmdSZWN0LmJvdHRvbSAtIGNsaXBwaW5nUmVjdC50b3A7XG4gIGNsaXBwaW5nUmVjdC54ID0gY2xpcHBpbmdSZWN0LmxlZnQ7XG4gIGNsaXBwaW5nUmVjdC55ID0gY2xpcHBpbmdSZWN0LnRvcDtcbiAgcmV0dXJuIGNsaXBwaW5nUmVjdDtcbn0iLCJpbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IGdldE5vZGVTY3JvbGwgZnJvbSBcIi4vZ2V0Tm9kZVNjcm9sbC5qc1wiO1xuaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbEJhclggZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsQmFyWC5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBpc1Njcm9sbFBhcmVudCBmcm9tIFwiLi9pc1Njcm9sbFBhcmVudC5qc1wiO1xuaW1wb3J0IHsgcm91bmQgfSBmcm9tIFwiLi4vdXRpbHMvbWF0aC5qc1wiO1xuXG5mdW5jdGlvbiBpc0VsZW1lbnRTY2FsZWQoZWxlbWVudCkge1xuICB2YXIgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciBzY2FsZVggPSByb3VuZChyZWN0LndpZHRoKSAvIGVsZW1lbnQub2Zmc2V0V2lkdGggfHwgMTtcbiAgdmFyIHNjYWxlWSA9IHJvdW5kKHJlY3QuaGVpZ2h0KSAvIGVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IDE7XG4gIHJldHVybiBzY2FsZVggIT09IDEgfHwgc2NhbGVZICE9PSAxO1xufSAvLyBSZXR1cm5zIHRoZSBjb21wb3NpdGUgcmVjdCBvZiBhbiBlbGVtZW50IHJlbGF0aXZlIHRvIGl0cyBvZmZzZXRQYXJlbnQuXG4vLyBDb21wb3NpdGUgbWVhbnMgaXQgdGFrZXMgaW50byBhY2NvdW50IHRyYW5zZm9ybXMgYXMgd2VsbCBhcyBsYXlvdXQuXG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Q29tcG9zaXRlUmVjdChlbGVtZW50T3JWaXJ0dWFsRWxlbWVudCwgb2Zmc2V0UGFyZW50LCBpc0ZpeGVkKSB7XG4gIGlmIChpc0ZpeGVkID09PSB2b2lkIDApIHtcbiAgICBpc0ZpeGVkID0gZmFsc2U7XG4gIH1cblxuICB2YXIgaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgPSBpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIHZhciBvZmZzZXRQYXJlbnRJc1NjYWxlZCA9IGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KSAmJiBpc0VsZW1lbnRTY2FsZWQob2Zmc2V0UGFyZW50KTtcbiAgdmFyIGRvY3VtZW50RWxlbWVudCA9IGdldERvY3VtZW50RWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICB2YXIgcmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50T3JWaXJ0dWFsRWxlbWVudCwgb2Zmc2V0UGFyZW50SXNTY2FsZWQsIGlzRml4ZWQpO1xuICB2YXIgc2Nyb2xsID0ge1xuICAgIHNjcm9sbExlZnQ6IDAsXG4gICAgc2Nyb2xsVG9wOiAwXG4gIH07XG4gIHZhciBvZmZzZXRzID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuXG4gIGlmIChpc09mZnNldFBhcmVudEFuRWxlbWVudCB8fCAhaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgJiYgIWlzRml4ZWQpIHtcbiAgICBpZiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSAhPT0gJ2JvZHknIHx8IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvMTA3OFxuICAgIGlzU2Nyb2xsUGFyZW50KGRvY3VtZW50RWxlbWVudCkpIHtcbiAgICAgIHNjcm9sbCA9IGdldE5vZGVTY3JvbGwob2Zmc2V0UGFyZW50KTtcbiAgICB9XG5cbiAgICBpZiAoaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICBvZmZzZXRzID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCwgdHJ1ZSk7XG4gICAgICBvZmZzZXRzLnggKz0gb2Zmc2V0UGFyZW50LmNsaWVudExlZnQ7XG4gICAgICBvZmZzZXRzLnkgKz0gb2Zmc2V0UGFyZW50LmNsaWVudFRvcDtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50RWxlbWVudCkge1xuICAgICAgb2Zmc2V0cy54ID0gZ2V0V2luZG93U2Nyb2xsQmFyWChkb2N1bWVudEVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogcmVjdC5sZWZ0ICsgc2Nyb2xsLnNjcm9sbExlZnQgLSBvZmZzZXRzLngsXG4gICAgeTogcmVjdC50b3AgKyBzY3JvbGwuc2Nyb2xsVG9wIC0gb2Zmc2V0cy55LFxuICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgIGhlaWdodDogcmVjdC5oZWlnaHRcbiAgfTtcbn0iLCJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSB7XG4gIHJldHVybiBnZXRXaW5kb3coZWxlbWVudCkuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbn0iLCJpbXBvcnQgeyBpc0VsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkge1xuICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBhc3N1bWUgYm9keSBpcyBhbHdheXMgYXZhaWxhYmxlXG4gIHJldHVybiAoKGlzRWxlbWVudChlbGVtZW50KSA/IGVsZW1lbnQub3duZXJEb2N1bWVudCA6IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICBlbGVtZW50LmRvY3VtZW50KSB8fCB3aW5kb3cuZG9jdW1lbnQpLmRvY3VtZW50RWxlbWVudDtcbn0iLCJpbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbEJhclggZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsQmFyWC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGwuanNcIjtcbmltcG9ydCB7IG1heCB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7IC8vIEdldHMgdGhlIGVudGlyZSBzaXplIG9mIHRoZSBzY3JvbGxhYmxlIGRvY3VtZW50IGFyZWEsIGV2ZW4gZXh0ZW5kaW5nIG91dHNpZGVcbi8vIG9mIHRoZSBgPGh0bWw+YCBhbmQgYDxib2R5PmAgcmVjdCBib3VuZHMgaWYgaG9yaXpvbnRhbGx5IHNjcm9sbGFibGVcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0RG9jdW1lbnRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIF9lbGVtZW50JG93bmVyRG9jdW1lbjtcblxuICB2YXIgaHRtbCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcbiAgdmFyIHdpblNjcm9sbCA9IGdldFdpbmRvd1Njcm9sbChlbGVtZW50KTtcbiAgdmFyIGJvZHkgPSAoX2VsZW1lbnQkb3duZXJEb2N1bWVuID0gZWxlbWVudC5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2VsZW1lbnQkb3duZXJEb2N1bWVuLmJvZHk7XG4gIHZhciB3aWR0aCA9IG1heChodG1sLnNjcm9sbFdpZHRoLCBodG1sLmNsaWVudFdpZHRoLCBib2R5ID8gYm9keS5zY3JvbGxXaWR0aCA6IDAsIGJvZHkgPyBib2R5LmNsaWVudFdpZHRoIDogMCk7XG4gIHZhciBoZWlnaHQgPSBtYXgoaHRtbC5zY3JvbGxIZWlnaHQsIGh0bWwuY2xpZW50SGVpZ2h0LCBib2R5ID8gYm9keS5zY3JvbGxIZWlnaHQgOiAwLCBib2R5ID8gYm9keS5jbGllbnRIZWlnaHQgOiAwKTtcbiAgdmFyIHggPSAtd2luU2Nyb2xsLnNjcm9sbExlZnQgKyBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpO1xuICB2YXIgeSA9IC13aW5TY3JvbGwuc2Nyb2xsVG9wO1xuXG4gIGlmIChnZXRDb21wdXRlZFN0eWxlKGJvZHkgfHwgaHRtbCkuZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgIHggKz0gbWF4KGh0bWwuY2xpZW50V2lkdGgsIGJvZHkgPyBib2R5LmNsaWVudFdpZHRoIDogMCkgLSB3aWR0aDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEhUTUxFbGVtZW50U2Nyb2xsKGVsZW1lbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBlbGVtZW50LnNjcm9sbExlZnQsXG4gICAgc2Nyb2xsVG9wOiBlbGVtZW50LnNjcm9sbFRvcFxuICB9O1xufSIsImltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4vZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI7IC8vIFJldHVybnMgdGhlIGxheW91dCByZWN0IG9mIGFuIGVsZW1lbnQgcmVsYXRpdmUgdG8gaXRzIG9mZnNldFBhcmVudC4gTGF5b3V0XG4vLyBtZWFucyBpdCBkb2Vzbid0IHRha2UgaW50byBhY2NvdW50IHRyYW5zZm9ybXMuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldExheW91dFJlY3QoZWxlbWVudCkge1xuICB2YXIgY2xpZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50KTsgLy8gVXNlIHRoZSBjbGllbnRSZWN0IHNpemVzIGlmIGl0J3Mgbm90IGJlZW4gdHJhbnNmb3JtZWQuXG4gIC8vIEZpeGVzIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvMTIyM1xuXG4gIHZhciB3aWR0aCA9IGVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gIHZhciBoZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcblxuICBpZiAoTWF0aC5hYnMoY2xpZW50UmVjdC53aWR0aCAtIHdpZHRoKSA8PSAxKSB7XG4gICAgd2lkdGggPSBjbGllbnRSZWN0LndpZHRoO1xuICB9XG5cbiAgaWYgKE1hdGguYWJzKGNsaWVudFJlY3QuaGVpZ2h0IC0gaGVpZ2h0KSA8PSAxKSB7XG4gICAgaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IGVsZW1lbnQub2Zmc2V0TGVmdCxcbiAgICB5OiBlbGVtZW50Lm9mZnNldFRvcCxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHRcbiAgfTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXROb2RlTmFtZShlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50ID8gKGVsZW1lbnQubm9kZU5hbWUgfHwgJycpLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xufSIsImltcG9ydCBnZXRXaW5kb3dTY3JvbGwgZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCBnZXRIVE1MRWxlbWVudFNjcm9sbCBmcm9tIFwiLi9nZXRIVE1MRWxlbWVudFNjcm9sbC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Tm9kZVNjcm9sbChub2RlKSB7XG4gIGlmIChub2RlID09PSBnZXRXaW5kb3cobm9kZSkgfHwgIWlzSFRNTEVsZW1lbnQobm9kZSkpIHtcbiAgICByZXR1cm4gZ2V0V2luZG93U2Nyb2xsKG5vZGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZXRIVE1MRWxlbWVudFNjcm9sbChub2RlKTtcbiAgfVxufSIsImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gXCIuL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQsIGlzU2hhZG93Um9vdCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCBpc1RhYmxlRWxlbWVudCBmcm9tIFwiLi9pc1RhYmxlRWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldFBhcmVudE5vZGUgZnJvbSBcIi4vZ2V0UGFyZW50Tm9kZS5qc1wiO1xuaW1wb3J0IGdldFVBU3RyaW5nIGZyb20gXCIuLi91dGlscy91c2VyQWdlbnQuanNcIjtcblxuZnVuY3Rpb24gZ2V0VHJ1ZU9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAvLyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzgzN1xuICBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudC5vZmZzZXRQYXJlbnQ7XG59IC8vIGAub2Zmc2V0UGFyZW50YCByZXBvcnRzIGBudWxsYCBmb3IgZml4ZWQgZWxlbWVudHMsIHdoaWxlIGFic29sdXRlIGVsZW1lbnRzXG4vLyByZXR1cm4gdGhlIGNvbnRhaW5pbmcgYmxvY2tcblxuXG5mdW5jdGlvbiBnZXRDb250YWluaW5nQmxvY2soZWxlbWVudCkge1xuICB2YXIgaXNGaXJlZm94ID0gL2ZpcmVmb3gvaS50ZXN0KGdldFVBU3RyaW5nKCkpO1xuICB2YXIgaXNJRSA9IC9UcmlkZW50L2kudGVzdChnZXRVQVN0cmluZygpKTtcblxuICBpZiAoaXNJRSAmJiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgLy8gSW4gSUUgOSwgMTAgYW5kIDExIGZpeGVkIGVsZW1lbnRzIGNvbnRhaW5pbmcgYmxvY2sgaXMgYWx3YXlzIGVzdGFibGlzaGVkIGJ5IHRoZSB2aWV3cG9ydFxuICAgIHZhciBlbGVtZW50Q3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcblxuICAgIGlmIChlbGVtZW50Q3NzLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICB2YXIgY3VycmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuXG4gIGlmIChpc1NoYWRvd1Jvb3QoY3VycmVudE5vZGUpKSB7XG4gICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5ob3N0O1xuICB9XG5cbiAgd2hpbGUgKGlzSFRNTEVsZW1lbnQoY3VycmVudE5vZGUpICYmIFsnaHRtbCcsICdib2R5J10uaW5kZXhPZihnZXROb2RlTmFtZShjdXJyZW50Tm9kZSkpIDwgMCkge1xuICAgIHZhciBjc3MgPSBnZXRDb21wdXRlZFN0eWxlKGN1cnJlbnROb2RlKTsgLy8gVGhpcyBpcyBub24tZXhoYXVzdGl2ZSBidXQgY292ZXJzIHRoZSBtb3N0IGNvbW1vbiBDU1MgcHJvcGVydGllcyB0aGF0XG4gICAgLy8gY3JlYXRlIGEgY29udGFpbmluZyBibG9jay5cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQ29udGFpbmluZ19ibG9jayNpZGVudGlmeWluZ190aGVfY29udGFpbmluZ19ibG9ja1xuXG4gICAgaWYgKGNzcy50cmFuc2Zvcm0gIT09ICdub25lJyB8fCBjc3MucGVyc3BlY3RpdmUgIT09ICdub25lJyB8fCBjc3MuY29udGFpbiA9PT0gJ3BhaW50JyB8fCBbJ3RyYW5zZm9ybScsICdwZXJzcGVjdGl2ZSddLmluZGV4T2YoY3NzLndpbGxDaGFuZ2UpICE9PSAtMSB8fCBpc0ZpcmVmb3ggJiYgY3NzLndpbGxDaGFuZ2UgPT09ICdmaWx0ZXInIHx8IGlzRmlyZWZveCAmJiBjc3MuZmlsdGVyICYmIGNzcy5maWx0ZXIgIT09ICdub25lJykge1xuICAgICAgcmV0dXJuIGN1cnJlbnROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59IC8vIEdldHMgdGhlIGNsb3Nlc3QgYW5jZXN0b3IgcG9zaXRpb25lZCBlbGVtZW50LiBIYW5kbGVzIHNvbWUgZWRnZSBjYXNlcyxcbi8vIHN1Y2ggYXMgdGFibGUgYW5jZXN0b3JzIGFuZCBjcm9zcyBicm93c2VyIGJ1Z3MuXG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgdmFyIHdpbmRvdyA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgdmFyIG9mZnNldFBhcmVudCA9IGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudCk7XG5cbiAgd2hpbGUgKG9mZnNldFBhcmVudCAmJiBpc1RhYmxlRWxlbWVudChvZmZzZXRQYXJlbnQpICYmIGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcbiAgICBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KG9mZnNldFBhcmVudCk7XG4gIH1cblxuICBpZiAob2Zmc2V0UGFyZW50ICYmIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpID09PSAnaHRtbCcgfHwgZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSA9PT0gJ2JvZHknICYmIGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHx8IHdpbmRvdztcbn0iLCJpbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgeyBpc1NoYWRvd1Jvb3QgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRQYXJlbnROb2RlKGVsZW1lbnQpIHtcbiAgaWYgKGdldE5vZGVOYW1lKGVsZW1lbnQpID09PSAnaHRtbCcpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHJldHVybiAoLy8gdGhpcyBpcyBhIHF1aWNrZXIgKGJ1dCBsZXNzIHR5cGUgc2FmZSkgd2F5IHRvIHNhdmUgcXVpdGUgc29tZSBieXRlcyBmcm9tIHRoZSBidW5kbGVcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG4gICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgZWxlbWVudC5hc3NpZ25lZFNsb3QgfHwgLy8gc3RlcCBpbnRvIHRoZSBzaGFkb3cgRE9NIG9mIHRoZSBwYXJlbnQgb2YgYSBzbG90dGVkIG5vZGVcbiAgICBlbGVtZW50LnBhcmVudE5vZGUgfHwgKCAvLyBET00gRWxlbWVudCBkZXRlY3RlZFxuICAgIGlzU2hhZG93Um9vdChlbGVtZW50KSA/IGVsZW1lbnQuaG9zdCA6IG51bGwpIHx8IC8vIFNoYWRvd1Jvb3QgZGV0ZWN0ZWRcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogSFRNTEVsZW1lbnQgaXMgYSBOb2RlXG4gICAgZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpIC8vIGZhbGxiYWNrXG5cbiAgKTtcbn0iLCJpbXBvcnQgZ2V0UGFyZW50Tm9kZSBmcm9tIFwiLi9nZXRQYXJlbnROb2RlLmpzXCI7XG5pbXBvcnQgaXNTY3JvbGxQYXJlbnQgZnJvbSBcIi4vaXNTY3JvbGxQYXJlbnQuanNcIjtcbmltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFNjcm9sbFBhcmVudChub2RlKSB7XG4gIGlmIChbJ2h0bWwnLCAnYm9keScsICcjZG9jdW1lbnQnXS5pbmRleE9mKGdldE5vZGVOYW1lKG5vZGUpKSA+PSAwKSB7XG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXTogYXNzdW1lIGJvZHkgaXMgYWx3YXlzIGF2YWlsYWJsZVxuICAgIHJldHVybiBub2RlLm93bmVyRG9jdW1lbnQuYm9keTtcbiAgfVxuXG4gIGlmIChpc0hUTUxFbGVtZW50KG5vZGUpICYmIGlzU2Nyb2xsUGFyZW50KG5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICByZXR1cm4gZ2V0U2Nyb2xsUGFyZW50KGdldFBhcmVudE5vZGUobm9kZSkpO1xufSIsImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbEJhclggZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsQmFyWC5qc1wiO1xuaW1wb3J0IGlzTGF5b3V0Vmlld3BvcnQgZnJvbSBcIi4vaXNMYXlvdXRWaWV3cG9ydC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSB7XG4gIHZhciB3aW4gPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIHZhciBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICB2YXIgdmlzdWFsVmlld3BvcnQgPSB3aW4udmlzdWFsVmlld3BvcnQ7XG4gIHZhciB3aWR0aCA9IGh0bWwuY2xpZW50V2lkdGg7XG4gIHZhciBoZWlnaHQgPSBodG1sLmNsaWVudEhlaWdodDtcbiAgdmFyIHggPSAwO1xuICB2YXIgeSA9IDA7XG5cbiAgaWYgKHZpc3VhbFZpZXdwb3J0KSB7XG4gICAgd2lkdGggPSB2aXN1YWxWaWV3cG9ydC53aWR0aDtcbiAgICBoZWlnaHQgPSB2aXN1YWxWaWV3cG9ydC5oZWlnaHQ7XG4gICAgdmFyIGxheW91dFZpZXdwb3J0ID0gaXNMYXlvdXRWaWV3cG9ydCgpO1xuXG4gICAgaWYgKGxheW91dFZpZXdwb3J0IHx8ICFsYXlvdXRWaWV3cG9ydCAmJiBzdHJhdGVneSA9PT0gJ2ZpeGVkJykge1xuICAgICAgeCA9IHZpc3VhbFZpZXdwb3J0Lm9mZnNldExlZnQ7XG4gICAgICB5ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHg6IHggKyBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpLFxuICAgIHk6IHlcbiAgfTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRXaW5kb3cobm9kZSkge1xuICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuXG4gIGlmIChub2RlLnRvU3RyaW5nKCkgIT09ICdbb2JqZWN0IFdpbmRvd10nKSB7XG4gICAgdmFyIG93bmVyRG9jdW1lbnQgPSBub2RlLm93bmVyRG9jdW1lbnQ7XG4gICAgcmV0dXJuIG93bmVyRG9jdW1lbnQgPyBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdyA6IHdpbmRvdztcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufSIsImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGwobm9kZSkge1xuICB2YXIgd2luID0gZ2V0V2luZG93KG5vZGUpO1xuICB2YXIgc2Nyb2xsTGVmdCA9IHdpbi5wYWdlWE9mZnNldDtcbiAgdmFyIHNjcm9sbFRvcCA9IHdpbi5wYWdlWU9mZnNldDtcbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBzY3JvbGxMZWZ0LFxuICAgIHNjcm9sbFRvcDogc2Nyb2xsVG9wXG4gIH07XG59IiwiaW1wb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmcm9tIFwiLi9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50KSB7XG4gIC8vIElmIDxodG1sPiBoYXMgYSBDU1Mgd2lkdGggZ3JlYXRlciB0aGFuIHRoZSB2aWV3cG9ydCwgdGhlbiB0aGlzIHdpbGwgYmVcbiAgLy8gaW5jb3JyZWN0IGZvciBSVEwuXG4gIC8vIFBvcHBlciAxIGlzIGJyb2tlbiBpbiB0aGlzIGNhc2UgYW5kIG5ldmVyIGhhZCBhIGJ1ZyByZXBvcnQgc28gbGV0J3MgYXNzdW1lXG4gIC8vIGl0J3Mgbm90IGFuIGlzc3VlLiBJIGRvbid0IHRoaW5rIGFueW9uZSBldmVyIHNwZWNpZmllcyB3aWR0aCBvbiA8aHRtbD5cbiAgLy8gYW55d2F5LlxuICAvLyBCcm93c2VycyB3aGVyZSB0aGUgbGVmdCBzY3JvbGxiYXIgZG9lc24ndCBjYXVzZSBhbiBpc3N1ZSByZXBvcnQgYDBgIGZvclxuICAvLyB0aGlzIChlLmcuIEVkZ2UgMjAxOSwgSUUxMSwgU2FmYXJpKVxuICByZXR1cm4gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSkubGVmdCArIGdldFdpbmRvd1Njcm9sbChlbGVtZW50KS5zY3JvbGxMZWZ0O1xufSIsImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5cbmZ1bmN0aW9uIGlzRWxlbWVudChub2RlKSB7XG4gIHZhciBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLkVsZW1lbnQ7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gaXNIVE1MRWxlbWVudChub2RlKSB7XG4gIHZhciBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLkhUTUxFbGVtZW50O1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBpc1NoYWRvd1Jvb3Qobm9kZSkge1xuICAvLyBJRSAxMSBoYXMgbm8gU2hhZG93Um9vdFxuICBpZiAodHlwZW9mIFNoYWRvd1Jvb3QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIE93bkVsZW1lbnQgPSBnZXRXaW5kb3cobm9kZSkuU2hhZG93Um9vdDtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBTaGFkb3dSb290O1xufVxuXG5leHBvcnQgeyBpc0VsZW1lbnQsIGlzSFRNTEVsZW1lbnQsIGlzU2hhZG93Um9vdCB9OyIsImltcG9ydCBnZXRVQVN0cmluZyBmcm9tIFwiLi4vdXRpbHMvdXNlckFnZW50LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc0xheW91dFZpZXdwb3J0KCkge1xuICByZXR1cm4gIS9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QoZ2V0VUFTdHJpbmcoKSk7XG59IiwiaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNTY3JvbGxQYXJlbnQoZWxlbWVudCkge1xuICAvLyBGaXJlZm94IHdhbnRzIHVzIHRvIGNoZWNrIGAteGAgYW5kIGAteWAgdmFyaWF0aW9ucyBhcyB3ZWxsXG4gIHZhciBfZ2V0Q29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCksXG4gICAgICBvdmVyZmxvdyA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93LFxuICAgICAgb3ZlcmZsb3dYID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3dYLFxuICAgICAgb3ZlcmZsb3dZID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3dZO1xuXG4gIHJldHVybiAvYXV0b3xzY3JvbGx8b3ZlcmxheXxoaWRkZW4vLnRlc3Qob3ZlcmZsb3cgKyBvdmVyZmxvd1kgKyBvdmVyZmxvd1gpO1xufSIsImltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNUYWJsZUVsZW1lbnQoZWxlbWVudCkge1xuICByZXR1cm4gWyd0YWJsZScsICd0ZCcsICd0aCddLmluZGV4T2YoZ2V0Tm9kZU5hbWUoZWxlbWVudCkpID49IDA7XG59IiwiaW1wb3J0IGdldFNjcm9sbFBhcmVudCBmcm9tIFwiLi9nZXRTY3JvbGxQYXJlbnQuanNcIjtcbmltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gXCIuL2dldFBhcmVudE5vZGUuanNcIjtcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgaXNTY3JvbGxQYXJlbnQgZnJvbSBcIi4vaXNTY3JvbGxQYXJlbnQuanNcIjtcbi8qXG5naXZlbiBhIERPTSBlbGVtZW50LCByZXR1cm4gdGhlIGxpc3Qgb2YgYWxsIHNjcm9sbCBwYXJlbnRzLCB1cCB0aGUgbGlzdCBvZiBhbmNlc29yc1xudW50aWwgd2UgZ2V0IHRvIHRoZSB0b3Agd2luZG93IG9iamVjdC4gVGhpcyBsaXN0IGlzIHdoYXQgd2UgYXR0YWNoIHNjcm9sbCBsaXN0ZW5lcnNcbnRvLCBiZWNhdXNlIGlmIGFueSBvZiB0aGVzZSBwYXJlbnQgZWxlbWVudHMgc2Nyb2xsLCB3ZSdsbCBuZWVkIHRvIHJlLWNhbGN1bGF0ZSB0aGVcbnJlZmVyZW5jZSBlbGVtZW50J3MgcG9zaXRpb24uXG4qL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsaXN0U2Nyb2xsUGFyZW50cyhlbGVtZW50LCBsaXN0KSB7XG4gIHZhciBfZWxlbWVudCRvd25lckRvY3VtZW47XG5cbiAgaWYgKGxpc3QgPT09IHZvaWQgMCkge1xuICAgIGxpc3QgPSBbXTtcbiAgfVxuXG4gIHZhciBzY3JvbGxQYXJlbnQgPSBnZXRTY3JvbGxQYXJlbnQoZWxlbWVudCk7XG4gIHZhciBpc0JvZHkgPSBzY3JvbGxQYXJlbnQgPT09ICgoX2VsZW1lbnQkb3duZXJEb2N1bWVuID0gZWxlbWVudC5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2VsZW1lbnQkb3duZXJEb2N1bWVuLmJvZHkpO1xuICB2YXIgd2luID0gZ2V0V2luZG93KHNjcm9sbFBhcmVudCk7XG4gIHZhciB0YXJnZXQgPSBpc0JvZHkgPyBbd2luXS5jb25jYXQod2luLnZpc3VhbFZpZXdwb3J0IHx8IFtdLCBpc1Njcm9sbFBhcmVudChzY3JvbGxQYXJlbnQpID8gc2Nyb2xsUGFyZW50IDogW10pIDogc2Nyb2xsUGFyZW50O1xuICB2YXIgdXBkYXRlZExpc3QgPSBsaXN0LmNvbmNhdCh0YXJnZXQpO1xuICByZXR1cm4gaXNCb2R5ID8gdXBkYXRlZExpc3QgOiAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogaXNCb2R5IHRlbGxzIHVzIHRhcmdldCB3aWxsIGJlIGFuIEhUTUxFbGVtZW50IGhlcmVcbiAgdXBkYXRlZExpc3QuY29uY2F0KGxpc3RTY3JvbGxQYXJlbnRzKGdldFBhcmVudE5vZGUodGFyZ2V0KSkpO1xufSIsImV4cG9ydCB2YXIgdG9wID0gJ3RvcCc7XG5leHBvcnQgdmFyIGJvdHRvbSA9ICdib3R0b20nO1xuZXhwb3J0IHZhciByaWdodCA9ICdyaWdodCc7XG5leHBvcnQgdmFyIGxlZnQgPSAnbGVmdCc7XG5leHBvcnQgdmFyIGF1dG8gPSAnYXV0byc7XG5leHBvcnQgdmFyIGJhc2VQbGFjZW1lbnRzID0gW3RvcCwgYm90dG9tLCByaWdodCwgbGVmdF07XG5leHBvcnQgdmFyIHN0YXJ0ID0gJ3N0YXJ0JztcbmV4cG9ydCB2YXIgZW5kID0gJ2VuZCc7XG5leHBvcnQgdmFyIGNsaXBwaW5nUGFyZW50cyA9ICdjbGlwcGluZ1BhcmVudHMnO1xuZXhwb3J0IHZhciB2aWV3cG9ydCA9ICd2aWV3cG9ydCc7XG5leHBvcnQgdmFyIHBvcHBlciA9ICdwb3BwZXInO1xuZXhwb3J0IHZhciByZWZlcmVuY2UgPSAncmVmZXJlbmNlJztcbmV4cG9ydCB2YXIgdmFyaWF0aW9uUGxhY2VtZW50cyA9IC8qI19fUFVSRV9fKi9iYXNlUGxhY2VtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gIHJldHVybiBhY2MuY29uY2F0KFtwbGFjZW1lbnQgKyBcIi1cIiArIHN0YXJ0LCBwbGFjZW1lbnQgKyBcIi1cIiArIGVuZF0pO1xufSwgW10pO1xuZXhwb3J0IHZhciBwbGFjZW1lbnRzID0gLyojX19QVVJFX18qL1tdLmNvbmNhdChiYXNlUGxhY2VtZW50cywgW2F1dG9dKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gIHJldHVybiBhY2MuY29uY2F0KFtwbGFjZW1lbnQsIHBsYWNlbWVudCArIFwiLVwiICsgc3RhcnQsIHBsYWNlbWVudCArIFwiLVwiICsgZW5kXSk7XG59LCBbXSk7IC8vIG1vZGlmaWVycyB0aGF0IG5lZWQgdG8gcmVhZCB0aGUgRE9NXG5cbmV4cG9ydCB2YXIgYmVmb3JlUmVhZCA9ICdiZWZvcmVSZWFkJztcbmV4cG9ydCB2YXIgcmVhZCA9ICdyZWFkJztcbmV4cG9ydCB2YXIgYWZ0ZXJSZWFkID0gJ2FmdGVyUmVhZCc7IC8vIHB1cmUtbG9naWMgbW9kaWZpZXJzXG5cbmV4cG9ydCB2YXIgYmVmb3JlTWFpbiA9ICdiZWZvcmVNYWluJztcbmV4cG9ydCB2YXIgbWFpbiA9ICdtYWluJztcbmV4cG9ydCB2YXIgYWZ0ZXJNYWluID0gJ2FmdGVyTWFpbic7IC8vIG1vZGlmaWVyIHdpdGggdGhlIHB1cnBvc2UgdG8gd3JpdGUgdG8gdGhlIERPTSAob3Igd3JpdGUgaW50byBhIGZyYW1ld29yayBzdGF0ZSlcblxuZXhwb3J0IHZhciBiZWZvcmVXcml0ZSA9ICdiZWZvcmVXcml0ZSc7XG5leHBvcnQgdmFyIHdyaXRlID0gJ3dyaXRlJztcbmV4cG9ydCB2YXIgYWZ0ZXJXcml0ZSA9ICdhZnRlcldyaXRlJztcbmV4cG9ydCB2YXIgbW9kaWZpZXJQaGFzZXMgPSBbYmVmb3JlUmVhZCwgcmVhZCwgYWZ0ZXJSZWFkLCBiZWZvcmVNYWluLCBtYWluLCBhZnRlck1haW4sIGJlZm9yZVdyaXRlLCB3cml0ZSwgYWZ0ZXJXcml0ZV07IiwiZXhwb3J0ICogZnJvbSBcIi4vZW51bXMuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL21vZGlmaWVycy9pbmRleC5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCB7IHBvcHBlckdlbmVyYXRvciwgZGV0ZWN0T3ZlcmZsb3csIGNyZWF0ZVBvcHBlciBhcyBjcmVhdGVQb3BwZXJCYXNlIH0gZnJvbSBcIi4vY3JlYXRlUG9wcGVyLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IHsgY3JlYXRlUG9wcGVyIH0gZnJvbSBcIi4vcG9wcGVyLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IHsgY3JlYXRlUG9wcGVyIGFzIGNyZWF0ZVBvcHBlckxpdGUgfSBmcm9tIFwiLi9wb3BwZXItbGl0ZS5qc1wiOyIsImltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4uL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzXCI7IC8vIFRoaXMgbW9kaWZpZXIgdGFrZXMgdGhlIHN0eWxlcyBwcmVwYXJlZCBieSB0aGUgYGNvbXB1dGVTdHlsZXNgIG1vZGlmaWVyXG4vLyBhbmQgYXBwbGllcyB0aGVtIHRvIHRoZSBIVE1MRWxlbWVudHMgc3VjaCBhcyBwb3BwZXIgYW5kIGFycm93XG5cbmZ1bmN0aW9uIGFwcGx5U3R5bGVzKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZTtcbiAgT2JqZWN0LmtleXMoc3RhdGUuZWxlbWVudHMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgc3R5bGUgPSBzdGF0ZS5zdHlsZXNbbmFtZV0gfHwge307XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBzdGF0ZS5hdHRyaWJ1dGVzW25hbWVdIHx8IHt9O1xuICAgIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudHNbbmFtZV07IC8vIGFycm93IGlzIG9wdGlvbmFsICsgdmlydHVhbCBlbGVtZW50c1xuXG4gICAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8ICFnZXROb2RlTmFtZShlbGVtZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gRmxvdyBkb2Vzbid0IHN1cHBvcnQgdG8gZXh0ZW5kIHRoaXMgcHJvcGVydHksIGJ1dCBpdCdzIHRoZSBtb3N0XG4gICAgLy8gZWZmZWN0aXZlIHdheSB0byBhcHBseSBzdHlsZXMgdG8gYW4gSFRNTEVsZW1lbnRcbiAgICAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV1cblxuXG4gICAgT2JqZWN0LmFzc2lnbihlbGVtZW50LnN0eWxlLCBzdHlsZSk7XG4gICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIHZhbHVlID0gYXR0cmlidXRlc1tuYW1lXTtcblxuICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlID09PSB0cnVlID8gJycgOiB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBlZmZlY3QoX3JlZjIpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGU7XG4gIHZhciBpbml0aWFsU3R5bGVzID0ge1xuICAgIHBvcHBlcjoge1xuICAgICAgcG9zaXRpb246IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICBsZWZ0OiAnMCcsXG4gICAgICB0b3A6ICcwJyxcbiAgICAgIG1hcmdpbjogJzAnXG4gICAgfSxcbiAgICBhcnJvdzoge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcbiAgICB9LFxuICAgIHJlZmVyZW5jZToge31cbiAgfTtcbiAgT2JqZWN0LmFzc2lnbihzdGF0ZS5lbGVtZW50cy5wb3BwZXIuc3R5bGUsIGluaXRpYWxTdHlsZXMucG9wcGVyKTtcbiAgc3RhdGUuc3R5bGVzID0gaW5pdGlhbFN0eWxlcztcblxuICBpZiAoc3RhdGUuZWxlbWVudHMuYXJyb3cpIHtcbiAgICBPYmplY3QuYXNzaWduKHN0YXRlLmVsZW1lbnRzLmFycm93LnN0eWxlLCBpbml0aWFsU3R5bGVzLmFycm93KTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgT2JqZWN0LmtleXMoc3RhdGUuZWxlbWVudHMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudHNbbmFtZV07XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IHN0YXRlLmF0dHJpYnV0ZXNbbmFtZV0gfHwge307XG4gICAgICB2YXIgc3R5bGVQcm9wZXJ0aWVzID0gT2JqZWN0LmtleXMoc3RhdGUuc3R5bGVzLmhhc093blByb3BlcnR5KG5hbWUpID8gc3RhdGUuc3R5bGVzW25hbWVdIDogaW5pdGlhbFN0eWxlc1tuYW1lXSk7IC8vIFNldCBhbGwgdmFsdWVzIHRvIGFuIGVtcHR5IHN0cmluZyB0byB1bnNldCB0aGVtXG5cbiAgICAgIHZhciBzdHlsZSA9IHN0eWxlUHJvcGVydGllcy5yZWR1Y2UoZnVuY3Rpb24gKHN0eWxlLCBwcm9wZXJ0eSkge1xuICAgICAgICBzdHlsZVtwcm9wZXJ0eV0gPSAnJztcbiAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgfSwge30pOyAvLyBhcnJvdyBpcyBvcHRpb25hbCArIHZpcnR1YWwgZWxlbWVudHNcblxuICAgICAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8ICFnZXROb2RlTmFtZShlbGVtZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgc3R5bGUpO1xuICAgICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2FwcGx5U3R5bGVzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICd3cml0ZScsXG4gIGZuOiBhcHBseVN0eWxlcyxcbiAgZWZmZWN0OiBlZmZlY3QsXG4gIHJlcXVpcmVzOiBbJ2NvbXB1dGVTdHlsZXMnXVxufTsiLCJpbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldExheW91dFJlY3QgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0LmpzXCI7XG5pbXBvcnQgY29udGFpbnMgZnJvbSBcIi4uL2RvbS11dGlscy9jb250YWlucy5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qc1wiO1xuaW1wb3J0IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgeyB3aXRoaW4gfSBmcm9tIFwiLi4vdXRpbHMvd2l0aGluLmpzXCI7XG5pbXBvcnQgbWVyZ2VQYWRkaW5nT2JqZWN0IGZyb20gXCIuLi91dGlscy9tZXJnZVBhZGRpbmdPYmplY3QuanNcIjtcbmltcG9ydCBleHBhbmRUb0hhc2hNYXAgZnJvbSBcIi4uL3V0aWxzL2V4cGFuZFRvSGFzaE1hcC5qc1wiO1xuaW1wb3J0IHsgbGVmdCwgcmlnaHQsIGJhc2VQbGFjZW1lbnRzLCB0b3AsIGJvdHRvbSB9IGZyb20gXCIuLi9lbnVtcy5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbnZhciB0b1BhZGRpbmdPYmplY3QgPSBmdW5jdGlvbiB0b1BhZGRpbmdPYmplY3QocGFkZGluZywgc3RhdGUpIHtcbiAgcGFkZGluZyA9IHR5cGVvZiBwYWRkaW5nID09PSAnZnVuY3Rpb24nID8gcGFkZGluZyhPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5yZWN0cywge1xuICAgIHBsYWNlbWVudDogc3RhdGUucGxhY2VtZW50XG4gIH0pKSA6IHBhZGRpbmc7XG4gIHJldHVybiBtZXJnZVBhZGRpbmdPYmplY3QodHlwZW9mIHBhZGRpbmcgIT09ICdudW1iZXInID8gcGFkZGluZyA6IGV4cGFuZFRvSGFzaE1hcChwYWRkaW5nLCBiYXNlUGxhY2VtZW50cykpO1xufTtcblxuZnVuY3Rpb24gYXJyb3coX3JlZikge1xuICB2YXIgX3N0YXRlJG1vZGlmaWVyc0RhdGEkO1xuXG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucztcbiAgdmFyIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93O1xuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cztcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHN0YXRlLnBsYWNlbWVudCk7XG4gIHZhciBheGlzID0gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGJhc2VQbGFjZW1lbnQpO1xuICB2YXIgaXNWZXJ0aWNhbCA9IFtsZWZ0LCByaWdodF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwO1xuICB2YXIgbGVuID0gaXNWZXJ0aWNhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICBpZiAoIWFycm93RWxlbWVudCB8fCAhcG9wcGVyT2Zmc2V0cykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwYWRkaW5nT2JqZWN0ID0gdG9QYWRkaW5nT2JqZWN0KG9wdGlvbnMucGFkZGluZywgc3RhdGUpO1xuICB2YXIgYXJyb3dSZWN0ID0gZ2V0TGF5b3V0UmVjdChhcnJvd0VsZW1lbnQpO1xuICB2YXIgbWluUHJvcCA9IGF4aXMgPT09ICd5JyA/IHRvcCA6IGxlZnQ7XG4gIHZhciBtYXhQcm9wID0gYXhpcyA9PT0gJ3knID8gYm90dG9tIDogcmlnaHQ7XG4gIHZhciBlbmREaWZmID0gc3RhdGUucmVjdHMucmVmZXJlbmNlW2xlbl0gKyBzdGF0ZS5yZWN0cy5yZWZlcmVuY2VbYXhpc10gLSBwb3BwZXJPZmZzZXRzW2F4aXNdIC0gc3RhdGUucmVjdHMucG9wcGVyW2xlbl07XG4gIHZhciBzdGFydERpZmYgPSBwb3BwZXJPZmZzZXRzW2F4aXNdIC0gc3RhdGUucmVjdHMucmVmZXJlbmNlW2F4aXNdO1xuICB2YXIgYXJyb3dPZmZzZXRQYXJlbnQgPSBnZXRPZmZzZXRQYXJlbnQoYXJyb3dFbGVtZW50KTtcbiAgdmFyIGNsaWVudFNpemUgPSBhcnJvd09mZnNldFBhcmVudCA/IGF4aXMgPT09ICd5JyA/IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudEhlaWdodCB8fCAwIDogYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50V2lkdGggfHwgMCA6IDA7XG4gIHZhciBjZW50ZXJUb1JlZmVyZW5jZSA9IGVuZERpZmYgLyAyIC0gc3RhcnREaWZmIC8gMjsgLy8gTWFrZSBzdXJlIHRoZSBhcnJvdyBkb2Vzbid0IG92ZXJmbG93IHRoZSBwb3BwZXIgaWYgdGhlIGNlbnRlciBwb2ludCBpc1xuICAvLyBvdXRzaWRlIG9mIHRoZSBwb3BwZXIgYm91bmRzXG5cbiAgdmFyIG1pbiA9IHBhZGRpbmdPYmplY3RbbWluUHJvcF07XG4gIHZhciBtYXggPSBjbGllbnRTaXplIC0gYXJyb3dSZWN0W2xlbl0gLSBwYWRkaW5nT2JqZWN0W21heFByb3BdO1xuICB2YXIgY2VudGVyID0gY2xpZW50U2l6ZSAvIDIgLSBhcnJvd1JlY3RbbGVuXSAvIDIgKyBjZW50ZXJUb1JlZmVyZW5jZTtcbiAgdmFyIG9mZnNldCA9IHdpdGhpbihtaW4sIGNlbnRlciwgbWF4KTsgLy8gUHJldmVudHMgYnJlYWtpbmcgc3ludGF4IGhpZ2hsaWdodGluZy4uLlxuXG4gIHZhciBheGlzUHJvcCA9IGF4aXM7XG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSAoX3N0YXRlJG1vZGlmaWVyc0RhdGEkID0ge30sIF9zdGF0ZSRtb2RpZmllcnNEYXRhJFtheGlzUHJvcF0gPSBvZmZzZXQsIF9zdGF0ZSRtb2RpZmllcnNEYXRhJC5jZW50ZXJPZmZzZXQgPSBvZmZzZXQgLSBjZW50ZXIsIF9zdGF0ZSRtb2RpZmllcnNEYXRhJCk7XG59XG5cbmZ1bmN0aW9uIGVmZmVjdChfcmVmMikge1xuICB2YXIgc3RhdGUgPSBfcmVmMi5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmMi5vcHRpb25zO1xuICB2YXIgX29wdGlvbnMkZWxlbWVudCA9IG9wdGlvbnMuZWxlbWVudCxcbiAgICAgIGFycm93RWxlbWVudCA9IF9vcHRpb25zJGVsZW1lbnQgPT09IHZvaWQgMCA/ICdbZGF0YS1wb3BwZXItYXJyb3ddJyA6IF9vcHRpb25zJGVsZW1lbnQ7XG5cbiAgaWYgKGFycm93RWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIENTUyBzZWxlY3RvclxuXG5cbiAgaWYgKHR5cGVvZiBhcnJvd0VsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMucG9wcGVyLnF1ZXJ5U2VsZWN0b3IoYXJyb3dFbGVtZW50KTtcblxuICAgIGlmICghYXJyb3dFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb250YWlucyhzdGF0ZS5lbGVtZW50cy5wb3BwZXIsIGFycm93RWxlbWVudCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBzdGF0ZS5lbGVtZW50cy5hcnJvdyA9IGFycm93RWxlbWVudDtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2Fycm93JyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgZm46IGFycm93LFxuICBlZmZlY3Q6IGVmZmVjdCxcbiAgcmVxdWlyZXM6IFsncG9wcGVyT2Zmc2V0cyddLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ3ByZXZlbnRPdmVyZmxvdyddXG59OyIsImltcG9ydCB7IHRvcCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgZW5kIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gXCIuLi91dGlscy9nZXRWYXJpYXRpb24uanNcIjtcbmltcG9ydCB7IHJvdW5kIH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG52YXIgdW5zZXRTaWRlcyA9IHtcbiAgdG9wOiAnYXV0bycsXG4gIHJpZ2h0OiAnYXV0bycsXG4gIGJvdHRvbTogJ2F1dG8nLFxuICBsZWZ0OiAnYXV0bydcbn07IC8vIFJvdW5kIHRoZSBvZmZzZXRzIHRvIHRoZSBuZWFyZXN0IHN1aXRhYmxlIHN1YnBpeGVsIGJhc2VkIG9uIHRoZSBEUFIuXG4vLyBab29taW5nIGNhbiBjaGFuZ2UgdGhlIERQUiwgYnV0IGl0IHNlZW1zIHRvIHJlcG9ydCBhIHZhbHVlIHRoYXQgd2lsbFxuLy8gY2xlYW5seSBkaXZpZGUgdGhlIHZhbHVlcyBpbnRvIHRoZSBhcHByb3ByaWF0ZSBzdWJwaXhlbHMuXG5cbmZ1bmN0aW9uIHJvdW5kT2Zmc2V0c0J5RFBSKF9yZWYsIHdpbikge1xuICB2YXIgeCA9IF9yZWYueCxcbiAgICAgIHkgPSBfcmVmLnk7XG4gIHZhciBkcHIgPSB3aW4uZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICByZXR1cm4ge1xuICAgIHg6IHJvdW5kKHggKiBkcHIpIC8gZHByIHx8IDAsXG4gICAgeTogcm91bmQoeSAqIGRwcikgLyBkcHIgfHwgMFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFwVG9TdHlsZXMoX3JlZjIpIHtcbiAgdmFyIF9PYmplY3QkYXNzaWduMjtcblxuICB2YXIgcG9wcGVyID0gX3JlZjIucG9wcGVyLFxuICAgICAgcG9wcGVyUmVjdCA9IF9yZWYyLnBvcHBlclJlY3QsXG4gICAgICBwbGFjZW1lbnQgPSBfcmVmMi5wbGFjZW1lbnQsXG4gICAgICB2YXJpYXRpb24gPSBfcmVmMi52YXJpYXRpb24sXG4gICAgICBvZmZzZXRzID0gX3JlZjIub2Zmc2V0cyxcbiAgICAgIHBvc2l0aW9uID0gX3JlZjIucG9zaXRpb24sXG4gICAgICBncHVBY2NlbGVyYXRpb24gPSBfcmVmMi5ncHVBY2NlbGVyYXRpb24sXG4gICAgICBhZGFwdGl2ZSA9IF9yZWYyLmFkYXB0aXZlLFxuICAgICAgcm91bmRPZmZzZXRzID0gX3JlZjIucm91bmRPZmZzZXRzLFxuICAgICAgaXNGaXhlZCA9IF9yZWYyLmlzRml4ZWQ7XG4gIHZhciBfb2Zmc2V0cyR4ID0gb2Zmc2V0cy54LFxuICAgICAgeCA9IF9vZmZzZXRzJHggPT09IHZvaWQgMCA/IDAgOiBfb2Zmc2V0cyR4LFxuICAgICAgX29mZnNldHMkeSA9IG9mZnNldHMueSxcbiAgICAgIHkgPSBfb2Zmc2V0cyR5ID09PSB2b2lkIDAgPyAwIDogX29mZnNldHMkeTtcblxuICB2YXIgX3JlZjMgPSB0eXBlb2Ygcm91bmRPZmZzZXRzID09PSAnZnVuY3Rpb24nID8gcm91bmRPZmZzZXRzKHtcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfSkgOiB7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG5cbiAgeCA9IF9yZWYzLng7XG4gIHkgPSBfcmVmMy55O1xuICB2YXIgaGFzWCA9IG9mZnNldHMuaGFzT3duUHJvcGVydHkoJ3gnKTtcbiAgdmFyIGhhc1kgPSBvZmZzZXRzLmhhc093blByb3BlcnR5KCd5Jyk7XG4gIHZhciBzaWRlWCA9IGxlZnQ7XG4gIHZhciBzaWRlWSA9IHRvcDtcbiAgdmFyIHdpbiA9IHdpbmRvdztcblxuICBpZiAoYWRhcHRpdmUpIHtcbiAgICB2YXIgb2Zmc2V0UGFyZW50ID0gZ2V0T2Zmc2V0UGFyZW50KHBvcHBlcik7XG4gICAgdmFyIGhlaWdodFByb3AgPSAnY2xpZW50SGVpZ2h0JztcbiAgICB2YXIgd2lkdGhQcm9wID0gJ2NsaWVudFdpZHRoJztcblxuICAgIGlmIChvZmZzZXRQYXJlbnQgPT09IGdldFdpbmRvdyhwb3BwZXIpKSB7XG4gICAgICBvZmZzZXRQYXJlbnQgPSBnZXREb2N1bWVudEVsZW1lbnQocG9wcGVyKTtcblxuICAgICAgaWYgKGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiAhPT0gJ3N0YXRpYycgJiYgcG9zaXRpb24gPT09ICdhYnNvbHV0ZScpIHtcbiAgICAgICAgaGVpZ2h0UHJvcCA9ICdzY3JvbGxIZWlnaHQnO1xuICAgICAgICB3aWR0aFByb3AgPSAnc2Nyb2xsV2lkdGgnO1xuICAgICAgfVxuICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FzdF06IGZvcmNlIHR5cGUgcmVmaW5lbWVudCwgd2UgY29tcGFyZSBvZmZzZXRQYXJlbnQgd2l0aCB3aW5kb3cgYWJvdmUsIGJ1dCBGbG93IGRvZXNuJ3QgZGV0ZWN0IGl0XG5cblxuICAgIG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudDtcblxuICAgIGlmIChwbGFjZW1lbnQgPT09IHRvcCB8fCAocGxhY2VtZW50ID09PSBsZWZ0IHx8IHBsYWNlbWVudCA9PT0gcmlnaHQpICYmIHZhcmlhdGlvbiA9PT0gZW5kKSB7XG4gICAgICBzaWRlWSA9IGJvdHRvbTtcbiAgICAgIHZhciBvZmZzZXRZID0gaXNGaXhlZCAmJiBvZmZzZXRQYXJlbnQgPT09IHdpbiAmJiB3aW4udmlzdWFsVmlld3BvcnQgPyB3aW4udmlzdWFsVmlld3BvcnQuaGVpZ2h0IDogLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgICBvZmZzZXRQYXJlbnRbaGVpZ2h0UHJvcF07XG4gICAgICB5IC09IG9mZnNldFkgLSBwb3BwZXJSZWN0LmhlaWdodDtcbiAgICAgIHkgKj0gZ3B1QWNjZWxlcmF0aW9uID8gMSA6IC0xO1xuICAgIH1cblxuICAgIGlmIChwbGFjZW1lbnQgPT09IGxlZnQgfHwgKHBsYWNlbWVudCA9PT0gdG9wIHx8IHBsYWNlbWVudCA9PT0gYm90dG9tKSAmJiB2YXJpYXRpb24gPT09IGVuZCkge1xuICAgICAgc2lkZVggPSByaWdodDtcbiAgICAgIHZhciBvZmZzZXRYID0gaXNGaXhlZCAmJiBvZmZzZXRQYXJlbnQgPT09IHdpbiAmJiB3aW4udmlzdWFsVmlld3BvcnQgPyB3aW4udmlzdWFsVmlld3BvcnQud2lkdGggOiAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICAgIG9mZnNldFBhcmVudFt3aWR0aFByb3BdO1xuICAgICAgeCAtPSBvZmZzZXRYIC0gcG9wcGVyUmVjdC53aWR0aDtcbiAgICAgIHggKj0gZ3B1QWNjZWxlcmF0aW9uID8gMSA6IC0xO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb21tb25TdHlsZXMgPSBPYmplY3QuYXNzaWduKHtcbiAgICBwb3NpdGlvbjogcG9zaXRpb25cbiAgfSwgYWRhcHRpdmUgJiYgdW5zZXRTaWRlcyk7XG5cbiAgdmFyIF9yZWY0ID0gcm91bmRPZmZzZXRzID09PSB0cnVlID8gcm91bmRPZmZzZXRzQnlEUFIoe1xuICAgIHg6IHgsXG4gICAgeTogeVxuICB9LCBnZXRXaW5kb3cocG9wcGVyKSkgOiB7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG5cbiAgeCA9IF9yZWY0Lng7XG4gIHkgPSBfcmVmNC55O1xuXG4gIGlmIChncHVBY2NlbGVyYXRpb24pIHtcbiAgICB2YXIgX09iamVjdCRhc3NpZ247XG5cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCAoX09iamVjdCRhc3NpZ24gPSB7fSwgX09iamVjdCRhc3NpZ25bc2lkZVldID0gaGFzWSA/ICcwJyA6ICcnLCBfT2JqZWN0JGFzc2lnbltzaWRlWF0gPSBoYXNYID8gJzAnIDogJycsIF9PYmplY3QkYXNzaWduLnRyYW5zZm9ybSA9ICh3aW4uZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSA8PSAxID8gXCJ0cmFuc2xhdGUoXCIgKyB4ICsgXCJweCwgXCIgKyB5ICsgXCJweClcIiA6IFwidHJhbnNsYXRlM2QoXCIgKyB4ICsgXCJweCwgXCIgKyB5ICsgXCJweCwgMClcIiwgX09iamVjdCRhc3NpZ24pKTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIChfT2JqZWN0JGFzc2lnbjIgPSB7fSwgX09iamVjdCRhc3NpZ24yW3NpZGVZXSA9IGhhc1kgPyB5ICsgXCJweFwiIDogJycsIF9PYmplY3QkYXNzaWduMltzaWRlWF0gPSBoYXNYID8geCArIFwicHhcIiA6ICcnLCBfT2JqZWN0JGFzc2lnbjIudHJhbnNmb3JtID0gJycsIF9PYmplY3QkYXNzaWduMikpO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlU3R5bGVzKF9yZWY1KSB7XG4gIHZhciBzdGF0ZSA9IF9yZWY1LnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWY1Lm9wdGlvbnM7XG4gIHZhciBfb3B0aW9ucyRncHVBY2NlbGVyYXQgPSBvcHRpb25zLmdwdUFjY2VsZXJhdGlvbixcbiAgICAgIGdwdUFjY2VsZXJhdGlvbiA9IF9vcHRpb25zJGdwdUFjY2VsZXJhdCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGdwdUFjY2VsZXJhdCxcbiAgICAgIF9vcHRpb25zJGFkYXB0aXZlID0gb3B0aW9ucy5hZGFwdGl2ZSxcbiAgICAgIGFkYXB0aXZlID0gX29wdGlvbnMkYWRhcHRpdmUgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRhZGFwdGl2ZSxcbiAgICAgIF9vcHRpb25zJHJvdW5kT2Zmc2V0cyA9IG9wdGlvbnMucm91bmRPZmZzZXRzLFxuICAgICAgcm91bmRPZmZzZXRzID0gX29wdGlvbnMkcm91bmRPZmZzZXRzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkcm91bmRPZmZzZXRzO1xuICB2YXIgY29tbW9uU3R5bGVzID0ge1xuICAgIHBsYWNlbWVudDogZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpLFxuICAgIHZhcmlhdGlvbjogZ2V0VmFyaWF0aW9uKHN0YXRlLnBsYWNlbWVudCksXG4gICAgcG9wcGVyOiBzdGF0ZS5lbGVtZW50cy5wb3BwZXIsXG4gICAgcG9wcGVyUmVjdDogc3RhdGUucmVjdHMucG9wcGVyLFxuICAgIGdwdUFjY2VsZXJhdGlvbjogZ3B1QWNjZWxlcmF0aW9uLFxuICAgIGlzRml4ZWQ6IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3kgPT09ICdmaXhlZCdcbiAgfTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzICE9IG51bGwpIHtcbiAgICBzdGF0ZS5zdHlsZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuc3R5bGVzLnBvcHBlciwgbWFwVG9TdHlsZXMoT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCB7XG4gICAgICBvZmZzZXRzOiBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMsXG4gICAgICBwb3NpdGlvbjogc3RhdGUub3B0aW9ucy5zdHJhdGVneSxcbiAgICAgIGFkYXB0aXZlOiBhZGFwdGl2ZSxcbiAgICAgIHJvdW5kT2Zmc2V0czogcm91bmRPZmZzZXRzXG4gICAgfSkpKTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLmFycm93ICE9IG51bGwpIHtcbiAgICBzdGF0ZS5zdHlsZXMuYXJyb3cgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5zdHlsZXMuYXJyb3csIG1hcFRvU3R5bGVzKE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywge1xuICAgICAgb2Zmc2V0czogc3RhdGUubW9kaWZpZXJzRGF0YS5hcnJvdyxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgYWRhcHRpdmU6IGZhbHNlLFxuICAgICAgcm91bmRPZmZzZXRzOiByb3VuZE9mZnNldHNcbiAgICB9KSkpO1xuICB9XG5cbiAgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciwge1xuICAgICdkYXRhLXBvcHBlci1wbGFjZW1lbnQnOiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdjb21wdXRlU3R5bGVzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdiZWZvcmVXcml0ZScsXG4gIGZuOiBjb21wdXRlU3R5bGVzLFxuICBkYXRhOiB7fVxufTsiLCJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0V2luZG93LmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxudmFyIHBhc3NpdmUgPSB7XG4gIHBhc3NpdmU6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGVmZmVjdChfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBpbnN0YW5jZSA9IF9yZWYuaW5zdGFuY2UsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zO1xuICB2YXIgX29wdGlvbnMkc2Nyb2xsID0gb3B0aW9ucy5zY3JvbGwsXG4gICAgICBzY3JvbGwgPSBfb3B0aW9ucyRzY3JvbGwgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRzY3JvbGwsXG4gICAgICBfb3B0aW9ucyRyZXNpemUgPSBvcHRpb25zLnJlc2l6ZSxcbiAgICAgIHJlc2l6ZSA9IF9vcHRpb25zJHJlc2l6ZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHJlc2l6ZTtcbiAgdmFyIHdpbmRvdyA9IGdldFdpbmRvdyhzdGF0ZS5lbGVtZW50cy5wb3BwZXIpO1xuICB2YXIgc2Nyb2xsUGFyZW50cyA9IFtdLmNvbmNhdChzdGF0ZS5zY3JvbGxQYXJlbnRzLnJlZmVyZW5jZSwgc3RhdGUuc2Nyb2xsUGFyZW50cy5wb3BwZXIpO1xuXG4gIGlmIChzY3JvbGwpIHtcbiAgICBzY3JvbGxQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHNjcm9sbFBhcmVudCkge1xuICAgICAgc2Nyb2xsUGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAocmVzaXplKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChzY3JvbGwpIHtcbiAgICAgIHNjcm9sbFBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAoc2Nyb2xsUGFyZW50KSB7XG4gICAgICAgIHNjcm9sbFBhcmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHJlc2l6ZSkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gICAgfVxuICB9O1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnZXZlbnRMaXN0ZW5lcnMnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ3dyaXRlJyxcbiAgZm46IGZ1bmN0aW9uIGZuKCkge30sXG4gIGVmZmVjdDogZWZmZWN0LFxuICBkYXRhOiB7fVxufTsiLCJpbXBvcnQgZ2V0T3Bwb3NpdGVQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldE9wcG9zaXRlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gXCIuLi91dGlscy9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IGNvbXB1dGVBdXRvUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9jb21wdXRlQXV0b1BsYWNlbWVudC5qc1wiO1xuaW1wb3J0IHsgYm90dG9tLCB0b3AsIHN0YXJ0LCByaWdodCwgbGVmdCwgYXV0byB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi4vdXRpbHMvZ2V0VmFyaWF0aW9uLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZnVuY3Rpb24gZ2V0RXhwYW5kZWRGYWxsYmFja1BsYWNlbWVudHMocGxhY2VtZW50KSB7XG4gIGlmIChnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgPT09IGF1dG8pIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgb3Bwb3NpdGVQbGFjZW1lbnQgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICByZXR1cm4gW2dldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50KHBsYWNlbWVudCksIG9wcG9zaXRlUGxhY2VtZW50LCBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChvcHBvc2l0ZVBsYWNlbWVudCldO1xufVxuXG5mdW5jdGlvbiBmbGlwKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdLl9za2lwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIF9vcHRpb25zJG1haW5BeGlzID0gb3B0aW9ucy5tYWluQXhpcyxcbiAgICAgIGNoZWNrTWFpbkF4aXMgPSBfb3B0aW9ucyRtYWluQXhpcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJG1haW5BeGlzLFxuICAgICAgX29wdGlvbnMkYWx0QXhpcyA9IG9wdGlvbnMuYWx0QXhpcyxcbiAgICAgIGNoZWNrQWx0QXhpcyA9IF9vcHRpb25zJGFsdEF4aXMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRhbHRBeGlzLFxuICAgICAgc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzID0gb3B0aW9ucy5mYWxsYmFja1BsYWNlbWVudHMsXG4gICAgICBwYWRkaW5nID0gb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgYm91bmRhcnkgPSBvcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeSA9IG9wdGlvbnMuYWx0Qm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRmbGlwVmFyaWF0aW8gPSBvcHRpb25zLmZsaXBWYXJpYXRpb25zLFxuICAgICAgZmxpcFZhcmlhdGlvbnMgPSBfb3B0aW9ucyRmbGlwVmFyaWF0aW8gPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRmbGlwVmFyaWF0aW8sXG4gICAgICBhbGxvd2VkQXV0b1BsYWNlbWVudHMgPSBvcHRpb25zLmFsbG93ZWRBdXRvUGxhY2VtZW50cztcbiAgdmFyIHByZWZlcnJlZFBsYWNlbWVudCA9IHN0YXRlLm9wdGlvbnMucGxhY2VtZW50O1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQocHJlZmVycmVkUGxhY2VtZW50KTtcbiAgdmFyIGlzQmFzZVBsYWNlbWVudCA9IGJhc2VQbGFjZW1lbnQgPT09IHByZWZlcnJlZFBsYWNlbWVudDtcbiAgdmFyIGZhbGxiYWNrUGxhY2VtZW50cyA9IHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyB8fCAoaXNCYXNlUGxhY2VtZW50IHx8ICFmbGlwVmFyaWF0aW9ucyA/IFtnZXRPcHBvc2l0ZVBsYWNlbWVudChwcmVmZXJyZWRQbGFjZW1lbnQpXSA6IGdldEV4cGFuZGVkRmFsbGJhY2tQbGFjZW1lbnRzKHByZWZlcnJlZFBsYWNlbWVudCkpO1xuICB2YXIgcGxhY2VtZW50cyA9IFtwcmVmZXJyZWRQbGFjZW1lbnRdLmNvbmNhdChmYWxsYmFja1BsYWNlbWVudHMpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gYWNjLmNvbmNhdChnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgPT09IGF1dG8gPyBjb21wdXRlQXV0b1BsYWNlbWVudChzdGF0ZSwge1xuICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmc6IHBhZGRpbmcsXG4gICAgICBmbGlwVmFyaWF0aW9uczogZmxpcFZhcmlhdGlvbnMsXG4gICAgICBhbGxvd2VkQXV0b1BsYWNlbWVudHM6IGFsbG93ZWRBdXRvUGxhY2VtZW50c1xuICAgIH0pIDogcGxhY2VtZW50KTtcbiAgfSwgW10pO1xuICB2YXIgcmVmZXJlbmNlUmVjdCA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZTtcbiAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIHZhciBjaGVja3NNYXAgPSBuZXcgTWFwKCk7XG4gIHZhciBtYWtlRmFsbGJhY2tDaGVja3MgPSB0cnVlO1xuICB2YXIgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gcGxhY2VtZW50c1swXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBsYWNlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcGxhY2VtZW50ID0gcGxhY2VtZW50c1tpXTtcblxuICAgIHZhciBfYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KTtcblxuICAgIHZhciBpc1N0YXJ0VmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgPT09IHN0YXJ0O1xuICAgIHZhciBpc1ZlcnRpY2FsID0gW3RvcCwgYm90dG9tXS5pbmRleE9mKF9iYXNlUGxhY2VtZW50KSA+PSAwO1xuICAgIHZhciBsZW4gPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuICAgIHZhciBvdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnk6IGFsdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZzogcGFkZGluZ1xuICAgIH0pO1xuICAgIHZhciBtYWluVmFyaWF0aW9uU2lkZSA9IGlzVmVydGljYWwgPyBpc1N0YXJ0VmFyaWF0aW9uID8gcmlnaHQgOiBsZWZ0IDogaXNTdGFydFZhcmlhdGlvbiA/IGJvdHRvbSA6IHRvcDtcblxuICAgIGlmIChyZWZlcmVuY2VSZWN0W2xlbl0gPiBwb3BwZXJSZWN0W2xlbl0pIHtcbiAgICAgIG1haW5WYXJpYXRpb25TaWRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpblZhcmlhdGlvblNpZGUpO1xuICAgIH1cblxuICAgIHZhciBhbHRWYXJpYXRpb25TaWRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpblZhcmlhdGlvblNpZGUpO1xuICAgIHZhciBjaGVja3MgPSBbXTtcblxuICAgIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgICBjaGVja3MucHVzaChvdmVyZmxvd1tfYmFzZVBsYWNlbWVudF0gPD0gMCk7XG4gICAgfVxuXG4gICAgaWYgKGNoZWNrQWx0QXhpcykge1xuICAgICAgY2hlY2tzLnB1c2gob3ZlcmZsb3dbbWFpblZhcmlhdGlvblNpZGVdIDw9IDAsIG92ZXJmbG93W2FsdFZhcmlhdGlvblNpZGVdIDw9IDApO1xuICAgIH1cblxuICAgIGlmIChjaGVja3MuZXZlcnkoZnVuY3Rpb24gKGNoZWNrKSB7XG4gICAgICByZXR1cm4gY2hlY2s7XG4gICAgfSkpIHtcbiAgICAgIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudDtcbiAgICAgIG1ha2VGYWxsYmFja0NoZWNrcyA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2hlY2tzTWFwLnNldChwbGFjZW1lbnQsIGNoZWNrcyk7XG4gIH1cblxuICBpZiAobWFrZUZhbGxiYWNrQ2hlY2tzKSB7XG4gICAgLy8gYDJgIG1heSBiZSBkZXNpcmVkIGluIHNvbWUgY2FzZXMg4oCTIHJlc2VhcmNoIGxhdGVyXG4gICAgdmFyIG51bWJlck9mQ2hlY2tzID0gZmxpcFZhcmlhdGlvbnMgPyAzIDogMTtcblxuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKF9pKSB7XG4gICAgICB2YXIgZml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudHMuZmluZChmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgICAgIHZhciBjaGVja3MgPSBjaGVja3NNYXAuZ2V0KHBsYWNlbWVudCk7XG5cbiAgICAgICAgaWYgKGNoZWNrcykge1xuICAgICAgICAgIHJldHVybiBjaGVja3Muc2xpY2UoMCwgX2kpLmV2ZXJ5KGZ1bmN0aW9uIChjaGVjaykge1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKGZpdHRpbmdQbGFjZW1lbnQpIHtcbiAgICAgICAgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gZml0dGluZ1BsYWNlbWVudDtcbiAgICAgICAgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9yICh2YXIgX2kgPSBudW1iZXJPZkNoZWNrczsgX2kgPiAwOyBfaS0tKSB7XG4gICAgICB2YXIgX3JldCA9IF9sb29wKF9pKTtcblxuICAgICAgaWYgKF9yZXQgPT09IFwiYnJlYWtcIikgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXRlLnBsYWNlbWVudCAhPT0gZmlyc3RGaXR0aW5nUGxhY2VtZW50KSB7XG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXS5fc2tpcCA9IHRydWU7XG4gICAgc3RhdGUucGxhY2VtZW50ID0gZmlyc3RGaXR0aW5nUGxhY2VtZW50O1xuICAgIHN0YXRlLnJlc2V0ID0gdHJ1ZTtcbiAgfVxufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnZmxpcCcsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIGZuOiBmbGlwLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ29mZnNldCddLFxuICBkYXRhOiB7XG4gICAgX3NraXA6IGZhbHNlXG4gIH1cbn07IiwiaW1wb3J0IHsgdG9wLCBib3R0b20sIGxlZnQsIHJpZ2h0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4uL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzXCI7XG5cbmZ1bmN0aW9uIGdldFNpZGVPZmZzZXRzKG92ZXJmbG93LCByZWN0LCBwcmV2ZW50ZWRPZmZzZXRzKSB7XG4gIGlmIChwcmV2ZW50ZWRPZmZzZXRzID09PSB2b2lkIDApIHtcbiAgICBwcmV2ZW50ZWRPZmZzZXRzID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0b3A6IG92ZXJmbG93LnRvcCAtIHJlY3QuaGVpZ2h0IC0gcHJldmVudGVkT2Zmc2V0cy55LFxuICAgIHJpZ2h0OiBvdmVyZmxvdy5yaWdodCAtIHJlY3Qud2lkdGggKyBwcmV2ZW50ZWRPZmZzZXRzLngsXG4gICAgYm90dG9tOiBvdmVyZmxvdy5ib3R0b20gLSByZWN0LmhlaWdodCArIHByZXZlbnRlZE9mZnNldHMueSxcbiAgICBsZWZ0OiBvdmVyZmxvdy5sZWZ0IC0gcmVjdC53aWR0aCAtIHByZXZlbnRlZE9mZnNldHMueFxuICB9O1xufVxuXG5mdW5jdGlvbiBpc0FueVNpZGVGdWxseUNsaXBwZWQob3ZlcmZsb3cpIHtcbiAgcmV0dXJuIFt0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRdLnNvbWUoZnVuY3Rpb24gKHNpZGUpIHtcbiAgICByZXR1cm4gb3ZlcmZsb3dbc2lkZV0gPj0gMDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGhpZGUoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgcHJldmVudGVkT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucHJldmVudE92ZXJmbG93O1xuICB2YXIgcmVmZXJlbmNlT3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgIGVsZW1lbnRDb250ZXh0OiAncmVmZXJlbmNlJ1xuICB9KTtcbiAgdmFyIHBvcHBlckFsdE92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICBhbHRCb3VuZGFyeTogdHJ1ZVxuICB9KTtcbiAgdmFyIHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKHJlZmVyZW5jZU92ZXJmbG93LCByZWZlcmVuY2VSZWN0KTtcbiAgdmFyIHBvcHBlckVzY2FwZU9mZnNldHMgPSBnZXRTaWRlT2Zmc2V0cyhwb3BwZXJBbHRPdmVyZmxvdywgcG9wcGVyUmVjdCwgcHJldmVudGVkT2Zmc2V0cyk7XG4gIHZhciBpc1JlZmVyZW5jZUhpZGRlbiA9IGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChyZWZlcmVuY2VDbGlwcGluZ09mZnNldHMpO1xuICB2YXIgaGFzUG9wcGVyRXNjYXBlZCA9IGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChwb3BwZXJFc2NhcGVPZmZzZXRzKTtcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IHtcbiAgICByZWZlcmVuY2VDbGlwcGluZ09mZnNldHM6IHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyxcbiAgICBwb3BwZXJFc2NhcGVPZmZzZXRzOiBwb3BwZXJFc2NhcGVPZmZzZXRzLFxuICAgIGlzUmVmZXJlbmNlSGlkZGVuOiBpc1JlZmVyZW5jZUhpZGRlbixcbiAgICBoYXNQb3BwZXJFc2NhcGVkOiBoYXNQb3BwZXJFc2NhcGVkXG4gIH07XG4gIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIsIHtcbiAgICAnZGF0YS1wb3BwZXItcmVmZXJlbmNlLWhpZGRlbic6IGlzUmVmZXJlbmNlSGlkZGVuLFxuICAgICdkYXRhLXBvcHBlci1lc2NhcGVkJzogaGFzUG9wcGVyRXNjYXBlZFxuICB9KTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2hpZGUnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ3ByZXZlbnRPdmVyZmxvdyddLFxuICBmbjogaGlkZVxufTsiLCJleHBvcnQgeyBkZWZhdWx0IGFzIGFwcGx5U3R5bGVzIH0gZnJvbSBcIi4vYXBwbHlTdHlsZXMuanNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgYXJyb3cgfSBmcm9tIFwiLi9hcnJvdy5qc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBjb21wdXRlU3R5bGVzIH0gZnJvbSBcIi4vY29tcHV0ZVN0eWxlcy5qc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBldmVudExpc3RlbmVycyB9IGZyb20gXCIuL2V2ZW50TGlzdGVuZXJzLmpzXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGZsaXAgfSBmcm9tIFwiLi9mbGlwLmpzXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGhpZGUgfSBmcm9tIFwiLi9oaWRlLmpzXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG9mZnNldCB9IGZyb20gXCIuL29mZnNldC5qc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBwb3BwZXJPZmZzZXRzIH0gZnJvbSBcIi4vcG9wcGVyT2Zmc2V0cy5qc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBwcmV2ZW50T3ZlcmZsb3cgfSBmcm9tIFwiLi9wcmV2ZW50T3ZlcmZsb3cuanNcIjsiLCJpbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IHsgdG9wLCBsZWZ0LCByaWdodCwgcGxhY2VtZW50cyB9IGZyb20gXCIuLi9lbnVtcy5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCBmdW5jdGlvbiBkaXN0YW5jZUFuZFNraWRkaW5nVG9YWShwbGFjZW1lbnQsIHJlY3RzLCBvZmZzZXQpIHtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIHZhciBpbnZlcnREaXN0YW5jZSA9IFtsZWZ0LCB0b3BdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMCA/IC0xIDogMTtcblxuICB2YXIgX3JlZiA9IHR5cGVvZiBvZmZzZXQgPT09ICdmdW5jdGlvbicgPyBvZmZzZXQoT2JqZWN0LmFzc2lnbih7fSwgcmVjdHMsIHtcbiAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudFxuICB9KSkgOiBvZmZzZXQsXG4gICAgICBza2lkZGluZyA9IF9yZWZbMF0sXG4gICAgICBkaXN0YW5jZSA9IF9yZWZbMV07XG5cbiAgc2tpZGRpbmcgPSBza2lkZGluZyB8fCAwO1xuICBkaXN0YW5jZSA9IChkaXN0YW5jZSB8fCAwKSAqIGludmVydERpc3RhbmNlO1xuICByZXR1cm4gW2xlZnQsIHJpZ2h0XS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDAgPyB7XG4gICAgeDogZGlzdGFuY2UsXG4gICAgeTogc2tpZGRpbmdcbiAgfSA6IHtcbiAgICB4OiBza2lkZGluZyxcbiAgICB5OiBkaXN0YW5jZVxuICB9O1xufVxuXG5mdW5jdGlvbiBvZmZzZXQoX3JlZjIpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZjIub3B0aW9ucyxcbiAgICAgIG5hbWUgPSBfcmVmMi5uYW1lO1xuICB2YXIgX29wdGlvbnMkb2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQsXG4gICAgICBvZmZzZXQgPSBfb3B0aW9ucyRvZmZzZXQgPT09IHZvaWQgMCA/IFswLCAwXSA6IF9vcHRpb25zJG9mZnNldDtcbiAgdmFyIGRhdGEgPSBwbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICBhY2NbcGxhY2VtZW50XSA9IGRpc3RhbmNlQW5kU2tpZGRpbmdUb1hZKHBsYWNlbWVudCwgc3RhdGUucmVjdHMsIG9mZnNldCk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICB2YXIgX2RhdGEkc3RhdGUkcGxhY2VtZW50ID0gZGF0YVtzdGF0ZS5wbGFjZW1lbnRdLFxuICAgICAgeCA9IF9kYXRhJHN0YXRlJHBsYWNlbWVudC54LFxuICAgICAgeSA9IF9kYXRhJHN0YXRlJHBsYWNlbWVudC55O1xuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMgIT0gbnVsbCkge1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cy54ICs9IHg7XG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnkgKz0geTtcbiAgfVxuXG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBkYXRhO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnb2Zmc2V0JyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgcmVxdWlyZXM6IFsncG9wcGVyT2Zmc2V0cyddLFxuICBmbjogb2Zmc2V0XG59OyIsImltcG9ydCBjb21wdXRlT2Zmc2V0cyBmcm9tIFwiLi4vdXRpbHMvY29tcHV0ZU9mZnNldHMuanNcIjtcblxuZnVuY3Rpb24gcG9wcGVyT2Zmc2V0cyhfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuICAvLyBPZmZzZXRzIGFyZSB0aGUgYWN0dWFsIHBvc2l0aW9uIHRoZSBwb3BwZXIgbmVlZHMgdG8gaGF2ZSB0byBiZVxuICAvLyBwcm9wZXJseSBwb3NpdGlvbmVkIG5lYXIgaXRzIHJlZmVyZW5jZSBlbGVtZW50XG4gIC8vIFRoaXMgaXMgdGhlIG1vc3QgYmFzaWMgcGxhY2VtZW50LCBhbmQgd2lsbCBiZSBhZGp1c3RlZCBieVxuICAvLyB0aGUgbW9kaWZpZXJzIGluIHRoZSBuZXh0IHN0ZXBcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IGNvbXB1dGVPZmZzZXRzKHtcbiAgICByZWZlcmVuY2U6IHN0YXRlLnJlY3RzLnJlZmVyZW5jZSxcbiAgICBlbGVtZW50OiBzdGF0ZS5yZWN0cy5wb3BwZXIsXG4gICAgc3RyYXRlZ3k6ICdhYnNvbHV0ZScsXG4gICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdwb3BwZXJPZmZzZXRzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdyZWFkJyxcbiAgZm46IHBvcHBlck9mZnNldHMsXG4gIGRhdGE6IHt9XG59OyIsImltcG9ydCB7IHRvcCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgc3RhcnQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRBbHRBeGlzIGZyb20gXCIuLi91dGlscy9nZXRBbHRBeGlzLmpzXCI7XG5pbXBvcnQgeyB3aXRoaW4sIHdpdGhpbk1heENsYW1wIH0gZnJvbSBcIi4uL3V0aWxzL3dpdGhpbi5qc1wiO1xuaW1wb3J0IGdldExheW91dFJlY3QgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4uL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzXCI7XG5pbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gXCIuLi91dGlscy9nZXRWYXJpYXRpb24uanNcIjtcbmltcG9ydCBnZXRGcmVzaFNpZGVPYmplY3QgZnJvbSBcIi4uL3V0aWxzL2dldEZyZXNoU2lkZU9iamVjdC5qc1wiO1xuaW1wb3J0IHsgbWluIGFzIG1hdGhNaW4sIG1heCBhcyBtYXRoTWF4IH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjtcblxuZnVuY3Rpb24gcHJldmVudE92ZXJmbG93KF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuICB2YXIgX29wdGlvbnMkbWFpbkF4aXMgPSBvcHRpb25zLm1haW5BeGlzLFxuICAgICAgY2hlY2tNYWluQXhpcyA9IF9vcHRpb25zJG1haW5BeGlzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkbWFpbkF4aXMsXG4gICAgICBfb3B0aW9ucyRhbHRBeGlzID0gb3B0aW9ucy5hbHRBeGlzLFxuICAgICAgY2hlY2tBbHRBeGlzID0gX29wdGlvbnMkYWx0QXhpcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRhbHRBeGlzLFxuICAgICAgYm91bmRhcnkgPSBvcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeSA9IG9wdGlvbnMuYWx0Qm91bmRhcnksXG4gICAgICBwYWRkaW5nID0gb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgX29wdGlvbnMkdGV0aGVyID0gb3B0aW9ucy50ZXRoZXIsXG4gICAgICB0ZXRoZXIgPSBfb3B0aW9ucyR0ZXRoZXIgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyR0ZXRoZXIsXG4gICAgICBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQgPSBvcHRpb25zLnRldGhlck9mZnNldCxcbiAgICAgIHRldGhlck9mZnNldCA9IF9vcHRpb25zJHRldGhlck9mZnNldCA9PT0gdm9pZCAwID8gMCA6IF9vcHRpb25zJHRldGhlck9mZnNldDtcbiAgdmFyIG92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgcGFkZGluZzogcGFkZGluZyxcbiAgICBhbHRCb3VuZGFyeTogYWx0Qm91bmRhcnlcbiAgfSk7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpO1xuICB2YXIgdmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHN0YXRlLnBsYWNlbWVudCk7XG4gIHZhciBpc0Jhc2VQbGFjZW1lbnQgPSAhdmFyaWF0aW9uO1xuICB2YXIgbWFpbkF4aXMgPSBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQoYmFzZVBsYWNlbWVudCk7XG4gIHZhciBhbHRBeGlzID0gZ2V0QWx0QXhpcyhtYWluQXhpcyk7XG4gIHZhciBwb3BwZXJPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzO1xuICB2YXIgcmVmZXJlbmNlUmVjdCA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZTtcbiAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIHZhciB0ZXRoZXJPZmZzZXRWYWx1ZSA9IHR5cGVvZiB0ZXRoZXJPZmZzZXQgPT09ICdmdW5jdGlvbicgPyB0ZXRoZXJPZmZzZXQoT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUucmVjdHMsIHtcbiAgICBwbGFjZW1lbnQ6IHN0YXRlLnBsYWNlbWVudFxuICB9KSkgOiB0ZXRoZXJPZmZzZXQ7XG4gIHZhciBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUgPSB0eXBlb2YgdGV0aGVyT2Zmc2V0VmFsdWUgPT09ICdudW1iZXInID8ge1xuICAgIG1haW5BeGlzOiB0ZXRoZXJPZmZzZXRWYWx1ZSxcbiAgICBhbHRBeGlzOiB0ZXRoZXJPZmZzZXRWYWx1ZVxuICB9IDogT2JqZWN0LmFzc2lnbih7XG4gICAgbWFpbkF4aXM6IDAsXG4gICAgYWx0QXhpczogMFxuICB9LCB0ZXRoZXJPZmZzZXRWYWx1ZSk7XG4gIHZhciBvZmZzZXRNb2RpZmllclN0YXRlID0gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXQgPyBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldFtzdGF0ZS5wbGFjZW1lbnRdIDogbnVsbDtcbiAgdmFyIGRhdGEgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG5cbiAgaWYgKCFwb3BwZXJPZmZzZXRzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICB2YXIgX29mZnNldE1vZGlmaWVyU3RhdGUkO1xuXG4gICAgdmFyIG1haW5TaWRlID0gbWFpbkF4aXMgPT09ICd5JyA/IHRvcCA6IGxlZnQ7XG4gICAgdmFyIGFsdFNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gYm90dG9tIDogcmlnaHQ7XG4gICAgdmFyIGxlbiA9IG1haW5BeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgdmFyIG9mZnNldCA9IHBvcHBlck9mZnNldHNbbWFpbkF4aXNdO1xuICAgIHZhciBtaW4gPSBvZmZzZXQgKyBvdmVyZmxvd1ttYWluU2lkZV07XG4gICAgdmFyIG1heCA9IG9mZnNldCAtIG92ZXJmbG93W2FsdFNpZGVdO1xuICAgIHZhciBhZGRpdGl2ZSA9IHRldGhlciA/IC1wb3BwZXJSZWN0W2xlbl0gLyAyIDogMDtcbiAgICB2YXIgbWluTGVuID0gdmFyaWF0aW9uID09PSBzdGFydCA/IHJlZmVyZW5jZVJlY3RbbGVuXSA6IHBvcHBlclJlY3RbbGVuXTtcbiAgICB2YXIgbWF4TGVuID0gdmFyaWF0aW9uID09PSBzdGFydCA/IC1wb3BwZXJSZWN0W2xlbl0gOiAtcmVmZXJlbmNlUmVjdFtsZW5dOyAvLyBXZSBuZWVkIHRvIGluY2x1ZGUgdGhlIGFycm93IGluIHRoZSBjYWxjdWxhdGlvbiBzbyB0aGUgYXJyb3cgZG9lc24ndCBnb1xuICAgIC8vIG91dHNpZGUgdGhlIHJlZmVyZW5jZSBib3VuZHNcblxuICAgIHZhciBhcnJvd0VsZW1lbnQgPSBzdGF0ZS5lbGVtZW50cy5hcnJvdztcbiAgICB2YXIgYXJyb3dSZWN0ID0gdGV0aGVyICYmIGFycm93RWxlbWVudCA/IGdldExheW91dFJlY3QoYXJyb3dFbGVtZW50KSA6IHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwXG4gICAgfTtcbiAgICB2YXIgYXJyb3dQYWRkaW5nT2JqZWN0ID0gc3RhdGUubW9kaWZpZXJzRGF0YVsnYXJyb3cjcGVyc2lzdGVudCddID8gc3RhdGUubW9kaWZpZXJzRGF0YVsnYXJyb3cjcGVyc2lzdGVudCddLnBhZGRpbmcgOiBnZXRGcmVzaFNpZGVPYmplY3QoKTtcbiAgICB2YXIgYXJyb3dQYWRkaW5nTWluID0gYXJyb3dQYWRkaW5nT2JqZWN0W21haW5TaWRlXTtcbiAgICB2YXIgYXJyb3dQYWRkaW5nTWF4ID0gYXJyb3dQYWRkaW5nT2JqZWN0W2FsdFNpZGVdOyAvLyBJZiB0aGUgcmVmZXJlbmNlIGxlbmd0aCBpcyBzbWFsbGVyIHRoYW4gdGhlIGFycm93IGxlbmd0aCwgd2UgZG9uJ3Qgd2FudFxuICAgIC8vIHRvIGluY2x1ZGUgaXRzIGZ1bGwgc2l6ZSBpbiB0aGUgY2FsY3VsYXRpb24uIElmIHRoZSByZWZlcmVuY2UgaXMgc21hbGxcbiAgICAvLyBhbmQgbmVhciB0aGUgZWRnZSBvZiBhIGJvdW5kYXJ5LCB0aGUgcG9wcGVyIGNhbiBvdmVyZmxvdyBldmVuIGlmIHRoZVxuICAgIC8vIHJlZmVyZW5jZSBpcyBub3Qgb3ZlcmZsb3dpbmcgYXMgd2VsbCAoZS5nLiB2aXJ0dWFsIGVsZW1lbnRzIHdpdGggbm9cbiAgICAvLyB3aWR0aCBvciBoZWlnaHQpXG5cbiAgICB2YXIgYXJyb3dMZW4gPSB3aXRoaW4oMCwgcmVmZXJlbmNlUmVjdFtsZW5dLCBhcnJvd1JlY3RbbGVuXSk7XG4gICAgdmFyIG1pbk9mZnNldCA9IGlzQmFzZVBsYWNlbWVudCA/IHJlZmVyZW5jZVJlY3RbbGVuXSAvIDIgLSBhZGRpdGl2ZSAtIGFycm93TGVuIC0gYXJyb3dQYWRkaW5nTWluIC0gbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLm1haW5BeGlzIDogbWluTGVuIC0gYXJyb3dMZW4gLSBhcnJvd1BhZGRpbmdNaW4gLSBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXM7XG4gICAgdmFyIG1heE9mZnNldCA9IGlzQmFzZVBsYWNlbWVudCA/IC1yZWZlcmVuY2VSZWN0W2xlbl0gLyAyICsgYWRkaXRpdmUgKyBhcnJvd0xlbiArIGFycm93UGFkZGluZ01heCArIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpcyA6IG1heExlbiArIGFycm93TGVuICsgYXJyb3dQYWRkaW5nTWF4ICsgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLm1haW5BeGlzO1xuICAgIHZhciBhcnJvd09mZnNldFBhcmVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93ICYmIGdldE9mZnNldFBhcmVudChzdGF0ZS5lbGVtZW50cy5hcnJvdyk7XG4gICAgdmFyIGNsaWVudE9mZnNldCA9IGFycm93T2Zmc2V0UGFyZW50ID8gbWFpbkF4aXMgPT09ICd5JyA/IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudFRvcCB8fCAwIDogYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50TGVmdCB8fCAwIDogMDtcbiAgICB2YXIgb2Zmc2V0TW9kaWZpZXJWYWx1ZSA9IChfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQgPSBvZmZzZXRNb2RpZmllclN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBvZmZzZXRNb2RpZmllclN0YXRlW21haW5BeGlzXSkgIT0gbnVsbCA/IF9vZmZzZXRNb2RpZmllclN0YXRlJCA6IDA7XG4gICAgdmFyIHRldGhlck1pbiA9IG9mZnNldCArIG1pbk9mZnNldCAtIG9mZnNldE1vZGlmaWVyVmFsdWUgLSBjbGllbnRPZmZzZXQ7XG4gICAgdmFyIHRldGhlck1heCA9IG9mZnNldCArIG1heE9mZnNldCAtIG9mZnNldE1vZGlmaWVyVmFsdWU7XG4gICAgdmFyIHByZXZlbnRlZE9mZnNldCA9IHdpdGhpbih0ZXRoZXIgPyBtYXRoTWluKG1pbiwgdGV0aGVyTWluKSA6IG1pbiwgb2Zmc2V0LCB0ZXRoZXIgPyBtYXRoTWF4KG1heCwgdGV0aGVyTWF4KSA6IG1heCk7XG4gICAgcG9wcGVyT2Zmc2V0c1ttYWluQXhpc10gPSBwcmV2ZW50ZWRPZmZzZXQ7XG4gICAgZGF0YVttYWluQXhpc10gPSBwcmV2ZW50ZWRPZmZzZXQgLSBvZmZzZXQ7XG4gIH1cblxuICBpZiAoY2hlY2tBbHRBeGlzKSB7XG4gICAgdmFyIF9vZmZzZXRNb2RpZmllclN0YXRlJDI7XG5cbiAgICB2YXIgX21haW5TaWRlID0gbWFpbkF4aXMgPT09ICd4JyA/IHRvcCA6IGxlZnQ7XG5cbiAgICB2YXIgX2FsdFNpZGUgPSBtYWluQXhpcyA9PT0gJ3gnID8gYm90dG9tIDogcmlnaHQ7XG5cbiAgICB2YXIgX29mZnNldCA9IHBvcHBlck9mZnNldHNbYWx0QXhpc107XG5cbiAgICB2YXIgX2xlbiA9IGFsdEF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICAgIHZhciBfbWluID0gX29mZnNldCArIG92ZXJmbG93W19tYWluU2lkZV07XG5cbiAgICB2YXIgX21heCA9IF9vZmZzZXQgLSBvdmVyZmxvd1tfYWx0U2lkZV07XG5cbiAgICB2YXIgaXNPcmlnaW5TaWRlID0gW3RvcCwgbGVmdF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSAhPT0gLTE7XG5cbiAgICB2YXIgX29mZnNldE1vZGlmaWVyVmFsdWUgPSAoX29mZnNldE1vZGlmaWVyU3RhdGUkMiA9IG9mZnNldE1vZGlmaWVyU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IG9mZnNldE1vZGlmaWVyU3RhdGVbYWx0QXhpc10pICE9IG51bGwgPyBfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQyIDogMDtcblxuICAgIHZhciBfdGV0aGVyTWluID0gaXNPcmlnaW5TaWRlID8gX21pbiA6IF9vZmZzZXQgLSByZWZlcmVuY2VSZWN0W19sZW5dIC0gcG9wcGVyUmVjdFtfbGVuXSAtIF9vZmZzZXRNb2RpZmllclZhbHVlICsgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLmFsdEF4aXM7XG5cbiAgICB2YXIgX3RldGhlck1heCA9IGlzT3JpZ2luU2lkZSA/IF9vZmZzZXQgKyByZWZlcmVuY2VSZWN0W19sZW5dICsgcG9wcGVyUmVjdFtfbGVuXSAtIF9vZmZzZXRNb2RpZmllclZhbHVlIC0gbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLmFsdEF4aXMgOiBfbWF4O1xuXG4gICAgdmFyIF9wcmV2ZW50ZWRPZmZzZXQgPSB0ZXRoZXIgJiYgaXNPcmlnaW5TaWRlID8gd2l0aGluTWF4Q2xhbXAoX3RldGhlck1pbiwgX29mZnNldCwgX3RldGhlck1heCkgOiB3aXRoaW4odGV0aGVyID8gX3RldGhlck1pbiA6IF9taW4sIF9vZmZzZXQsIHRldGhlciA/IF90ZXRoZXJNYXggOiBfbWF4KTtcblxuICAgIHBvcHBlck9mZnNldHNbYWx0QXhpc10gPSBfcHJldmVudGVkT2Zmc2V0O1xuICAgIGRhdGFbYWx0QXhpc10gPSBfcHJldmVudGVkT2Zmc2V0IC0gX29mZnNldDtcbiAgfVxuXG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBkYXRhO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAncHJldmVudE92ZXJmbG93JyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgZm46IHByZXZlbnRPdmVyZmxvdyxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydvZmZzZXQnXVxufTsiLCJpbXBvcnQgeyBwb3BwZXJHZW5lcmF0b3IsIGRldGVjdE92ZXJmbG93IH0gZnJvbSBcIi4vY3JlYXRlUG9wcGVyLmpzXCI7XG5pbXBvcnQgZXZlbnRMaXN0ZW5lcnMgZnJvbSBcIi4vbW9kaWZpZXJzL2V2ZW50TGlzdGVuZXJzLmpzXCI7XG5pbXBvcnQgcG9wcGVyT2Zmc2V0cyBmcm9tIFwiLi9tb2RpZmllcnMvcG9wcGVyT2Zmc2V0cy5qc1wiO1xuaW1wb3J0IGNvbXB1dGVTdHlsZXMgZnJvbSBcIi4vbW9kaWZpZXJzL2NvbXB1dGVTdHlsZXMuanNcIjtcbmltcG9ydCBhcHBseVN0eWxlcyBmcm9tIFwiLi9tb2RpZmllcnMvYXBwbHlTdHlsZXMuanNcIjtcbnZhciBkZWZhdWx0TW9kaWZpZXJzID0gW2V2ZW50TGlzdGVuZXJzLCBwb3BwZXJPZmZzZXRzLCBjb21wdXRlU3R5bGVzLCBhcHBseVN0eWxlc107XG52YXIgY3JlYXRlUG9wcGVyID0gLyojX19QVVJFX18qL3BvcHBlckdlbmVyYXRvcih7XG4gIGRlZmF1bHRNb2RpZmllcnM6IGRlZmF1bHRNb2RpZmllcnNcbn0pOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCB7IGNyZWF0ZVBvcHBlciwgcG9wcGVyR2VuZXJhdG9yLCBkZWZhdWx0TW9kaWZpZXJzLCBkZXRlY3RPdmVyZmxvdyB9OyIsImltcG9ydCB7IHBvcHBlckdlbmVyYXRvciwgZGV0ZWN0T3ZlcmZsb3cgfSBmcm9tIFwiLi9jcmVhdGVQb3BwZXIuanNcIjtcbmltcG9ydCBldmVudExpc3RlbmVycyBmcm9tIFwiLi9tb2RpZmllcnMvZXZlbnRMaXN0ZW5lcnMuanNcIjtcbmltcG9ydCBwb3BwZXJPZmZzZXRzIGZyb20gXCIuL21vZGlmaWVycy9wb3BwZXJPZmZzZXRzLmpzXCI7XG5pbXBvcnQgY29tcHV0ZVN0eWxlcyBmcm9tIFwiLi9tb2RpZmllcnMvY29tcHV0ZVN0eWxlcy5qc1wiO1xuaW1wb3J0IGFwcGx5U3R5bGVzIGZyb20gXCIuL21vZGlmaWVycy9hcHBseVN0eWxlcy5qc1wiO1xuaW1wb3J0IG9mZnNldCBmcm9tIFwiLi9tb2RpZmllcnMvb2Zmc2V0LmpzXCI7XG5pbXBvcnQgZmxpcCBmcm9tIFwiLi9tb2RpZmllcnMvZmxpcC5qc1wiO1xuaW1wb3J0IHByZXZlbnRPdmVyZmxvdyBmcm9tIFwiLi9tb2RpZmllcnMvcHJldmVudE92ZXJmbG93LmpzXCI7XG5pbXBvcnQgYXJyb3cgZnJvbSBcIi4vbW9kaWZpZXJzL2Fycm93LmpzXCI7XG5pbXBvcnQgaGlkZSBmcm9tIFwiLi9tb2RpZmllcnMvaGlkZS5qc1wiO1xudmFyIGRlZmF1bHRNb2RpZmllcnMgPSBbZXZlbnRMaXN0ZW5lcnMsIHBvcHBlck9mZnNldHMsIGNvbXB1dGVTdHlsZXMsIGFwcGx5U3R5bGVzLCBvZmZzZXQsIGZsaXAsIHByZXZlbnRPdmVyZmxvdywgYXJyb3csIGhpZGVdO1xudmFyIGNyZWF0ZVBvcHBlciA9IC8qI19fUFVSRV9fKi9wb3BwZXJHZW5lcmF0b3Ioe1xuICBkZWZhdWx0TW9kaWZpZXJzOiBkZWZhdWx0TW9kaWZpZXJzXG59KTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgeyBjcmVhdGVQb3BwZXIsIHBvcHBlckdlbmVyYXRvciwgZGVmYXVsdE1vZGlmaWVycywgZGV0ZWN0T3ZlcmZsb3cgfTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgeyBjcmVhdGVQb3BwZXIgYXMgY3JlYXRlUG9wcGVyTGl0ZSB9IGZyb20gXCIuL3BvcHBlci1saXRlLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0ICogZnJvbSBcIi4vbW9kaWZpZXJzL2luZGV4LmpzXCI7IiwiaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi9nZXRWYXJpYXRpb24uanNcIjtcbmltcG9ydCB7IHZhcmlhdGlvblBsYWNlbWVudHMsIGJhc2VQbGFjZW1lbnRzLCBwbGFjZW1lbnRzIGFzIGFsbFBsYWNlbWVudHMgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4vZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcHV0ZUF1dG9QbGFjZW1lbnQoc3RhdGUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICBwbGFjZW1lbnQgPSBfb3B0aW9ucy5wbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeSA9IF9vcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZyA9IF9vcHRpb25zLnBhZGRpbmcsXG4gICAgICBmbGlwVmFyaWF0aW9ucyA9IF9vcHRpb25zLmZsaXBWYXJpYXRpb25zLFxuICAgICAgX29wdGlvbnMkYWxsb3dlZEF1dG9QID0gX29wdGlvbnMuYWxsb3dlZEF1dG9QbGFjZW1lbnRzLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzID0gX29wdGlvbnMkYWxsb3dlZEF1dG9QID09PSB2b2lkIDAgPyBhbGxQbGFjZW1lbnRzIDogX29wdGlvbnMkYWxsb3dlZEF1dG9QO1xuICB2YXIgdmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCk7XG4gIHZhciBwbGFjZW1lbnRzID0gdmFyaWF0aW9uID8gZmxpcFZhcmlhdGlvbnMgPyB2YXJpYXRpb25QbGFjZW1lbnRzIDogdmFyaWF0aW9uUGxhY2VtZW50cy5maWx0ZXIoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgIHJldHVybiBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSA9PT0gdmFyaWF0aW9uO1xuICB9KSA6IGJhc2VQbGFjZW1lbnRzO1xuICB2YXIgYWxsb3dlZFBsYWNlbWVudHMgPSBwbGFjZW1lbnRzLmZpbHRlcihmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIGFsbG93ZWRBdXRvUGxhY2VtZW50cy5pbmRleE9mKHBsYWNlbWVudCkgPj0gMDtcbiAgfSk7XG5cbiAgaWYgKGFsbG93ZWRQbGFjZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGFsbG93ZWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cztcbiAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXTogRmxvdyBzZWVtcyB0byBoYXZlIHByb2JsZW1zIHdpdGggdHdvIGFycmF5IHVuaW9ucy4uLlxuXG5cbiAgdmFyIG92ZXJmbG93cyA9IGFsbG93ZWRQbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICBhY2NbcGxhY2VtZW50XSA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZzogcGFkZGluZ1xuICAgIH0pW2dldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KV07XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICByZXR1cm4gT2JqZWN0LmtleXMob3ZlcmZsb3dzKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIG92ZXJmbG93c1thXSAtIG92ZXJmbG93c1tiXTtcbiAgfSk7XG59IiwiaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4vZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi9nZXRWYXJpYXRpb24uanNcIjtcbmltcG9ydCBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQgZnJvbSBcIi4vZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgeyB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQsIHN0YXJ0LCBlbmQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbXB1dGVPZmZzZXRzKF9yZWYpIHtcbiAgdmFyIHJlZmVyZW5jZSA9IF9yZWYucmVmZXJlbmNlLFxuICAgICAgZWxlbWVudCA9IF9yZWYuZWxlbWVudCxcbiAgICAgIHBsYWNlbWVudCA9IF9yZWYucGxhY2VtZW50O1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudCA/IGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSA6IG51bGw7XG4gIHZhciB2YXJpYXRpb24gPSBwbGFjZW1lbnQgPyBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSA6IG51bGw7XG4gIHZhciBjb21tb25YID0gcmVmZXJlbmNlLnggKyByZWZlcmVuY2Uud2lkdGggLyAyIC0gZWxlbWVudC53aWR0aCAvIDI7XG4gIHZhciBjb21tb25ZID0gcmVmZXJlbmNlLnkgKyByZWZlcmVuY2UuaGVpZ2h0IC8gMiAtIGVsZW1lbnQuaGVpZ2h0IC8gMjtcbiAgdmFyIG9mZnNldHM7XG5cbiAgc3dpdGNoIChiYXNlUGxhY2VtZW50KSB7XG4gICAgY2FzZSB0b3A6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSAtIGVsZW1lbnQuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIGJvdHRvbTpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IGNvbW1vblgsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSByaWdodDpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIGxlZnQ6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCAtIGVsZW1lbnQud2lkdGgsXG4gICAgICAgIHk6IGNvbW1vbllcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnlcbiAgICAgIH07XG4gIH1cblxuICB2YXIgbWFpbkF4aXMgPSBiYXNlUGxhY2VtZW50ID8gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGJhc2VQbGFjZW1lbnQpIDogbnVsbDtcblxuICBpZiAobWFpbkF4aXMgIT0gbnVsbCkge1xuICAgIHZhciBsZW4gPSBtYWluQXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gICAgc3dpdGNoICh2YXJpYXRpb24pIHtcbiAgICAgIGNhc2Ugc3RhcnQ6XG4gICAgICAgIG9mZnNldHNbbWFpbkF4aXNdID0gb2Zmc2V0c1ttYWluQXhpc10gLSAocmVmZXJlbmNlW2xlbl0gLyAyIC0gZWxlbWVudFtsZW5dIC8gMik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIGVuZDpcbiAgICAgICAgb2Zmc2V0c1ttYWluQXhpc10gPSBvZmZzZXRzW21haW5BeGlzXSArIChyZWZlcmVuY2VbbGVuXSAvIDIgLSBlbGVtZW50W2xlbl0gLyAyKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9mZnNldHM7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGVib3VuY2UoZm4pIHtcbiAgdmFyIHBlbmRpbmc7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFwZW5kaW5nKSB7XG4gICAgICBwZW5kaW5nID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcGVuZGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICByZXNvbHZlKGZuKCkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBwZW5kaW5nO1xuICB9O1xufSIsImltcG9ydCBnZXRDbGlwcGluZ1JlY3QgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRDbGlwcGluZ1JlY3QuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4uL2RvbS11dGlscy9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCBjb21wdXRlT2Zmc2V0cyBmcm9tIFwiLi9jb21wdXRlT2Zmc2V0cy5qc1wiO1xuaW1wb3J0IHJlY3RUb0NsaWVudFJlY3QgZnJvbSBcIi4vcmVjdFRvQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IHsgY2xpcHBpbmdQYXJlbnRzLCByZWZlcmVuY2UsIHBvcHBlciwgYm90dG9tLCB0b3AsIHJpZ2h0LCBiYXNlUGxhY2VtZW50cywgdmlld3BvcnQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCB7IGlzRWxlbWVudCB9IGZyb20gXCIuLi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IG1lcmdlUGFkZGluZ09iamVjdCBmcm9tIFwiLi9tZXJnZVBhZGRpbmdPYmplY3QuanNcIjtcbmltcG9ydCBleHBhbmRUb0hhc2hNYXAgZnJvbSBcIi4vZXhwYW5kVG9IYXNoTWFwLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICBfb3B0aW9ucyRwbGFjZW1lbnQgPSBfb3B0aW9ucy5wbGFjZW1lbnQsXG4gICAgICBwbGFjZW1lbnQgPSBfb3B0aW9ucyRwbGFjZW1lbnQgPT09IHZvaWQgMCA/IHN0YXRlLnBsYWNlbWVudCA6IF9vcHRpb25zJHBsYWNlbWVudCxcbiAgICAgIF9vcHRpb25zJHN0cmF0ZWd5ID0gX29wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICBzdHJhdGVneSA9IF9vcHRpb25zJHN0cmF0ZWd5ID09PSB2b2lkIDAgPyBzdGF0ZS5zdHJhdGVneSA6IF9vcHRpb25zJHN0cmF0ZWd5LFxuICAgICAgX29wdGlvbnMkYm91bmRhcnkgPSBfb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIGJvdW5kYXJ5ID0gX29wdGlvbnMkYm91bmRhcnkgPT09IHZvaWQgMCA/IGNsaXBwaW5nUGFyZW50cyA6IF9vcHRpb25zJGJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMkcm9vdEJvdW5kYXJ5ID09PSB2b2lkIDAgPyB2aWV3cG9ydCA6IF9vcHRpb25zJHJvb3RCb3VuZGFyeSxcbiAgICAgIF9vcHRpb25zJGVsZW1lbnRDb250ZSA9IF9vcHRpb25zLmVsZW1lbnRDb250ZXh0LFxuICAgICAgZWxlbWVudENvbnRleHQgPSBfb3B0aW9ucyRlbGVtZW50Q29udGUgPT09IHZvaWQgMCA/IHBvcHBlciA6IF9vcHRpb25zJGVsZW1lbnRDb250ZSxcbiAgICAgIF9vcHRpb25zJGFsdEJvdW5kYXJ5ID0gX29wdGlvbnMuYWx0Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeSA9IF9vcHRpb25zJGFsdEJvdW5kYXJ5ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGFsdEJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkcGFkZGluZyA9IF9vcHRpb25zLnBhZGRpbmcsXG4gICAgICBwYWRkaW5nID0gX29wdGlvbnMkcGFkZGluZyA9PT0gdm9pZCAwID8gMCA6IF9vcHRpb25zJHBhZGRpbmc7XG4gIHZhciBwYWRkaW5nT2JqZWN0ID0gbWVyZ2VQYWRkaW5nT2JqZWN0KHR5cGVvZiBwYWRkaW5nICE9PSAnbnVtYmVyJyA/IHBhZGRpbmcgOiBleHBhbmRUb0hhc2hNYXAocGFkZGluZywgYmFzZVBsYWNlbWVudHMpKTtcbiAgdmFyIGFsdENvbnRleHQgPSBlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyID8gcmVmZXJlbmNlIDogcG9wcGVyO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1thbHRCb3VuZGFyeSA/IGFsdENvbnRleHQgOiBlbGVtZW50Q29udGV4dF07XG4gIHZhciBjbGlwcGluZ0NsaWVudFJlY3QgPSBnZXRDbGlwcGluZ1JlY3QoaXNFbGVtZW50KGVsZW1lbnQpID8gZWxlbWVudCA6IGVsZW1lbnQuY29udGV4dEVsZW1lbnQgfHwgZ2V0RG9jdW1lbnRFbGVtZW50KHN0YXRlLmVsZW1lbnRzLnBvcHBlciksIGJvdW5kYXJ5LCByb290Qm91bmRhcnksIHN0cmF0ZWd5KTtcbiAgdmFyIHJlZmVyZW5jZUNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qoc3RhdGUuZWxlbWVudHMucmVmZXJlbmNlKTtcbiAgdmFyIHBvcHBlck9mZnNldHMgPSBjb21wdXRlT2Zmc2V0cyh7XG4gICAgcmVmZXJlbmNlOiByZWZlcmVuY2VDbGllbnRSZWN0LFxuICAgIGVsZW1lbnQ6IHBvcHBlclJlY3QsXG4gICAgc3RyYXRlZ3k6ICdhYnNvbHV0ZScsXG4gICAgcGxhY2VtZW50OiBwbGFjZW1lbnRcbiAgfSk7XG4gIHZhciBwb3BwZXJDbGllbnRSZWN0ID0gcmVjdFRvQ2xpZW50UmVjdChPYmplY3QuYXNzaWduKHt9LCBwb3BwZXJSZWN0LCBwb3BwZXJPZmZzZXRzKSk7XG4gIHZhciBlbGVtZW50Q2xpZW50UmVjdCA9IGVsZW1lbnRDb250ZXh0ID09PSBwb3BwZXIgPyBwb3BwZXJDbGllbnRSZWN0IDogcmVmZXJlbmNlQ2xpZW50UmVjdDsgLy8gcG9zaXRpdmUgPSBvdmVyZmxvd2luZyB0aGUgY2xpcHBpbmcgcmVjdFxuICAvLyAwIG9yIG5lZ2F0aXZlID0gd2l0aGluIHRoZSBjbGlwcGluZyByZWN0XG5cbiAgdmFyIG92ZXJmbG93T2Zmc2V0cyA9IHtcbiAgICB0b3A6IGNsaXBwaW5nQ2xpZW50UmVjdC50b3AgLSBlbGVtZW50Q2xpZW50UmVjdC50b3AgKyBwYWRkaW5nT2JqZWN0LnRvcCxcbiAgICBib3R0b206IGVsZW1lbnRDbGllbnRSZWN0LmJvdHRvbSAtIGNsaXBwaW5nQ2xpZW50UmVjdC5ib3R0b20gKyBwYWRkaW5nT2JqZWN0LmJvdHRvbSxcbiAgICBsZWZ0OiBjbGlwcGluZ0NsaWVudFJlY3QubGVmdCAtIGVsZW1lbnRDbGllbnRSZWN0LmxlZnQgKyBwYWRkaW5nT2JqZWN0LmxlZnQsXG4gICAgcmlnaHQ6IGVsZW1lbnRDbGllbnRSZWN0LnJpZ2h0IC0gY2xpcHBpbmdDbGllbnRSZWN0LnJpZ2h0ICsgcGFkZGluZ09iamVjdC5yaWdodFxuICB9O1xuICB2YXIgb2Zmc2V0RGF0YSA9IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0OyAvLyBPZmZzZXRzIGNhbiBiZSBhcHBsaWVkIG9ubHkgdG8gdGhlIHBvcHBlciBlbGVtZW50XG5cbiAgaWYgKGVsZW1lbnRDb250ZXh0ID09PSBwb3BwZXIgJiYgb2Zmc2V0RGF0YSkge1xuICAgIHZhciBvZmZzZXQgPSBvZmZzZXREYXRhW3BsYWNlbWVudF07XG4gICAgT2JqZWN0LmtleXMob3ZlcmZsb3dPZmZzZXRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBtdWx0aXBseSA9IFtyaWdodCwgYm90dG9tXS5pbmRleE9mKGtleSkgPj0gMCA/IDEgOiAtMTtcbiAgICAgIHZhciBheGlzID0gW3RvcCwgYm90dG9tXS5pbmRleE9mKGtleSkgPj0gMCA/ICd5JyA6ICd4JztcbiAgICAgIG92ZXJmbG93T2Zmc2V0c1trZXldICs9IG9mZnNldFtheGlzXSAqIG11bHRpcGx5O1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIG92ZXJmbG93T2Zmc2V0cztcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBleHBhbmRUb0hhc2hNYXAodmFsdWUsIGtleXMpIHtcbiAgcmV0dXJuIGtleXMucmVkdWNlKGZ1bmN0aW9uIChoYXNoTWFwLCBrZXkpIHtcbiAgICBoYXNoTWFwW2tleV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gaGFzaE1hcDtcbiAgfSwge30pO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEFsdEF4aXMoYXhpcykge1xuICByZXR1cm4gYXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xufSIsImltcG9ydCB7IGF1dG8gfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRGcmVzaFNpZGVPYmplY3QoKSB7XG4gIHJldHVybiB7XG4gICAgdG9wOiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiAwXG4gIH07XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZihwbGFjZW1lbnQpID49IDAgPyAneCcgOiAneSc7XG59IiwidmFyIGhhc2ggPSB7XG4gIGxlZnQ6ICdyaWdodCcsXG4gIHJpZ2h0OiAnbGVmdCcsXG4gIGJvdHRvbTogJ3RvcCcsXG4gIHRvcDogJ2JvdHRvbSdcbn07XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywgZnVuY3Rpb24gKG1hdGNoZWQpIHtcbiAgICByZXR1cm4gaGFzaFttYXRjaGVkXTtcbiAgfSk7XG59IiwidmFyIGhhc2ggPSB7XG4gIHN0YXJ0OiAnZW5kJyxcbiAgZW5kOiAnc3RhcnQnXG59O1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvc3RhcnR8ZW5kL2csIGZ1bmN0aW9uIChtYXRjaGVkKSB7XG4gICAgcmV0dXJuIGhhc2hbbWF0Y2hlZF07XG4gIH0pO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFZhcmlhdGlvbihwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzFdO1xufSIsImV4cG9ydCB2YXIgbWF4ID0gTWF0aC5tYXg7XG5leHBvcnQgdmFyIG1pbiA9IE1hdGgubWluO1xuZXhwb3J0IHZhciByb3VuZCA9IE1hdGgucm91bmQ7IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWVyZ2VCeU5hbWUobW9kaWZpZXJzKSB7XG4gIHZhciBtZXJnZWQgPSBtb2RpZmllcnMucmVkdWNlKGZ1bmN0aW9uIChtZXJnZWQsIGN1cnJlbnQpIHtcbiAgICB2YXIgZXhpc3RpbmcgPSBtZXJnZWRbY3VycmVudC5uYW1lXTtcbiAgICBtZXJnZWRbY3VycmVudC5uYW1lXSA9IGV4aXN0aW5nID8gT2JqZWN0LmFzc2lnbih7fSwgZXhpc3RpbmcsIGN1cnJlbnQsIHtcbiAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLm9wdGlvbnMsIGN1cnJlbnQub3B0aW9ucyksXG4gICAgICBkYXRhOiBPYmplY3QuYXNzaWduKHt9LCBleGlzdGluZy5kYXRhLCBjdXJyZW50LmRhdGEpXG4gICAgfSkgOiBjdXJyZW50O1xuICAgIHJldHVybiBtZXJnZWQ7XG4gIH0sIHt9KTsgLy8gSUUxMSBkb2VzIG5vdCBzdXBwb3J0IE9iamVjdC52YWx1ZXNcblxuICByZXR1cm4gT2JqZWN0LmtleXMobWVyZ2VkKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBtZXJnZWRba2V5XTtcbiAgfSk7XG59IiwiaW1wb3J0IGdldEZyZXNoU2lkZU9iamVjdCBmcm9tIFwiLi9nZXRGcmVzaFNpZGVPYmplY3QuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lcmdlUGFkZGluZ09iamVjdChwYWRkaW5nT2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBnZXRGcmVzaFNpZGVPYmplY3QoKSwgcGFkZGluZ09iamVjdCk7XG59IiwiaW1wb3J0IHsgbW9kaWZpZXJQaGFzZXMgfSBmcm9tIFwiLi4vZW51bXMuanNcIjsgLy8gc291cmNlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80OTg3NTI1NVxuXG5mdW5jdGlvbiBvcmRlcihtb2RpZmllcnMpIHtcbiAgdmFyIG1hcCA9IG5ldyBNYXAoKTtcbiAgdmFyIHZpc2l0ZWQgPSBuZXcgU2V0KCk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgbWFwLnNldChtb2RpZmllci5uYW1lLCBtb2RpZmllcik7XG4gIH0pOyAvLyBPbiB2aXNpdGluZyBvYmplY3QsIGNoZWNrIGZvciBpdHMgZGVwZW5kZW5jaWVzIGFuZCB2aXNpdCB0aGVtIHJlY3Vyc2l2ZWx5XG5cbiAgZnVuY3Rpb24gc29ydChtb2RpZmllcikge1xuICAgIHZpc2l0ZWQuYWRkKG1vZGlmaWVyLm5hbWUpO1xuICAgIHZhciByZXF1aXJlcyA9IFtdLmNvbmNhdChtb2RpZmllci5yZXF1aXJlcyB8fCBbXSwgbW9kaWZpZXIucmVxdWlyZXNJZkV4aXN0cyB8fCBbXSk7XG4gICAgcmVxdWlyZXMuZm9yRWFjaChmdW5jdGlvbiAoZGVwKSB7XG4gICAgICBpZiAoIXZpc2l0ZWQuaGFzKGRlcCkpIHtcbiAgICAgICAgdmFyIGRlcE1vZGlmaWVyID0gbWFwLmdldChkZXApO1xuXG4gICAgICAgIGlmIChkZXBNb2RpZmllcikge1xuICAgICAgICAgIHNvcnQoZGVwTW9kaWZpZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmVzdWx0LnB1c2gobW9kaWZpZXIpO1xuICB9XG5cbiAgbW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgaWYgKCF2aXNpdGVkLmhhcyhtb2RpZmllci5uYW1lKSkge1xuICAgICAgLy8gY2hlY2sgZm9yIHZpc2l0ZWQgb2JqZWN0XG4gICAgICBzb3J0KG1vZGlmaWVyKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBvcmRlck1vZGlmaWVycyhtb2RpZmllcnMpIHtcbiAgLy8gb3JkZXIgYmFzZWQgb24gZGVwZW5kZW5jaWVzXG4gIHZhciBvcmRlcmVkTW9kaWZpZXJzID0gb3JkZXIobW9kaWZpZXJzKTsgLy8gb3JkZXIgYmFzZWQgb24gcGhhc2VcblxuICByZXR1cm4gbW9kaWZpZXJQaGFzZXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBoYXNlKSB7XG4gICAgcmV0dXJuIGFjYy5jb25jYXQob3JkZXJlZE1vZGlmaWVycy5maWx0ZXIoZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgICByZXR1cm4gbW9kaWZpZXIucGhhc2UgPT09IHBoYXNlO1xuICAgIH0pKTtcbiAgfSwgW10pO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlY3RUb0NsaWVudFJlY3QocmVjdCkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgcmVjdCwge1xuICAgIGxlZnQ6IHJlY3QueCxcbiAgICB0b3A6IHJlY3QueSxcbiAgICByaWdodDogcmVjdC54ICsgcmVjdC53aWR0aCxcbiAgICBib3R0b206IHJlY3QueSArIHJlY3QuaGVpZ2h0XG4gIH0pO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFVBU3RyaW5nKCkge1xuICB2YXIgdWFEYXRhID0gbmF2aWdhdG9yLnVzZXJBZ2VudERhdGE7XG5cbiAgaWYgKHVhRGF0YSAhPSBudWxsICYmIHVhRGF0YS5icmFuZHMgJiYgQXJyYXkuaXNBcnJheSh1YURhdGEuYnJhbmRzKSkge1xuICAgIHJldHVybiB1YURhdGEuYnJhbmRzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIGl0ZW0uYnJhbmQgKyBcIi9cIiArIGl0ZW0udmVyc2lvbjtcbiAgICB9KS5qb2luKCcgJyk7XG4gIH1cblxuICByZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbn0iLCJpbXBvcnQgeyBtYXggYXMgbWF0aE1heCwgbWluIGFzIG1hdGhNaW4gfSBmcm9tIFwiLi9tYXRoLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gd2l0aGluKG1pbiwgdmFsdWUsIG1heCkge1xuICByZXR1cm4gbWF0aE1heChtaW4sIG1hdGhNaW4odmFsdWUsIG1heCkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdpdGhpbk1heENsYW1wKG1pbiwgdmFsdWUsIG1heCkge1xuICB2YXIgdiA9IHdpdGhpbihtaW4sIHZhbHVlLCBtYXgpO1xuICByZXR1cm4gdiA+IG1heCA/IG1heCA6IHY7XG59IiwiXG5yZXF1aXJlKCcuL3Nhc3MvX2FwcC5zY3NzJyk7XG5cbi8vIC0tLS0tLSBLaW1haSBpdHNlbGYgLS0tLS0tXG5yZXF1aXJlKCcuL2pzL0tpbWFpV2ViTG9hZGVyLmpzJyk7XG5nbG9iYWwuS2ltYWlQYWdpbmF0ZWRCb3hXaWRnZXQgPSByZXF1aXJlKCcuL2pzL3dpZGdldHMvS2ltYWlQYWdpbmF0ZWRCb3hXaWRnZXQnKS5kZWZhdWx0O1xuZ2xvYmFsLktpbWFpUmVsb2FkUGFnZVdpZGdldCA9IHJlcXVpcmUoJy4vanMvd2lkZ2V0cy9LaW1haVJlbG9hZFBhZ2VXaWRnZXQnKS5kZWZhdWx0O1xuZ2xvYmFsLktpbWFpQ29sb3IgPSByZXF1aXJlKCcuL2pzL3dpZGdldHMvS2ltYWlDb2xvcicpLmRlZmF1bHQ7XG5nbG9iYWwuS2ltYWlTdG9yYWdlID0gcmVxdWlyZSgnLi9qcy93aWRnZXRzL0tpbWFpU3RvcmFnZScpLmRlZmF1bHQ7XG4iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgdGhlIEtpbWFpIHRpbWUtdHJhY2tpbmcgYXBwLlxuICpcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cbiAqL1xuXG4vKiFcbiAqIFtLSU1BSV0gS2ltYWlDb25maWd1cmF0aW9uOiBoYW5kbGluZyBhbGwgY29uZmlndXJhdGlvbiBhbmQgcnVudGltZSBzZXR0aW5nc1xuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEtpbWFpQ29uZmlndXJhdGlvbiB7XG5cbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9ucykge1xuICAgICAgICB0aGlzLl9jb25maWd1cmF0aW9ucyA9IGNvbmZpZ3VyYXRpb25zO1xuICAgIH1cblxuICAgIGdldChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25maWd1cmF0aW9uc1tuYW1lXTtcbiAgICB9XG5cbiAgICBoYXMobmFtZSkge1xuICAgICAgICByZXR1cm4gbmFtZSBpbiB0aGlzLl9jb25maWd1cmF0aW9ucztcbiAgICB9XG5cbiAgICBpc1JUTCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KCdkaXJlY3Rpb24nKSA9PT0gJ3J0bCc7XG4gICAgfVxuXG4gICAgZ2V0TGFuZ3VhZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldCgnbG9jYWxlJykucmVwbGFjZSgnXycsICctJyk7XG4gICAgfVxuXG4gICAgaXMyNEhvdXJzKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmdldCgndHdlbnR5Rm91ckhvdXJzJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc29cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0Rmlyc3REYXlPZldlZWsoaXNvID0gdHJ1ZSkge1xuICAgICAgICBpZiAoaXNvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlzbyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbmZpZyA9IHRoaXMuZ2V0KCdmaXJzdF9kb3dfaXNvJyk7XG4gICAgICAgIGlmICghaXNvKSB7XG4gICAgICAgICAgICBjb25maWcgPSBjb25maWcgJSA3O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuXG59XG4iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgdGhlIEtpbWFpIHRpbWUtdHJhY2tpbmcgYXBwLlxuICpcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cbiAqL1xuXG4vKiFcbiAqIFtLSU1BSV0gS2ltYWlDb250YWluZXJcbiAqXG4gKiBTZXJ2aWNlQ29udGFpbmVyIGZvciBLaW1haVxuICovXG5cbmltcG9ydCBLaW1haUNvbmZpZ3VyYXRpb24gZnJvbSAnLi9LaW1haUNvbmZpZ3VyYXRpb24nO1xuaW1wb3J0IEtpbWFpVHJhbnNsYXRpb24gZnJvbSAnLi9LaW1haVRyYW5zbGF0aW9uJztcbmltcG9ydCBLaW1haVBsdWdpbiBmcm9tICcuL0tpbWFpUGx1Z2luJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgS2ltYWlDb250YWluZXIge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IENvbnRhaW5lciB3aXRoIHRoZSBnaXZlbiBjb25maWd1cmF0aW9ucyBhbmQgdHJhbnNsYXRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtLaW1haUNvbmZpZ3VyYXRpb259IGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0ge0tpbWFpVHJhbnNsYXRpb259IHRyYW5zbGF0aW9uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvbiwgdHJhbnNsYXRpb24pIHtcbiAgICAgICAgaWYgKCEoY29uZmlndXJhdGlvbiBpbnN0YW5jZW9mIEtpbWFpQ29uZmlndXJhdGlvbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29uZmlndXJhdGlvbiBuZWVkcyB0byBhIEtpbWFpQ29uZmlndXJhdGlvbiBpbnN0YW5jZScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvbmZpZ3VyYXRpb24gPSBjb25maWd1cmF0aW9uO1xuXG4gICAgICAgIGlmICghKHRyYW5zbGF0aW9uIGluc3RhbmNlb2YgS2ltYWlUcmFuc2xhdGlvbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29uZmlndXJhdGlvbiBuZWVkcyB0byBhIEtpbWFpVHJhbnNsYXRpb24gaW5zdGFuY2UnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90cmFuc2xhdGlvbiA9IHRyYW5zbGF0aW9uO1xuICAgICAgICB0aGlzLl9wbHVnaW5zID0gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSBuZXcgUGx1Z2luLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtLaW1haVBsdWdpbn0gcGx1Z2luXG4gICAgICogQHJldHVybnMge0tpbWFpUGx1Z2lufVxuICAgICAqL1xuICAgIHJlZ2lzdGVyUGx1Z2luKHBsdWdpbikge1xuICAgICAgICBpZiAoIShwbHVnaW4gaW5zdGFuY2VvZiBLaW1haVBsdWdpbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwbHVnaW4gZ2l2ZW4sIG5lZWRzIHRvIGJlIGEgS2ltYWlQbHVnaW4gaW5zdGFuY2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBsdWdpbi5zZXRDb250YWluZXIodGhpcyk7XG5cbiAgICAgICAgdGhpcy5fcGx1Z2lucy5wdXNoKHBsdWdpbik7XG5cbiAgICAgICAgcmV0dXJuIHBsdWdpbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEByZXR1cm5zIHtLaW1haVBsdWdpbn1cbiAgICAgKi9cbiAgICBnZXRQbHVnaW4obmFtZSkge1xuICAgICAgICBmb3IgKGxldCBwbHVnaW4gb2YgdGhpcy5fcGx1Z2lucykge1xuICAgICAgICAgICAgaWYgKHBsdWdpbi5nZXRJZCgpICE9PSBudWxsICYmIHBsdWdpbi5nZXRJZCgpID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBsdWdpbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcGx1Z2luOiAnICsgbmFtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0FycmF5PEtpbWFpUGx1Z2luPn1cbiAgICAgKi9cbiAgICBnZXRQbHVnaW5zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGx1Z2lucztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7S2ltYWlUcmFuc2xhdGlvbn1cbiAgICAgKi9cbiAgICBnZXRUcmFuc2xhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zbGF0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtLaW1haUNvbmZpZ3VyYXRpb259XG4gICAgICovXG4gICAgZ2V0Q29uZmlndXJhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbmZpZ3VyYXRpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0tpbWFpVXNlcn1cbiAgICAgKi9cbiAgICBnZXRVc2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRQbHVnaW4oJ3VzZXInKTtcbiAgICB9XG5cbn1cbiIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiB0aGUgS2ltYWkgdGltZS10cmFja2luZyBhcHAuXG4gKlxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxuICovXG5cbi8qIVxuICogW0tJTUFJXSBLaW1haUxvYWRlcjogYm9vdHN0cmFwIHRoZSBhcHBsaWNhdGlvbiBhbmQgYWxsIHBsdWdpbnNcbiAqL1xuXG5pbXBvcnQgeyBTZXR0aW5ncyB9IGZyb20gJ2x1eG9uJztcbmltcG9ydCBLaW1haVRyYW5zbGF0aW9uIGZyb20gXCIuL0tpbWFpVHJhbnNsYXRpb25cIjtcbmltcG9ydCBLaW1haUNvbmZpZ3VyYXRpb24gZnJvbSBcIi4vS2ltYWlDb25maWd1cmF0aW9uXCI7XG5pbXBvcnQgS2ltYWlDb250YWluZXIgZnJvbSBcIi4vS2ltYWlDb250YWluZXJcIjtcbmltcG9ydCBLaW1haURhdGF0YWJsZUNvbHVtblZpZXcgZnJvbSAnLi9wbHVnaW5zL0tpbWFpRGF0YXRhYmxlQ29sdW1uVmlldy5qcyc7XG5pbXBvcnQgS2ltYWlUaGVtZUluaXRpYWxpemVyIGZyb20gXCIuL3BsdWdpbnMvS2ltYWlUaGVtZUluaXRpYWxpemVyXCI7XG5pbXBvcnQgS2ltYWlEYXRlUmFuZ2VQaWNrZXIgZnJvbSBcIi4vZm9ybXMvS2ltYWlEYXRlUmFuZ2VQaWNrZXJcIjtcbmltcG9ydCBLaW1haURhdGF0YWJsZSBmcm9tIFwiLi9wbHVnaW5zL0tpbWFpRGF0YXRhYmxlXCI7XG5pbXBvcnQgS2ltYWlUb29sYmFyIGZyb20gXCIuL3BsdWdpbnMvS2ltYWlUb29sYmFyXCI7XG5pbXBvcnQgS2ltYWlBUEkgZnJvbSBcIi4vcGx1Z2lucy9LaW1haUFQSVwiO1xuaW1wb3J0IEtpbWFpQWx0ZXJuYXRpdmVMaW5rcyBmcm9tIFwiLi9wbHVnaW5zL0tpbWFpQWx0ZXJuYXRpdmVMaW5rc1wiO1xuaW1wb3J0IEtpbWFpQWpheE1vZGFsRm9ybSBmcm9tIFwiLi9wbHVnaW5zL0tpbWFpQWpheE1vZGFsRm9ybVwiO1xuaW1wb3J0IEtpbWFpQWN0aXZlUmVjb3JkcyBmcm9tIFwiLi9wbHVnaW5zL0tpbWFpQWN0aXZlUmVjb3Jkc1wiO1xuaW1wb3J0IEtpbWFpRXZlbnQgZnJvbSBcIi4vcGx1Z2lucy9LaW1haUV2ZW50XCI7XG5pbXBvcnQgS2ltYWlBUElMaW5rIGZyb20gXCIuL3BsdWdpbnMvS2ltYWlBUElMaW5rXCI7XG5pbXBvcnQgS2ltYWlBbGVydCBmcm9tIFwiLi9wbHVnaW5zL0tpbWFpQWxlcnRcIjtcbmltcG9ydCBLaW1haUF1dG9jb21wbGV0ZSBmcm9tIFwiLi9mb3Jtcy9LaW1haUF1dG9jb21wbGV0ZVwiO1xuaW1wb3J0IEtpbWFpRm9ybVNlbGVjdCBmcm9tIFwiLi9mb3Jtcy9LaW1haUZvcm1TZWxlY3RcIjtcbmltcG9ydCBLaW1haUZvcm0gZnJvbSBcIi4vcGx1Z2lucy9LaW1haUZvcm1cIjtcbmltcG9ydCBLaW1haURhdGVQaWNrZXIgZnJvbSBcIi4vZm9ybXMvS2ltYWlEYXRlUGlja2VyXCI7XG5pbXBvcnQgS2ltYWlDb25maXJtYXRpb25MaW5rIGZyb20gXCIuL3BsdWdpbnMvS2ltYWlDb25maXJtYXRpb25MaW5rXCI7XG5pbXBvcnQgS2ltYWlNdWx0aVVwZGF0ZVRhYmxlIGZyb20gXCIuL3BsdWdpbnMvS2ltYWlNdWx0aVVwZGF0ZVRhYmxlXCI7XG5pbXBvcnQgS2ltYWlEYXRlVXRpbHMgZnJvbSBcIi4vcGx1Z2lucy9LaW1haURhdGVVdGlsc1wiO1xuaW1wb3J0IEtpbWFpRXNjYXBlIGZyb20gXCIuL3BsdWdpbnMvS2ltYWlFc2NhcGVcIjtcbmltcG9ydCBLaW1haUZldGNoIGZyb20gXCIuL3BsdWdpbnMvS2ltYWlGZXRjaFwiO1xuaW1wb3J0IEtpbWFpVGltZXNoZWV0Rm9ybSBmcm9tIFwiLi9mb3Jtcy9LaW1haVRpbWVzaGVldEZvcm1cIjtcbmltcG9ydCBLaW1haVRlYW1Gb3JtIGZyb20gXCIuL2Zvcm1zL0tpbWFpVGVhbUZvcm1cIjtcbmltcG9ydCBLaW1haUNvcHlEYXRhRm9ybSBmcm9tIFwiLi9mb3Jtcy9LaW1haUNvcHlEYXRhRm9ybVwiO1xuaW1wb3J0IEtpbWFpRGF0ZU5vd0Zvcm0gZnJvbSBcIi4vZm9ybXMvS2ltYWlEYXRlTm93Rm9ybVwiO1xuaW1wb3J0IEtpbWFpTm90aWZpY2F0aW9uIGZyb20gXCIuL3BsdWdpbnMvS2ltYWlOb3RpZmljYXRpb25cIjtcbmltcG9ydCBLaW1haUhvdGtleXMgZnJvbSBcIi4vcGx1Z2lucy9LaW1haUhvdGtleXNcIjtcbmltcG9ydCBLaW1haVJlbW90ZU1vZGFsIGZyb20gXCIuL3BsdWdpbnMvS2ltYWlSZW1vdGVNb2RhbFwiO1xuaW1wb3J0IEtpbWFpVXNlciBmcm9tIFwiLi9wbHVnaW5zL0tpbWFpVXNlclwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBLaW1haUxvYWRlciB7XG5cbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9ucywgdHJhbnNsYXRpb25zKSB7XG4gICAgICAgIC8vIHNldCB0aGUgY3VycmVudCBsb2NhbGUgZm9yIGFsbCBqYXZhc2NyaXB0IGNvbXBvbmVudHNcbiAgICAgICAgU2V0dGluZ3MuZGVmYXVsdExvY2FsZSA9IGNvbmZpZ3VyYXRpb25zWydsb2NhbGUnXS5yZXBsYWNlKCdfJywgJy0nKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBTZXR0aW5ncy5kZWZhdWx0Wm9uZSA9IGNvbmZpZ3VyYXRpb25zWyd0aW1lem9uZSddO1xuXG4gICAgICAgIGNvbnN0IGtpbWFpID0gbmV3IEtpbWFpQ29udGFpbmVyKFxuICAgICAgICAgICAgbmV3IEtpbWFpQ29uZmlndXJhdGlvbihjb25maWd1cmF0aW9ucyksXG4gICAgICAgICAgICBuZXcgS2ltYWlUcmFuc2xhdGlvbih0cmFuc2xhdGlvbnMpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gR0xPQkFMIEhFTFBFUiBQTFVHSU5TXG4gICAgICAgIGtpbWFpLnJlZ2lzdGVyUGx1Z2luKG5ldyBLaW1haVVzZXIoKSk7XG4gICAgICAgIGtpbWFpLnJlZ2lzdGVyUGx1Z2luKG5ldyBLaW1haUVzY2FwZSgpKTtcbiAgICAgICAga2ltYWkucmVnaXN0ZXJQbHVnaW4obmV3IEtpbWFpRXZlbnQoKSk7XG4gICAgICAgIGtpbWFpLnJlZ2lzdGVyUGx1Z2luKG5ldyBLaW1haUFQSSgpKTtcbiAgICAgICAga2ltYWkucmVnaXN0ZXJQbHVnaW4obmV3IEtpbWFpQWxlcnQoKSk7XG4gICAgICAgIGtpbWFpLnJlZ2lzdGVyUGx1Z2luKG5ldyBLaW1haUZldGNoKCkpO1xuICAgICAgICBraW1haS5yZWdpc3RlclBsdWdpbihuZXcgS2ltYWlEYXRlVXRpbHMoKSk7XG4gICAgICAgIGtpbWFpLnJlZ2lzdGVyUGx1Z2luKG5ldyBLaW1haU5vdGlmaWNhdGlvbigpKTtcblxuICAgICAgICAvLyBGT1JNIFBMVUdJTlNcbiAgICAgICAga2ltYWkucmVnaXN0ZXJQbHVnaW4obmV3IEtpbWFpRm9ybVNlbGVjdCgnLnNlbGVjdHBpY2tlcicsICdzZWxlY3RbZGF0YS1yZWxhdGVkLXNlbGVjdF0nKSk7XG4gICAgICAgIGtpbWFpLnJlZ2lzdGVyUGx1Z2luKG5ldyBLaW1haURhdGVSYW5nZVBpY2tlcignaW5wdXRbZGF0YS1kYXRlcmFuZ2VwaWNrZXI9XCJvblwiXScpKTtcbiAgICAgICAga2ltYWkucmVnaXN0ZXJQbHVnaW4obmV3IEtpbWFpRGF0ZVBpY2tlcignaW5wdXRbZGF0YS1kYXRlcGlja2VyPVwib25cIl0nKSk7XG4gICAgICAgIGtpbWFpLnJlZ2lzdGVyUGx1Z2luKG5ldyBLaW1haUF1dG9jb21wbGV0ZSgpKTtcbiAgICAgICAga2ltYWkucmVnaXN0ZXJQbHVnaW4obmV3IEtpbWFpVGltZXNoZWV0Rm9ybSgpKTtcbiAgICAgICAga2ltYWkucmVnaXN0ZXJQbHVnaW4obmV3IEtpbWFpVGVhbUZvcm0oKSk7XG4gICAgICAgIGtpbWFpLnJlZ2lzdGVyUGx1Z2luKG5ldyBLaW1haUNvcHlEYXRhRm9ybSgpKTtcbiAgICAgICAga2ltYWkucmVnaXN0ZXJQbHVnaW4obmV3IEtpbWFpRGF0ZU5vd0Zvcm0oKSk7XG4gICAgICAgIGtpbWFpLnJlZ2lzdGVyUGx1Z2luKG5ldyBLaW1haUZvcm0oKSk7XG4gICAgICAgIGtpbWFpLnJlZ2lzdGVyUGx1Z2luKG5ldyBLaW1haUhvdGtleXMoKSk7XG5cbiAgICAgICAgLy8gU1BFQ0lBTCBGRUFUVVJFU1xuICAgICAgICBraW1haS5yZWdpc3RlclBsdWdpbihuZXcgS2ltYWlDb25maXJtYXRpb25MaW5rKCdjb25maXJtYXRpb24tbGluaycpKTtcbiAgICAgICAga2ltYWkucmVnaXN0ZXJQbHVnaW4obmV3IEtpbWFpRGF0YXRhYmxlQ29sdW1uVmlldygnZGF0YS1jb2x1bW4tdmlzaWJpbGl0eScpKTtcbiAgICAgICAga2ltYWkucmVnaXN0ZXJQbHVnaW4obmV3IEtpbWFpRGF0YXRhYmxlKCdzZWN0aW9uLmNvbnRlbnQnLCAndGFibGUuZGF0YVRhYmxlJykpO1xuICAgICAgICBraW1haS5yZWdpc3RlclBsdWdpbihuZXcgS2ltYWlUb29sYmFyKCdmb3JtLnNlYXJjaGZvcm0nLCAndG9vbGJhci1hY3Rpb24nKSk7XG4gICAgICAgIGtpbWFpLnJlZ2lzdGVyUGx1Z2luKG5ldyBLaW1haUFsdGVybmF0aXZlTGlua3MoJy5hbHRlcm5hdGl2ZS1saW5rJykpO1xuICAgICAgICBraW1haS5yZWdpc3RlclBsdWdpbihuZXcgS2ltYWlBamF4TW9kYWxGb3JtKCcubW9kYWwtYWpheC1mb3JtJykpO1xuICAgICAgICBraW1haS5yZWdpc3RlclBsdWdpbihuZXcgS2ltYWlSZW1vdGVNb2RhbCgpKTtcbiAgICAgICAga2ltYWkucmVnaXN0ZXJQbHVnaW4obmV3IEtpbWFpQWN0aXZlUmVjb3JkcygpKTtcbiAgICAgICAga2ltYWkucmVnaXN0ZXJQbHVnaW4obmV3IEtpbWFpQVBJTGluaygnYXBpLWxpbmsnKSk7XG4gICAgICAgIGtpbWFpLnJlZ2lzdGVyUGx1Z2luKG5ldyBLaW1haU11bHRpVXBkYXRlVGFibGUoKSk7XG4gICAgICAgIGtpbWFpLnJlZ2lzdGVyUGx1Z2luKG5ldyBLaW1haVRoZW1lSW5pdGlhbGl6ZXIoKSk7XG5cbiAgICAgICAgLy8gbm90aWZ5IGFsbCBsaXN0ZW5lcnMgdGhhdCBLaW1haSBwbHVnaW5zIGNhbiBub3cgYmUgcmVnaXN0ZXJlZFxuICAgICAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgna2ltYWkucGx1Z2luUmVnaXN0ZXInLCB7ZGV0YWlsOiB7J2tpbWFpJzoga2ltYWl9fSkpO1xuXG4gICAgICAgIC8vIGluaXRpYWxpemUgYWxsIHBsdWdpbnNcbiAgICAgICAga2ltYWkuZ2V0UGx1Z2lucygpLm1hcChwbHVnaW4gPT4geyBwbHVnaW4uaW5pdCgpOyB9KTtcblxuICAgICAgICAvLyBub3RpZnkgYWxsIGxpc3RlbmVycyB0aGF0IEtpbWFpIGlzIG5vdyByZWFkeSB0byBiZSB1c2VkXG4gICAgICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdraW1haS5pbml0aWFsaXplZCcsIHtkZXRhaWw6IHsna2ltYWknOiBraW1haX19KSk7XG5cbiAgICAgICAgdGhpcy5raW1haSA9IGtpbWFpO1xuICAgIH1cblxuICAgIGdldEtpbWFpKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5raW1haTtcbiAgICB9XG5cbn1cbiIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiB0aGUgS2ltYWkgdGltZS10cmFja2luZyBhcHAuXG4gKlxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxuICovXG5cbi8qIVxuICogW0tJTUFJXSBLaW1haVBsdWdpbjogYmFzZSBjbGFzcyBmb3IgYWxsIHBsdWdpbnNcbiAqL1xuXG5pbXBvcnQgS2ltYWlDb250YWluZXIgZnJvbSBcIi4vS2ltYWlDb250YWluZXJcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgS2ltYWlQbHVnaW4ge1xuXG4gICAgLyoqXG4gICAgICogT3ZlcndyaXRlIHRoaXMgbWV0aG9kIHRvIGluaXRpYWxpemUgeW91ciBwbHVnaW4uXG4gICAgICpcbiAgICAgKiBJdCBpcyBjYWxsZWQgQUZURVIgc2V0Q29udGFpbmVyKCkgYW5kIEFGVEVSIERPTUNvbnRlbnRMb2FkZWQgd2FzIGZpcmVkLlxuICAgICAqIFlvdSBkb24ndCBoYXZlIGFjY2VzcyB0byB0aGUgY29udGFpbmVyIGJlZm9yZSB0aGlzIG1ldGhvZCFcbiAgICAgKi9cbiAgICBpbml0KCkge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIHlvdSByZXR1cm4gYW4gSUQsIHlvdSBpbmRpY2F0ZSB0aGF0IHlvdXIgcGx1Z2luIGNhbiBiZSB1c2VkIGJ5IG90aGVyIHBsdWdpbnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgZ2V0SWQoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7S2ltYWlDb250YWluZXJ9IGNvcmVcbiAgICAgKi9cbiAgICBzZXRDb250YWluZXIoY29yZSkge1xuICAgICAgICBpZiAoIShjb3JlIGluc3RhbmNlb2YgS2ltYWlDb250YWluZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsdWdpbiB3YXMgZ2l2ZW4gYW4gaW52YWxpZCBLaW1haUNvbnRhaW5lcicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvcmUgPSBjb3JlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBudWxsLCBpZiB5b3UgY2FsbCBpdCBCRUZPUkUgaW5pdCgpLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0tpbWFpQ29udGFpbmVyfVxuICAgICAqL1xuICAgIGdldENvbnRhaW5lcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvcmU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJucyB7KHN0cmluZ3xudW1iZXJ8Ym9vbGVhbil9XG4gICAgICovXG4gICAgZ2V0Q29uZmlndXJhdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbnRhaW5lcigpLmdldENvbmZpZ3VyYXRpb24oKS5nZXQobmFtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7S2ltYWlDb25maWd1cmF0aW9ufVxuICAgICAqL1xuICAgIGdldENvbmZpZ3VyYXRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb250YWluZXIoKS5nZXRDb25maWd1cmF0aW9uKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0tpbWFpRGF0ZVV0aWxzfVxuICAgICAqL1xuICAgIGdldERhdGVVdGlscygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UGx1Z2luKCdkYXRlJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJucyB7S2ltYWlQbHVnaW59XG4gICAgICovXG4gICAgZ2V0UGx1Z2luKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29udGFpbmVyKCkuZ2V0UGx1Z2luKG5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtLaW1haVRyYW5zbGF0aW9ufVxuICAgICAqL1xuICAgIGdldFRyYW5zbGF0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb250YWluZXIoKS5nZXRUcmFuc2xhdGlvbigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICB0cmFuc2xhdGUobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRUcmFuc2xhdGlvbigpLmdldChuYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGl0bGVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGVzY2FwZSh0aXRsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRQbHVnaW4oJ2VzY2FwZScpLmVzY2FwZUZvckh0bWwodGl0bGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVsbH0gZGV0YWlsc1xuICAgICAqL1xuICAgIHRyaWdnZXIobmFtZSwgZGV0YWlscyA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5nZXRQbHVnaW4oJ2V2ZW50JykudHJpZ2dlcihuYW1lLCBkZXRhaWxzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZXNwb25zZT59XG4gICAgICovXG4gICAgZmV0Y2godXJsLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UGx1Z2luKCdmZXRjaCcpLmZldGNoKHVybCwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtIVE1MRm9ybUVsZW1lbnR9IGZvcm1cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bGx9IHVybFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFJlc3BvbnNlPn1cbiAgICAgKi9cbiAgICBmZXRjaEZvcm0oZm9ybSwgb3B0aW9ucyA9IHt9LCB1cmwgPSBudWxsKSB7XG4gICAgICAgIHVybCA9IHVybCB8fCBmb3JtLmdldEF0dHJpYnV0ZSgnYWN0aW9uJyk7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IGZvcm0uZ2V0QXR0cmlidXRlKCdtZXRob2QnKS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgIGlmIChtZXRob2QgPT09ICdHRVQnKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5nZXRQbHVnaW4oJ2Zvcm0nKS5jb252ZXJ0Rm9ybURhdGFUb1F1ZXJ5U3RyaW5nKGZvcm0sIHt9LCB0cnVlKTtcbiAgICAgICAgICAgIC8vIFRPRE8gY29uc3QgZGF0YSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMobmV3IEZvcm1EYXRhKGZvcm0pKS50b1N0cmluZygpO1xuICAgICAgICAgICAgdXJsID0gdXJsICsgKHVybC5pbmNsdWRlcygnPycpID8gJyYnIDogJz8nKSArIGRhdGE7XG4gICAgICAgICAgICBvcHRpb25zID0gey4uLnttZXRob2Q6ICdHRVQnfSwgLi4ub3B0aW9uc307XG4gICAgICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSAnUE9TVCcpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7Li4ue1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGJvZHk6IG5ldyBGb3JtRGF0YShmb3JtKVxuICAgICAgICAgICAgfSwgLi4ub3B0aW9uc307XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaCh1cmwsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBjdXJyZW50IGRldmljZSBpcyBhIG1vYmlsZSBkZXZpY2UgKHRhcmdldGluZyB0aGUgYm9vdHN0cmlwIHhzIGJyZWFrcG9pbnQgc2l6ZSkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc01vYmlsZSgpIHtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBNYXRoLm1heChcbiAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgIHdpbmRvdy5pbm5lcldpZHRoIHx8IDBcbiAgICAgICAgKVxuXG4gICAgICAgIHJldHVybiB3aWR0aCA8IDU3NjtcbiAgICB9XG59XG4iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgdGhlIEtpbWFpIHRpbWUtdHJhY2tpbmcgYXBwLlxuICpcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cbiAqL1xuXG4vKiFcbiAqIFtLSU1BSV0gS2ltYWlUcmFuc2xhdGlvbjogaGFuZGxpbmcgdHJhbnNsYXRpb24gc3RyaW5nc1xuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEtpbWFpVHJhbnNsYXRpb24ge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheTxzdHJpbmcsIHN0cmluZz59IHRyYW5zbGF0aW9uc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRyYW5zbGF0aW9ucykge1xuICAgICAgICB0aGlzLl90cmFuc2xhdGlvbnMgPSB0cmFuc2xhdGlvbnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFuc2xhdGlvbnNbbmFtZV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXMobmFtZSkge1xuICAgICAgICByZXR1cm4gbmFtZSBpbiB0aGlzLl90cmFuc2xhdGlvbnM7XG4gICAgfVxuXG59XG4iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgdGhlIEtpbWFpIHRpbWUtdHJhY2tpbmcgYXBwLlxuICpcbiAqIE1haW4gSlMgYXBwbGljYXRpb24gZmlsZSBmb3IgS2ltYWkgMi4gVGhpcyBmaWxlIHNob3VsZCBiZSBpbmNsdWRlZCBpbiBhbGwgcGFnZXMuXG4gKlxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxuICovXG5cbi8qIVxuICogW0tJTUFJXSBXcmFwcGVyIGNsYXNzIGZvciBsb2FkaW5nIEtpbWFpIGFwcCBpbiBicm93c2VyIHNjcmlwdCBzY29wZVxuICovXG5cbmltcG9ydCBLaW1haUxvYWRlciBmcm9tIFwiLi9LaW1haUxvYWRlclwiO1xuXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShbXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIChyb290LktpbWFpV2ViTG9hZGVyID0gZmFjdG9yeSgpKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByb290LktpbWFpV2ViTG9hZGVyID0gZmFjdG9yeSgpO1xuICAgIH1cbn0odHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMsIGZ1bmN0aW9uICgpIHtcblxuICAgIGNsYXNzIEtpbWFpV2ViTG9hZGVyIGV4dGVuZHMgS2ltYWlMb2FkZXIge1xuICAgIH1cblxuICAgIHJldHVybiBLaW1haVdlYkxvYWRlcjtcblxufSkpO1xuIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHRoZSBLaW1haSB0aW1lLXRyYWNraW5nIGFwcC5cbiAqXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXG4gKi9cblxuaW1wb3J0IFRvbVNlbGVjdCBmcm9tICd0b20tc2VsZWN0JztcbmltcG9ydCBLaW1haUZvcm1QbHVnaW4gZnJvbSBcIi4vS2ltYWlGb3JtUGx1Z2luXCI7XG5cbi8qKlxuICogU3VwcG9ydGluZyBhdXRvLWNvbXBsZXRlIGZpZWxkcyB2aWEgQVBJLlxuICogVXNlZCBmb3IgdGltZXNoZWV0IHRhZ2dpbmcgaW4gdG9vbGJhciBhbmQgZWRpdCBkaWFsb2dzLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBLaW1haUF1dG9jb21wbGV0ZSBleHRlbmRzIEtpbWFpRm9ybVBsdWdpbiB7XG5cbiAgICBpbml0KClcbiAgICB7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSAnW2RhdGEtZm9ybS13aWRnZXQ9XCJhdXRvY29tcGxldGVcIl0nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7SFRNTEZvcm1FbGVtZW50fSBmb3JtXG4gICAgICogQHJldHVybiBib29sZWFuXG4gICAgICovXG4gICAgc3VwcG9ydHNGb3JtKGZvcm0pIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGFjdGl2YXRlRm9ybShmb3JtKVxuICAgIHtcbiAgICAgICAgLyoqIEB0eXBlIHtLaW1haUFQSX0gQVBJICovXG4gICAgICAgIGNvbnN0IEFQSSA9IHRoaXMuZ2V0Q29udGFpbmVyKCkuZ2V0UGx1Z2luKCdhcGknKTtcblxuICAgICAgICBbXS5zbGljZS5jYWxsKGZvcm0ucXVlcnlTZWxlY3RvckFsbCh0aGlzLnNlbGVjdG9yKSkubWFwKChub2RlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhcGlVcmwgPSBub2RlLmRhdGFzZXRbJ2F1dG9jb21wbGV0ZVVybCddO1xuICAgICAgICAgICAgbGV0IG1pbkNoYXJzID0gMztcbiAgICAgICAgICAgIGlmIChub2RlLmRhdGFzZXRbJ21pbmltdW1DaGFyYWN0ZXInXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbWluQ2hhcnMgPSBwYXJzZUludChub2RlLmRhdGFzZXRbJ21pbmltdW1DaGFyYWN0ZXInXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5ldyBUb21TZWxlY3Qobm9kZSwge1xuICAgICAgICAgICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vb3JjaGlkanMvdG9tLXNlbGVjdC9pc3N1ZXMvNTQzI2lzc3VlY29tbWVudC0xNjY0MzQyMjU3XG4gICAgICAgICAgICAgICAgb25JdGVtQWRkOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgcmVtYWluaW5nIGNoYXJhY3RlcnMgZnJvbSBpbnB1dCBhZnRlciBzZWxlY3RpbmcgYW4gaXRlbVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFRleHRib3hWYWx1ZSgnJyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgbW9yZSB0aGFuIDUwMCwgdGhleSBuZWVkIHRvIGJlIGZvdW5kIGJ5IFwidHlwaW5nXCJcbiAgICAgICAgICAgICAgICBtYXhPcHRpb25zOiA1MDAsXG4gICAgICAgICAgICAgICAgLy8gdGhlIGF1dG9jb21wbGV0ZSBpcyBPTkxZIHVzZWQsIHdoZW4gdGhlIHVzZXIgY2FuIGNyZWF0ZSB0YWdzXG4gICAgICAgICAgICAgICAgY3JlYXRlOiBub2RlLmRhdGFzZXRbJ2NyZWF0ZSddICE9PSB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgb25PcHRpb25BZGQ6ICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBub2RlLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdjcmVhdGUnLCB7ZGV0YWlsOiB7J3ZhbHVlJzogdmFsdWV9fSkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcGx1Z2luczogWydyZW1vdmVfYnV0dG9uJ10sXG4gICAgICAgICAgICAgICAgc2hvdWxkTG9hZDogZnVuY3Rpb24ocXVlcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHF1ZXJ5Lmxlbmd0aCA+PSBtaW5DaGFycztcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGxvYWQ6IChxdWVyeSwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgICAgICAgICAgQVBJLmdldChhcGlVcmwsIHsnbmFtZSc6IHF1ZXJ5fSwgKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXS5zbGljZS5jYWxsKGRhdGEpLm1hcCgocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHt0ZXh0OiByZXN1bHQsIHZhbHVlOiByZXN1bHR9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHRzKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZW5kZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICAgICAgICAgIG5vdF9sb2FkaW5nOiAoZGF0YSwgZXNjYXBlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBubyBkZWZhdWx0IGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uX2NyZWF0ZTogKGRhdGEsIGVzY2FwZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGVzY2FwZShkYXRhLmlucHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYW1lLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRwbCA9IHRoaXMudHJhbnNsYXRlKCdzZWxlY3Quc2VhcmNoLmNyZWF0ZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHBsUmVwbGFjZWQgPSB0cGwucmVwbGFjZSgnJWlucHV0JScsICc8c3Ryb25nPicgKyBuYW1lICsgJzwvc3Ryb25nPicpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJzxkaXYgY2xhc3M9XCJjcmVhdGVcIj4nICsgdHBsUmVwbGFjZWQgKyAnPC9kaXY+JztcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbm9fcmVzdWx0czogKGRhdGEsIGVzY2FwZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHBsID0gdGhpcy50cmFuc2xhdGUoJ3NlbGVjdC5zZWFyY2gubm90Zm91bmQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRwbFJlcGxhY2VkID0gdHBsLnJlcGxhY2UoJyVpbnB1dCUnLCAnPHN0cm9uZz4nICsgZXNjYXBlKGRhdGEuaW5wdXQpICsgJzwvc3Ryb25nPicpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJzxkaXYgY2xhc3M9XCJuby1yZXN1bHRzXCI+JyArIHRwbFJlcGxhY2VkICsgJzwvZGl2Pic7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBkZXN0cm95Rm9ybShmb3JtKSB7XG4gICAgICAgIFtdLnNsaWNlLmNhbGwoZm9ybS5xdWVyeVNlbGVjdG9yQWxsKHRoaXMuc2VsZWN0b3IpKS5tYXAoKG5vZGUpID0+IHtcbiAgICAgICAgICAgIGlmIChub2RlLnRvbXNlbGVjdCkge1xuICAgICAgICAgICAgICAgIG5vZGUudG9tc2VsZWN0LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG59XG4iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgdGhlIEtpbWFpIHRpbWUtdHJhY2tpbmcgYXBwLlxuICpcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cbiAqL1xuXG4vKiFcbiAqIFtLSU1BSV0gS2ltYWlFZGl0VGltZXNoZWV0Rm9ybTogcmVzcG9uc2libGUgZm9yIHRoZSBtb3N0IGltcG9ydGFudCBmb3JtIGluIHRoZSBhcHBsaWNhdGlvblxuICovXG5cbmltcG9ydCBLaW1haUZvcm1QbHVnaW4gZnJvbSBcIi4vS2ltYWlGb3JtUGx1Z2luXCI7XG5cbi8qKlxuICogVXNlZCBmb3Igc2ltcGxlIGNvcHkgZnJvbSBsaW5rIHRvIGlucHV0IGFjdGlvbiwgZS5nLiB0aGUgdGltZSBhbmQgZHVyYXRpb24gZHJvcGRvd25zXG4gKiBjb3B5IHRoZSBzZWxlY3RlZCB2YWx1ZXMgaW50byB0aGVpciBjb3JyZXNwb25kaW5nIGlucHV0LlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBLaW1haUNvcHlEYXRhRm9ybSBleHRlbmRzIEtpbWFpRm9ybVBsdWdpbiB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0hUTUxGb3JtRWxlbWVudH0gZm9ybVxuICAgICAqIEByZXR1cm4gYm9vbGVhblxuICAgICAqL1xuICAgIHN1cHBvcnRzRm9ybShmb3JtKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0hUTUxGb3JtRWxlbWVudH0gZm9ybVxuICAgICAqL1xuICAgIGFjdGl2YXRlRm9ybShmb3JtKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAge1xuICAgICAgICBpZiAodGhpcy5fZXZlbnRIYW5kbGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50SGFuZGxlciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBlbGVtZW50ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgICAgIGlmICghZWxlbWVudC5tYXRjaGVzKCdhW2RhdGEtZm9ybS13aWRnZXQ9XCJjb3B5LWRhdGFcIl0nKSkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlOyAvLyBtb3N0bHkgZm9yIGljb25zXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZWxlbWVudC5tYXRjaGVzKCdhW2RhdGEtZm9ybS13aWRnZXQ9XCJjb3B5LWRhdGFcIl0nKSB8fCBlbGVtZW50LmRhdGFzZXQudGFyZ2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsZW1lbnQuZGF0YXNldC50YXJnZXQpO1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0YXJnZXQudmFsdWUgPSBlbGVtZW50LmRhdGFzZXQudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuZGF0YXNldC5ldmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZXZlbnQgb2YgZWxlbWVudC5kYXRhc2V0LmV2ZW50LnNwbGl0KCcgJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChldmVudCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50LmRhdGFzZXQuZXZlbnRCdWJibGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBldmVudCBvZiBlbGVtZW50LmRhdGFzZXQuZXZlbnRCdWJibGVzLnNwbGl0KCcgJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChldmVudCwge2J1YmJsZXM6IHRydWV9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZm9ybS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2V2ZW50SGFuZGxlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtIVE1MRm9ybUVsZW1lbnR9IGZvcm1cbiAgICAgKi9cbiAgICBkZXN0cm95Rm9ybShmb3JtKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAge1xuICAgICAgICBmb3JtLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fZXZlbnRIYW5kbGVyKTtcbiAgICB9XG5cbn1cbiIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiB0aGUgS2ltYWkgdGltZS10cmFja2luZyBhcHAuXG4gKlxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxuICovXG5cbi8qIVxuICogW0tJTUFJXSBLaW1haUVkaXRUaW1lc2hlZXRGb3JtOiByZXNwb25zaWJsZSBmb3IgdGhlIG1vc3QgaW1wb3J0YW50IGZvcm0gaW4gdGhlIGFwcGxpY2F0aW9uXG4gKi9cblxuaW1wb3J0IEtpbWFpRm9ybVBsdWdpbiBmcm9tIFwiLi9LaW1haUZvcm1QbHVnaW5cIjtcblxuLyoqXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEtpbWFpRGF0ZU5vd0Zvcm0gZXh0ZW5kcyBLaW1haUZvcm1QbHVnaW4ge1xuXG4gICAgaW5pdCgpXG4gICAge1xuICAgICAgICB0aGlzLnNlbGVjdG9yID0gJ2FbZGF0YS1mb3JtLXdpZGdldD1cImRhdGUtbm93XCJdJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0hUTUxGb3JtRWxlbWVudH0gZm9ybVxuICAgICAqIEByZXR1cm4gYm9vbGVhblxuICAgICAqL1xuICAgIHN1cHBvcnRzRm9ybShmb3JtKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0hUTUxGb3JtRWxlbWVudH0gZm9ybVxuICAgICAqL1xuICAgIGFjdGl2YXRlRm9ybShmb3JtKVxuICAgIHtcbiAgICAgICAgW10uc2xpY2UuY2FsbChmb3JtLnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5zZWxlY3RvcikpLm1hcCgoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQuZGF0YXNldC5mb3JtYXQgIT09IHVuZGVmaW5lZCAmJiBlbGVtZW50LmRhdGFzZXQudGFyZ2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZXZlbnRIYW5kbGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRIYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5rVGFyZ2V0ID0gZXZlbnQuY3VycmVudFRhcmdldDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZm9ybUVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChsaW5rVGFyZ2V0LmRhdGFzZXQudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZm9ybUVsZW1lbnQuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtRWxlbWVudC52YWx1ZSA9IHRoaXMuZ2V0RGF0ZVV0aWxzKCkuZm9ybWF0KGxpbmtUYXJnZXQuZGF0YXNldC5mb3JtYXQsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1FbGVtZW50LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdjaGFuZ2UnLCB7YnViYmxlczogdHJ1ZX0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2V2ZW50SGFuZGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtIVE1MRm9ybUVsZW1lbnR9IGZvcm1cbiAgICAgKi9cbiAgICBkZXN0cm95Rm9ybShmb3JtKVxuICAgIHtcbiAgICAgICAgW10uc2xpY2UuY2FsbChmb3JtLnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5zZWxlY3RvcikpLm1hcCgoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQuZGF0YXNldC5mb3JtYXQgIT09IHVuZGVmaW5lZCAmJiBlbGVtZW50LmRhdGFzZXQudGFyZ2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fZXZlbnRIYW5kbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG59XG4iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgdGhlIEtpbWFpIHRpbWUtdHJhY2tpbmcgYXBwLlxuICpcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cbiAqL1xuXG4vKiFcbiAqIFtLSU1BSV0gS2ltYWlEYXRlUGlja2VyOiBzaW5nbGUgZGF0ZSBzZWxlY3RzIChjdXJyZW50bHkgdW51c2VkKVxuICovXG5cbmltcG9ydCB7IExpdGVwaWNrZXIgfSBmcm9tICdsaXRlcGlja2VyJztcbmltcG9ydCAnbGl0ZXBpY2tlci9kaXN0L3BsdWdpbnMvbW9iaWxlZnJpZW5kbHknO1xuaW1wb3J0IEtpbWFpRm9ybVBsdWdpbiBmcm9tIFwiLi9LaW1haUZvcm1QbHVnaW5cIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgS2ltYWlEYXRlUGlja2VyIGV4dGVuZHMgS2ltYWlGb3JtUGx1Z2luIHtcblxuICAgIGNvbnN0cnVjdG9yKHNlbGVjdG9yKVxuICAgIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICB9XG5cbiAgICBpbml0KClcbiAgICB7XG4gICAgICAgIHdpbmRvdy5kaXNhYmxlTGl0ZXBpY2tlclN0eWxlcyA9IHRydWU7XG4gICAgICAgIHRoaXMuX3BpY2tlcnMgPSBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0hUTUxGb3JtRWxlbWVudH0gZm9ybVxuICAgICAqIEByZXR1cm4gYm9vbGVhblxuICAgICAqL1xuICAgIHN1cHBvcnRzRm9ybShmb3JtKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0hUTUxGb3JtRWxlbWVudH0gZm9ybVxuICAgICAqL1xuICAgIGFjdGl2YXRlRm9ybShmb3JtKVxuICAgIHtcbiAgICAgICAgY29uc3QgRklSU1RfRE9XID0gdGhpcy5nZXRDb25maWd1cmF0aW9ucygpLmdldEZpcnN0RGF5T2ZXZWVrKGZhbHNlKTtcbiAgICAgICAgY29uc3QgTEFOR1VBR0UgPSB0aGlzLmdldENvbmZpZ3VyYXRpb25zKCkuZ2V0TGFuZ3VhZ2UoKTtcblxuICAgICAgICBsZXQgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGJ1dHRvblRleHQ6IHtcbiAgICAgICAgICAgICAgICBwcmV2aW91c01vbnRoOiBgPGkgY2xhc3M9XCJmYXMgZmEtY2hldnJvbi1sZWZ0XCI+PC9pPmAsXG4gICAgICAgICAgICAgICAgbmV4dE1vbnRoOiBgPGkgY2xhc3M9XCJmYXMgZmEtY2hldnJvbi1yaWdodFwiPjwvaT5gLFxuICAgICAgICAgICAgICAgIGFwcGx5OiB0aGlzLnRyYW5zbGF0ZSgnY29uZmlybScpLFxuICAgICAgICAgICAgICAgIGNhbmNlbDogdGhpcy50cmFuc2xhdGUoJ2NhbmNlbCcpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBuZXdQaWNrZXJzID0gW10uc2xpY2UuY2FsbChmb3JtLnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5fc2VsZWN0b3IpKS5tYXAoKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50LmRhdGFzZXQuZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVHJ5aW5nIHRvIGJpbmQgbGl0ZXBpY2tlciB0byBhbiBlbGVtZW50IHdpdGhvdXQgZGF0YS1mb3JtYXQgYXR0cmlidXRlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRpb25zID0gey4uLm9wdGlvbnMsIC4uLntcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IGVsZW1lbnQuZGF0YXNldC5mb3JtYXQsXG4gICAgICAgICAgICAgICAgc2hvd1Rvb2x0aXA6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgICAgICAgICAgbGFuZzogTEFOR1VBR0UsXG4gICAgICAgICAgICAgICAgYXV0b1JlZnJlc2g6IHRydWUsXG4gICAgICAgICAgICAgICAgZmlyc3REYXk6IEZJUlNUX0RPVywgLy8gTGl0ZXBpY2tlcjogMCA9IFN1bmRheSwgMSA9IE1vbmRheVxuICAgICAgICAgICAgICAgIHNldHVwOiAocGlja2VyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5hc3R5IGhhY2ssIGJlY2F1c2UgbGl0ZXBpY2tlciBkb2VzIG5vdCB0cmlnZ2VyIGNoYW5nZSBldmVudCBvbiB0aGUgaW5wdXQgYW5kIHRoZSBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICAgICAgLy8gZXZlbnQgXCJzZWxlY3RlZFwiIGlzIHRyaWdnZXJlZCB3aHkgdG8gb2Z0ZW4sIGV2ZW4gd2hlbiBtb3ZpbmcgdGhlIGN1cnNvciBpbnNpZGUgdGhlIGlucHV0XG4gICAgICAgICAgICAgICAgICAgIC8vIGVsZW1lbnQgKG5vdCBldmVuIHR5cGluZyBpcyBuZWNlc3NhcnkpIGFuZCBzbyB3ZSBoYXZlIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBtYW51YWwgXCJjbGlja1wiIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgIC8vICh3b3JrcyBmb3IgdG91Y2ggYXMgd2VsbCkgaGFwcGVuZWQgYmVmb3JlIHdlIGFjdHVhbGx5IGRpc3BhdGNoIHRoZSBjaGFuZ2UgZXZlbnQgbWFudWFsbHkgLi4uXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoYXQ/IHJlcG9ydCBmb3JtcyB3b3VsZCBiZSBzdWJtaXR0ZWQgdXBvbiBjdXJzb3IgbW92ZSB3aXRob3V0IHRoZSBcInByZXNlbGVjdOKAnSBjaGVja1xuICAgICAgICAgICAgICAgICAgICBwaWNrZXIub24oJ3ByZXNlbGVjdCcsIChkYXRlMSwgZGF0ZTIpID0+IHsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpY2tlci5fd2FzUHJlc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcGlja2VyLm9uKCdzZWxlY3RlZCcsIChkYXRlMSwgZGF0ZTIpID0+IHsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwaWNrZXIuX3dhc1ByZXNlbGVjdGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdjaGFuZ2UnLCB7YnViYmxlczogdHJ1ZX0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgcGlja2VyLl93YXNQcmVzZWxlY3RlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gb25seSBpZiBtb2JpbGUuZnJpZW5kbHkgcGx1Z2luIGlzIGFjdGl2YXRlZFxuICAgICAgICAgICAgICAgICAgICBpZiAocGlja2VyLmJhY2tkcm9wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBub2RlIG5lZWRzIHRvIGJlIG1vdmVkLCBzbyB0aGUgZmxhdCBmb3JtIGxheW91dCB3b3JrcyBwcm9wZXJseSAoZS5nLiBmb3IgZGF0ZSB0eXBlcylcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocGlja2VyLmJhY2tkcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9fTtcblxuICAgICAgICAgICAgcmV0dXJuIFtlbGVtZW50LCBuZXcgTGl0ZXBpY2tlcih0aGlzLnByZXBhcmVPcHRpb25zKG9wdGlvbnMpKV07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX3BpY2tlcnMgPSB0aGlzLl9waWNrZXJzLmNvbmNhdChuZXdQaWNrZXJzKTtcbiAgICB9XG5cbiAgICBwcmVwYXJlT3B0aW9ucyhvcHRpb25zKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHsuLi5vcHRpb25zLCAuLi57XG4gICAgICAgICAgICBwbHVnaW5zOiBbJ21vYmlsZWZyaWVuZGx5J10sXG4gICAgICAgIH19O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7SFRNTEZvcm1FbGVtZW50fSBmb3JtXG4gICAgICovXG4gICAgZGVzdHJveUZvcm0oZm9ybSlcbiAgICB7XG4gICAgICAgIFtdLnNsaWNlLmNhbGwoZm9ybS5xdWVyeVNlbGVjdG9yQWxsKHRoaXMuX3NlbGVjdG9yKSkubWFwKChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3BpY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcGlja2Vyc1tpXVswXSA9PT0gZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9waWNrZXJzW2ldWzFdLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGlja2Vycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbn1cbiIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiB0aGUgS2ltYWkgdGltZS10cmFja2luZyBhcHAuXG4gKlxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxuICovXG5cbi8qIVxuICogW0tJTUFJXSBLaW1haURhdGVSYW5nZVBpY2tlcjogYWN0aXZhdGUgdGhlIChkYXRlcmFuZ2UgcGlja2VyKSBjb21wb3VuZCBmaWVsZCBpbiB0b29sYmFyXG4gKi9cblxuaW1wb3J0IEtpbWFpRGF0ZVBpY2tlciBmcm9tIFwiLi9LaW1haURhdGVQaWNrZXJcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgS2ltYWlEYXRlUmFuZ2VQaWNrZXIgZXh0ZW5kcyBLaW1haURhdGVQaWNrZXIge1xuXG4gICAgcHJlcGFyZU9wdGlvbnMob3B0aW9ucylcbiAgICB7XG4gICAgICAgIHJldHVybiB7Li4ub3B0aW9ucywgLi4ue1xuICAgICAgICAgICAgcGx1Z2luczogWydtb2JpbGVmcmllbmRseSddLFxuICAgICAgICAgICAgc2luZ2xlTW9kZTogZmFsc2UsXG4gICAgICAgICAgICBhdXRvUmVmcmVzaDogdHJ1ZSxcbiAgICAgICAgfX07XG4gICAgfVxuXG59XG4iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgdGhlIEtpbWFpIHRpbWUtdHJhY2tpbmcgYXBwLlxuICpcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cbiAqL1xuXG4vKiFcbiAqIFtLSU1BSV0gS2ltYWlGb3JtUGx1Z2luOiBiYXNlIGNsYXNzIGZvciBhbGwgbm9uZSBJRCBwbHVnaW4gdGhhdCBoYW5kbGUgZm9ybXNcbiAqL1xuXG5pbXBvcnQgS2ltYWlQbHVnaW4gZnJvbSAnLi4vS2ltYWlQbHVnaW4nO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBLaW1haUZvcm1QbHVnaW4gZXh0ZW5kcyBLaW1haVBsdWdpbiB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0hUTUxGb3JtRWxlbWVudH0gZm9ybVxuICAgICAqIEByZXR1cm4gYm9vbGVhblxuICAgICAqL1xuICAgIHN1cHBvcnRzRm9ybShmb3JtKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtIVE1MRm9ybUVsZW1lbnR9IGZvcm1cbiAgICAgKi9cbiAgICBhY3RpdmF0ZUZvcm0oZm9ybSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0hUTUxGb3JtRWxlbWVudH0gZm9ybVxuICAgICAqL1xuICAgIGRlc3Ryb3lGb3JtKGZvcm0pIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB7XG4gICAgfVxuXG59XG4iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgdGhlIEtpbWFpIHRpbWUtdHJhY2tpbmcgYXBwLlxuICpcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cbiAqL1xuXG4vKiFcbiAqIFtLSU1BSV0gS2ltYWlGb3JtU2VsZWN0OiBlbmhhbmNlZCBmdW5jdGlvbmFsaXR5IGZvciBIVE1MU2VsZWN0RWxlbWVudFxuICovXG5cbmltcG9ydCBUb21TZWxlY3QgZnJvbSAndG9tLXNlbGVjdCc7XG5pbXBvcnQgS2ltYWlGb3JtUGx1Z2luIGZyb20gXCIuL0tpbWFpRm9ybVBsdWdpblwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBLaW1haUZvcm1TZWxlY3QgZXh0ZW5kcyBLaW1haUZvcm1QbHVnaW4ge1xuXG4gICAgY29uc3RydWN0b3Ioc2VsZWN0b3IsIGFwaVNlbGVjdHMpXG4gICAge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICB0aGlzLl9hcGlTZWxlY3RzID0gYXBpU2VsZWN0cztcbiAgICB9XG5cbiAgICBnZXRJZCgpXG4gICAge1xuICAgICAgICByZXR1cm4gJ2Zvcm0tc2VsZWN0JztcbiAgICB9XG5cbiAgICBpbml0KClcbiAgICB7XG4gICAgICAgIC8vIHNlbGVjdHMgdGhlIG9yaWdpbmFsIHZhbHVlIGluc2lkZSBkcm9wZG93bnMsIGFzIHRoZSBcInJlc2V0XCIgZXZlbnQgKHRoZSB1cGRhdGVkIG9wdGlvbilcbiAgICAgICAgLy8gaXMgbm90IGF1dG9tYXRpY2FsbHkgcHJvcGFnYXRlZCB0byB0aGUgSlMgZWxlbWVudFxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdyZXNldCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnRhcmdldC50YWdOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdGT1JNJykge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWVsZHMgPSBldmVudC50YXJnZXQucXVlcnlTZWxlY3RvckFsbCh0aGlzLl9zZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGZpZWxkIG9mIGZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkLnRhZ05hbWUudG9VcHBlckNhc2UoKSA9PT0gJ1NFTEVDVCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnZGF0YS1yZWxvYWRlZCcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtIVE1MRm9ybUVsZW1lbnR9IG5vZGVcbiAgICAgKi9cbiAgICBhY3RpdmF0ZVNlbGVjdFBpY2tlckJ5RWxlbWVudChub2RlKVxuICAgIHtcbiAgICAgICAgbGV0IHBsdWdpbnMgPSBbJ2NoYW5nZV9saXN0ZW5lciddO1xuXG4gICAgICAgIGNvbnN0IGlzTXVsdGlwbGUgPSBub2RlLm11bHRpcGxlICE9PSB1bmRlZmluZWQgJiYgbm9kZS5tdWx0aXBsZSA9PT0gdHJ1ZTtcbiAgICAgICAgY29uc3QgaXNSZXF1aXJlZCA9IG5vZGUucmVxdWlyZWQgIT09IHVuZGVmaW5lZCAmJiBub2RlLnJlcXVpcmVkID09PSB0cnVlO1xuXG4gICAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgICAgICBwbHVnaW5zLnB1c2goJ25vX2JhY2tzcGFjZV9kZWxldGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc011bHRpcGxlKSB7XG4gICAgICAgICAgICBwbHVnaW5zLnB1c2goJ3JlbW92ZV9idXR0b24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qXG4gICAgICAgIGNvbnN0IGlzT3JkZXJpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKGlzT3JkZXJpbmcpIHtcbiAgICAgICAgICAgIHBsdWdpbnMucHVzaCgnY2FyZXRfcG9zaXRpb24nKTtcbiAgICAgICAgICAgIHBsdWdpbnMucHVzaCgnZHJhZ19kcm9wJyk7XG4gICAgICAgIH1cbiAgICAgICAgKi9cblxuICAgICAgICBsZXQgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vb3JjaGlkanMvdG9tLXNlbGVjdC9pc3N1ZXMvNTQzI2lzc3VlY29tbWVudC0xNjY0MzQyMjU3XG4gICAgICAgICAgICBvbkl0ZW1BZGQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHJlbWFpbmluZyBjaGFyYWN0ZXJzIGZyb20gaW5wdXQgYWZ0ZXIgc2VsZWN0aW5nIGFuIGl0ZW1cbiAgICAgICAgICAgICAgICB0aGlzLnNldFRleHRib3hWYWx1ZSgnJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbG9ja09wdGdyb3VwT3JkZXI6IHRydWUsXG4gICAgICAgICAgICBhbGxvd0VtcHR5T3B0aW9uOiAhaXNSZXF1aXJlZCxcbiAgICAgICAgICAgIGhpZGVQbGFjZWhvbGRlcjogZmFsc2UsXG4gICAgICAgICAgICBwbHVnaW5zOiBwbHVnaW5zLFxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG1vcmUgdGhhbiBYIGVudHJpZXMsIHRoZSBvdGhlciBvbmVzIGFyZSBoaWRkZW4gYW5kIGNhbiBvbmx5IGJlIGZvdW5kXG4gICAgICAgICAgICAvLyBieSB0eXBpbmcgc29tZSBjaGFyYWN0ZXJzIHRvIHRyaWdnZXIgdGhlIGludGVybmFsIG9wdGlvbiBzZWFyY2hcbiAgICAgICAgICAgIG1heE9wdGlvbnM6IDUwMCxcbiAgICAgICAgfTtcblxuICAgICAgICBsZXQgcmVuZGVyID0ge1xuICAgICAgICAgICAgb3B0aW9uX2NyZWF0ZTogKGRhdGEsIGVzY2FwZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBlc2NhcGUoZGF0YS5pbnB1dCk7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUubGVuZ3RoIDwgMykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdHBsID0gdGhpcy50cmFuc2xhdGUoJ3NlbGVjdC5zZWFyY2guY3JlYXRlJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHBsUmVwbGFjZWQgPSB0cGwucmVwbGFjZSgnJWlucHV0JScsICc8c3Ryb25nPicgKyBuYW1lICsgJzwvc3Ryb25nPicpO1xuICAgICAgICAgICAgICAgIHJldHVybiAnPGRpdiBjbGFzcz1cImNyZWF0ZVwiPicgKyB0cGxSZXBsYWNlZCArICc8L2Rpdj4nO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5vX3Jlc3VsdHM6IChkYXRhLCBlc2NhcGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cGwgPSB0aGlzLnRyYW5zbGF0ZSgnc2VsZWN0LnNlYXJjaC5ub3Rmb3VuZCcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRwbFJlcGxhY2VkID0gdHBsLnJlcGxhY2UoJyVpbnB1dCUnLCAnPHN0cm9uZz4nICsgZXNjYXBlKGRhdGEuaW5wdXQpICsgJzwvc3Ryb25nPicpO1xuICAgICAgICAgICAgICAgIHJldHVybiAnPGRpdiBjbGFzcz1cIm5vLXJlc3VsdHNcIj4nICsgdHBsUmVwbGFjZWQgKyAnPC9kaXY+JztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbk9wdGlvbkFkZDogKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgbm9kZS5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnY3JlYXRlJywge2RldGFpbDogeyd2YWx1ZSc6IHZhbHVlfX0pKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG5vZGUuZGF0YXNldFsnY3JlYXRlJ10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHsuLi5vcHRpb25zLCAuLi57XG4gICAgICAgICAgICAgICAgcGVyc2lzdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjcmVhdGU6IHRydWUsXG4gICAgICAgICAgICB9fTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7Li4ub3B0aW9ucywgLi4ue1xuICAgICAgICAgICAgICAgIHBlcnNpc3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNyZWF0ZTogZmFsc2UsXG4gICAgICAgICAgICB9fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub2RlLmRhdGFzZXQuZGlzYWJsZVNlYXJjaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gey4uLm9wdGlvbnMsIC4uLntcbiAgICAgICAgICAgICAgICBjb250cm9sSW5wdXQ6IG51bGwsXG4gICAgICAgICAgICB9fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub2RlLmRhdGFzZXRbJ3JlbmRlcmVyJ10gIT09IHVuZGVmaW5lZCAmJiBub2RlLmRhdGFzZXRbJ3JlbmRlcmVyJ10gPT09ICdjb2xvcicpIHtcbiAgICAgICAgICAgIG9wdGlvbnMucmVuZGVyID0gey4uLnJlbmRlciwgLi4ue1xuICAgICAgICAgICAgICAgIG9wdGlvbjogZnVuY3Rpb24oZGF0YSwgZXNjYXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpdGVtID0gJzxkaXYgY2xhc3M9XCJsaXN0LWdyb3VwLWl0ZW0gYm9yZGVyLTAgcC0xIHBzLTIgdGV4dC1ub3dyYXBcIj4nO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5jb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtICs9ICc8c3BhbiBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6JyArIGRhdGEuY29sb3IgKyAnXCIgY2xhc3M9XCJjb2xvci1jaG9pY2UtaXRlbVwiPiZuYnNwOzwvc3Bhbj4nO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSArPSAnPHNwYW4gY2xhc3M9XCJjb2xvci1jaG9pY2UtaXRlbVwiPiZuYnNwOzwvc3Bhbj4nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0gKz0gZXNjYXBlKGRhdGEudGV4dCkgKyAnPC9kaXY+JztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpdGVtOiBmdW5jdGlvbihkYXRhLCBlc2NhcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGl0ZW0gPSAnPGRpdiBjbGFzcz1cInRleHQtbm93cmFwXCI+JztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuY29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSArPSAnPHNwYW4gc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOicgKyBkYXRhLmNvbG9yICsgJ1wiIGNsYXNzPVwiY29sb3ItY2hvaWNlLWl0ZW1cIj4mbmJzcDs8L3NwYW4+JztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gKz0gJzxzcGFuIGNsYXNzPVwiY29sb3ItY2hvaWNlLWl0ZW1cIj4mbmJzcDs8L3NwYW4+JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpdGVtICs9IGVzY2FwZShkYXRhLnRleHQpICsgJzwvZGl2Pic7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH19O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucy5yZW5kZXIgPSB7Li4ucmVuZGVyLCAuLi57XG4gICAgICAgICAgICAgICAgLy8gdGhlIGVtcHR5IGVudHJ5IHdvdWxkIGNvbGxhcHNlIGFuZCBvbmx5IHNob3cgYXMgYSB0aW55IDVweCBsaW5lIGlmIHRoZXJlIGlzIG5vIGNvbnRlbnQgaW5zaWRlXG4gICAgICAgICAgICAgICAgb3B0aW9uOiBmdW5jdGlvbihkYXRhLCBlc2NhcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRleHQgPSBkYXRhLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0ID09PSBudWxsIHx8IHRleHQudHJpbSgpID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9ICcmbmJzcDsnO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9IGVzY2FwZSh0ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJzxkaXY+JyArIHRleHQgKyAnPC9kaXY+JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNlbGVjdCA9IG5ldyBUb21TZWxlY3Qobm9kZSwgb3B0aW9ucyk7XG4gICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignZGF0YS1yZWxvYWRlZCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgc2VsZWN0LmNsZWFyKHRydWUpO1xuICAgICAgICAgICAgc2VsZWN0LmNsZWFyT3B0aW9uR3JvdXBzKCk7XG4gICAgICAgICAgICBzZWxlY3QuY2xlYXJPcHRpb25zKCk7XG4gICAgICAgICAgICBzZWxlY3Quc3luYygpO1xuICAgICAgICAgICAgc2VsZWN0LnNldFZhbHVlKGV2ZW50LmRldGFpbCk7XG4gICAgICAgICAgICBzZWxlY3QucmVmcmVzaEl0ZW1zKCk7XG4gICAgICAgICAgICBzZWxlY3QucmVmcmVzaE9wdGlvbnMoZmFsc2UpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBzdXBwb3J0IHJlbG9hZGluZyB0aGUgbGlzdCB1cG9uIGV4dGVybmFsIGV2ZW50XG4gICAgICAgIGlmIChub2RlLmRhdGFzZXRbJ3JlbG9hZCddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcigncmVsb2FkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNlbGVjdC5kaXNhYmxlKCk7XG4gICAgICAgICAgICAgICAgbm9kZS5kaXNhYmxlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAvKiogQHR5cGUge0tpbWFpQVBJfSBBUEkgKi9cbiAgICAgICAgICAgICAgICBjb25zdCBBUEkgPSB0aGlzLmdldENvbnRhaW5lcigpLmdldFBsdWdpbignYXBpJyk7XG5cbiAgICAgICAgICAgICAgICBBUEkuZ2V0KG5vZGUuZGF0YXNldFsncmVsb2FkJ10sIHt9LCAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVTZWxlY3Qobm9kZSwgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdC5lbmFibGUoKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgbm9kZS5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnY2hhbmdlJykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0hUTUxGb3JtRWxlbWVudH0gZm9ybVxuICAgICAqIEByZXR1cm4gYm9vbGVhblxuICAgICAqL1xuICAgIHN1cHBvcnRzRm9ybShmb3JtKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0hUTUxGb3JtRWxlbWVudH0gZm9ybVxuICAgICAqL1xuICAgIGFjdGl2YXRlRm9ybShmb3JtKVxuICAgIHtcbiAgICAgICAgW10uc2xpY2UuY2FsbChmb3JtLnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5fc2VsZWN0b3IpKS5tYXAoKG5vZGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZhdGVTZWxlY3RQaWNrZXJCeUVsZW1lbnQobm9kZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX2FjdGl2YXRlQXBpU2VsZWN0cyh0aGlzLl9hcGlTZWxlY3RzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0hUTUxGb3JtRWxlbWVudH0gZm9ybVxuICAgICAqL1xuICAgIGRlc3Ryb3lGb3JtKGZvcm0pXG4gICAge1xuICAgICAgICBbXS5zbGljZS5jYWxsKGZvcm0ucXVlcnlTZWxlY3RvckFsbCh0aGlzLl9zZWxlY3RvcikpLm1hcCgobm9kZSkgPT4ge1xuICAgICAgICAgICAgaWYgKG5vZGUudG9tc2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgbm9kZS50b21zZWxlY3QuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xFbGVtZW50fSBzZWxlY3RJZGVudGlmaWVyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91cGRhdGVPcHRpb25zKHNlbGVjdElkZW50aWZpZXIsIGRhdGEpXG4gICAge1xuICAgICAgICBsZXQgZW1wdHlPcHRpb24gPSBudWxsO1xuICAgICAgICBsZXQgbm9kZSA9IG51bGw7XG4gICAgICAgIGlmIChzZWxlY3RJZGVudGlmaWVyIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICAgICAgbm9kZSA9IHNlbGVjdElkZW50aWZpZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2RlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RJZGVudGlmaWVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ01pc3Npbmcgc2VsZWN0OiAnICsgc2VsZWN0SWRlbnRpZmllcik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRWYWx1ZSA9IG5vZGUudmFsdWU7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLm9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChub2RlLm9wdGlvbnNbaV0udmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgZW1wdHlPcHRpb24gPSBub2RlLm9wdGlvbnNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBub2RlLm9wdGlvbnMubGVuZ3RoID0gMDtcblxuICAgICAgICBpZiAoZW1wdHlPcHRpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQodGhpcy5fY3JlYXRlT3B0aW9uKGVtcHR5T3B0aW9uLnRleHQsICcnKSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZW1wdHlPcHRzID0gW107XG4gICAgICAgIGxldCBvcHRpb25zID0gW107XG4gICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfG51bGx9IHRpdGxlUGF0dGVybiAqL1xuICAgICAgICBsZXQgdGl0bGVQYXR0ZXJuID0gbnVsbDtcbiAgICAgICAgaWYgKG5vZGUuZGF0YXNldCAhPT0gdW5kZWZpbmVkICYmIG5vZGUuZGF0YXNldFsnb3B0aW9uUGF0dGVybiddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRpdGxlUGF0dGVybiA9IG5vZGUuZGF0YXNldFsnb3B0aW9uUGF0dGVybiddO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aXRsZVBhdHRlcm4gPT09IG51bGwgfHwgdGl0bGVQYXR0ZXJuID09PSAnJykge1xuICAgICAgICAgICAgdGl0bGVQYXR0ZXJuID0gJ3tuYW1lfSc7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhkYXRhKSkge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ19fZW1wdHlfXycpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBlbXB0eU9wdHMucHVzaCh0aGlzLl9jcmVhdGVPcHRpb24odGhpcy5fZ2V0VGl0bGVGcm9tUGF0dGVybih0aXRsZVBhdHRlcm4sIGVudGl0eSksIGVudGl0eS5pZCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IG9wdEdyb3VwID0gdGhpcy5fY3JlYXRlT3B0Z3JvdXAoa2V5KTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZW50aXR5IG9mIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgb3B0R3JvdXAuYXBwZW5kQ2hpbGQodGhpcy5fY3JlYXRlT3B0aW9uKHRoaXMuX2dldFRpdGxlRnJvbVBhdHRlcm4odGl0bGVQYXR0ZXJuLCBlbnRpdHkpLCBlbnRpdHkuaWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbnMucHVzaChvcHRHcm91cCk7XG4gICAgICAgIH1cblxuICAgICAgICBvcHRpb25zLmZvckVhY2goY2hpbGQgPT4gbm9kZS5hcHBlbmRDaGlsZChjaGlsZCkpO1xuICAgICAgICBlbXB0eU9wdHMuZm9yRWFjaChjaGlsZCA9PiBub2RlLmFwcGVuZENoaWxkKGNoaWxkKSk7XG5cbiAgICAgICAgLy8gaWYgYXZhaWxhYmxlLCByZS1zZWxlY3QgdGhlIHByZXZpb3VzIHNlbGVjdGVkIG9wdGlvbiAobW9zdGx5IHVzYWJsZSBmb3IgZ2xvYmFsIGFjdGl2aXRpZXMpXG4gICAgICAgIG5vZGUudmFsdWUgPSBzZWxlY3RlZFZhbHVlO1xuXG4gICAgICAgIC8vIHByZS1zZWxlY3QgYW4gb3B0aW9uIGlmIGl0IGlzIHRoZSBvbmx5IGF2YWlsYWJsZSBvbmVcbiAgICAgICAgaWYgKG5vZGUudmFsdWUgPT09ICcnIHx8IG5vZGUudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGFsbE9wdGlvbnMgPSBub2RlLm9wdGlvbnM7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25MZW5ndGggPSBhbGxPcHRpb25zLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBzZWxlY3RPcHRpb24gPSAnJztcblxuICAgICAgICAgICAgaWYgKG9wdGlvbkxlbmd0aCA9PT0gMSAmJiBub2RlLmRhdGFzZXRbJ2F1dG9zZWxlY3QnXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0T3B0aW9uID0gYWxsT3B0aW9uc1swXS52YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9uTGVuZ3RoID09PSAyICYmIGVtcHR5T3B0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0T3B0aW9uID0gYWxsT3B0aW9uc1sxXS52YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNlbGVjdE9wdGlvbiAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICBub2RlLnZhbHVlID0gc2VsZWN0T3B0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhpcyB3aWxsIHVwZGF0ZSB0aGUgYXR0YWNoZWQgamF2YXNjcmlwdCBjb21wb25lbnRcbiAgICAgICAgbm9kZS5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnZGF0YS1yZWxvYWRlZCcsIHtkZXRhaWw6IG5vZGUudmFsdWV9KSk7XG4gICAgICAgIC8vIGlmIHdlIGRvbid0IHRyaWdnZXIgdGhlIGNoYW5nZSwgdGhlIG90aGVyIHNlbGVjdHMgd29uJ3QgcmVzZXRcbiAgICAgICAgbm9kZS5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnY2hhbmdlJykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXR0ZXJuXG4gICAgICogQHBhcmFtIHthcnJheX0gZW50aXR5XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0VGl0bGVGcm9tUGF0dGVybihwYXR0ZXJuLCBlbnRpdHkpXG4gICAge1xuICAgICAgICBjb25zdCBEQVRFX1VUSUxTID0gdGhpcy5nZXREYXRlVXRpbHMoKTtcbiAgICAgICAgY29uc3QgcmVnZXhwID0gbmV3IFJlZ0V4cCgne1tefV0qP30nLCdnJyk7XG4gICAgICAgIGxldCB0aXRsZSA9IHBhdHRlcm47XG4gICAgICAgIGxldCBtYXRjaCA9IG51bGw7XG5cbiAgICAgICAgd2hpbGUgKChtYXRjaCA9IHJlZ2V4cC5leGVjKHBhdHRlcm4pKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gY3V0dGluZyBhIHN0cmluZyBsaWtlIFwie25hbWV9XCIgaW50byBcIm5hbWVcIlxuICAgICAgICAgICAgY29uc3QgZmllbGQgPSBtYXRjaFswXS5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBlbnRpdHlbZmllbGRdID09PSB1bmRlZmluZWQgPyBudWxsIDogZW50aXR5W2ZpZWxkXTtcbiAgICAgICAgICAgIGlmICgoZmllbGQgPT09ICdzdGFydCcgfHwgZmllbGQgPT09ICdlbmQnKSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICc/JztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IERBVEVfVVRJTFMuZ2V0Rm9ybWF0dGVkRGF0ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aXRsZSA9IHRpdGxlLnJlcGxhY2UobmV3IFJlZ0V4cCgneycgKyBmaWVsZCArICd9JywgJ2cnKSwgdmFsdWUgPz8gJycpO1xuICAgICAgICB9XG4gICAgICAgIHRpdGxlID0gdGl0bGUucmVwbGFjZSgvLSBcXD8tXFw/LywgJycpO1xuICAgICAgICB0aXRsZSA9IHRpdGxlLnJlcGxhY2UoL1xcclxcbnxcXHJ8XFxuL2csICcgJyk7XG4gICAgICAgIHRpdGxlID0gdGl0bGUuc3Vic3RyaW5nKDAsIDExMCk7XG5cbiAgICAgICAgY29uc3QgY2hhcnMgPSAnLSAnO1xuICAgICAgICBsZXQgc3RhcnQgPSAwLCBlbmQgPSB0aXRsZS5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKHN0YXJ0IDwgZW5kICYmIGNoYXJzLmluZGV4T2YodGl0bGVbc3RhcnRdKSA+PSAwKSB7XG4gICAgICAgICAgICArK3N0YXJ0O1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGVuZCA+IHN0YXJ0ICYmIGNoYXJzLmluZGV4T2YodGl0bGVbZW5kIC0gMV0pID49IDApIHtcbiAgICAgICAgICAgIC0tZW5kO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJlc3VsdCA9IChzdGFydCA+IDAgfHwgZW5kIDwgdGl0bGUubGVuZ3RoKSA/IHRpdGxlLnN1YnN0cmluZyhzdGFydCwgZW5kKSA6IHRpdGxlO1xuXG4gICAgICAgIGlmIChyZXN1bHQgPT09ICcnICYmIGVudGl0eVsnbmFtZSddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBlbnRpdHlbJ25hbWUnXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtIVE1MU2VsZWN0RWxlbWVudH0gc2VsZWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxhYmVsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGFzZXRcbiAgICAgKi9cbiAgICBhZGRPcHRpb24oc2VsZWN0LCBsYWJlbCwgdmFsdWUsIGRhdGFzZXQpXG4gICAge1xuICAgICAgICBjb25zdCBvcHRpb24gPSB0aGlzLl9jcmVhdGVPcHRpb24obGFiZWwsIHZhbHVlKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZGF0YXNldCkge1xuICAgICAgICAgICAgb3B0aW9uLmRhdGFzZXRba2V5XSA9IGRhdGFzZXRba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGVjdC5vcHRpb25zLmFkZChvcHRpb24pO1xuICAgICAgICBpZiAoc2VsZWN0LnRvbXNlbGVjdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzZWxlY3QudG9tc2VsZWN0LnN5bmMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MU2VsZWN0RWxlbWVudH0gc2VsZWN0XG4gICAgICogQHBhcmFtIHtIVE1MT3B0aW9uRWxlbWVudH0gb3B0aW9uXG4gICAgICovXG4gICAgcmVtb3ZlT3B0aW9uKHNlbGVjdCwgb3B0aW9uKVxuICAgIHtcbiAgICAgICAgb3B0aW9uLnJlbW92ZSgpO1xuICAgICAgICBpZiAoc2VsZWN0LnRvbXNlbGVjdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzZWxlY3QudG9tc2VsZWN0LnJlbW92ZU9wdGlvbihvcHRpb24udmFsdWUsIHRydWUpO1xuICAgICAgICAgICAgc2VsZWN0LnRvbXNlbGVjdC5jbGVhcih0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYWJlbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jcmVhdGVPcHRpb24obGFiZWwsIHZhbHVlKVxuICAgIHtcbiAgICAgICAgbGV0IG9wdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICAgICAgICBvcHRpb24uaW5uZXJUZXh0ID0gbGFiZWw7XG4gICAgICAgIG9wdGlvbi52YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gb3B0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYWJlbFxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jcmVhdGVPcHRncm91cChsYWJlbClcbiAgICB7XG4gICAgICAgIGxldCBvcHRHcm91cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGdyb3VwJyk7XG4gICAgICAgIG9wdEdyb3VwLmxhYmVsID0gbGFiZWw7XG4gICAgICAgIHJldHVybiBvcHRHcm91cDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hY3RpdmF0ZUFwaVNlbGVjdHMoc2VsZWN0b3IpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5fZXZlbnRIYW5kbGVyQXBpU2VsZWN0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9ldmVudEhhbmRsZXJBcGlTZWxlY3RzID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gbnVsbCB8fCAhZXZlbnQudGFyZ2V0Lm1hdGNoZXMoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4vLyB0aW1lc2hlZXRfZWRpdF9mb3JtX3RpbWVzaGVldF9lZGl0X2Zvcm1fbWV0YUZpZWxkc19yc3BrbF9zdWJhY3Rpdml0eV92YWx1ZVxuLy8gdGltZXNoZWV0X2VkaXRfZm9ybV9tZXRhRmllbGRzX3JzcGtsX3N1YmFjdGl2aXR5X3ZhbHVlXG4gICAgICAgICAgICAgICAgY29uc3QgYXBpU2VsZWN0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldFNlbGVjdElkID0gJyMnICsgYXBpU2VsZWN0LmRhdGFzZXRbJ3JlbGF0ZWRTZWxlY3QnXTtcbiAgICAgICAgICAgICAgICAvKiogQHR5cGUge0hUTUxTZWxlY3RFbGVtZW50fSB0YXJnZXRTZWxlY3QgKi9cbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRTZWxlY3QgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChhcGlTZWxlY3QuZGF0YXNldFsncmVsYXRlZFNlbGVjdCddKTtcblxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSByZWxhdGVkIHRhcmdldCBzZWxlY3QgZG9lcyBub3QgZXhpc3QsIHdlIGRvIG5vdCBuZWVkIHRvIGxvYWQgdGhlIHJlbGF0ZWQgZGF0YVxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRTZWxlY3QgPT09IG51bGwgfHwgdGFyZ2V0U2VsZWN0LmRhdGFzZXRbJ3JlbG9hZGluZyddID09PSAnMScpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0YXJnZXRTZWxlY3QuZGF0YXNldFsncmVsb2FkaW5nJ10gPSAnMSc7XG5cbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0U2VsZWN0LnRvbXNlbGVjdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFNlbGVjdC50b21zZWxlY3QuZGlzYWJsZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0YXJnZXRTZWxlY3QuZGlzYWJsZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgbGV0IGZvcm1QcmVmaXggPSBhcGlTZWxlY3QuZGF0YXNldFsnZm9ybVByZWZpeCddO1xuICAgICAgICAgICAgICAgIGlmIChmb3JtUHJlZml4ID09PSB1bmRlZmluZWQgfHwgZm9ybVByZWZpeCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBmb3JtUHJlZml4ID0gJyc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChmb3JtUHJlZml4Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybVByZWZpeCArPSAnXyc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IG5ld0FwaVVybCA9IHRoaXMuX2J1aWxkVXJsV2l0aEZvcm1GaWVsZHMoYXBpU2VsZWN0LmRhdGFzZXRbJ2FwaVVybCddLCBmb3JtUHJlZml4KTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdFZhbHVlID0gYXBpU2VsZWN0LnZhbHVlO1xuXG5cbmNvbnNvbGUubG9nKGBuZXdBcGlVcmw6YCwgbmV3QXBpVXJsID8/IG51bGwsXG4gICAgYFxcbnRhcmdldFNlbGVjdDpgLCB0YXJnZXRTZWxlY3QgPz8gbnVsbCxcbiAgICBgXFxuc2VsZWN0VmFsdWU6ICR7c2VsZWN0VmFsdWV9XFxuXFxuYFxuICAgIClcbiAgICAgICAgICAgICAgICAvLyBQcm9ibGVtOiBzZWxlY3QgYSBwcm9qZWN0IHdpdGggYWN0aXZpdGllcyBhbmQgdGhlbiBzZWxlY3QgYSBjdXN0b21lciB0aGF0IGhhcyBubyBwcm9qZWN0XG4gICAgICAgICAgICAgICAgLy8gcmVzdWx0cyBpbiBhIHdyb25nIFVSTCwgaXQgdHJpZ2dlcnMgXCJhY3Rpdml0aWVzP3Byb2plY3Q9XCIgaW5zdGVhZCBvZiB1c2luZyB0aGUgXCJlbXB0eVVybFwiXG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdFZhbHVlID09PSB1bmRlZmluZWQgfHwgc2VsZWN0VmFsdWUgPT09IG51bGwgfHwgc2VsZWN0VmFsdWUgPT09ICcnIHx8IChBcnJheS5pc0FycmF5KHNlbGVjdFZhbHVlKSAmJiBzZWxlY3RWYWx1ZS5sZW5ndGggPT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcGlTZWxlY3QuZGF0YXNldFsnZW1wdHlVcmwnXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVTZWxlY3QodGFyZ2V0U2VsZWN0SWQsIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFNlbGVjdC5kYXRhc2V0WydyZWxvYWRpbmcnXSA9ICcwJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBuZXdBcGlVcmwgPSB0aGlzLl9idWlsZFVybFdpdGhGb3JtRmllbGRzKGFwaVNlbGVjdC5kYXRhc2V0WydlbXB0eVVybCddLCBmb3JtUHJlZml4KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvKiogQHR5cGUge0tpbWFpQVBJfSBBUEkgKi9cbiAgICAgICAgICAgICAgICBjb25zdCBBUEkgPSB0aGlzLmdldENvbnRhaW5lcigpLmdldFBsdWdpbignYXBpJyk7XG5cbiAgICAgICAgICAgICAgICBBUEkuZ2V0KG5ld0FwaVVybCwge30sIChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVNlbGVjdCh0YXJnZXRTZWxlY3RJZCwgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRTZWxlY3QudG9tc2VsZWN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFNlbGVjdC50b21zZWxlY3QuZW5hYmxlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0U2VsZWN0LmRhdGFzZXRbJ3JlbG9hZGluZyddID0gJzAnO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRTZWxlY3QuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5fZXZlbnRIYW5kbGVyQXBpU2VsZWN0cyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXBpVXJsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZvcm1QcmVmaXhcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYnVpbGRVcmxXaXRoRm9ybUZpZWxkcyhhcGlVcmwsIGZvcm1QcmVmaXgpXG4gICAge1xuICAgICAgICBsZXQgbmV3QXBpVXJsID0gYXBpVXJsO1xuXG5cbiAgICAgICAgYXBpVXJsLnNwbGl0KCc/JylbMV0uc3BsaXQoJyYnKS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgY29uc3QgW2tleSwgdmFsdWVdID0gaXRlbS5zcGxpdCgnPScpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICAgICAgICBjb25zdCBkZWNvZGVkID0gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbiAgICAgICAgICAgIGNvbnN0IHRlc3QgPSBkZWNvZGVkLm1hdGNoKC8lKC4qKSUvKTtcbiAgICAgICAgICAgIGlmICh0ZXN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxGaWVsZE5hbWUgPSB0ZXN0WzFdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldEZpZWxkTmFtZSA9IChmb3JtUHJlZml4ICsgb3JpZ2luYWxGaWVsZE5hbWUpLnJlcGxhY2UoL1xcWy8sICcnKS5yZXBsYWNlKC9dLywgJycpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldEZpZWxkID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGFyZ2V0RmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICBsZXQgbmV3VmFsdWUgPSAnJztcbmNvbnNvbGUubG9nKGBcXG5cXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5gICtcbmBuZXdBcGlVcmw6YCArIG5ld0FwaVVybCA/PyBudWxsLFxuYHRhcmdldEZpZWxkOmAsIHRhcmdldEZpZWxkID8/IG51bGwsXG5gXFxudGFyZ2V0RmllbGQudmFsdWU6ICR7dGFyZ2V0RmllbGQ/LnZhbHVlID8/IG51bGx9YClcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0RmllbGQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaGFwcGVucyBmb3IgZXhhbXBsZTpcbiAgICAgICAgICAgICAgICAgICAgLy8gLSBpbiBkdXJhdGlvbiBvbmx5IG1vZGUsIHdoZW4gdGhlIGVuZCBmaWVsZCBpcyBub3QgZm91bmRcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0VSUk9SOiBDYW5ub3QgZmluZCBmaWVsZCB3aXRoIG5hbWUgXCInICsgdGVzdFsxXSArICdcIiBieSBzZWxlY3RvcjogIycgKyBmb3JtUHJlZml4ICsgdGVzdFsxXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldEZpZWxkLnZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IHRhcmdldEZpZWxkLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldEZpZWxkLnRhZ05hbWUgPT09ICdTRUxFQ1QnICYmIHRhcmdldEZpZWxkLm11bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBbLi4udGFyZ2V0RmllbGQuc2VsZWN0ZWRPcHRpb25zXS5tYXAobyA9PiBvLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV3VmFsdWUgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldEZpZWxkLnR5cGUgPT09ICdkYXRlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0aW1lSWQgPSB0YXJnZXRGaWVsZC5pZC5yZXBsYWNlKCdfZGF0ZScsICdfdGltZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGltZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGltZSA9IHRpbWVFbGVtZW50ID09PSBudWxsID8gJzEyOjAwOjAwJyA6IHRpbWVFbGVtZW50LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1c2luZyAxMjowMCBhcyBmYWxsYmFjaywgYmVjYXVzZSB0aW1lem9uZSBoYW5kbGluZyBtaWdodCBjaGFuZ2UgdGhlIGRhdGUgaWYgd2UgdXNlIDAwOjAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0RhdGUgPSB0aGlzLmdldERhdGVVdGlscygpLmZyb21IdG1sNUlucHV0KG5ld1ZhbHVlLCB0aW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPSB0aGlzLmdldERhdGVVdGlscygpLmZvcm1hdEZvckFQSShuZXdEYXRlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0YXJnZXRGaWVsZC50eXBlID09PSAndGV4dCcgJiYgdGFyZ2V0RmllbGQubmFtZS5pbmNsdWRlcygnZGF0ZScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVJZCA9IHRhcmdldEZpZWxkLmlkLnJlcGxhY2UoJ19kYXRlJywgJ190aW1lJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGltZUVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aW1lSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1c2luZyAxMjowMCBhcyBmYWxsYmFjaywgYmVjYXVzZSB0aW1lem9uZSBoYW5kbGluZyBtaWdodCBjaGFuZ2UgdGhlIGRhdGUgaWYgd2UgdXNlIDAwOjAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0aW1lID0gJzEyOjAwOjAwJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRpbWVGb3JtYXQgPSAnSEg6bW0nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGltZUVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWUgPSB0aW1lRWxlbWVudC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVGb3JtYXQgPSB0aW1lRWxlbWVudC5kYXRhc2V0Wydmb3JtYXQnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdEYXRlID0gdGhpcy5nZXREYXRlVXRpbHMoKS5mcm9tRm9ybWF0KG5ld1ZhbHVlLnRyaW0oKSArICcgJyArIHRpbWUudHJpbSgpLCB0YXJnZXRGaWVsZC5kYXRhc2V0Wydmb3JtYXQnXSArICcgJyArIHRpbWVGb3JtYXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IHRoaXMuZ2V0RGF0ZVV0aWxzKCkuZm9ybWF0Rm9yQVBJKG5ld0RhdGUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldEZpZWxkLmRhdGFzZXRbJ2Zvcm1hdCddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmluZCBvdXQgd2hlbiB0aGlzIGVsc2UgYnJhbmNoIGlzIHRyaWdnZXJlZCBhbmQgZG9jdW1lbnQhXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2V0RGF0ZVV0aWxzKCkuaXNWYWxpZERhdGVUaW1lKG5ld1ZhbHVlLCB0YXJnZXRGaWVsZC5kYXRhc2V0Wydmb3JtYXQnXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gdGhpcy5nZXREYXRlVXRpbHMoKS5mb3JtYXQodGFyZ2V0RmllbGQuZGF0YXNldFsnZm9ybWF0J10sIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGFwcGVucyBmb3IgZXhhbXBsZTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtIHdoZW4gdGhlIGVuZCBkYXRlIGlzIG5vdCBzZXQgb24gYSB0aW1lc2hlZXQgcmVjb3JkIGFuZCB0aGUgcHJvamVjdCBsaXN0IGlzIGxvYWRlZCAoYXMgdGhlIFVSTCBjb250YWlucyB0aGUgJWVuZCUgcmVwbGFjZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0VtcHR5IHZhbHVlIGZvdW5kIGZvciBmaWVsZCB3aXRoIG5hbWUgXCInICsgdGVzdFsxXSArICdcIiBieSBzZWxlY3RvcjogIycgKyBmb3JtUHJlZml4ICsgdGVzdFsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBoYXBwZW5zIGZvciBleGFtcGxlOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gLSB3aGVuIGEgY3VzdG9tZXIgd2l0aG91dCBwcm9qZWN0cyBpcyBzZWxlY3RlZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0VSUk9SOiBFbXB0eSBmaWVsZCB3aXRoIG5hbWUgXCInICsgdGVzdFsxXSArICdcIiBieSBzZWxlY3RvcjogIycgKyBmb3JtUHJlZml4ICsgdGVzdFsxXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG5ld1ZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdXJsUGFyYW1zID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHRtcFZhbHVlIG9mIG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG1wVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXBWYWx1ZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsUGFyYW1zLnB1c2gob3JpZ2luYWxGaWVsZE5hbWUgKyAnPScgKyB0bXBWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbmV3QXBpVXJsID0gbmV3QXBpVXJsLnJlcGxhY2UoaXRlbSwgdXJsUGFyYW1zLmpvaW4oJyYnKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1ZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5ld0FwaVVybCA9IG5ld0FwaVVybC5yZXBsYWNlKHZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbmV3QXBpVXJsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfEVsZW1lbnR9IHNlbGVjdFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdXBkYXRlU2VsZWN0KHNlbGVjdCwgZGF0YSlcbiAgICB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBhcGlEYXRhIG9mIGRhdGEpIHtcbiAgICAgICAgICAgIGxldCB0aXRsZSA9ICdfX2VtcHR5X18nO1xuICAgICAgICAgICAgaWYgKGFwaURhdGFbJ3BhcmVudFRpdGxlJ10gIT09IHVuZGVmaW5lZCAmJiBhcGlEYXRhWydwYXJlbnRUaXRsZSddICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGl0bGUgPSBhcGlEYXRhWydwYXJlbnRUaXRsZSddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnNbdGl0bGVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zW3RpdGxlXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3B0aW9uc1t0aXRsZV0ucHVzaChhcGlEYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9yZGVyZWQgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXMob3B0aW9ucykuc29ydCgpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBvcmRlcmVkW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZU9wdGlvbnMoc2VsZWN0LCBvcmRlcmVkKTtcbiAgICB9XG59XG4iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgdGhlIEtpbWFpIHRpbWUtdHJhY2tpbmcgYXBwLlxuICpcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cbiAqL1xuXG4vKiFcbiAqIFtLSU1BSV0gS2ltYWlFZGl0VGltZXNoZWV0Rm9ybTogcmVzcG9uc2libGUgZm9yIHRoZSBtb3N0IGltcG9ydGFudCBmb3JtIGluIHRoZSBhcHBsaWNhdGlvblxuICovXG5cbmltcG9ydCBLaW1haUZvcm1QbHVnaW4gZnJvbSBcIi4vS2ltYWlGb3JtUGx1Z2luXCI7XG5pbXBvcnQgS2ltYWlDb2xvciBmcm9tIFwiLi4vd2lkZ2V0cy9LaW1haUNvbG9yXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEtpbWFpVGVhbUZvcm0gZXh0ZW5kcyBLaW1haUZvcm1QbHVnaW4ge1xuXG4gICAgaW5pdCgpXG4gICAge1xuICAgICAgICB0aGlzLnVzZXJzSWQgPSAndGVhbV9lZGl0X2Zvcm1fdXNlcnMnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7SFRNTEZvcm1FbGVtZW50fSBmb3JtXG4gICAgICogQHJldHVybiBib29sZWFuXG4gICAgICovXG4gICAgc3VwcG9ydHNGb3JtKGZvcm0pXG4gICAge1xuICAgICAgICByZXR1cm4gZm9ybS5uYW1lID09PSAndGVhbV9lZGl0X2Zvcm0nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldFByb3RvdHlwZSgpXG4gICAge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RlYW1fZWRpdF9mb3JtX21lbWJlcnMnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0hUTUxGb3JtRWxlbWVudH0gZm9ybVxuICAgICAqL1xuICAgIGFjdGl2YXRlRm9ybShmb3JtKVxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLnN1cHBvcnRzRm9ybShmb3JtKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbXVzdCBiZSBhdHRhY2hlZCB0byB0aGUgZm9ybSwgYmVjYXVzZSB0aGUgYnV0dG9uIGlzIGFkZGVkIGR5bmFtaWNhbGx5XG4gICAgICAgIGZvcm0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBldmVudCA9PiB0aGlzLl9yZW1vdmVNZW1iZXIoZXZlbnQpKTtcblxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLnVzZXJzSWQpLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbiA9IHNlbGVjdC5vcHRpb25zW3NlbGVjdC5zZWxlY3RlZEluZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IG1lbWJlciA9IHRoaXMuX2NyZWF0ZU1lbWJlcihvcHRpb24pO1xuICAgICAgICAgICAgdGhpcy5fZ2V0UHJvdG90eXBlKCkuYXBwZW5kKG1lbWJlcik7XG4gICAgICAgICAgICB0aGlzLmdldFBsdWdpbignZm9ybS1zZWxlY3QnKS5yZW1vdmVPcHRpb24oc2VsZWN0LCBvcHRpb24pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0hUTUxPcHRpb25FbGVtZW50fSBvcHRpb25cbiAgICAgKiBAcmV0dXJucyB7RWxlbWVudH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jcmVhdGVNZW1iZXIob3B0aW9uKVxuICAgIHtcbiAgICAgICAgLyoqIEB0eXBlIHtLaW1haUVzY2FwZX0gRVNDQVBFUiAqL1xuICAgICAgICBjb25zdCBFU0NBUEVSID0gdGhpcy5nZXRQbHVnaW4oJ2VzY2FwZScpO1xuICAgICAgICBjb25zdCBwcm90b3R5cGUgPSB0aGlzLl9nZXRQcm90b3R5cGUoKTtcbiAgICAgICAgbGV0IGNvdW50ZXIgPSBwcm90b3R5cGUuZGF0YXNldFsnd2lkZ2V0Q291bnRlciddIHx8IHByb3RvdHlwZS5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICAgICAgbGV0IG5ld1dpZGdldCA9IHByb3RvdHlwZS5kYXRhc2V0Wydwcm90b3R5cGUnXTtcblxuICAgICAgICBuZXdXaWRnZXQgPSBuZXdXaWRnZXQucmVwbGFjZSgvX19uYW1lX18vZywgY291bnRlcik7XG5cbiAgICAgICAgbmV3V2lkZ2V0ID0gbmV3V2lkZ2V0LnJlcGxhY2UoLyMwMDAwMDAvZywgS2ltYWlDb2xvci5jYWxjdWxhdGVDb250cmFzdENvbG9yKG9wdGlvbi5kYXRhc2V0LmNvbG9yKSk7XG4gICAgICAgIG5ld1dpZGdldCA9IG5ld1dpZGdldC5yZXBsYWNlKC9fX0RJU1BMQVlfXy9nLCBFU0NBUEVSLmVzY2FwZUZvckh0bWwob3B0aW9uLmRhdGFzZXQuZGlzcGxheSkpO1xuICAgICAgICBuZXdXaWRnZXQgPSBuZXdXaWRnZXQucmVwbGFjZSgvX19DT0xPUl9fL2csIG9wdGlvbi5kYXRhc2V0LmNvbG9yKTtcbiAgICAgICAgbmV3V2lkZ2V0ID0gbmV3V2lkZ2V0LnJlcGxhY2UoL19fSU5JVElBTFNfXy9nLCBFU0NBUEVSLmVzY2FwZUZvckh0bWwob3B0aW9uLmRhdGFzZXQuaW5pdGlhbHMpKTtcbiAgICAgICAgbmV3V2lkZ2V0ID0gbmV3V2lkZ2V0LnJlcGxhY2UoL19fVElUTEVfXy9nLCBFU0NBUEVSLmVzY2FwZUZvckh0bWwob3B0aW9uLmRhdGFzZXQudGl0bGUpKTtcbiAgICAgICAgbmV3V2lkZ2V0ID0gbmV3V2lkZ2V0LnJlcGxhY2UoL19fVVNFUk5BTUVfXy9nLCBFU0NBUEVSLmVzY2FwZUZvckh0bWwob3B0aW9uLnRleHQpKTtcblxuICAgICAgICBwcm90b3R5cGUuZGF0YXNldFsnd2lkZ2V0Q291bnRlciddID0gKCsrY291bnRlcikudG9TdHJpbmcoKTtcblxuICAgICAgICBjb25zdCB0ZW1wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRlbXAuaW5uZXJIVE1MID0gbmV3V2lkZ2V0O1xuICAgICAgICB0ZW1wLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0W3R5cGU9aGlkZGVuXScpLnZhbHVlID0gb3B0aW9uLnZhbHVlO1xuXG4gICAgICAgIGNvbnN0IG5ld05vZGUgPSB0ZW1wLmZpcnN0RWxlbWVudENoaWxkO1xuXG4gICAgICAgIC8vIGNvcHkgb3ZlciBhbGwgaW5pdGlhbCBzZXR0aW5ncywgc28gd2UgYXJlIGFibGUgdG8gcmVidWlsZCB0aGUgb3JpZ2luYWwgb3B0aW9uIGlmIHRoZVxuICAgICAgICAvLyBtZW1iZXIgaXMgcmVtb3ZlZCBmcm9tIHRoZSBsaXN0IGxhdGVyIG9uXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9wdGlvbi5kYXRhc2V0KSB7XG4gICAgICAgICAgICBuZXdOb2RlLmRhdGFzZXRba2V5XSA9IG9wdGlvbi5kYXRhc2V0W2tleV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3Tm9kZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbW92ZU1lbWJlcihldmVudClcbiAgICB7XG4gICAgICAgIGxldCBidXR0b24gPSBldmVudC50YXJnZXQ7XG5cbiAgICAgICAgaWYgKGJ1dHRvbi5wYXJlbnROb2RlLm1hdGNoZXMoJy5yZW1vdmUtbWVtYmVyJykpIHtcbiAgICAgICAgICAgIGJ1dHRvbiA9IGJ1dHRvbi5wYXJlbnROb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJ1dHRvbi5tYXRjaGVzKCcucmVtb3ZlLW1lbWJlcicpKSB7XG4gICAgICAgICAgICAvLyBzZWUgYmxvY2tzLmh0bWwudHdpZyA9PiBibG9jayB0ZWFtX21lbWJlcl93aWRnZXRcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBidXR0b24ucGFyZW50Tm9kZS5wYXJlbnROb2RlLnBhcmVudE5vZGUucGFyZW50Tm9kZS5wYXJlbnROb2RlO1xuXG4gICAgICAgICAgICAvLyByZS1hZGRpbmcgdGhlIG9wdGlvbiB0byB0aGUgc2VsZWN0IG1ha2VzIHVwIGZvciBmb3JtIHZhbGlkYXRpb24gZXJyb3JzXG4gICAgICAgICAgICAvLyBiZWNhdXNlIHRoZSBsaXN0IHdvdWxkIGhhdmUgdG8gYmUgcmUtb3JkZXJlZCBhbmQgaW5kaWNlcyBuZWVkIHRvIGJlIGNoYW5nZWQgLi4uXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgdGhpcy5nZXRQbHVnaW4oJ2Zvcm0tc2VsZWN0JykuYWRkT3B0aW9uKFxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMudXNlcnNJZCksXG4gICAgICAgICAgICAgICAgZWxlbWVudC5kYXRhc2V0WydkaXNwbGF5J10sXG4gICAgICAgICAgICAgICAgZWxlbWVudC5kYXRhc2V0WydpZCddLFxuICAgICAgICAgICAgICAgIGVsZW1lbnQuZGF0YXNldFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IHByb3RvdHlwZSA9IHRoaXMuX2dldFByb3RvdHlwZSgpO1xuICAgICAgICAgICAgcHJvdG90eXBlLmRhdGFzZXRbJ3dpZGdldENvdW50ZXInXSA9IChwcm90b3R5cGUuZGF0YXNldFsnd2lkZ2V0Q291bnRlciddIC0gMSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlKCk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0hUTUxGb3JtRWxlbWVudH0gZm9ybVxuICAgICAqL1xuICAgIGRlc3Ryb3lGb3JtKGZvcm0pXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuc3VwcG9ydHNGb3JtKGZvcm0pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fcmVtb3ZlTWVtYmVyKTtcbiAgICB9XG5cbn1cbiIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiB0aGUgS2ltYWkgdGltZS10cmFja2luZyBhcHAuXG4gKlxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxuICovXG5cbi8qIVxuICogW0tJTUFJXSBLaW1haUVkaXRUaW1lc2hlZXRGb3JtOiByZXNwb25zaWJsZSBmb3IgdGhlIG1vc3QgaW1wb3J0YW50IGZvcm0gaW4gdGhlIGFwcGxpY2F0aW9uXG4gKi9cblxuaW1wb3J0IHsgRGF0ZVRpbWUgfSBmcm9tICdsdXhvbic7XG5pbXBvcnQgS2ltYWlGb3JtUGx1Z2luIGZyb20gXCIuL0tpbWFpRm9ybVBsdWdpblwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBLaW1haVRpbWVzaGVldEZvcm0gZXh0ZW5kcyBLaW1haUZvcm1QbHVnaW4ge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtIVE1MRm9ybUVsZW1lbnR9IGZvcm1cbiAgICAgKiBAcmV0dXJuIGJvb2xlYW5cbiAgICAgKi9cbiAgICBzdXBwb3J0c0Zvcm0oZm9ybSlcbiAgICB7XG4gICAgICAgIHJldHVybiAoZm9ybS5uYW1lID09PSAndGltZXNoZWV0X2VkaXRfZm9ybScgfHwgZm9ybS5uYW1lID09PSd0aW1lc2hlZXRfYWRtaW5fZWRpdF9mb3JtJyB8fCBmb3JtLm5hbWUgPT09J3RpbWVzaGVldF9tdWx0aV91c2VyX2VkaXRfZm9ybScpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7SFRNTEZvcm1FbGVtZW50fSBmb3JtXG4gICAgICovXG4gICAgZGVzdHJveUZvcm0oZm9ybSlcbiAgICB7XG4gICAgICAgIGlmICghdGhpcy5zdXBwb3J0c0Zvcm0oZm9ybSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9iZWdpbkRhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fYmVnaW5EYXRlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuX2JlZ2luTGlzdGVuZXIpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2JlZ2luTGlzdGVuZXI7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fYmVnaW5EYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2JlZ2luVGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9iZWdpblRpbWUucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5fYmVnaW5MaXN0ZW5lcik7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fYmVnaW5UaW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2VuZFRpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fZW5kVGltZS5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl9lbmRMaXN0ZW5lcik7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fZW5kVGltZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9kdXJhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9kdXJhdGlvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl9kdXJhdGlvbkxpc3RlbmVyKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9kdXJhdGlvbkxpc3RlbmVyO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2R1cmF0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2R1cmF0aW9uVG9nZ2xlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fZHVyYXRpb25Ub2dnbGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2R1cmF0aW9uVG9nZ2xlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuX2R1cmF0aW9uVG9nZ2xlTGlzdGVuZXIpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2R1cmF0aW9uVG9nZ2xlTGlzdGVuZXI7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fZHVyYXRpb25Ub2dnbGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fYWN0aXZpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fYWN0aXZpdHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignY3JlYXRlJywgdGhpcy5fYWN0aXZpdHlMaXN0ZW5lcik7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fYWN0aXZpdHlMaXN0ZW5lcjtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9hY3Rpdml0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9wcm9qZWN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9wcm9qZWN0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWN0aXZhdGVGb3JtKGZvcm0pXG4gICAge1xuXG5jb25zb2xlLmxvZygnYWN0aXZhdGUgZm9ybScpXG4gICAgICAgIGlmICghdGhpcy5zdXBwb3J0c0Zvcm0oZm9ybSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZvcm1QcmVmaXggPSBmb3JtLm5hbWU7XG5cbiAgICAgICAgdGhpcy5fYWN0aXZpdHkgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChmb3JtUHJlZml4ICsgJ19hY3Rpdml0eScpO1xuICAgICAgICB0aGlzLl9wcm9qZWN0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZm9ybVByZWZpeCArICdfcHJvamVjdCcpO1xuXG4gICAgICAgIC8qKiBAcGFyYW0ge0N1c3RvbUV2ZW50fSBldmVudCAqL1xuICAgICAgICB0aGlzLl9hY3Rpdml0eUxpc3RlbmVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwcm9qZWN0ID0gdGhpcy5fcHJvamVjdC52YWx1ZTtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7S2ltYWlBUEl9IEFQSSAqL1xuICAgICAgICAgICAgY29uc3QgQVBJID0gdGhpcy5nZXRDb250YWluZXIoKS5nZXRQbHVnaW4oJ2FwaScpO1xuICAgICAgICAgICAgQVBJLnBvc3QodGhpcy5fYWN0aXZpdHkuZGF0YXNldFsnY3JlYXRlJ10sIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBldmVudC5kZXRhaWwudmFsdWUsXG4gICAgICAgICAgICAgICAgcHJvamVjdDogKHByb2plY3QgPT09ICcnID8gbnVsbCA6IHByb2plY3QpLFxuICAgICAgICAgICAgICAgIHZpc2libGU6IHRydWUsXG4gICAgICAgICAgICB9LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvamVjdC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnY2hhbmdlJykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2FjdGl2aXR5LmFkZEV2ZW50TGlzdGVuZXIoJ2NyZWF0ZScsIHRoaXMuX2FjdGl2aXR5TGlzdGVuZXIpO1xuXG4gICAgICAgIHRoaXMuX2JlZ2luRGF0ZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGZvcm1QcmVmaXggKyAnX2JlZ2luX2RhdGUnKTtcbiAgICAgICAgdGhpcy5fYmVnaW5UaW1lID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZm9ybVByZWZpeCArICdfYmVnaW5fdGltZScpO1xuICAgICAgICB0aGlzLl9lbmRUaW1lID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZm9ybVByZWZpeCArICdfZW5kX3RpbWUnKTtcbiAgICAgICAgdGhpcy5fZHVyYXRpb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChmb3JtUHJlZml4ICsgJ19kdXJhdGlvbicpO1xuICAgICAgICB0aGlzLl9kdXJhdGlvblRvZ2dsZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGZvcm1QcmVmaXggKyAnX2R1cmF0aW9uX3RvZ2dsZScpO1xuXG4gICAgICAgIGlmICh0aGlzLl9iZWdpbkRhdGUgPT09IG51bGwgfHwgdGhpcy5fYmVnaW5UaW1lID09PSBudWxsIHx8IHRoaXMuX2VuZFRpbWUgPT09IG51bGwgfHwgdGhpcy5fZHVyYXRpb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2JlZ2luTGlzdGVuZXIgPSAoKSA9PiB0aGlzLl9jaGFuZ2VkQmVnaW4oKTtcbiAgICAgICAgdGhpcy5fZW5kTGlzdGVuZXIgPSAoKSA9PiB0aGlzLl9jaGFuZ2VkRW5kKCk7XG4gICAgICAgIHRoaXMuX2R1cmF0aW9uTGlzdGVuZXIgPSAoKSA9PiB0aGlzLl9jaGFuZ2VkRHVyYXRpb24oKTtcblxuICAgICAgICB0aGlzLl9iZWdpbkRhdGUuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5fYmVnaW5MaXN0ZW5lcik7XG4gICAgICAgIHRoaXMuX2JlZ2luVGltZS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl9iZWdpbkxpc3RlbmVyKTtcbiAgICAgICAgdGhpcy5fZW5kVGltZS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl9lbmRMaXN0ZW5lcik7XG4gICAgICAgIHRoaXMuX2R1cmF0aW9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuX2R1cmF0aW9uTGlzdGVuZXIpO1xuXG4gICAgICAgIGlmICh0aGlzLl9kdXJhdGlvbiAhPT0gbnVsbCAmJiB0aGlzLl9kdXJhdGlvblRvZ2dsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fZHVyYXRpb25Ub2dnbGVMaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kdXJhdGlvblRvZ2dsZS5jbGFzc0xpc3QudG9nZ2xlKCd0ZXh0LXN1Y2Nlc3MnKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl9kdXJhdGlvblRvZ2dsZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2R1cmF0aW9uVG9nZ2xlTGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2lzRHVyYXRpb25Db25uZWN0ZWQoKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuX2R1cmF0aW9uID09PSBudWxsICYmIHRoaXMuX2R1cmF0aW9uVG9nZ2xlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZHVyYXRpb25Ub2dnbGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2R1cmF0aW9uVG9nZ2xlLmNsYXNzTGlzdC5jb250YWlucygndGV4dC1zdWNjZXNzJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0RhdGVUaW1lfG51bGx9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0QmVnaW4oKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuX2JlZ2luRGF0ZS52YWx1ZSA9PT0gJycgfHwgdGhpcy5fYmVnaW5UaW1lLnZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZGF0ZSA9IHRoaXMuX3BhcnNlQmVnaW4odGhpcy5fYmVnaW5UaW1lLmRhdGFzZXRbJ2Zvcm1hdCddKTtcblxuICAgICAgICBpZiAoZGF0ZS5pbnZhbGlkKSB7XG4gICAgICAgICAgICBkYXRlID0gdGhpcy5fcGFyc2VCZWdpbih0aGlzLl9maXhUaW1lRm9ybWF0KHRoaXMuX2JlZ2luVGltZS5kYXRhc2V0Wydmb3JtYXQnXSkpO1xuXG4gICAgICAgICAgICBpZiAoZGF0ZS5pbnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICBfcGFyc2VCZWdpbih0aW1lRm9ybWF0KVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGF0ZVV0aWxzKCkuZnJvbUZvcm1hdChcbiAgICAgICAgICAgIHRoaXMuX2JlZ2luRGF0ZS52YWx1ZSArICcgJyArIHRoaXMuX2JlZ2luVGltZS52YWx1ZSxcbiAgICAgICAgICAgIHRoaXMuX2JlZ2luRGF0ZS5kYXRhc2V0Wydmb3JtYXQnXSArICcgJyArIHRpbWVGb3JtYXQsXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgX3BhcnNlRW5kKGVuZERhdGUsIHRpbWVGb3JtYXQpXG4gICAge1xuICAgICAgICBsZXQgZGF0ZSA9IHRoaXMuZ2V0RGF0ZVV0aWxzKCkuZnJvbUZvcm1hdChcbiAgICAgICAgICAgIGVuZERhdGUudG9Gb3JtYXQoJ3l5eXktTEwtZGQnKSArICcgJyArIHRoaXMuX2VuZFRpbWUudmFsdWUsXG4gICAgICAgICAgICAneXl5eS1MTC1kZCAnICsgdGltZUZvcm1hdCxcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoZGF0ZS5pbnZhbGlkKSB7XG4gICAgICAgICAgICBkYXRlID0gdGhpcy5nZXREYXRlVXRpbHMoKS5mcm9tRm9ybWF0KFxuICAgICAgICAgICAgICAgIGVuZERhdGUudG9Gb3JtYXQoJ3l5eXktTEwtZGQnKSArICcgJyArIHRoaXMuX2VuZFRpbWUudmFsdWUsXG4gICAgICAgICAgICAgICAgJ3l5eXktTEwtZGQgJyArIHRoaXMuX2ZpeFRpbWVGb3JtYXQodGltZUZvcm1hdCksXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuXG4gICAgX2ZpeFRpbWVGb3JtYXQoZm9ybWF0KVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdC5yZXBsYWNlKCdISCcsICdIJykucmVwbGFjZSgnaGgnLCAnaCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtEYXRlVGltZXxudWxsfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldEVuZCgpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5fZW5kVGltZS52YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGRhdGUgPSB0aGlzLl9wYXJzZUVuZChEYXRlVGltZS5ub3coKSwgdGhpcy5fZW5kVGltZS5kYXRhc2V0Wydmb3JtYXQnXSk7XG5cbiAgICAgICAgY29uc3QgYmVnaW4gPSB0aGlzLl9nZXRCZWdpbigpO1xuICAgICAgICBpZiAoYmVnaW4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIGRhdGUgPSB0aGlzLl9wYXJzZUVuZChiZWdpbiwgdGhpcy5fZW5kVGltZS5kYXRhc2V0Wydmb3JtYXQnXSk7XG5cbiAgICAgICAgICAgIGlmIChkYXRlIDwgYmVnaW4pIHtcbiAgICAgICAgICAgICAgICBkYXRlID0gZGF0ZS5wbHVzKHtkYXlzOiAxfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0ZS5pbnZhbGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJ1bGVzZXQ6XG4gICAgICogLSBpbnZhbGlkIGJlZ2luID0+IHNraXBcbiAgICAgKiAtIGVtcHR5IGVuZCA9PiBzZXQgZW5kIHRvIGJlZ2luIChvbmx5IGlmIGR1cmF0aW9uID4gMCA9IHJ1bm5pbmcgcmVjb3JkKVxuICAgICAqIC0gaW52YWxpZCBlbmQgPT4gc2tpcFxuICAgICAqIC0gY2FsY3VsYXRlIGR1cmF0aW9uXG4gICAgICovXG4gICAgX2NoYW5nZWRCZWdpbigpXG4gICAge1xuICAgICAgICBjb25zdCBiZWdpbiA9IHRoaXMuX2dldEJlZ2luKCk7XG4gICAgICAgIGlmIChiZWdpbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZHVyYXRpb24gPSB0aGlzLl9nZXRQYXJzZWREdXJhdGlvbigpO1xuICAgICAgICBjb25zdCBoYXNEdXJhdGlvbiA9IGR1cmF0aW9uLmFzKCdzZWNvbmRzJykgPiAwO1xuICAgICAgICBjb25zdCBlbmQgPSB0aGlzLl9nZXRFbmQoKTtcblxuICAgICAgICBpZiAoZW5kID09PSBudWxsICYmIGhhc0R1cmF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9hcHBseURhdGVUb0ZpZWxkKGJlZ2luLnBsdXMoZHVyYXRpb24pLCBudWxsLCB0aGlzLl9lbmRUaW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUR1cmF0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSdWxlc2V0OlxuICAgICAqIC0gaW52YWxpZCBlbmQgPT4gc2tpcFxuICAgICAqIC0gZW1wdHkgYmVnaW4gPT4gc2V0IGJlZ2luIHRvIGVuZFxuICAgICAqIC0gaW52YWxpZCBiZWdpbiA9PiBza2lwXG4gICAgICogLSBjYWxjdWxhdGUgZHVyYXRpb25cbiAgICAgKi9cbiAgICBfY2hhbmdlZEVuZCgpXG4gICAge1xuICAgICAgICBjb25zdCBlbmQgPSB0aGlzLl9nZXRFbmQoKTtcbiAgICAgICAgLy8gZW1wdHkgb3IgaW52YWxpZCBkYXRlID0+IHJlc2V0IGR1cmF0aW9uIGFuZCBzdG9wIHByb2dyZXNzXG4gICAgICAgIGlmIChlbmQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGR1cmF0aW9uID0gdGhpcy5fZ2V0UGFyc2VkRHVyYXRpb24oKTtcbiAgICAgICAgY29uc3QgaGFzRHVyYXRpb24gPSBkdXJhdGlvbi5hcygnc2Vjb25kcycpID4gMDtcbiAgICAgICAgY29uc3QgYmVnaW4gPSB0aGlzLl9nZXRCZWdpbigpO1xuXG4gICAgICAgIGlmIChiZWdpbiA9PT0gbnVsbCAmJiBoYXNEdXJhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fYXBwbHlEYXRlVG9GaWVsZChlbmQubWludXMoZHVyYXRpb24pLCB0aGlzLl9iZWdpbkRhdGUsIHRoaXMuX2JlZ2luVGltZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVEdXJhdGlvbigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdXBkYXRlRHVyYXRpb24oKVxuICAgIHtcbiAgICAgICAgY29uc3QgYmVnaW4gPSB0aGlzLl9nZXRCZWdpbigpO1xuICAgICAgICBjb25zdCBlbmQgPSB0aGlzLl9nZXRFbmQoKTtcbiAgICAgICAgbGV0IG5ld0R1cmF0aW9uID0gbnVsbDtcblxuICAgICAgICBpZiAoYmVnaW4gIT09IG51bGwgJiYgZW5kICE9PSBudWxsKSB7XG4gICAgICAgICAgICBuZXdEdXJhdGlvbiA9IGVuZC5kaWZmKGJlZ2luKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3NldER1cmF0aW9uQXNTdHJpbmcobmV3RHVyYXRpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJ1bGVzZXQ6XG4gICAgICogLSBpbnZhbGlkIGR1cmF0aW9uID0+IHNraXBcbiAgICAgKiAtIGlmIGJlZ2luIGFuZCBlbmQgYXJlIGVtcHR5OiBzZXQgYmVnaW4gdG8gbm93IGFuZCBlbmQgdG8gZHVyYXRpb25cbiAgICAgKiAtIGlmIGJlZ2luIGlzIGVtcHR5IGFuZCBlbmQgaXMgbm90IGVtcHR5OiBzZXQgYmVnaW4gdG8gZW5kIG1pbnVzIGR1cmF0aW9uXG4gICAgICogLSBpZiBiZWdpbiBpcyBub3QgZW1wdHkgYW5kIGVuZCBpcyBlbXB0eSBhbmQgZHVyYXRpb24gaXMgPiAwIChydW5uaW5nIHJlY29yZHMgPSAwKTogc2V0IGVuZCB0byBiZWdpbiBwbHVzIGR1cmF0aW9uXG4gICAgICovXG4gICAgX2NoYW5nZWREdXJhdGlvbigpXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuX2lzRHVyYXRpb25Db25uZWN0ZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZHVyYXRpb24gPSB0aGlzLl9nZXRQYXJzZWREdXJhdGlvbigpO1xuICAgICAgICBpZiAoIWR1cmF0aW9uLmlzVmFsaWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldER1cmF0aW9uQXNTdHJpbmcobnVsbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBiZWdpbiA9IHRoaXMuX2dldEJlZ2luKCk7XG4gICAgICAgIGxldCBlbmQgPSB0aGlzLl9nZXRFbmQoKTtcbiAgICAgICAgY29uc3Qgc2Vjb25kcyA9IGR1cmF0aW9uLmFzKCdzZWNvbmRzJyk7XG5cbiAgICAgICAgaWYgKHNlY29uZHMgPCAwKSB7XG4gICAgICAgICAgICBlbmQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJlZ2luID09PSBudWxsICYmIGVuZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgbmV3QmVnaW4gPSBEYXRlVGltZS5ub3coKTtcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5RGF0ZVRvRmllbGQobmV3QmVnaW4sIHRoaXMuX2JlZ2luRGF0ZSwgdGhpcy5fYmVnaW5UaW1lKTtcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5RGF0ZVRvRmllbGQobmV3QmVnaW4ucGx1cyh7c2Vjb25kczogc2Vjb25kc30pLCBudWxsLCB0aGlzLl9lbmRUaW1lKTtcbiAgICAgICAgfSBlbHNlIGlmIChiZWdpbiA9PT0gbnVsbCAmJiBlbmQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5RGF0ZVRvRmllbGQoZW5kLm1pbnVzKHtzZWNvbmRzOiBzZWNvbmRzfSksIHRoaXMuX2JlZ2luRGF0ZSwgdGhpcy5fYmVnaW5UaW1lKTtcbiAgICAgICAgfSBlbHNlIGlmIChiZWdpbiAhPT0gbnVsbCAmJiBzZWNvbmRzID49IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5RGF0ZVRvRmllbGQoYmVnaW4ucGx1cyh7c2Vjb25kczogc2Vjb25kc30pLCBudWxsLCB0aGlzLl9lbmRUaW1lKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdyaXRlcyB0aGUgdmFsdWUgb2YgYSBkdXJhdGlvbiBvYmplY3QgYXMgaHVtYW4tcmVhZGFibGUgc3RyaW5nIGludG8gdGhlIGR1cmF0aW9uIGZpZWxkXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0R1cmF0aW9ufG51bGx9IGR1cmF0aW9uXG4gICAgICovXG4gICAgX3NldER1cmF0aW9uQXNTdHJpbmcoZHVyYXRpb24pXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuX2lzRHVyYXRpb25Db25uZWN0ZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGR1cmF0aW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9kdXJhdGlvbi52YWx1ZSA9ICcnO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFkdXJhdGlvbi5pc1ZhbGlkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzZWNvbmRzID0gZHVyYXRpb24uYXMoJ3NlY29uZHMnKTtcbiAgICAgICAgaWYgKHNlY29uZHMgPCAwKSB7XG4gICAgICAgICAgICB0aGlzLl9kdXJhdGlvbi52YWx1ZSA9ICcnO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaG91cnMgPSBNYXRoLmZsb29yKHNlY29uZHMgLyAzNjAwKTtcbiAgICAgICAgbGV0IG1pbnV0ZXMgPSBNYXRoLmZsb29yKChzZWNvbmRzIC0gKGhvdXJzICogMzYwMCkpIC8gNjApO1xuXG4gICAgICAgIGlmIChtaW51dGVzIDwgMTApIHtcbiAgICAgICAgICAgIG1pbnV0ZXMgPSAnMCcgKyBtaW51dGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZHVyYXRpb24udmFsdWUgPSBob3VycyArICc6JyArIG1pbnV0ZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGR1cmF0aW9uIG9iamVjdCBmcm9tIHRoZSBkdXJhdGlvbiBpbnB1dCBmaWVsZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAgICovXG4gICAgX2dldFBhcnNlZER1cmF0aW9uKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldERhdGVVdGlscygpLnBhcnNlRHVyYXRpb24odGhpcy5fZHVyYXRpb24udmFsdWUudG9VcHBlckNhc2UoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtEYXRlVGltZXxudWxsfSBkYXRlVGltZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8bnVsbH0gZGF0ZUZpZWxkXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGltZUZpZWxkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYXBwbHlEYXRlVG9GaWVsZChkYXRlVGltZSwgZGF0ZUZpZWxkLCB0aW1lRmllbGQpXG4gICAge1xuICAgICAgICBpZiAoZGF0ZVRpbWUgPT09IG51bGwgfHwgZGF0ZVRpbWUuaW52YWxpZCkge1xuICAgICAgICAgICAgZGF0ZUZpZWxkLnZhbHVlID0gJyc7XG4gICAgICAgICAgICB0aW1lRmllbGQudmFsdWUgPSAnJztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRlRmllbGQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGRhdGVGaWVsZC52YWx1ZSA9IHRoaXMuZ2V0RGF0ZVV0aWxzKCkuZm9ybWF0KGRhdGVGaWVsZC5kYXRhc2V0Wydmb3JtYXQnXSwgZGF0ZVRpbWUpO1xuICAgICAgICB9XG4gICAgICAgIHRpbWVGaWVsZC52YWx1ZSA9IHRoaXMuZ2V0RGF0ZVV0aWxzKCkuZm9ybWF0KHRpbWVGaWVsZC5kYXRhc2V0Wydmb3JtYXQnXSwgZGF0ZVRpbWUpO1xuICAgIH1cblxufVxuIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHRoZSBLaW1haSB0aW1lLXRyYWNraW5nIGFwcC5cbiAqXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXG4gKi9cblxuLyohXG4gKiBbS0lNQUldIEtpbWFpQVBJOiBlYXN5IGFjY2VzcyB0byBBUEkgbWV0aG9kc1xuICovXG5cbmltcG9ydCBLaW1haVBsdWdpbiBmcm9tIFwiLi4vS2ltYWlQbHVnaW5cIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgS2ltYWlBUEkgZXh0ZW5kcyBLaW1haVBsdWdpbiB7XG5cbiAgICBnZXRJZCgpIHtcbiAgICAgICAgcmV0dXJuICdhcGknO1xuICAgIH1cblxuICAgIF9oZWFkZXJzKCkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICAgICAgaGVhZGVycy5hcHBlbmQoJ1gtQVVUSC1TRVNTSU9OJywgJzEnKTtcbiAgICAgICAgaGVhZGVycy5hcHBlbmQoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi9qc29uJyk7XG5cbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuXG4gICAgZ2V0KHVybCwgZGF0YSwgY2FsbGJhY2tTdWNjZXNzLCBjYWxsYmFja0Vycm9yKSB7XG4gICAgICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IChuZXcgVVJMU2VhcmNoUGFyYW1zKGRhdGEpKS50b1N0cmluZygpO1xuICAgICAgICAgICAgaWYgKHBhcmFtcyAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICB1cmwgPSB1cmwgKyAodXJsLmluY2x1ZGVzKCc/JykgPyAnJicgOiAnPycpICsgcGFyYW1zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNhbGxiYWNrRXJyb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2FsbGJhY2tFcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRXJyb3IoJ0FuIGVycm9yIG9jY3VycmVkJywgZXJyb3IpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZmV0Y2godXJsLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5faGVhZGVycygpXG4gICAgICAgIH0pLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICByZXNwb25zZS5qc29uKCkudGhlbigoanNvbikgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrU3VjY2Vzcyhqc29uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGNhbGxiYWNrRXJyb3IoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwb3N0KHVybCwgZGF0YSwgY2FsbGJhY2tTdWNjZXNzLCBjYWxsYmFja0Vycm9yKSB7XG4gICAgICAgIGlmIChjYWxsYmFja0Vycm9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrRXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUVycm9yKCdhY3Rpb24udXBkYXRlLmVycm9yJywgZXJyb3IpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZmV0Y2godXJsLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGJvZHk6IHRoaXMuX3BhcnNlRGF0YShkYXRhKSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuX2hlYWRlcnMoKVxuICAgICAgICB9KS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgcmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb24pID0+IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja1N1Y2Nlc3MoanNvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBjYWxsYmFja0Vycm9yKGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcGF0Y2godXJsLCBkYXRhLCBjYWxsYmFja1N1Y2Nlc3MsIGNhbGxiYWNrRXJyb3IpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrRXJyb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2FsbGJhY2tFcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRXJyb3IoJ2FjdGlvbi51cGRhdGUuZXJyb3InLCBlcnJvcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5mZXRjaCh1cmwsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BBVENIJyxcbiAgICAgICAgICAgIGJvZHk6IHRoaXMuX3BhcnNlRGF0YShkYXRhKSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuX2hlYWRlcnMoKVxuICAgICAgICB9KS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDIwNCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrU3VjY2VzcygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZS5qc29uKCkudGhlbigoanNvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja1N1Y2Nlc3MoanNvbik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgY2FsbGJhY2tFcnJvcihlcnJvcik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGRlbGV0ZSh1cmwsIGNhbGxiYWNrU3VjY2VzcywgY2FsbGJhY2tFcnJvcikge1xuICAgICAgICBpZiAoY2FsbGJhY2tFcnJvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjYWxsYmFja0Vycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVFcnJvcignYWN0aW9uLmRlbGV0ZS5lcnJvcicsIGVycm9yKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZldGNoKHVybCwge1xuICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuX2hlYWRlcnMoKVxuICAgICAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGNhbGxiYWNrU3VjY2VzcygpO1xuICAgICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGNhbGxiYWNrRXJyb3IoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IGRhdGFcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3BhcnNlRGF0YShkYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gICAgICogQHBhcmFtIHtSZXNwb25zZX0gcmVzcG9uc2VcbiAgICAgKi9cbiAgICBoYW5kbGVFcnJvcihtZXNzYWdlLCByZXNwb25zZSkge1xuICAgICAgICBpZiAocmVzcG9uc2UuaGVhZGVycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGNhbiBoYXBwZW4gaWYgc29tZW9uZSBjbGlja3MgdG8gZmFzdCBhbmQgYXV0byBydW5uaW5nXG4gICAgICAgICAgICAvLyByZXF1ZXN0cyAoZS5nLiBhY3RpdmUgcmVjb3JkcykgYXJlIGFib3J0ZWRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIik7XG4gICAgICAgIGlmIChjb250ZW50VHlwZSAmJiBjb250ZW50VHlwZS5pbmRleE9mKFwiYXBwbGljYXRpb24vanNvblwiKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlLmpzb24oKS50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHRFcnJvciA9IGRhdGEubWVzc2FnZTtcbiAgICAgICAgICAgICAgICAvLyBmaW5kIHZhbGlkYXRpb24gZXJyb3JzXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDAwICYmIGRhdGEuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb2xsZWN0ZWQgPSBbJzx1PicgKyByZXN1bHRFcnJvciArICc8L3U+J107XG4gICAgICAgICAgICAgICAgICAgIC8vIGZvcm0gZXJyb3JzIHRoYXQgYXJlIG5vdCBhdHRhY2hlZCB0byBhIGZpZWxkIChsaWtlIGV4dHJhIGZpZWxkcylcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuZXJyb3JzLmVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgZXJyb3Igb2YgZGF0YS5lcnJvcnMuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGVkLnB1c2goZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmVycm9ycy5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgZmllbGQgaW4gZGF0YS5lcnJvcnMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdG1wRmllbGQgPSBkYXRhLmVycm9ycy5jaGlsZHJlbltmaWVsZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRtcEZpZWxkLmVycm9ycyAhPT0gdW5kZWZpbmVkICYmIHRtcEZpZWxkLmVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGVycm9yIG9mIHRtcEZpZWxkLmVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGVkLnB1c2goZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2xsZWN0ZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0RXJyb3IgPSBjb2xsZWN0ZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmdldFBsdWdpbignYWxlcnQnKS5lcnJvcihtZXNzYWdlLCByZXN1bHRFcnJvcik7XG5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzcG9uc2UudGV4dCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdEVycm9yID0gJ1snICsgcmVzcG9uc2Uuc3RhdHVzQ29kZSArICddICcgKyByZXNwb25zZS5zdGF0dXNUZXh0O1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0UGx1Z2luKCdhbGVydCcpLmVycm9yKG1lc3NhZ2UsIHJlc3VsdEVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG59XG4iLCIvKlxyXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiB0aGUgS2ltYWkgdGltZS10cmFja2luZyBhcHAuXHJcbiAqXHJcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXHJcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxyXG4gKi9cclxuXHJcbmltcG9ydCBLaW1haVBsdWdpbiBmcm9tIFwiLi4vS2ltYWlQbHVnaW5cIjtcclxuXHJcbi8qKlxyXG4gKiBOZWVkcyB0byBiZSBpbml0aWFsaXplZCB3aXRoIGEgY2xhc3MgbmFtZS5cclxuICpcclxuICogQSBsaW5rIGxpa2UgPGEgaHJlZj0jIGNsYXNzPXJlbW90ZUxpbms+IGNhbiBiZSBhY3RpdmF0ZWQgd2l0aDpcclxuICogbmV3IEtpbWFpQVBJTGluaygncmVtb3RlTGluaycpXHJcbiAqXHJcbiAqIEFsbG93cyB0byBhc3NpZ24gdGhlIGdpdmVuIHNlbGVjdG9yIHRvIGFueSBlbGVtZW50LCB3aGljaCB0aGVuIGlzIHVzZWQgYXMgY2xpY2staGFuZGxlclxyXG4gKiBjYWxsaW5nIGFuIEFQSSBtZXRob2QgYW5kIHRyaWdnZXIgdGhlIGV2ZW50IGZyb20gZGF0YS1ldmVudCBhdHRyaWJ1dGUgYWZ0ZXJ3YXJkcy5cclxuICpcclxuICogQHBhcmFtIHNlbGVjdG9yXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBLaW1haUFQSUxpbmsgZXh0ZW5kcyBLaW1haVBsdWdpbiB7XHJcblxyXG4gICAgY29uc3RydWN0b3Ioc2VsZWN0b3IpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX3NlbGVjdG9yID0gc2VsZWN0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgaW5pdCgpIHtcclxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xyXG4gICAgICAgICAgICB3aGlsZSAodGFyZ2V0ICE9PSBudWxsICYmIHR5cGVvZiB0YXJnZXQubWF0Y2hlcyA9PT0gXCJmdW5jdGlvblwiICYmICF0YXJnZXQubWF0Y2hlcygnYm9keScpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyh0aGlzLl9zZWxlY3RvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gdGFyZ2V0LmRhdGFzZXQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGxldCB1cmwgPSBhdHRyaWJ1dGVzWydocmVmJ107XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF1cmwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gdGFyZ2V0LmdldEF0dHJpYnV0ZSgnaHJlZicpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXMucXVlc3Rpb24gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdldENvbnRhaW5lcigpLmdldFBsdWdpbignYWxlcnQnKS5xdWVzdGlvbihhdHRyaWJ1dGVzLnF1ZXN0aW9uLCAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbGxBcGkodXJsLCBhdHRyaWJ1dGVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FsbEFwaSh1cmwsIGF0dHJpYnV0ZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxyXG4gICAgICogQHBhcmFtIHtET01TdHJpbmdNYXB9IGF0dHJpYnV0ZXNcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9jYWxsQXBpKHVybCwgYXR0cmlidXRlcylcclxuICAgIHtcclxuICAgICAgICBjb25zdCBtZXRob2QgPSBhdHRyaWJ1dGVzWydtZXRob2QnXTtcclxuICAgICAgICBjb25zdCBldmVudE5hbWUgPSBhdHRyaWJ1dGVzWydldmVudCddO1xyXG4gICAgICAgIC8qKiBAdHlwZSB7S2ltYWlBUEl9IEFQSSAqL1xyXG4gICAgICAgIGNvbnN0IEFQSSA9IHRoaXMuZ2V0Q29udGFpbmVyKCkuZ2V0UGx1Z2luKCdhcGknKTtcclxuICAgICAgICAvKiogQHR5cGUge0tpbWFpRXZlbnR9IEVWRU5UUyAqL1xyXG4gICAgICAgIGNvbnN0IEVWRU5UUyA9IHRoaXMuZ2V0Q29udGFpbmVyKCkuZ2V0UGx1Z2luKCdldmVudCcpO1xyXG4gICAgICAgIC8qKiBAdHlwZSB7S2ltYWlBbGVydH0gQUxFUlQgKi9cclxuICAgICAgICBjb25zdCBBTEVSVCA9IHRoaXMuZ2V0Q29udGFpbmVyKCkuZ2V0UGx1Z2luKCdhbGVydCcpO1xyXG4gICAgICAgIGNvbnN0IHN1Y2Nlc3NIYW5kbGUgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIEVWRU5UUy50cmlnZ2VyKGV2ZW50TmFtZSk7XHJcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVzWydtc2dTdWNjZXNzJ10gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgQUxFUlQuc3VjY2VzcyhhdHRyaWJ1dGVzWydtc2dTdWNjZXNzJ10pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBlcnJvckhhbmRsZSA9IChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICBsZXQgbWVzc2FnZSA9ICdhY3Rpb24udXBkYXRlLmVycm9yJztcclxuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXNbJ21zZ0Vycm9yJ10gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGF0dHJpYnV0ZXNbJ21zZ0Vycm9yJ107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgQVBJLmhhbmRsZUVycm9yKG1lc3NhZ2UsIGVycm9yKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBsZXQgZGF0YSA9IHt9O1xyXG4gICAgICAgIGlmIChhdHRyaWJ1dGVzWydwYXlsb2FkJ10gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBkYXRhID0gYXR0cmlidXRlc1sncGF5bG9hZCddO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gJ1BBVENIJykge1xyXG4gICAgICAgICAgICBBUEkucGF0Y2godXJsLCBkYXRhLCBzdWNjZXNzSGFuZGxlLCBlcnJvckhhbmRsZSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09ICdQT1NUJykge1xyXG4gICAgICAgICAgICBsZXQgZGF0YSA9IHt9O1xyXG4gICAgICAgICAgICBBUEkucG9zdCh1cmwsIGRhdGEsIHN1Y2Nlc3NIYW5kbGUsIGVycm9ySGFuZGxlKTtcclxuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gJ0RFTEVURScpIHtcclxuICAgICAgICAgICAgQVBJLmRlbGV0ZSh1cmwsIHN1Y2Nlc3NIYW5kbGUsIGVycm9ySGFuZGxlKTtcclxuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gJ0dFVCcpIHtcclxuICAgICAgICAgICAgQVBJLmdldCh1cmwsIGRhdGEsIHN1Y2Nlc3NIYW5kbGUsIGVycm9ySGFuZGxlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59XHJcbiIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiB0aGUgS2ltYWkgdGltZS10cmFja2luZyBhcHAuXG4gKlxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxuICovXG5cbi8qIVxuICogW0tJTUFJXSBLaW1haUFjdGl2ZVJlY29yZHM6IHJlc3BvbnNpYmxlIHRvIGRpc3BsYXkgdGhlIHVzZXJzIGFjdGl2ZSByZWNvcmRzXG4gKi9cblxuaW1wb3J0IEtpbWFpUGx1Z2luIGZyb20gJy4uL0tpbWFpUGx1Z2luJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgS2ltYWlBY3RpdmVSZWNvcmRzIGV4dGVuZHMgS2ltYWlQbHVnaW4ge1xuXG4gICAgY29uc3RydWN0b3IoKVxuICAgIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fc2VsZWN0b3IgPSAnLnRpY2t0YWMtbWVudSc7XG4gICAgICAgIHRoaXMuX3NlbGVjdG9yRW1wdHkgPSAnLnRpY2t0YWMtbWVudS1lbXB0eSc7XG4gICAgICAgIHRoaXMuX2Zhdkljb25VcmwgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0SWQoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuICdhY3RpdmUtcmVjb3Jkcyc7XG4gICAgfVxuXG4gICAgaW5pdCgpXG4gICAge1xuICAgICAgICAvLyB0aGUgbWVudSBjYW4gYmUgaGlkZGVuIGlmIHVzZXIgaGFzIG5vIHBlcm1pc3Npb25zIHRvIHNlZSBpdFxuICAgICAgICBpZiAoZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0aGlzLl9zZWxlY3RvcikgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGhhbmRsZVVwZGF0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVsb2FkQWN0aXZlUmVjb3JkcygpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tpbWFpLnRpbWVzaGVldFVwZGF0ZScsIGhhbmRsZVVwZGF0ZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tpbWFpLnRpbWVzaGVldERlbGV0ZScsIGhhbmRsZVVwZGF0ZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tpbWFpLmFjdGl2aXR5VXBkYXRlJywgaGFuZGxlVXBkYXRlKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2ltYWkuYWN0aXZpdHlEZWxldGUnLCBoYW5kbGVVcGRhdGUpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdraW1haS5wcm9qZWN0VXBkYXRlJywgaGFuZGxlVXBkYXRlKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2ltYWkucHJvamVjdERlbGV0ZScsIGhhbmRsZVVwZGF0ZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tpbWFpLmN1c3RvbWVyVXBkYXRlJywgaGFuZGxlVXBkYXRlKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2ltYWkuY3VzdG9tZXJEZWxldGUnLCBoYW5kbGVVcGRhdGUpO1xuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIGhhbmRsZSBkdXJhdGlvbiBpbiB0aGUgdmlzaWJsZSBVSVxuICAgICAgICB0aGlzLl91cGRhdGVCcm93c2VyVGl0bGUgPSAhIXRoaXMuZ2V0Q29uZmlndXJhdGlvbigndXBkYXRlQnJvd3NlclRpdGxlJyk7XG5cbiAgICAgICAgY29uc3QgaGFuZGxlID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlRHVyYXRpb24oKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fdXBkYXRlc0hhbmRsZXIgPSBzZXRJbnRlcnZhbChoYW5kbGUsIDEwMDAwKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2ltYWkudGltZXNoZWV0VXBkYXRlJywgaGFuZGxlKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2ltYWkucmVsb2FkZWRDb250ZW50JywgaGFuZGxlKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPIHdlIGNvdWxkIHVucmVnaXN0ZXIgYWxsIGhhbmRsZXIgYW5kIGxpc3RlbmVyXG4gICAgLy8gX3VucmVnaXN0ZXJIYW5kbGVyKCkge1xuICAgIC8vICAgICBjbGVhckludGVydmFsKHRoaXMuX3VwZGF0ZXNIYW5kbGVyKTtcbiAgICAvLyB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBkdXJhdGlvbiBvZiBhbGwgcnVubmluZyBlbnRyaWVzLCBib3RoIGluIHRoZSB0aWNrdGFjIG1lbnVzIGFuZCBpbiB0aGUgbGlzdGluZyBwYWdlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3VwZGF0ZUR1cmF0aW9uKClcbiAgICB7XG4gICAgICAgIC8vIG5lZWRzIHRvIHNlYXJjaCBpbiBkb2N1bWVudCwgdG8gZmluZCBhbGwgcnVubmluZyBlbnRyaWVzLCBib3RoIGluIFwidGlja3RhY1wiIGFuZCBsaXN0aW5nIHBhZ2VzXG4gICAgICAgIGNvbnN0IGFjdGl2ZVJlY29yZHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1zaW5jZV06bm90KFtkYXRhLXNpbmNlPVwiXCJdKScpO1xuXG4gICAgICAgIGlmICh0aGlzLl91cGRhdGVCcm93c2VyVGl0bGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZUZhdmljb24oYWN0aXZlUmVjb3Jkcy5sZW5ndGggPiAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhY3RpdmVSZWNvcmRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3VwZGF0ZUJyb3dzZXJUaXRsZSkge1xuICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudC5ib2R5LmRhdGFzZXRbJ3RpdGxlJ10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVCcm93c2VyVGl0bGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC50aXRsZSA9IGRvY3VtZW50LmJvZHkuZGF0YXNldFsndGl0bGUnXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBEQVRFID0gdGhpcy5nZXREYXRlVXRpbHMoKTtcbiAgICAgICAgbGV0IGR1cmF0aW9ucyA9IFtdO1xuXG4gICAgICAgIGZvciAoY29uc3QgcmVjb3JkIG9mIGFjdGl2ZVJlY29yZHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGR1cmF0aW9uID0gREFURS5mb3JtYXREdXJhdGlvbihyZWNvcmQuZGF0YXNldFsnc2luY2UnXSk7XG4gICAgICAgICAgICAvLyBvbmx5IHVzZSB0aGUgb25lcyBmcm9tIHRoZSBtZW51IGZvciB0aGUgdGl0bGVcbiAgICAgICAgICAgIGlmIChyZWNvcmQuZGF0YXNldFsncmVwbGFjZXInXSAhPT0gdW5kZWZpbmVkICYmIHJlY29yZC5kYXRhc2V0Wyd0aXRsZSddICE9PSBudWxsICYmIGR1cmF0aW9uICE9PSAnPycpIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbnMucHVzaChkdXJhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBidXQgdXBkYXRlIGFsbCBvbiB0aGUgcGFnZSAocnVubmluZyBlbnRyaWVzIGluIGxpc3QgcGFnZXMpXG4gICAgICAgICAgICByZWNvcmQudGV4dENvbnRlbnQgPSBkdXJhdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkdXJhdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fdXBkYXRlQnJvd3NlclRpdGxlKSB7XG4gICAgICAgICAgICAvLyBvbmx5IHNob3cgdGhlIGZpcnN0IGZvdW5kIHJlY29yZCwgZXZlbiBpZiB3ZSBoYXZlIG1vcmVcbiAgICAgICAgICAgIGRvY3VtZW50LnRpdGxlID0gZHVyYXRpb25zLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGFwdHMgdGhlIHRpY2t0YWMgbWVudXMgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBlbnRyaWVzIChhbW91bnQgYW5kIGR1cmF0aW9uKS5cbiAgICAgKiBEb2VzIG5vdCBpbmZsdWVuY2UgbGlzdGluZyBwYWdlcywgYXMgdGhvc2UgcmVmcmVzaCB0aGVtc2VsdmVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHthcnJheX0gZW50cmllc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldEVudHJpZXMoZW50cmllcylcbiAgICB7XG4gICAgICAgIGNvbnN0IGhhc0VudHJpZXMgPSBlbnRyaWVzLmxlbmd0aCA+IDA7XG5cbiAgICAgICAgLy8gdGhlc2UgY29udGFpbiB0aGUgXCJzdGFydFwiIGJ1dHRvblxuICAgICAgICBmb3IgKGxldCBtZW51RW1wdHkgb2YgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh0aGlzLl9zZWxlY3RvckVtcHR5KSkge1xuICAgICAgICAgICAgbWVudUVtcHR5LnN0eWxlLmRpc3BsYXkgPSAhaGFzRW50cmllcyA/ICdpbmxpbmUtYmxvY2snIDogJ25vbmUnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYW5kIHRoZXkgY29udGFpbiB0aGUgXCJzdG9wXCIgYnV0dG9uXG4gICAgICAgIGZvciAobGV0IG1lbnUgb2YgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh0aGlzLl9zZWxlY3RvcikpIHtcbiAgICAgICAgICAgIG1lbnUuc3R5bGUuZGlzcGxheSA9IGhhc0VudHJpZXMgPyAnaW5saW5lLWJsb2NrJyA6ICdub25lJztcbiAgICAgICAgICAgIGlmICghaGFzRW50cmllcykge1xuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGF0IHRlbXBsYXRlIGVudHJpZXMgaW4gdGhlIG1lbnUgYXJlIHJlbW92ZWQsIG90aGVyd2lzZSB0aGV5XG4gICAgICAgICAgICAgICAgLy8gbWlnaHQgc3RpbGwgYmUgc2hvd24gaW4gdGhlIGJyb3dzZXJzIHRpdGxlXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcmVjb3JkIG9mIG1lbnUucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtc2luY2VdJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkLmRhdGFzZXRbJ3NpbmNlJ10gPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHN0b3AgPSBtZW51LnF1ZXJ5U2VsZWN0b3IoJy50aWNrdGFjLXN0b3AnKTtcblxuICAgICAgICAgICAgaWYgKCFoYXNFbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcC5hY2Nlc3NrZXkgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHN0b3ApIHtcbiAgICAgICAgICAgICAgICBzdG9wLmFjY2Vzc2tleSA9ICdzJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3JlcGxhY2VJbk5vZGUobWVudSwgZW50cmllc1swXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl91cGRhdGVEdXJhdGlvbigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdGltZXNoZWV0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVwbGFjZUluTm9kZShub2RlLCB0aW1lc2hlZXQpXG4gICAge1xuICAgICAgICBcbiAgICAgICAgY29uc3QgZGF0ZSA9IHRoaXMuZ2V0RGF0ZVV0aWxzKCk7XG4gICAgICAgIGNvbnN0IGFsbFJlcGxhY2VyID0gbm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1yZXBsYWNlcl0nKTtcbiAgICAgICAgZm9yIChsZXQgbGluayBvZiBhbGxSZXBsYWNlcikge1xuICAgICAgICAgICAgY29uc3QgcmVwbGFjZXJOYW1lID0gbGluay5kYXRhc2V0WydyZXBsYWNlciddO1xuY29uc29sZS5sb2coYHJlcGxhY2VyTmFtZTogJHtyZXBsYWNlck5hbWV9YClcbiAgICAgICAgICAgIGlmIChyZXBsYWNlck5hbWUgPT09ICd1cmwnKSB7XG4gICAgICAgICAgICAgICAgbGluay5kYXRhc2V0WydocmVmJ10gPSBub2RlLmRhdGFzZXRbJ2hyZWYnXS5yZXBsYWNlKCcwMDAnLCB0aW1lc2hlZXQuaWQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyZXBsYWNlck5hbWUgPT09ICdhY3Rpdml0eScpIHtcbiAgICAgICAgICAgICAgICBsaW5rLmlubmVyVGV4dCA9IHRpbWVzaGVldC5hY3Rpdml0eS5uYW1lO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyZXBsYWNlck5hbWUgPT09ICdwcm9qZWN0Jykge1xuICAgICAgICAgICAgICAgIGxpbmsuaW5uZXJUZXh0ID0gdGltZXNoZWV0LnByb2plY3QubmFtZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVwbGFjZXJOYW1lID09PSAnY3VzdG9tZXInKSB7XG4gICAgICAgICAgICAgICAgbGluay5pbm5lclRleHQgPSB0aW1lc2hlZXQucHJvamVjdC5jdXN0b21lci5uYW1lO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyZXBsYWNlck5hbWUgPT09ICdkdXJhdGlvbicpIHtcbiAgICAgICAgICAgICAgICBsaW5rLmRhdGFzZXRbJ3NpbmNlJ10gPSB0aW1lc2hlZXQuYmVnaW47XG4gICAgICAgICAgICAgICAgbGluay5pbm5lclRleHQgPSBkYXRlLmZvcm1hdER1cmF0aW9uKHRpbWVzaGVldC5kdXJhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZWxvYWRBY3RpdmVSZWNvcmRzKClcbiAgICB7XG4gICAgICAgIC8qKiBAdHlwZSB7S2ltYWlBUEl9IEFQSSAqL1xuICAgICAgICBjb25zdCBBUEkgPSB0aGlzLmdldENvbnRhaW5lcigpLmdldFBsdWdpbignYXBpJyk7XG5cbiAgICAgICAgLy8gVE9ETyB1c2luZyB0aGUgZmlyc3QgZm91bmQgXCJ0aWNrdGFjXCIgbWVudSBpcyB3b3JraW5nLCBidXQgY2FuIGJlIGRvbmUgYmV0dGVyXG4gICAgICAgIGNvbnN0IGFwaVVybCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5fc2VsZWN0b3IpLmRhdGFzZXRbJ2FwaSddO1xuXG4gICAgICAgIEFQSS5nZXQoYXBpVXJsLCB7fSwgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fc2V0RW50cmllcyhyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJ1bm5pbmdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jaGFuZ2VGYXZpY29uKHJ1bm5pbmcpXG4gICAge1xuICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgY29uc3Qgb3JpZyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmYXZpY29uJyk7XG4gICAgICAgIGlmICh0aGlzLl9mYXZJY29uVXJsID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9mYXZJY29uVXJsID0gb3JpZy5ocmVmO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxpbmsgPSBvcmlnLmNsb25lTm9kZSh0cnVlKTtcblxuICAgICAgICBpZiAoY2FudmFzLmdldENvbnRleHQgJiYgbGluaykge1xuICAgICAgICAgICAgY29uc3QgcmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgICAgICAgIGNvbnN0IGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGNhbnZhcy53aWR0aCA9IDE2ICogcmF0aW87XG4gICAgICAgICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcywgMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBpZiAocnVubmluZykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB3aWR0aCA9IDUuNSAqIHJhdGlvO1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3JnYigxODIsNTcsNTcpJztcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KChjYW52YXMud2lkdGggLyAyKSAtICh3aWR0aCAvIDIpLCAoY2FudmFzLmhlaWdodCAvIDIpIC0gKHdpZHRoIC8gMiksIHdpZHRoLCB3aWR0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxpbmsuaHJlZiA9IGNhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL3BuZycpO1xuICAgICAgICAgICAgICAgIG9yaWcucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChsaW5rKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpbWcuc3JjID0gdGhpcy5fZmF2SWNvblVybDtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiB0aGUgS2ltYWkgdGltZS10cmFja2luZyBhcHAuXG4gKlxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxuICovXG5cbi8qIVxuICogW0tJTUFJXSBLaW1haUFqYXhNb2RhbEZvcm1cbiAqXG4gKiBhbGxvd3MgdG8gYXNzaWduIHRoZSBnaXZlbiBzZWxlY3RvciB0byBhbnkgZWxlbWVudCwgd2hpY2ggdGhlbiBpcyB1c2VkIGFzIGNsaWNrLWhhbmRsZXI6XG4gKiBvcGVuaW5nIGEgbW9kYWwgd2l0aCB0aGUgY29udGVudCBmcm9tIHRoZSBVUkwgZ2l2ZW4gaW4gdGhlIGVsZW1lbnRzICdkYXRhLWhyZWYnIG9yICdocmVmJyBhdHRyaWJ1dGVcbiAqL1xuXG5pbXBvcnQgS2ltYWlSZWR1Y2VkQ2xpY2tIYW5kbGVyIGZyb20gXCIuL0tpbWFpUmVkdWNlZENsaWNrSGFuZGxlclwiO1xuaW1wb3J0IHsgTW9kYWwgfSBmcm9tICdib290c3RyYXAnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBLaW1haUFqYXhNb2RhbEZvcm0gZXh0ZW5kcyBLaW1haVJlZHVjZWRDbGlja0hhbmRsZXIge1xuXG4gICAgY29uc3RydWN0b3Ioc2VsZWN0b3IpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICB9XG5cbiAgICBnZXRJZCgpXG4gICAge1xuICAgICAgICByZXR1cm4gJ21vZGFsJztcbiAgICB9XG5cbiAgICBpbml0KClcbiAgICB7XG4gICAgICAgIHRoaXMuX2lzRGlydHkgPSBmYWxzZTtcblxuICAgICAgICBjb25zdCBtb2RhbEVsZW1lbnQgPSB0aGlzLl9nZXRNb2RhbEVsZW1lbnQoKTtcbiAgICAgICAgaWYgKG1vZGFsRWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbW9kYWxFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2hpZGUuYnMubW9kYWwnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0RpcnR5KSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vZGFsRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcubW9kYWwtYm9keSAucmVtb3RlX21vZGFsX2lzX2RpcnR5X3dhcm5pbmcnKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSB0aGlzLnRyYW5zbGF0ZSgnbW9kYWwuZGlydHknKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVtcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgICAgICB0ZW1wLmlubmVySFRNTCA9ICc8cCBjbGFzcz1cInRleHQtZGFuZ2VyIHNtYWxsIHJlbW90ZV9tb2RhbF9pc19kaXJ0eV93YXJuaW5nXCI+JyArIG1zZyArICc8L3A+JztcbiAgICAgICAgICAgICAgICAgICAgbW9kYWxFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5tb2RhbC1ib2R5JykucHJlcGVuZCh0ZW1wLmZpcnN0RWxlbWVudENoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9pc0RpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnbW9kYWwtaGlkZScpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbW9kYWxFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2hpZGRlbi5icy5tb2RhbCcsICgpID0+IHtcbiAgICAgICAgICAgIC8vIGtpbGwgYWxsIHJlZmVyZW5jZXMsIHNvIEdDIGNhbiBraWNrIGluXG4gICAgICAgICAgICB0aGlzLmdldENvbnRhaW5lcigpLmdldFBsdWdpbignZm9ybScpLmRlc3Ryb3lGb3JtKHRoaXMuX2dldEZvcm1JZGVudGlmaWVyKCkpO1xuICAgICAgICAgICAgbW9kYWxFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5tb2RhbC1ib2R5JykucmVwbGFjZVdpdGgoJycpO1xuICAgICAgICB9KTtcblxuICAgICAgICBtb2RhbEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2hvdy5icy5tb2RhbCcsICgpID0+IHtcbiAgICAgICAgICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdtb2RhbC1zaG93JykpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZENsaWNrSGFuZGxlcih0aGlzLl9zZWxlY3RvciwgKGhyZWYpID0+IHtcbiAgICAgICAgICAgIHRoaXMub3BlblVybEluTW9kYWwoaHJlZik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIF9nZXRNb2RhbCgpXG4gICAge1xuICAgICAgICByZXR1cm4gTW9kYWwuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLl9nZXRNb2RhbEVsZW1lbnQoKSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihSZXNwb25zZSl9IGVycm9yIHRoZSBjYWxsYmFjayB0byBleGVjdXRlIGlmIHRoZSBmZXRjaCBmYWlsZWRcbiAgICAgKi9cbiAgICBvcGVuVXJsSW5Nb2RhbCh1cmwsIGVycm9yKVxuICAgIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gICAgICAgIGhlYWRlcnMuYXBwZW5kKCdYLVJlcXVlc3RlZC1XaXRoJywgJ0tpbWFpLU1vZGFsJyk7XG5cbiAgICAgICAgdGhpcy5mZXRjaCh1cmwsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICByZWRpcmVjdDogJ2ZvbGxvdycsXG4gICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzXG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24gPSB1cmw7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpLnRoZW4oaHRtbCA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3BlbkZvcm1Jbk1vZGFsKGh0bWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgocmVhc29uKSA9PiAge1xuICAgICAgICAgICAgaWYgKGVycm9yID09PSB1bmRlZmluZWQgfHwgZXJyb3IgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24gPSB1cmw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVycm9yKHJlYXNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIENTUyBzZWxlY3RvciBmb3IgdGhlIG1vZGFsIGZvcm0uXG4gICAgICogXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRGb3JtSWRlbnRpZmllcigpXG4gICAge1xuICAgICAgICByZXR1cm4gJyNyZW1vdGVfZm9ybV9tb2RhbCAubW9kYWwtY29udGVudCBmb3JtJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR8bnVsbH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRNb2RhbEVsZW1lbnQoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyZW1vdGVfZm9ybV9tb2RhbCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudHxDaGlsZE5vZGV9IG5vZGVcbiAgICAgKiBAcmV0dXJucyB7RWxlbWVudH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlU2NyaXB0RXhlY3V0YWJsZShub2RlKSB7XG4gICAgICAgIGlmIChub2RlLnRhZ05hbWUgIT09IHVuZGVmaW5lZCAmJiBub2RlLnRhZ05hbWUgPT09ICdTQ1JJUFQnKSB7XG4gICAgICAgICAgICBjb25zdCBzY3JpcHQgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgICAgICBzY3JpcHQudGV4dCA9IG5vZGUuaW5uZXJIVE1MO1xuICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChzY3JpcHQsIG5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBub2RlLmNoaWxkTm9kZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYWtlU2NyaXB0RXhlY3V0YWJsZShjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG5cbiAgICBfb3BlbkZvcm1Jbk1vZGFsKGh0bWwpXG4gICAge1xuICAgICAgICBjb25zdCBmb3JtSWRlbnRpZmllciA9IHRoaXMuX2dldEZvcm1JZGVudGlmaWVyKCk7XG4gICAgICAgIGxldCByZW1vdGVNb2RhbCA9IHRoaXMuX2dldE1vZGFsRWxlbWVudCgpO1xuICAgICAgICBjb25zdCBuZXdGb3JtSHRtbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBuZXdGb3JtSHRtbC5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgICBjb25zdCBuZXdNb2RhbENvbnRlbnQgPSB0aGlzLl9tYWtlU2NyaXB0RXhlY3V0YWJsZShuZXdGb3JtSHRtbC5xdWVyeVNlbGVjdG9yKCcjZm9ybV9tb2RhbCAubW9kYWwtY29udGVudCcpKTtcblxuICAgICAgICAvLyBsb2FkIG5ldyBmb3JtIGZyb20gZ2l2ZW4gY29udGVudFxuICAgICAgICBpZiAobmV3TW9kYWxDb250ZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBTdXBwb3J0IGNoYW5naW5nIG1vZGFsIHNpemVzXG4gICAgICAgICAgICBsZXQgbW9kYWxEaWFsb2cgPSByZW1vdGVNb2RhbC5xdWVyeVNlbGVjdG9yKCcubW9kYWwtZGlhbG9nJyk7XG4gICAgICAgICAgICBsZXQgbGFyZ2VNb2RhbCA9IG5ld0Zvcm1IdG1sLnF1ZXJ5U2VsZWN0b3IoJy5tb2RhbC1kaWFsb2cnKS5jbGFzc0xpc3QuY29udGFpbnMoJ21vZGFsLWxnJyk7XG5cbiAgICAgICAgICAgIGlmIChsYXJnZU1vZGFsICYmICFtb2RhbERpYWxvZy5jbGFzc0xpc3QuY29udGFpbnMoJ21vZGFsLWxnJykpIHtcbiAgICAgICAgICAgICAgICBtb2RhbERpYWxvZy5jbGFzc0xpc3QudG9nZ2xlKCdtb2RhbC1sZycpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWxhcmdlTW9kYWwgJiYgbW9kYWxEaWFsb2cuY2xhc3NMaXN0LmNvbnRhaW5zKCdtb2RhbC1sZycpKSB7XG4gICAgICAgICAgICAgICAgbW9kYWxEaWFsb2cuY2xhc3NMaXN0LnRvZ2dsZSgnbW9kYWwtbGcnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVtb3RlTW9kYWwucXVlcnlTZWxlY3RvcignLm1vZGFsLWNvbnRlbnQnKS5yZXBsYWNlV2l0aChuZXdNb2RhbENvbnRlbnQpO1xuICAgICAgICAgICAgW10uc2xpY2UuY2FsbChyZW1vdGVNb2RhbC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1icy1kaXNtaXNzPVwibW9kYWxcIl0nKSkubWFwKChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faXNEaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9nZXRNb2RhbCgpLmhpZGUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBhY3RpdmF0ZSBuZXcgbG9hZGVkIHdpZGdldHNcbiAgICAgICAgICAgIHRoaXMuZ2V0Q29udGFpbmVyKCkuZ2V0UGx1Z2luKCdmb3JtJykuYWN0aXZhdGVGb3JtKGZvcm1JZGVudGlmaWVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNob3cgZXJyb3IgZmxhc2ggbWVzc2FnZXNcbiAgICAgICAgbGV0IGZsYXNoTWVzc2FnZXMgPSBuZXdGb3JtSHRtbC5xdWVyeVNlbGVjdG9yKCdkaXYuYWxlcnQnKTtcbiAgICAgICAgaWYgKGZsYXNoTWVzc2FnZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlbW90ZU1vZGFsLnF1ZXJ5U2VsZWN0b3IoJy5tb2RhbC1ib2R5JykucHJlcGVuZChmbGFzaE1lc3NhZ2VzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoZSBuZXcgZm9ybSB0aGF0IHdhcyBsb2FkZWQgdmlhIGFqYXhcbiAgICAgICAgY29uc3QgZm9ybSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZm9ybUlkZW50aWZpZXIpO1xuXG4gICAgICAgIGZvcm0uYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5faXNEaXJ0eSA9IHRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGNsaWNrIGhhbmRsZXIgZm9yIG1vZGFsIHNhdmUgYnV0dG9uLCB0byBzZW5kIGZvcm1zIHZpYSBhamF4XG4gICAgICAgIGZvcm0uYWRkRXZlbnRMaXN0ZW5lcignc3VibWl0JywgdGhpcy5fZ2V0RXZlbnRIYW5kbGVyKCkpO1xuXG4gICAgICAgIHRoaXMuX2dldE1vZGFsKCkuc2hvdygpO1xuICAgIH1cblxuICAgIF9nZXRFdmVudEhhbmRsZXIoKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRIYW5kbGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRIYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZm9ybSA9IGV2ZW50LnRhcmdldDtcblxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBmb3JtIGhhcyBhIHRhcmdldCwgd2UgbGV0IHRoZSBub3JtYWwgSFRNTCBmbG93IGhhcHBlblxuICAgICAgICAgICAgICAgIGlmIChmb3JtLnRhcmdldCAhPT0gdW5kZWZpbmVkICYmIGZvcm0udGFyZ2V0ICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2Ugd2UgZG8gc29tZSBBSkFYIG1hZ2ljIHRvIHByb2Nlc3MgdGhlIGZvcm0gaW4gdGhlIGJhY2tncm91bmRcbiAgICAgICAgICAgICAgICAvKiogQHR5cGUge0hUTUxCdXR0b25FbGVtZW50fSBidG4gKi9cbiAgICAgICAgICAgICAgICBjb25zdCBidG4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRoaXMuX2dldEZvcm1JZGVudGlmaWVyKCkgKyAnIGJ1dHRvblt0eXBlPXN1Ym1pdF0nKTtcbiAgICAgICAgICAgICAgICBidG4udGV4dENvbnRlbnQgPSBidG4udGV4dENvbnRlbnQgKyAnIOKApic7XG4gICAgICAgICAgICAgICAgYnRuLmRpc2FibGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50TmFtZSA9IGZvcm0uZGF0YXNldFsnZm9ybUV2ZW50J107XG4gICAgICAgICAgICAgICAgLyoqIEB0eXBlIHtLaW1haUV2ZW50fSBhbGVydCAqL1xuICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50cyA9IHRoaXMuZ2V0Q29udGFpbmVyKCkuZ2V0UGx1Z2luKCdldmVudCcpO1xuICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7S2ltYWlBbGVydH0gYWxlcnQgKi9cbiAgICAgICAgICAgICAgICBjb25zdCBhbGVydCA9IHRoaXMuZ2V0Q29udGFpbmVyKCkuZ2V0UGx1Z2luKCdhbGVydCcpO1xuXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICAgICAgICAgICAgICAgIGhlYWRlcnMuYXBwZW5kKCdYLVJlcXVlc3RlZC1XaXRoJywgJ0tpbWFpLU1vZGFsJyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtoZWFkZXJzOiBoZWFkZXJzfTtcblxuICAgICAgICAgICAgICAgIHRoaXMuZmV0Y2hGb3JtKGZvcm0sIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnRleHQoKS50aGVuKChodG1sKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqIEB0eXBlIHtIVE1MRGl2RWxlbWVudH0gcmVzcG9uc2VIdG1sICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VIdG1sID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VIdG1sLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGhhc0ZpZWxkRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaGFzRm9ybUVycm9yID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGhhc0ZsYXNoRXJyb3IgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dHRvbiBtdXN0IGJlIHJlLWVuYWJsZWQgYW55d2F5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnRuLnRleHRDb250ZW50ID0gYnRuLnRleHRDb250ZW50LnJlcGxhY2UoJyDigKYnLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnRuLmRpc2FibGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgcmVxdWVzdCB3YXMgc3VjY2Vzc2Z1bCwgdGhlcmUgd2lsbCBiZSBubyBmb3JtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqIEB0eXBlIHtFbGVtZW50fSBtb2RhbENvbnRlbnQgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtb2RhbENvbnRlbnQgPSByZXNwb25zZUh0bWwucXVlcnlTZWxlY3RvcignI2Zvcm1fbW9kYWwgLm1vZGFsLWNvbnRlbnQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kYWxDb250ZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc0ZpZWxkRXJyb3IgPSBtb2RhbENvbnRlbnQucXVlcnlTZWxlY3RvcignLmlzLWludmFsaWQnKSAhPT0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNGaWVsZEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBoYXBwZW5zIHdoZW4gYW4gZXJyb3Igb2NjdXJzIGZvciBhIFwiaGlkZGVuIG9yIG5vbi1jbGFzc2ljYWxcIiBmb3JtIGVsZW1lbnQgZS5nLiBjcmVhdGluZyB0ZWFtIHdpdGhvdXQgdXNlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc0ZpZWxkRXJyb3IgPSBtb2RhbENvbnRlbnQucXVlcnlTZWxlY3RvcignLmludmFsaWQtZmVlZGJhY2snKSAhPT0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNGb3JtRXJyb3IgPSBtb2RhbENvbnRlbnQucXVlcnlTZWxlY3RvcigndWwubGlzdC11bnN0eWxlZCBsaS50ZXh0LWRhbmdlcicpICE9PSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNGbGFzaEVycm9yID0gcmVzcG9uc2VIdG1sLnF1ZXJ5U2VsZWN0b3IoJ2Rpdi5hbGVydC1kYW5nZXInKSAhPT0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzRmllbGRFcnJvciB8fCBoYXNGb3JtRXJyb3IgfHwgaGFzRmxhc2hFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcGVuRm9ybUluTW9kYWwoaHRtbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzLnRyaWdnZXIoZXZlbnROYW1lKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnkgdG8gZmluZCBmb3JtIGRlZmluZWQgbWVzc2FnZSBmaXJzdCwgYnV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtc2cgPSBmb3JtLmRhdGFzZXRbJ21zZ1N1Y2Nlc3MnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhhdCBpcyBub3QgYXZhaWxhYmxlOiB1c2UgYSBnZW5lcmljIGZhbGxiYWNrIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1zZyA9PT0gbnVsbCB8fCBtc2cgPT09IHVuZGVmaW5lZCB8fCBtc2cgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtc2cgPSAnYWN0aW9uLnVwZGF0ZS5zdWNjZXNzJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pc0RpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2dldE1vZGFsKCkuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGVydC5zdWNjZXNzKG1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWVzc2FnZSA9IGZvcm0uZGF0YXNldFsnbXNnRXJyb3InXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlID09PSBudWxsIHx8IG1lc3NhZ2UgPT09IHVuZGVmaW5lZCB8fCBtZXNzYWdlID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSAnYWN0aW9uLnVwZGF0ZS5lcnJvcic7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFsZXJ0LmVycm9yKG1lc3NhZ2UsIGVycm9yLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIHVzZWZ1bCBmb3IgY2hhbmdpbmcgZm9ybSBmaWVsZHMgYW5kIHJldHJ5aW5nIHRvIHNhdmUgKGFuZCBpbiBkZXZlbG9wbWVudCB0byB0ZXN0IGZvcm0gY2hhbmdlcylcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT57XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY3JpdGljYWwgZXJyb3IsIGFsbG93IHRvIHJlLXN1Ym1pdD9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidG4udGV4dENvbnRlbnQgPSBidG4udGV4dENvbnRlbnQucmVwbGFjZSgnIOKApicsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidG4uZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIDE1MDApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5ldmVudEhhbmRsZXI7XG4gICAgfVxuXG59XG4iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgdGhlIEtpbWFpIHRpbWUtdHJhY2tpbmcgYXBwLlxuICpcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cbiAqL1xuXG4vKiFcbiAqIFtLSU1BSV0gS2ltYWlBbGVydDogbm90aWZpY2F0aW9ucyBmb3IgS2ltYWlcbiAqL1xuXG5pbXBvcnQgS2ltYWlQbHVnaW4gZnJvbSBcIi4uL0tpbWFpUGx1Z2luXCI7XG5pbXBvcnQge01vZGFsLCBUb2FzdH0gZnJvbSBcImJvb3RzdHJhcFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBLaW1haUFsZXJ0IGV4dGVuZHMgS2ltYWlQbHVnaW4ge1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldElkKCkge1xuICAgICAgICByZXR1cm4gJ2FsZXJ0JztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGl0bGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xhcnJheXx1bmRlZmluZWR9IG1lc3NhZ2VcbiAgICAgKi9cbiAgICBlcnJvcih0aXRsZSwgbWVzc2FnZSkge1xuICAgICAgICBjb25zdCB0cmFuc2xhdGlvbiA9IHRoaXMuZ2V0VHJhbnNsYXRpb24oKTtcbiAgICAgICAgaWYgKHRyYW5zbGF0aW9uLmhhcyh0aXRsZSkpIHtcbiAgICAgICAgICAgIHRpdGxlID0gdHJhbnNsYXRpb24uZ2V0KHRpdGxlKTtcbiAgICAgICAgfVxuICAgICAgICB0aXRsZSA9IHRpdGxlLnJlcGxhY2UoJyVyZWFzb24lJywgJycpO1xuXG4gICAgICAgIGlmIChtZXNzYWdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lc3NhZ2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0cmFuc2xhdGlvbi5oYXMobWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gdHJhbnNsYXRpb24uZ2V0KG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gbWVzc2FnZS5qb2luKCc8YnI+Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpZCA9ICdhbGVydF9nbG9iYWxfZXJyb3InO1xuICAgICAgICBjb25zdCBvbGRNb2RhbEVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgICAgIGlmIChvbGRNb2RhbEVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIE1vZGFsLmdldE9yQ3JlYXRlSW5zdGFuY2Uob2xkTW9kYWxFbGVtZW50KS5oaWRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBodG1sID0gYFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsIG1vZGFsLWJsdXIgZmFkZVwiIGlkPVwiYCArIGlkICsgYFwiIHRhYmluZGV4PVwiLTFcIiByb2xlPVwiZGlhbG9nXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsLWRpYWxvZyBtb2RhbC1zbSBtb2RhbC1kaWFsb2ctY2VudGVyZWRcIiByb2xlPVwiZG9jdW1lbnRcIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsLWNvbnRlbnRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1zdGF0dXMgYmctYCArIHRoaXMuX21hcENsYXNzKCdkYW5nZXInKSArIGBcIj48L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1ib2R5IHRleHQtY2VudGVyIHB5LTRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cImZhcyBmYS1leGNsYW1hdGlvbi1jaXJjbGUgZmEtM3ggbWItMyB0ZXh0LWRhbmdlclwiPjwvaT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aDI+YCArIHRpdGxlICsgYDwvaDI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYCArIChtZXNzYWdlICE9PSBudWxsID8gJzxkaXYgY2xhc3M9XCJ0ZXh0LW11dGVkXCI+JyArIG1lc3NhZ2UgKyAnPC9kaXY+JyA6ICcnKSArIGBcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsLWZvb3RlclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ3LTEwMFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicm93XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sIHRleHQtY2VudGVyXCI+PGEgaHJlZj1cIiNcIiBjbGFzcz1cImJ0biBidG4tcHJpbWFyeVwiIGRhdGEtYnMtZGlzbWlzcz1cIm1vZGFsXCI+YCArIHRyYW5zbGF0aW9uLmdldCgnY2xvc2UnKSArIGA8L2E+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIGA7XG5cbiAgICAgICAgdGhpcy5fc2hvd01vZGFsKGh0bWwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gICAgICovXG4gICAgd2FybmluZyhtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuX3Nob3coJ3dhcm5pbmcnLCBtZXNzYWdlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVxuICAgICAqL1xuICAgIHN1Y2Nlc3MobWVzc2FnZSkge1xuICAgICAgICB0aGlzLl90b2FzdCgnc3VjY2VzcycsIG1lc3NhZ2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gICAgICovXG4gICAgaW5mbyhtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuX3Nob3coJ2luZm8nLCBtZXNzYWdlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Nob3dNb2RhbChodG1sKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmJvZHk7XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gaHRtbC50cmltKCk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0ZW1wbGF0ZS5jb250ZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbGVtZW50KTtcblxuICAgICAgICBjb25zdCBtb2RhbCA9IG5ldyBNb2RhbChlbGVtZW50KTtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdoaWRkZW4uYnMubW9kYWwnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICBtb2RhbC5zaG93KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Nob3codHlwZSwgbWVzc2FnZSkge1xuICAgICAgICBjb25zdCB0cmFuc2xhdGlvbiA9IHRoaXMuZ2V0VHJhbnNsYXRpb24oKTtcblxuICAgICAgICBpZiAodHJhbnNsYXRpb24uaGFzKG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gdHJhbnNsYXRpb24uZ2V0KG1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaHRtbCA9IGBcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtb2RhbCBtb2RhbC1ibHVyIGZhZGVcIiB0YWJpbmRleD1cIi0xXCIgcm9sZT1cImRpYWxvZ1wiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1kaWFsb2cgbW9kYWwtc20gbW9kYWwtZGlhbG9nLWNlbnRlcmVkXCIgcm9sZT1cImRvY3VtZW50XCI+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1jb250ZW50XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibW9kYWwtc3RhdHVzIGJnLWAgKyB0aGlzLl9tYXBDbGFzcyh0eXBlKSArIGBcIj48L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1ib2R5IHRleHQtY2VudGVyIHB5LTRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cImZhcyBmYS1leGNsYW1hdGlvbi1jaXJjbGUgZmEtM3ggbWItMyB0ZXh0LWAgKyB0aGlzLl9tYXBDbGFzcyh0eXBlKSArIGBcIj48L2k+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGgyPmAgKyBtZXNzYWdlICsgYDwvaDI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1mb290ZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidy0xMDBcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInJvd1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbCB0ZXh0LWNlbnRlclwiPjxhIGhyZWY9XCIjXCIgY2xhc3M9XCJidG4gYnRuLXByaW1hcnlcIiBkYXRhLWJzLWRpc21pc3M9XCJtb2RhbFwiPmAgKyB0cmFuc2xhdGlvbi5nZXQoJ2Nsb3NlJykgKyBgPC9hPjwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICBgO1xuXG4gICAgICAgIHRoaXMuX3Nob3dNb2RhbChodG1sKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYXBDbGFzcyh0eXBlKSB7XG4gICAgICAgIGlmICh0eXBlID09PSAnaW5mbycgfHwgdHlwZSA9PT0gJ3N1Y2Nlc3MnIHx8IHR5cGUgPT09ICd3YXJuaW5nJyB8fCB0eXBlID09PSAnZGFuZ2VyJykge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgcmV0dXJuICdkYW5nZXInO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICdwcmltYXJ5JztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gdHlwZVxuICAgICAqIEBwYXJhbSBtZXNzYWdlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdG9hc3QodHlwZSwgbWVzc2FnZSkge1xuICAgICAgICBjb25zdCB0cmFuc2xhdGlvbiA9IHRoaXMuZ2V0VHJhbnNsYXRpb24oKTtcblxuICAgICAgICBpZiAodHJhbnNsYXRpb24uaGFzKG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gdHJhbnNsYXRpb24uZ2V0KG1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGljb24gPSAnPGkgY2xhc3M9XCJmYXMgZmEtaW5mbyBtZS0yXCI+PC9pPic7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdzdWNjZXNzJykge1xuICAgICAgICAgICAgaWNvbiA9ICc8aSBjbGFzcz1cImZhcyBmYS1jaGVjayBtZS0yXCI+PC9pPic7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3dhcm5pbmcnKSB7XG4gICAgICAgICAgICBpY29uID0gJzxpIGNsYXNzPVwiZmFzIGZhLWV4Y2xhbWF0aW9uIG1lLTJcIj48L2k+JztcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnZGFuZ2VyJyB8fCB0eXBlID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICBpY29uID0gJzxpIGNsYXNzPVwiZmFzIGZhLWV4Y2xhbWF0aW9uLWNpcmNsZSBtZS0yXCI+PC9pPic7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBodG1sID1cbiAgICAgICAgYDxkaXYgY2xhc3M9XCJ0b2FzdCBhbGlnbi1pdGVtcy1jZW50ZXIgdGV4dC13aGl0ZSBiZy1gICsgdGhpcy5fbWFwQ2xhc3ModHlwZSkgKyBgIGJvcmRlci0wXCIgZGF0YS1icy1kZWxheT1cIjIwMDBcIiByb2xlPVwiYWxlcnRcIiBhcmlhLWxpdmU9XCJhc3NlcnRpdmVcIiBhcmlhLWF0b21pYz1cInRydWVcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkLWZsZXhcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidG9hc3QtYm9keVwiPlxuICAgICAgICAgICAgICAgICAgICBgICsgaWNvbiArICcgJyArIG1lc3NhZ2UgKyBgXG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4tY2xvc2UgbWUtMiBtLWF1dG9cIiBkYXRhLWJzLWRpc21pc3M9XCJ0b2FzdFwiIGFyaWEtbGFiZWw9XCJgICsgdHJhbnNsYXRpb24uZ2V0KCdjbG9zZScpICsgYFwiPjwvYnV0dG9uPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PmA7XG5cbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RvYXN0LWNvbnRhaW5lcicpO1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG5cbiAgICAgICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gaHRtbC50cmltKCk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0ZW1wbGF0ZS5jb250ZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbGVtZW50KTtcblxuICAgICAgICBjb25zdCB0b2FzdCA9IG5ldyBUb2FzdChlbGVtZW50KTtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdoaWRkZW4uYnMudG9hc3QnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgIH0pXG4gICAgICAgIHRvYXN0LnNob3coKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayByZWNlaXZlcyBhIGJvb2wgdmFsdWUgKHRydWUgPSBjb25maXJtLCBmYWxzZSA9IGNhbmNlbCAvIGNsb3NlIHdpdGhvdXQgYWN0aW9uKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXNzYWdlXG4gICAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAgICovXG4gICAgcXVlc3Rpb24obWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgdHJhbnNsYXRpb24gPSB0aGlzLmdldFRyYW5zbGF0aW9uKCk7XG5cbiAgICAgICAgaWYgKHRyYW5zbGF0aW9uLmhhcyhtZXNzYWdlKSkge1xuICAgICAgICAgICAgbWVzc2FnZSA9IHRyYW5zbGF0aW9uLmdldChtZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNzcyA9IHRoaXMuX21hcENsYXNzKCdpbmZvJyk7XG4gICAgICAgIGNvbnN0IGh0bWwgPSBgXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwibW9kYWwgbW9kYWwtYmx1ciBmYWRlXCIgdGFiaW5kZXg9XCItMVwiIHJvbGU9XCJkaWFsb2dcIiBkYXRhLWJzLWJhY2tkcm9wPVwic3RhdGljXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsLWRpYWxvZyBtb2RhbC1zbSBtb2RhbC1kaWFsb2ctY2VudGVyZWRcIiByb2xlPVwiZG9jdW1lbnRcIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsLWNvbnRlbnRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1zdGF0dXMgYmctYCArIGNzcyArIGBcIj48L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1ib2R5IHRleHQtY2VudGVyIHB5LTRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cImZhcyBmYS1xdWVzdGlvbiBmYS0zeCBtYi0zIHRleHQtYCArIGNzcyArIGBcIj48L2k+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGgyPmAgKyBtZXNzYWdlICsgYDwvaDI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1mb290ZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidy0xMDBcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInJvd1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbFwiPjxhIGhyZWY9XCIjXCIgY2xhc3M9XCJxdWVzdGlvbi1jb25maXJtIGJ0biBidG4tcHJpbWFyeSB3LTEwMFwiIGRhdGEtYnMtZGlzbWlzcz1cIm1vZGFsXCI+YCArIHRyYW5zbGF0aW9uLmdldCgnY29uZmlybScpICsgYDwvYT48L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2xcIj48YSBocmVmPVwiI1wiIGNsYXNzPVwicXVlc3Rpb24tY2FuY2VsIGJ0biB3LTEwMFwiIGRhdGEtYnMtZGlzbWlzcz1cIm1vZGFsXCI+YCArIHRyYW5zbGF0aW9uLmdldCgnY2FuY2VsJykgKyBgPC9hPjwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICBgO1xuXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmJvZHk7XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gaHRtbC50cmltKCk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0ZW1wbGF0ZS5jb250ZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgICAgZWxlbWVudC5xdWVyeVNlbGVjdG9yKCcucXVlc3Rpb24tY29uZmlybScpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgY2FsbGJhY2sodHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5xdWVzdGlvbi1jYW5jZWwnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGZhbHNlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgbW9kYWwgPSBuZXcgTW9kYWwoZWxlbWVudCk7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignaGlkZGVuLmJzLm1vZGFsJywgKCkgPT4ge1xuICAgICAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgbW9kYWwuc2hvdygpO1xuICAgIH1cbn1cbiIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiB0aGUgS2ltYWkgdGltZS10cmFja2luZyBhcHAuXG4gKlxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxuICovXG5cbi8qIVxuICogW0tJTUFJXSBLaW1haUFsdGVybmF0aXZlTGlua3NcbiAqXG4gKiBhbGxvd3MgdG8gYXNzaWduIHRoZSBnaXZlbiBzZWxlY3RvciB0byBhbnkgZWxlbWVudCwgd2hpY2ggdGhlbiBpcyB1c2VkIGFzIGNsaWNrLWhhbmRsZXJcbiAqIHJlZGlyZWN0aW5nIHRvIHRoZSBVUkwgZ2l2ZW4gaW4gdGhlIGVsZW1lbnRzICdkYXRhLWhyZWYnIG9yICdocmVmJyBhdHRyaWJ1dGVcbiAqL1xuXG5pbXBvcnQgS2ltYWlSZWR1Y2VkQ2xpY2tIYW5kbGVyIGZyb20gXCIuL0tpbWFpUmVkdWNlZENsaWNrSGFuZGxlclwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBLaW1haUFsdGVybmF0aXZlTGlua3MgZXh0ZW5kcyBLaW1haVJlZHVjZWRDbGlja0hhbmRsZXIge1xuXG4gICAgY29uc3RydWN0b3Ioc2VsZWN0b3IpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICB9XG5cbiAgICBpbml0KCkge1xuICAgICAgICB0aGlzLmFkZENsaWNrSGFuZGxlcih0aGlzLl9zZWxlY3RvciwgZnVuY3Rpb24oaHJlZikge1xuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uID0gaHJlZjtcbiAgICAgICAgfSk7XG4gICAgfVxuXG59XG4iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgdGhlIEtpbWFpIHRpbWUtdHJhY2tpbmcgYXBwLlxuICpcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cbiAqL1xuXG5pbXBvcnQgS2ltYWlQbHVnaW4gZnJvbSBcIi4uL0tpbWFpUGx1Z2luXCI7XG5cbi8qKlxuICogTmVlZHMgdG8gYmUgaW5pdGlhbGl6ZWQgd2l0aCBhIGNsYXNzIG5hbWUuXG4gKlxuICogQWxsb3dzIHRvIGFzc2lnbiB0aGUgZ2l2ZW4gc2VsZWN0b3IgdG8gYW55IGVsZW1lbnQsIHdoaWNoIHRoZW4gaXMgdXNlZCBhcyBjbGljay1oYW5kbGVyXG4gKiBjYWxsaW5nIGFuIEFQSSBtZXRob2QgYW5kIHRyaWdnZXIgdGhlIGV2ZW50IGZyb20gZGF0YS1ldmVudCBhdHRyaWJ1dGUgYWZ0ZXJ3YXJkcy5cbiAqXG4gKiBAcGFyYW0gc2VsZWN0b3JcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgS2ltYWlDb25maXJtYXRpb25MaW5rIGV4dGVuZHMgS2ltYWlQbHVnaW4ge1xuXG4gICAgY29uc3RydWN0b3Ioc2VsZWN0b3IpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICB9XG5cbiAgICBpbml0KCkge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgIHdoaWxlICh0YXJnZXQgIT09IG51bGwgJiYgdHlwZW9mIHRhcmdldC5tYXRjaGVzID09PSBcImZ1bmN0aW9uXCIgJiYgIXRhcmdldC5tYXRjaGVzKCdib2R5JykpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyh0aGlzLl9zZWxlY3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IHRhcmdldC5kYXRhc2V0O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlzIHRoaXMgYSBsaW5rPyBcbiAgICAgICAgICAgICAgICAgICAgbGV0IHVybCA9IGF0dHJpYnV0ZXNbJ2hyZWYnXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gb3IgYW5vdGhlciBIVE1MIGVsZW1lbnQgd2l0aCBhIGN1c3RvbSBocmVmIFxuICAgICAgICAgICAgICAgICAgICBpZiAoIXVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gdGFyZ2V0LmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBvciBpcyB0aGlzIGEgYnV0dG9uP1xuICAgICAgICAgICAgICAgICAgICBsZXQgZm9ybSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQudHlwZSA9PT0gJ3N1Ym1pdCcgJiYgdGFyZ2V0LmZvcm0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybSA9IHRhcmdldC5mb3JtO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXMucXVlc3Rpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRDb250YWluZXIoKS5nZXRQbHVnaW4oJ2FsZXJ0JykucXVlc3Rpb24oYXR0cmlidXRlcy5xdWVzdGlvbiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvcm0gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmxvY2F0aW9uID0gdXJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVybCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm0uYWN0aW9uID0gdXJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybS5zdWJtaXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxufVxuIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHRoZSBLaW1haSB0aW1lLXRyYWNraW5nIGFwcC5cbiAqXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXG4gKi9cblxuLyohXG4gKiBbS0lNQUldIEtpbWFpRGF0YXRhYmxlOiBoYW5kbGVzIGZ1bmN0aW9uYWxpdHkgZm9yIHRoZSBkYXRhdGFibGVcbiAqL1xuXG5pbXBvcnQgS2ltYWlQbHVnaW4gZnJvbSBcIi4uL0tpbWFpUGx1Z2luXCI7XG5pbXBvcnQgS2ltYWlDb250ZXh0TWVudSBmcm9tIFwiLi4vd2lkZ2V0cy9LaW1haUNvbnRleHRNZW51XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEtpbWFpRGF0YXRhYmxlIGV4dGVuZHMgS2ltYWlQbHVnaW4ge1xuXG4gICAgY29uc3RydWN0b3IoY29udGVudEFyZWFTZWxlY3RvciwgdGFibGVTZWxlY3Rvcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9jb250ZW50QXJlYSA9IGNvbnRlbnRBcmVhU2VsZWN0b3I7XG4gICAgICAgIHRoaXMuX3NlbGVjdG9yID0gdGFibGVTZWxlY3RvcjtcbiAgICB9XG5cbiAgICBnZXRJZCgpIHtcbiAgICAgICAgcmV0dXJuICdkYXRhdGFibGUnO1xuICAgIH1cblxuICAgIGluaXQoKSB7XG4gICAgICAgIGNvbnN0IGRhdGFUYWJsZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5fc2VsZWN0b3IpO1xuXG4gICAgICAgIC8vIG5vdCBldmVyeSBwYWdlIGNvbnRhaW5zIGEgZGF0YVRhYmxlXG4gICAgICAgIGlmIChkYXRhVGFibGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVnaXN0ZXJDb250ZXh0TWVudSh0aGlzLl9zZWxlY3Rvcik7XG5cbiAgICAgICAgY29uc3QgZXZlbnRzID0gZGF0YVRhYmxlLmRhdGFzZXRbJ3JlbG9hZEV2ZW50J107XG4gICAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaGFuZGxlID0gKCkgPT4geyB0aGlzLnJlbG9hZERhdGF0YWJsZSgpOyB9O1xuXG4gICAgICAgIGZvciAobGV0IGV2ZW50TmFtZSBvZiBldmVudHMuc3BsaXQoJyAnKSkge1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZSk7XG4gICAgICAgIH1cblxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwYWdpbmF0aW9uLWNoYW5nZScsIGhhbmRsZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZpbHRlci1jaGFuZ2UnLCBoYW5kbGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcmVnaXN0ZXJDb250ZXh0TWVudShzZWxlY3RvcilcbiAgICB7XG4gICAgICAgIEtpbWFpQ29udGV4dE1lbnUuY3JlYXRlRm9yRGF0YVRhYmxlKHNlbGVjdG9yKTtcbiAgICB9XG5cbiAgICByZWxvYWREYXRhdGFibGUoKVxuICAgIHtcbiAgICAgICAgY29uc3QgdG9vbGJhclNlbGVjdG9yID0gdGhpcy5nZXRDb250YWluZXIoKS5nZXRQbHVnaW4oJ3Rvb2xiYXInKS5nZXRTZWxlY3RvcigpO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7SFRNTEZvcm1FbGVtZW50fSBmb3JtICovXG4gICAgICAgIGNvbnN0IGZvcm0gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRvb2xiYXJTZWxlY3Rvcik7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gKHRleHQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRlbXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHRlbXAuaW5uZXJIVE1MID0gdGV4dDtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NvbnRlbnQgPSB0ZW1wLnF1ZXJ5U2VsZWN0b3IodGhpcy5fY29udGVudEFyZWEpO1xuICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0aGlzLl9jb250ZW50QXJlYSkucmVwbGFjZVdpdGgobmV3Q29udGVudCk7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyQ29udGV4dE1lbnUodGhpcy5fc2VsZWN0b3IpO1xuICAgICAgICAgICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2tpbWFpLnJlbG9hZGVkQ29udGVudCcpKTtcbiAgICAgICAgfTtcblxuICAgICAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgna2ltYWkucmVsb2FkQ29udGVudCcsIHtkZXRhaWw6IHRoaXMuX2NvbnRlbnRBcmVhfSkpO1xuXG4gICAgICAgIGlmIChmb3JtID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmZldGNoKGRvY3VtZW50LmxvY2F0aW9uKVxuICAgICAgICAgICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UudGV4dCgpLnRoZW4oY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZldGNoRm9ybShmb3JtKVxuICAgICAgICAudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgICAgICByZXNwb25zZS50ZXh0KCkudGhlbihjYWxsYmFjayk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICBmb3JtLnN1Ym1pdCgpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgdGhlIEtpbWFpIHRpbWUtdHJhY2tpbmcgYXBwLlxuICpcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cbiAqL1xuXG4vKiFcbiAqIFtLSU1BSV0gS2ltYWlEYXRhdGFibGVDb2x1bW5WaWV3OiBtYW5hZ2VzIHRoZSB2aXNpYmlsaXR5IG9mIGRhdGEtdGFibGUgY29sdW1ucyBpbiBjb29raWVzXG4gKi9cblxuaW1wb3J0IEtpbWFpUGx1Z2luIGZyb20gXCIuLi9LaW1haVBsdWdpblwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBLaW1haURhdGF0YWJsZUNvbHVtblZpZXcgZXh0ZW5kcyBLaW1haVBsdWdpbiB7XG5cbiAgICBjb25zdHJ1Y3RvcihkYXRhQXR0cmlidXRlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZGF0YUF0dHJpYnV0ZSA9IGRhdGFBdHRyaWJ1dGU7XG4gICAgfVxuXG4gICAgZ2V0SWQoKSB7XG4gICAgICAgIHJldHVybiAnZGF0YXRhYmxlLWNvbHVtbi12aXNpYmlsaXR5JztcbiAgICB9XG5cbiAgICBpbml0KCkge1xuICAgICAgICBsZXQgZGF0YVRhYmxlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignWycgKyB0aGlzLmRhdGFBdHRyaWJ1dGUgKyAnXScpO1xuICAgICAgICBpZiAoZGF0YVRhYmxlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faWQgPSBkYXRhVGFibGUuZ2V0QXR0cmlidXRlKHRoaXMuZGF0YUF0dHJpYnV0ZSk7XG4gICAgICAgIHRoaXMuX21vZGFsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vZGFsXycgKyB0aGlzLl9pZCk7XG4gICAgICAgIHRoaXMuX21vZGFsLmFkZEV2ZW50TGlzdGVuZXIoJ3Nob3cuYnMubW9kYWwnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9ldmFsdWF0ZUNoZWNrYm94ZXMoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX21vZGFsLnF1ZXJ5U2VsZWN0b3IoJ2J1dHRvbltkYXRhLXR5cGU9c2F2ZV0nKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3NhdmVWaXNpYmlsaXR5KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9tb2RhbC5xdWVyeVNlbGVjdG9yKCdidXR0b25bZGF0YS10eXBlPXJlc2V0XScpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9yZXNldFZpc2liaWxpdHkoZXZlbnQuY3VycmVudFRhcmdldCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9tb2RhbC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFtuYW1lPWRhdGF0YWJsZV9wcm9maWxlXScpLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmb3JtID0gdGhpcy5fbW9kYWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2Zvcm0nKVswXTtcbiAgICAgICAgICAgICAgICB0aGlzLmZldGNoRm9ybShmb3JtLCB7fSwgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtaHJlZicpKVxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGxvY2FsIHN0b3JhZ2UgaXMgcmVhZCBpbiB0aGUgbG9naW4gc2NyZWVuIHRvIHNldCBhIGNvb2tpZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hpY2ggdHJpZ2dlcnMgdGhlIHNlc3Npb24gc3dpdGNoIGluIFByb2ZpbGVTdWJzY3JpYmVyXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdraW1haV9wcm9maWxlJywgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJykpO1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm0uc2V0QXR0cmlidXRlKCdhY3Rpb24nLCBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1ocmVmJykpO1xuICAgICAgICAgICAgICAgICAgICBmb3JtLnN1Ym1pdCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKGxldCBjaGVja2JveCBvZiB0aGlzLl9tb2RhbC5xdWVyeVNlbGVjdG9yQWxsKCdmb3JtIGlucHV0W3R5cGU9Y2hlY2tib3hdJykpIHtcbiAgICAgICAgICAgIGNoZWNrYm94LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsICgpID0+ICB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlVmlzaWJpbGl0eShjaGVja2JveC5nZXRBdHRyaWJ1dGUoJ25hbWUnKSwgY2hlY2tib3guY2hlY2tlZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9ldmFsdWF0ZUNoZWNrYm94ZXMoKSB7XG4gICAgICAgIGNvbnN0IGZvcm0gPSB0aGlzLl9tb2RhbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnZm9ybScpWzBdO1xuICAgICAgICBjb25zdCB0YWJsZSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2RhdGF0YWJsZV8nICsgdGhpcy5faWQpWzBdO1xuICAgICAgICBmb3IgKGxldCBjb2x1bW5FbGVtZW50IG9mIHRhYmxlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCd0aCcpKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZE5hbWUgPSBjb2x1bW5FbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1maWVsZCcpO1xuICAgICAgICAgICAgaWYgKGZpZWxkTmFtZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2hlY2tib3ggPSBmb3JtLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0W25hbWU9JyArIGZpZWxkTmFtZSArICddJyk7XG4gICAgICAgICAgICBpZiAoY2hlY2tib3ggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoZWNrYm94LmNoZWNrZWQgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShjb2x1bW5FbGVtZW50KS5kaXNwbGF5ICE9PSAnbm9uZSc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfc2F2ZVZpc2liaWxpdHkoKSB7XG4gICAgICAgIGNvbnN0IGZvcm0gPSB0aGlzLl9tb2RhbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnZm9ybScpWzBdO1xuXG4gICAgICAgIHRoaXMuZmV0Y2hGb3JtKGZvcm0pXG4gICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGRvY3VtZW50LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgZm9ybS5zdWJtaXQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgX3Jlc2V0VmlzaWJpbGl0eShidXR0b24pIHtcbiAgICAgICAgY29uc3QgZm9ybSA9IHRoaXMuX21vZGFsLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdmb3JtJylbMF07XG5cbiAgICAgICAgdGhpcy5mZXRjaEZvcm0oZm9ybSwge30sIGJ1dHRvbi5nZXRBdHRyaWJ1dGUoJ2Zvcm1hY3Rpb24nKSlcbiAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgZG9jdW1lbnQubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICBmb3JtLnNldEF0dHJpYnV0ZSgnYWN0aW9uJywgYnV0dG9uLmdldEF0dHJpYnV0ZSgnZm9ybWFjdGlvbicpKTtcbiAgICAgICAgICAgIGZvcm0uc3VibWl0KCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIF9jaGFuZ2VWaXNpYmlsaXR5KGNvbHVtbk5hbWUsIGNoZWNrZWQpIHtcbiAgICAgICAgZm9yIChjb25zdCB0YWJsZUJveCBvZiBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdkYXRhdGFibGVfJyArIHRoaXMuX2lkKSkge1xuICAgICAgICAgICAgbGV0IHRhcmdldENsYXNzZXMgPSBudWxsO1xuICAgICAgICAgICAgZm9yIChsZXQgZWxlbWVudCBvZiB0YWJsZUJveC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdjb2xfJyArIGNvbHVtbk5hbWUpKSB7XG4gICAgICAgICAgICAgICAgLy8gb25seSBjYWxjdWxhdGUgdGhhdCBvbmNlIGFuZCByZS11c2UgdGhlIGNhY2hlZCBjbGFzcyBsaXN0XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldENsYXNzZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlbW92ZUNsYXNzID0gJy1ub25lJztcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFkZENsYXNzID0gJ2QtdGFibGUtY2VsbCc7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyA9ICctdGFibGUtY2VsbCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRDbGFzcyA9ICdkLW5vbmUnO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Q2xhc3NlcyA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5mb3JFYWNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKG5hbWUsIGluZGV4LCBsaXN0T2JqKSB7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUuaW5kZXhPZihyZW1vdmVDbGFzcykgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldENsYXNzZXMgKz0gJyAnICsgbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldENsYXNzZXMuaW5kZXhPZihhZGRDbGFzcykgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRDbGFzc2VzICs9ICcgJyArIGFkZENsYXNzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSB0YXJnZXRDbGFzc2VzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG59XG4iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgdGhlIEtpbWFpIHRpbWUtdHJhY2tpbmcgYXBwLlxuICpcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cbiAqL1xuXG4vKiFcbiAqIFtLSU1BSV0gS2ltYWlEYXRlVXRpbHM6IHJlc3BvbnNpYmxlIGZvciBoYW5kbGluZyBkYXRlIHNwZWNpZmljIHRhc2tzXG4gKi9cblxuaW1wb3J0IEtpbWFpUGx1Z2luIGZyb20gJy4uL0tpbWFpUGx1Z2luJztcbmltcG9ydCB7IERhdGVUaW1lLCBEdXJhdGlvbiB9IGZyb20gJ2x1eG9uJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgS2ltYWlEYXRlVXRpbHMgZXh0ZW5kcyBLaW1haVBsdWdpbiB7XG5cbiAgICBnZXRJZCgpXG4gICAge1xuICAgICAgICByZXR1cm4gJ2RhdGUnO1xuICAgIH1cblxuICAgIGluaXQoKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0Q29uZmlndXJhdGlvbnMoKS5pczI0SG91cnMoKSkge1xuICAgICAgICAgICAgdGhpcy50aW1lRm9ybWF0ID0gJ0hIOm1tJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudGltZUZvcm1hdCA9ICdoaDptbSBhJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmR1cmF0aW9uRm9ybWF0ID0gdGhpcy5nZXRDb25maWd1cmF0aW9uKCdmb3JtYXREdXJhdGlvbicpO1xuICAgICAgICB0aGlzLmRhdGVGb3JtYXQgPSB0aGlzLmdldENvbmZpZ3VyYXRpb24oJ2Zvcm1hdERhdGUnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAc2VlIGh0dHBzOi8vbW9tZW50LmdpdGh1Yi5pby9sdXhvbi8jL2Zvcm1hdHRpbmc/aWQ9dGFibGUtb2YtdG9rZW5zXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZvcm1hdFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcGFyc2VGb3JtYXQoZm9ybWF0KVxuICAgIHtcbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJ0REJywgJ2RkJyk7XG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCdEJywgJ2QnKTtcbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJ01NJywgJ0xMJyk7XG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCdNJywgJ0wnKTtcbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJ1lZWVknLCAneXl5eScpO1xuICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnWVknLCAneXknKTtcbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJ0EnLCAnYScpO1xuXG4gICAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZvcm1hdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfERhdGV8bnVsbHx1bmRlZmluZWR9IGRhdGVUaW1lXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBmb3JtYXQoZm9ybWF0LCBkYXRlVGltZSlcbiAgICB7XG4gICAgICAgIGxldCBuZXdEYXRlID0gbnVsbDtcblxuICAgICAgICBpZiAoZGF0ZVRpbWUgPT09IG51bGwgfHwgZGF0ZVRpbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbmV3RGF0ZSA9IERhdGVUaW1lLm5vdygpO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGVUaW1lIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgbmV3RGF0ZSA9IERhdGVUaW1lLmZyb21KU0RhdGUoZGF0ZVRpbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3RGF0ZSA9IERhdGVUaW1lLmZyb21JU08oZGF0ZVRpbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXNpbmcgbG9jYWxlIGVuZ2xpc2ggaGVyZSBwcmV2ZW50cyB0aGF0IHRoYXQgQU0vUE0gaXMgdHJhbnNsYXRlZCB0byB0aGVcbiAgICAgICAgLy8gbG9jYWxlIHZhcmlhbnQ6IGUuZy4gXCJrb1wiIHRyYW5zbGF0ZXMgaXQgdG8g7Jik7ZuEIC8g7Jik7KCEXG4gICAgICAgIHJldHVybiBuZXdEYXRlLnRvRm9ybWF0KHRoaXMuX3BhcnNlRm9ybWF0KGZvcm1hdCksIHsgbG9jYWxlOiAnZW4tdXMnIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfERhdGV9IGRhdGVUaW1lXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRGb3JtYXR0ZWREYXRlKGRhdGVUaW1lKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KHRoaXMuX3BhcnNlRm9ybWF0KHRoaXMuZGF0ZUZvcm1hdCksIGRhdGVUaW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgXCJZWVlZLU1NLUREVEhIOm1tOnNzXCIgZm9ybWF0dGVkIHN0cmluZyBpbiBsb2NhbCB0aW1lLlxuICAgICAqIFRoaXMgY2FuIHRha2UgRGF0ZSBvYmplY3RzIChlLmcuIGZyb20gRnVsbENhbGVuZGFyKSBhbmQgdHVybiB0aGVtIGludG8gdGhlIGNvcnJlY3QgZm9ybWF0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtEYXRlfERhdGVUaW1lfSBkYXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufHVuZGVmaW5lZH0gaXNVdGNcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gICAgZm9ybWF0Rm9yQVBJKGRhdGUsIGlzVXRjID0gZmFsc2UpXG4gICAge1xuICAgICAgICBpZiAoZGF0ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgIGRhdGUgPSBEYXRlVGltZS5mcm9tSlNEYXRlKGRhdGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzVXRjID09PSB1bmRlZmluZWQgfHwgIWlzVXRjKSB7XG4gICAgICAgICAgICBkYXRlID0gZGF0ZS50b1VUQygpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGUudG9JU08oeyBpbmNsdWRlT2Zmc2V0OiBmYWxzZSwgc3VwcHJlc3NNaWxsaXNlY29uZHM6IHRydWUgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZm9ybWF0XG4gICAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAgICovXG4gICAgZnJvbUZvcm1hdChkYXRlLCBmb3JtYXQpXG4gICAge1xuICAgICAgICAvLyB1c2luZyBsb2NhbGUgZW4tdXMgaGVyZSBwcmV2ZW50cyB0aGF0IEx1eG9uIGV4cGVjdHMgdGhlIGxvY2FsaXplZFxuICAgICAgICAvLyB2ZXJzaW9uIG9mIEFNL1BNIChlLmcuIOyYpO2bhCAvIOyYpOyghCBmb3IgbG9jYWxlIFwia29cIilcbiAgICAgICAgcmV0dXJuIERhdGVUaW1lLmZyb21Gb3JtYXQoZGF0ZSwgdGhpcy5fcGFyc2VGb3JtYXQoZm9ybWF0KSwgeyBsb2NhbGU6ICdlbi11cycgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVsbH0gZGF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bGx9IHRpbWVcbiAgICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICAgKi9cbiAgICBmcm9tSHRtbDVJbnB1dChkYXRlLCB0aW1lKVxuICAgIHtcbiAgICAgICAgZGF0ZSA9IGRhdGUgPz8gJyc7XG4gICAgICAgIHRpbWUgPSB0aW1lID8/ICcnO1xuXG4gICAgICAgIGlmIChkYXRlID09PSAnJyAmJiB0aW1lID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQoJ0VtcHR5IGRhdGUgYW5kIHRpbWUgZ2l2ZW4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRlICE9PSAnJyAmJiB0aW1lICE9PSAnJykge1xuICAgICAgICAgICAgZGF0ZSA9IGRhdGUgKyAnVCcgKyB0aW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIERhdGVUaW1lLmZyb21JU08oZGF0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZm9ybWF0XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1ZhbGlkRGF0ZVRpbWUoZGF0ZSwgZm9ybWF0KVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbUZvcm1hdChkYXRlLCBmb3JtYXQpLmlzVmFsaWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIHN0cmluZyBsaWtlIFwiMDA6MzA6MDBcIiBvciBcIjAxOjE1XCIgdG8gYSBnaXZlbiBkYXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtEYXRlfSBkYXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGR1cmF0aW9uXG4gICAgICogQHJldHVybiB7RGF0ZX1cbiAgICAgKi9cbiAgICBhZGRIdW1hbkR1cmF0aW9uKGRhdGUsIGR1cmF0aW9uKVxuICAgIHtcbiAgICAgICAgLyoqIEB0eXBlIHtEYXRlVGltZX0gbmV3RGF0ZSAqL1xuICAgICAgICBsZXQgbmV3RGF0ZSA9IG51bGw7XG5cbiAgICAgICAgaWYgKGRhdGUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICBuZXdEYXRlID0gRGF0ZVRpbWUuZnJvbUpTRGF0ZShkYXRlKTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRlIGluc3RhbmNlb2YgRGF0ZVRpbWUpIHtcbiAgICAgICAgICAgIG5ld0RhdGUgPSBkYXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgJ2FkZEh1bWFuRHVyYXRpb24oKSBuZWVkcyBhIEpTIERhdGUnO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcGFyc2VkID0gRGF0ZVRpbWUuZnJvbUlTTyhkdXJhdGlvbik7XG4gICAgICAgIGNvbnN0IHRvZGF5ID0gRGF0ZVRpbWUubm93KCkuc3RhcnRPZignZGF5Jyk7XG4gICAgICAgIGNvbnN0IHRpbWVPZkRheSA9IHBhcnNlZC5kaWZmKHRvZGF5KTtcblxuICAgICAgICByZXR1cm4gbmV3RGF0ZS5wbHVzKHRpbWVPZkRheSkudG9KU0RhdGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xpbnRlZ2VyfG51bGx9IHNpbmNlXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIGZvcm1hdER1cmF0aW9uKHNpbmNlKVxuICAgIHtcbiAgICAgICAgbGV0IGR1cmF0aW9uID0gbnVsbDtcblxuICAgICAgICBpZiAodHlwZW9mIHNpbmNlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZHVyYXRpb24gPSBEYXRlVGltZS5ub3coKS5kaWZmKERhdGVUaW1lLmZyb21JU08oc2luY2UpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0gRHVyYXRpb24uZnJvbUlTTygnUFQnICsgKHNpbmNlID09PSBudWxsID8gMCA6IHNpbmNlKSArICdTJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXRMdXhvbkR1cmF0aW9uKGR1cmF0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IHNlY29uZHNcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gICAgZm9ybWF0U2Vjb25kcyhzZWNvbmRzKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0THV4b25EdXJhdGlvbihEdXJhdGlvbi5mcm9tT2JqZWN0KHtzZWNvbmRzOiBzZWNvbmRzfSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RHVyYXRpb259IGR1cmF0aW9uXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZvcm1hdEx1eG9uRHVyYXRpb24oZHVyYXRpb24pXG4gICAge1xuICAgICAgICBkdXJhdGlvbiA9IGR1cmF0aW9uLnNoaWZ0VG8oJ2hvdXJzJywgJ21pbnV0ZXMnLCAnc2Vjb25kcycpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdEFzRHVyYXRpb24oZHVyYXRpb24uaG91cnMsIGR1cmF0aW9uLm1pbnV0ZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RGF0ZX0gZGF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnx1bmRlZmluZWR9IGlzVXRjXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIGZvcm1hdFRpbWUoZGF0ZSwgaXNVdGMgPSBmYWxzZSlcbiAgICB7XG4gICAgICAgIGxldCBuZXdEYXRlID0gRGF0ZVRpbWUuZnJvbUpTRGF0ZShkYXRlKTtcblxuICAgICAgICBpZiAoaXNVdGMgPT09IHVuZGVmaW5lZCB8fCAhaXNVdGMpIHtcbiAgICAgICAgICAgIG5ld0RhdGUgPSBuZXdEYXRlLnRvVVRDKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAudXRjKCkgaXMgcmVxdWlyZWQgZm9yIGNhbGVuZGFyXG4gICAgICAgIHJldHVybiBuZXdEYXRlLnRvRm9ybWF0KHRoaXMudGltZUZvcm1hdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtpbnR9IGhvdXJzXG4gICAgICogQHBhcmFtIHtpbnR9IG1pbnV0ZXNcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gICAgZm9ybWF0QXNEdXJhdGlvbihob3VycywgbWludXRlcylcbiAgICB7XG4gICAgICAgIGxldCBmb3JtYXQgPSB0aGlzLmR1cmF0aW9uRm9ybWF0O1xuXG4gICAgICAgIGlmIChob3VycyA8IDAgfHwgbWludXRlcyA8IDApIHtcbiAgICAgICAgICAgIGhvdXJzID0gTWF0aC5hYnMoaG91cnMpO1xuICAgICAgICAgICAgbWludXRlcyA9IE1hdGguYWJzKG1pbnV0ZXMpO1xuICAgICAgICAgICAgZm9ybWF0ID0gJy0nICsgZm9ybWF0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdC5yZXBsYWNlKCclaCcsIGhvdXJzLnRvU3RyaW5nKCkpLnJlcGxhY2UoJyVtJywgKCcwJyArIG1pbnV0ZXMpLnNsaWNlKC0yKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGR1cmF0aW9uXG4gICAgICogQHJldHVybnMge2ludH1cbiAgICAgKi9cbiAgICBnZXRTZWNvbmRzRnJvbUR1cmF0aW9uU3RyaW5nKGR1cmF0aW9uKVxuICAgIHtcbiAgICAgICAgY29uc3QgbHV4b25EdXJhdGlvbiA9IHRoaXMucGFyc2VEdXJhdGlvbihkdXJhdGlvbik7XG5cbiAgICAgICAgaWYgKGx1eG9uRHVyYXRpb24gPT09IG51bGwgfHwgIWx1eG9uRHVyYXRpb24uaXNWYWxpZCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbHV4b25EdXJhdGlvbi5hcygnc2Vjb25kcycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkdXJhdGlvblxuICAgICAqIEByZXR1cm5zIHtEdXJhdGlvbn1cbiAgICAgKi9cbiAgICBwYXJzZUR1cmF0aW9uKGR1cmF0aW9uKVxuICAgIHtcbiAgICAgICAgaWYgKGR1cmF0aW9uID09PSB1bmRlZmluZWQgfHwgZHVyYXRpb24gPT09IG51bGwgfHwgZHVyYXRpb24gPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IER1cmF0aW9uKHtzZWNvbmRzOiAwfSk7XG4gICAgICAgIH1cblxuICAgICAgICBkdXJhdGlvbiA9IGR1cmF0aW9uLnRyaW0oKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBsZXQgbHV4b25EdXJhdGlvbiA9IG51bGw7XG5cbiAgICAgICAgaWYgKGR1cmF0aW9uLmluZGV4T2YoJzonKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IFssIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzXSA9IGR1cmF0aW9uLm1hdGNoKC8oXFxkKyk6KFxcZCspKD86OihcXGQrKSkqLyk7XG4gICAgICAgICAgICBsdXhvbkR1cmF0aW9uID0gRHVyYXRpb24uZnJvbU9iamVjdCh7aG91cnM6IGhvdXJzLCBtaW51dGVzOiBtaW51dGVzLCBzZWNvbmRzOiBzZWNvbmRzfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZHVyYXRpb24uaW5kZXhPZignLicpICE9PSAtMSB8fCBkdXJhdGlvbi5pbmRleE9mKCcsJykgIT09IC0xKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IGR1cmF0aW9uLnJlcGxhY2UoLywvLCAnLicpO1xuICAgICAgICAgICAgZHVyYXRpb24gPSAocGFyc2VGbG9hdChkdXJhdGlvbikgKiAzNjAwKS50b1N0cmluZygpO1xuICAgICAgICAgICAgbHV4b25EdXJhdGlvbiA9IER1cmF0aW9uLmZyb21JU08oJ1BUJyArIGR1cmF0aW9uICsgJ1MnKTtcbiAgICAgICAgfSBlbHNlIGlmIChkdXJhdGlvbi5pbmRleE9mKCdIJykgIT09IC0xIHx8IGR1cmF0aW9uLmluZGV4T2YoJ00nKSAhPT0gLTEgfHwgZHVyYXRpb24uaW5kZXhPZignUycpICE9PSAtMSkge1xuICAgICAgICAgICAgLyogRCBmb3IgZGF5cyBkb2VzIG5vdCB3b3JrLCBiZWNhdXNlICdQVDFIJyBidXQgd2l0aCBkYXlzICdQMUQnIGlzIHVzZWQgKi9cbiAgICAgICAgICAgIGx1eG9uRHVyYXRpb24gPSBEdXJhdGlvbi5mcm9tSVNPKCdQVCcgKyBkdXJhdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgYyA9IHBhcnNlSW50KGR1cmF0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IGQgPSBwYXJzZUludChkdXJhdGlvbikudG9GaXhlZCgpO1xuICAgICAgICAgICAgaWYgKCFpc05hTihjKSAmJiBkdXJhdGlvbiA9PT0gZCkge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gKGMgKiAzNjAwKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGx1eG9uRHVyYXRpb24gPSBEdXJhdGlvbi5mcm9tSVNPKCdQVCcgKyBkdXJhdGlvbiArICdTJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobHV4b25EdXJhdGlvbiA9PT0gbnVsbCB8fCAhbHV4b25EdXJhdGlvbi5pc1ZhbGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IER1cmF0aW9uKHtzZWNvbmRzOiAwfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhY3R1YWxseSwgdGhlIHBhcnNpbmcgYWJvdmUgc2hvdWxkIGJlIGltcHJvdmVkLCBidXQgdGhhdCB3b3JrcyBhcyB3ZWxsXG4gICAgICAgIGlmIChkdXJhdGlvblswXSA9PT0gJy0nICYmIGx1eG9uRHVyYXRpb24udmFsdWVPZigpID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGx1eG9uRHVyYXRpb24ubmVnYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbHV4b25EdXJhdGlvbjtcbiAgICB9XG5cbn1cbiIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiB0aGUgS2ltYWkgdGltZS10cmFja2luZyBhcHAuXG4gKlxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxuICovXG5cbi8qIVxuICogW0tJTUFJXSBLaW1haUVzY2FwZTogc2FuaXRpemUgc3RyaW5nc1xuICovXG5cbmltcG9ydCBLaW1haVBsdWdpbiBmcm9tIFwiLi4vS2ltYWlQbHVnaW5cIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgS2ltYWlFc2NhcGUgZXh0ZW5kcyBLaW1haVBsdWdpbiB7XG5cbiAgICBnZXRJZCgpIHtcbiAgICAgICAgcmV0dXJuICdlc2NhcGUnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZXNjYXBlRm9ySHRtbCh0aXRsZSkge1xuICAgICAgICBpZiAodGl0bGUgPT09IHVuZGVmaW5lZCB8fCB0aXRsZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGFnc1RvUmVwbGFjZSA9IHtcbiAgICAgICAgICAgICcmJzogJyZhbXA7JyxcbiAgICAgICAgICAgICc8JzogJyZsdDsnLFxuICAgICAgICAgICAgJz4nOiAnJmd0OycsXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRpdGxlLnJlcGxhY2UoL1smPD5dL2csIGZ1bmN0aW9uKHRhZykge1xuICAgICAgICAgICAgcmV0dXJuIHRhZ3NUb1JlcGxhY2VbdGFnXSB8fCB0YWc7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiB0aGUgS2ltYWkgdGltZS10cmFja2luZyBhcHAuXG4gKlxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxuICovXG5cbi8qIVxuICogW0tJTUFJXSBLaW1haUV2ZW50OiBoZWxwZXIgdG8gdHJpZ2dlciBldmVudHNcbiAqL1xuXG5pbXBvcnQgS2ltYWlQbHVnaW4gZnJvbSBcIi4uL0tpbWFpUGx1Z2luXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEtpbWFpRXZlbnQgZXh0ZW5kcyBLaW1haVBsdWdpbiB7XG5cbiAgICBnZXRJZCgpXG4gICAge1xuICAgICAgICByZXR1cm4gJ2V2ZW50JztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfGFycmF5fG9iamVjdHxudWxsfSBkZXRhaWxzXG4gICAgICovXG4gICAgdHJpZ2dlcihuYW1lLCBkZXRhaWxzID0gbnVsbClcbiAgICB7XG4gICAgICAgIGlmIChuYW1lID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBldmVudCBvZiBuYW1lLnNwbGl0KCcgJykpIHtcbiAgICAgICAgICAgIGxldCB0cmlnZ2VyRXZlbnQgPSBuZXcgRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgaWYgKGRldGFpbHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoZXZlbnQsIHtkZXRhaWw6IGRldGFpbHN9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQodHJpZ2dlckV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiB0aGUgS2ltYWkgdGltZS10cmFja2luZyBhcHAuXG4gKlxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxuICovXG5cbi8qIVxuICogW0tJTUFJXSBLaW1haUVzY2FwZTogc2FuaXRpemUgc3RyaW5nc1xuICovXG5cbmltcG9ydCBLaW1haVBsdWdpbiBmcm9tIFwiLi4vS2ltYWlQbHVnaW5cIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgS2ltYWlGZXRjaCBleHRlbmRzIEtpbWFpUGx1Z2luIHtcblxuICAgIGdldElkKCkge1xuICAgICAgICByZXR1cm4gJ2ZldGNoJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZXNwb25zZT59XG4gICAgICovXG4gICAgZmV0Y2godXJsLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuaGVhZGVycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcHRpb25zLmhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMuaGVhZGVycy5hcHBlbmQoJ1gtUmVxdWVzdGVkLVdpdGgnLCAnS2ltYWknKTtcblxuICAgICAgICBvcHRpb25zID0gey4uLntcbiAgICAgICAgICAgIHJlZGlyZWN0OiAnZm9sbG93JyxcbiAgICAgICAgfSwgLi4ub3B0aW9uc307XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGZldGNoKHVybCwgb3B0aW9ucykudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMSAmJiByZXNwb25zZS5oZWFkZXJzLmhhcygneC1tb2RhbC1yZWRpcmVjdCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24gPSByZXNwb25zZS5oZWFkZXJzLmdldCgneC1tb2RhbC1yZWRpcmVjdCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gXCJva1wiIGlzIG9ubHkgaW4gc3RhdHVzIGNvZGUgcmFuZ2Ugb2YgMnh4XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IHN0b3BQcm9wYWdhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAocmVzcG9uc2Uuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDAzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UuaGVhZGVycy5oYXMoJ2xvZ2luLXJlcXVpcmVkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dpblVybCA9IHRoaXMuZ2V0Q29uZmlndXJhdGlvbignbG9naW4nKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7S2ltYWlBbGVydH0gYWxlcnQgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhbGVydCA9IHRoaXMuZ2V0Q29udGFpbmVyKCkuZ2V0UGx1Z2luKCdhbGVydCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsZXJ0LnF1ZXN0aW9uKHRoaXMudHJhbnNsYXRlKCdsb2dpbi5yZXF1aXJlZCcpLCAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKGxvZ2luVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3BQcm9wYWdhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnU29tZSBlcnJvciBvY2N1cnJlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIXN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdFcnJvciBvY2N1cnJlZCB3aGlsZSB0YWxraW5nIHRvIEtpbWFpIGJhY2tlbmQnLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgdGhlIEtpbWFpIHRpbWUtdHJhY2tpbmcgYXBwLlxuICpcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cbiAqL1xuXG4vKiFcbiAqIFtLSU1BSV0gS2ltYWlGb3JtOiBiYXNpYyBmdW5jdGlvbnMgZm9yIGFsbCBmb3Jtc1xuICovXG5cbmltcG9ydCBLaW1haVBsdWdpbiBmcm9tIFwiLi4vS2ltYWlQbHVnaW5cIjtcbmltcG9ydCBLaW1haUZvcm1QbHVnaW4gZnJvbSBcIi4uL2Zvcm1zL0tpbWFpRm9ybVBsdWdpblwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBLaW1haUZvcm0gZXh0ZW5kcyBLaW1haVBsdWdpbiB7XG5cbiAgICBnZXRJZCgpXG4gICAge1xuICAgICAgICByZXR1cm4gJ2Zvcm0nO1xuICAgIH1cblxuICAgIGFjdGl2YXRlRm9ybShmb3JtU2VsZWN0b3IpXG4gICAge1xuICAgICAgICBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZm9ybVNlbGVjdG9yKSkubWFwKChmb3JtKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiB0aGlzLmdldENvbnRhaW5lcigpLmdldFBsdWdpbnMoKSkge1xuICAgICAgICAgICAgICAgIGlmIChwbHVnaW4gaW5zdGFuY2VvZiBLaW1haUZvcm1QbHVnaW4gJiYgcGx1Z2luLnN1cHBvcnRzRm9ybShmb3JtKSkge1xuICAgICAgICAgICAgICAgICAgICBwbHVnaW4uYWN0aXZhdGVGb3JtKGZvcm0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZGVzdHJveUZvcm0oZm9ybVNlbGVjdG9yKVxuICAgIHtcbiAgICAgICAgW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGZvcm1TZWxlY3RvcikpLm1hcCgoZm9ybSkgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwbHVnaW4gb2YgdGhpcy5nZXRDb250YWluZXIoKS5nZXRQbHVnaW5zKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luIGluc3RhbmNlb2YgS2ltYWlGb3JtUGx1Z2luICYmIHBsdWdpbi5zdXBwb3J0c0Zvcm0oZm9ybSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luLmRlc3Ryb3lGb3JtKGZvcm0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtIVE1MRm9ybUVsZW1lbnR9IGZvcm1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3ZlcndyaXRlc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVtb3ZlRW1wdHlcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGNvbnZlcnRGb3JtRGF0YVRvUXVlcnlTdHJpbmcoZm9ybSwgb3ZlcndyaXRlcyA9IHt9LCByZW1vdmVFbXB0eSA9IGZhbHNlKVxuICAgIHtcbiAgICAgICAgbGV0IHNlcmlhbGl6ZWQgPSBbXTtcbiAgICAgICAgbGV0IGRhdGEgPSBuZXcgRm9ybURhdGEoZm9ybSk7XG5cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb3ZlcndyaXRlcykge1xuICAgICAgICAgICAgZGF0YS5zZXQoa2V5LCBvdmVyd3JpdGVzW2tleV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgcm93IG9mIGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghcmVtb3ZlRW1wdHkgfHwgcm93WzFdICE9PSAnJykge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWQucHVzaChlbmNvZGVVUklDb21wb25lbnQocm93WzBdKSArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHJvd1sxXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQuam9pbignJicpO1xuICAgIH1cbn1cbiIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiB0aGUgS2ltYWkgdGltZS10cmFja2luZyBhcHAuXG4gKlxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxuICovXG5cbmltcG9ydCBLaW1haVBsdWdpbiBmcm9tIFwiLi4vS2ltYWlQbHVnaW5cIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgS2ltYWlIb3RrZXlzIGV4dGVuZHMgS2ltYWlQbHVnaW4ge1xuXG4gICAgZ2V0SWQoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuICdob3RrZXlzJztcbiAgICB9XG5cbiAgICBpbml0KClcbiAgICB7XG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50XG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50L2tleVxuXG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gJ1tkYXRhLWhvdGtleT1cImN0cmwrRW50ZXJcIl0nO1xuXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIChldikgPT4ge1xuICAgICAgICAgICAgaWYgKGV2LmN0cmxLZXkgJiYgZXYua2V5ID09PSAnRW50ZXInKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudHMgPSBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcildLmZpbHRlcihlbGVtZW50ID0+IHRoaXMuaXNWaXNpYmxlKGVsZW1lbnQpKTtcblxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignS2ltYWlIb3RrZXlzOiBNb3JlIHRoYW4gb25lIHZpc2libGUgZWxlbWVudCBtYXRjaGVzICR7c2VsZWN0b3J9LiBObyBhY3Rpb24gdHJpZ2dlcmVkLicpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHNbMF0uY2xpY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gYWRvcHRlZCBmcm9tIEJvb3RzdHJhcCA1LjEuMSwgTUlUXG4gICAgaXNWaXNpYmxlIChlbGVtZW50KVxuICAgIHtcbiAgICAgICAgaWYgKCFlbGVtZW50IHx8IGVsZW1lbnQuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUoJ3Zpc2liaWxpdHknKSA9PT0gJ3Zpc2libGUnO1xuICAgIH1cbn0iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgdGhlIEtpbWFpIHRpbWUtdHJhY2tpbmcgYXBwLlxuICpcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cbiAqL1xuXG4vKiFcbiAqIFtLSU1BSV0gS2ltYWlNdWx0aVVwZGF0ZUZvcm06IGhhbmRsZSB0aGUgbXVsdGkgdXBkYXRlIGNoZWNrYm94IGxpc3QgYW5kIGZvcm1cbiAqL1xuXG5pbXBvcnQgS2ltYWlQbHVnaW4gZnJvbSAnLi4vS2ltYWlQbHVnaW4nO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBLaW1haU11bHRpVXBkYXRlVGFibGUgZXh0ZW5kcyBLaW1haVBsdWdpbiB7XG5cbiAgICBpbml0KClcbiAgICB7XG4gICAgICAgIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbXVsdGlfdXBkYXRlX2FsbCcpID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3ZSBoYXZlIHRvIGF0dGFjaCBpdCB0byB0aGUgXCJwYWdlLWJvZHlcIiBkaXYsIGJlY2F1c2Ugc2VjdGlvbi5jb250ZW50IGNhbiBiZSByZXBsYWNlZFxuICAgICAgICAvLyB2aWEgS2ltYWlEYXRhYmxlIGFuZCBldmVyeXRoaW5nIGluc2lkZSB3aWxsIGJlIHJlbW92ZWQsIGluY2x1ZGluZyBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2Rpdi5wYWdlLWJvZHknKTtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC50YXJnZXQubWF0Y2hlcygnI211bHRpX3VwZGF0ZV9hbGwnKSkge1xuICAgICAgICAgICAgICAgIC8vIHRoZSBcImNoZWNrIGFsbFwiIGNoZWNrYm94IGluIHRoZSB1cHBlciBzdGFydCBjb3JuZXIgb2YgdGhlIHRhYmxlXG4gICAgICAgICAgICAgICAgY29uc3QgY2hlY2tlZCA9IGV2ZW50LnRhcmdldC5jaGVja2VkO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcubXVsdGlfdXBkYXRlX3NpbmdsZScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuY2hlY2tlZCA9IGNoZWNrZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3RvZ2dsZUZvcm0oKTtcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQudGFyZ2V0Lm1hdGNoZXMoJy5tdWx0aV91cGRhdGVfc2luZ2xlJykpIHtcbiAgICAgICAgICAgICAgICAvLyBzaW5nbGUgY2hlY2tib3hlcyBpbiBmcm9udCBvZiBlYWNoIHJvd1xuICAgICAgICAgICAgICAgIHRoaXMuX3RvZ2dsZUZvcm0oKTtcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnRhcmdldC5tYXRjaGVzKCcubXVsdGlfdXBkYXRlX3RhYmxlX2FjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRJdGVtID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkcyA9IHRoaXMuX2dldFNlbGVjdGVkSWRzKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZm9ybSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtdWx0aV91cGRhdGVfZm9ybScpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHF1ZXN0aW9uID0gZm9ybS5kYXRhc2V0WydxdWVzdGlvbiddLnJlcGxhY2UoLyVhY3Rpb24lLywgc2VsZWN0ZWRJdGVtLnRleHRDb250ZW50KS5yZXBsYWNlKC8lY291bnQlLywgaWRzLmxlbmd0aC50b1N0cmluZygpKTtcblxuICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7S2ltYWlBbGVydH0gQUxFUlQgKi9cbiAgICAgICAgICAgICAgICBjb25zdCBBTEVSVCA9IHRoaXMuZ2V0UGx1Z2luKCdhbGVydCcpO1xuICAgICAgICAgICAgICAgIEFMRVJULnF1ZXN0aW9uKHF1ZXN0aW9uLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZvcm0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbXVsdGlfdXBkYXRlX2Zvcm0nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm0uYWN0aW9uID0gc2VsZWN0ZWRJdGVtLmRhdGFzZXRbJ2hyZWYnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm0uc3VibWl0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIF9nZXRTZWxlY3RlZElkcygpXG4gICAge1xuICAgICAgICBsZXQgaWRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgYm94IG9mIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0Lm11bHRpX3VwZGF0ZV9zaW5nbGU6Y2hlY2tlZCcpKSB7XG4gICAgICAgICAgICBpZHMucHVzaChib3gudmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGlkcztcbiAgICB9XG4gICAgXG4gICAgX3RvZ2dsZUZvcm0oKVxuICAgIHtcbiAgICAgICAgY29uc3QgaWRzID0gdGhpcy5fZ2V0U2VsZWN0ZWRJZHMoKTtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ211bHRpX3VwZGF0ZV90YWJsZV9lbnRpdGllcycpLnZhbHVlID0gaWRzLmpvaW4oJywnKTtcblxuICAgICAgICBpZiAoaWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdtdWx0aV91cGRhdGVfZm9ybV9oaWRlJykpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KCdkaXNwbGF5JywgJ25vbmUnLCAnaW1wb3J0YW50Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbXVsdGlfdXBkYXRlX2Zvcm0nKS5zdHlsZS5kaXNwbGF5ID0gbnVsbDsvLydibG9jayc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbXVsdGlfdXBkYXRlX2Zvcm0nKS5zdHlsZS5zZXRQcm9wZXJ0eSgnZGlzcGxheScsICdub25lJywgJ2ltcG9ydGFudCcpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ211bHRpX3VwZGF0ZV9mb3JtX2hpZGUnKSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG59XG4iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgdGhlIEtpbWFpIHRpbWUtdHJhY2tpbmcgYXBwLlxuICpcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cbiAqL1xuXG4vKiFcbiAqIFtLSU1BSV0gTm90aWZpY2F0aW9uOiBub3RpZmljYXRpb25zIGZvciBLaW1haVxuICovXG5cbmltcG9ydCBLaW1haVBsdWdpbiBmcm9tICcuLi9LaW1haVBsdWdpbic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEtpbWFpTm90aWZpY2F0aW9uIGV4dGVuZHMgS2ltYWlQbHVnaW4ge1xuXG4gICAgZ2V0SWQoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuICdub3RpZmljYXRpb24nO1xuICAgIH1cblxuICAgIGlzU3VwcG9ydGVkKClcbiAgICB7XG4gICAgICAgIGlmICghd2luZG93Lk5vdGlmaWNhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE5vdGlmaWNhdGlvbi5wZXJtaXNzaW9uID09PSAnZGVuaWVkJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE5vdGlmaWNhdGlvbi5wZXJtaXNzaW9uID09PSBcImdyYW50ZWRcIjtcbiAgICB9XG5cbiAgICByZXF1ZXN0KGNhbGxiYWNrKVxuICAgIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIE5vdGlmaWNhdGlvbi5yZXF1ZXN0UGVybWlzc2lvbigpLnRoZW4oKHBlcm1pc3Npb24pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocGVybWlzc2lvbiA9PT0gXCJncmFudGVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwZXJtaXNzaW9uID09PSBcImRlZmF1bHRcIikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIE5vdGlmaWNhdGlvbi5yZXF1ZXN0UGVybWlzc2lvbigocGVybWlzc2lvbikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwZXJtaXNzaW9uID09PSBcImdyYW50ZWRcIikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh0cnVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBlcm1pc3Npb24gPT09IFwiZGVmYXVsdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5vdGlmeSh0aXRsZSwgbWVzc2FnZSwgaWNvbiwgb3B0aW9ucylcbiAgICB7XG4gICAgICAgIHRoaXMucmVxdWVzdCgocGVybWlzc2lvbikgPT4ge1xuXG4gICAgICAgICAgICBpZiAocGVybWlzc2lvbiAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIC8qKiBAdHlwZSBLaW1haUFsZXJ0ICovXG4gICAgICAgICAgICAgICAgY29uc3QgQUxFUlQgPSB0aGlzLmdldFBsdWdpbignYWxlcnQnKTtcbiAgICAgICAgICAgICAgICBBTEVSVC5pbmZvKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgb3B0cyA9IHtcbiAgICAgICAgICAgICAgICBib2R5OiBtZXNzYWdlLFxuICAgICAgICAgICAgICAgIGRpcjogdGhpcy5nZXRDb25maWd1cmF0aW9ucygpLmlzUlRMKCkgPyAncnRsJyA6ICdsdHInLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vb3B0cy5yZXF1aXJlSW50ZXJhY3Rpb24gPSB0cnVlO1xuICAgICAgICAgICAgLy9vcHRzLnJlbm90aWZ5ID0gdHJ1ZTtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICBpZiAob3B0aW9ucy50YWcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG9wdHMudGFnID0gJ2tpbWFpJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoaWNvbiAhPT0gdW5kZWZpbmVkICYmIGljb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvcHRzLmljb24gPSBpY29uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgblRpdGxlID0gJ0tpbWFpJztcbiAgICAgICAgICAgIGlmICh0aXRsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG5UaXRsZSA9IG5UaXRsZSArICc6ICcgKyB0aXRsZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgb3B0cyA9IHsgLi4ub3B0cywgLi4ub3B0aW9uc307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IG5vdGlmaWNhdGlvbiA9IG5ldyB3aW5kb3cuTm90aWZpY2F0aW9uKG5UaXRsZSwgb3B0cyk7XG5cbiAgICAgICAgICAgIG5vdGlmaWNhdGlvbi5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5mb2N1cygpO1xuICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbi5jbG9zZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHRoZSBLaW1haSB0aW1lLXRyYWNraW5nIGFwcC5cbiAqXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXG4gKi9cblxuLyohXG4gKiBbS0lNQUldIEtpbWFpUmVkdWNlZENsaWNrSGFuZGxlcjogYWJzdHJhY3QgY2xhc3NcbiAqL1xuXG5pbXBvcnQgS2ltYWlQbHVnaW4gZnJvbSBcIi4uL0tpbWFpUGx1Z2luXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEtpbWFpUmVkdWNlZENsaWNrSGFuZGxlciBleHRlbmRzIEtpbWFpUGx1Z2luIHtcblxuICAgIC8qKlxuICAgICAqIE5vIF91bmRlcnNjb3JlIG5hbWluZyBmb3Igbm93LCBhcyBpdCB3b3VsZCBiZSBtYW5nbGVkIG90aGVyd2lzZVxuICAgICAqIEBwYXJhbSBzZWxlY3RvclxuICAgICAqIEBwYXJhbSBjYWxsYmFja1xuICAgICAqL1xuICAgIGFkZENsaWNrSGFuZGxlcihzZWxlY3RvciwgY2FsbGJhY2spIHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgLy8gZXZlbnQuY3VycmVudFRhcmdldCBpcyBBTFdBWVMgdGhlIGJvZHlcblxuICAgICAgICAgICAgbGV0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgIHdoaWxlICh0YXJnZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YWdOYW1lID0gdGFyZ2V0LnRhZ05hbWUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ0JPRFknKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0Lm1hdGNoZXMoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHdoZW4gYW4gZWxlbWVudCBpcyBjbGlja2VkLCB3aGljaCBjYW4gdHJpZ2dlciBzdHVmZiBpdHNlbGYsIHdlIGRvbid0IHdhbnQgdGhlIGV2ZW50IHRvIGJlIHByb2Nlc3NlZFxuICAgICAgICAgICAgICAgIGlmICh0YWdOYW1lID09PSAnQScgfHwgdGFnTmFtZSA9PT0gJ0JVVFRPTicgfHwgdGFnTmFtZSA9PT0gJ0lOUFVUJyB8fCB0YWdOYW1lID09PSAnTEFCRUwnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8ganVzdCBpbiBjYXNlIGFuIGlubmVyIGVsZW1lbnQgaXMgZWRpdGFibGUsIHRoZW4gdGhpcyBzaG91bGQgbm90IGJlIHRyaWdnZXJlZFxuICAgICAgICAgICAgaWYgKHRhcmdldC5pc0NvbnRlbnRFZGl0YWJsZSB8fCB0YXJnZXQucGFyZW50Tm9kZS5pc0NvbnRlbnRFZGl0YWJsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0YXJnZXQubWF0Y2hlcyhzZWxlY3RvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgbGV0IGhyZWYgPSB0YXJnZXQuZGF0YXNldFsnaHJlZiddO1xuICAgICAgICAgICAgaWYgKGhyZWYgPT09IHVuZGVmaW5lZCB8fCBocmVmID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaHJlZiA9IHRhcmdldC5ocmVmO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaHJlZiA9PT0gdW5kZWZpbmVkIHx8IGhyZWYgPT09IG51bGwgfHwgaHJlZiA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhbGxiYWNrKGhyZWYpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbn1cbiIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiB0aGUgS2ltYWkgdGltZS10cmFja2luZyBhcHAuXG4gKlxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxuICovXG5cbi8qIVxuICogW0tJTUFJXSBLaW1haVJlY2VudEFjdGl2aXRpZXM6IHJlc3BvbnNpYmxlIHRvIHJlbG9hZCB0aGUgdXNlcnMgcmVjZW50IGFjdGl2aXRpZXNcbiAqL1xuXG5pbXBvcnQgS2ltYWlQbHVnaW4gZnJvbSAnLi4vS2ltYWlQbHVnaW4nO1xuaW1wb3J0IHsgTW9kYWwgfSBmcm9tICdib290c3RyYXAnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBLaW1haVJlbW90ZU1vZGFsIGV4dGVuZHMgS2ltYWlQbHVnaW4ge1xuXG4gICAgY29uc3RydWN0b3IoKVxuICAgIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fc2VsZWN0b3IgPSAnYS5yZW1vdGUtbW9kYWwtbG9hZCc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRJZCgpXG4gICAge1xuICAgICAgICByZXR1cm4gJ3JlbW90ZS1tb2RhbCc7XG4gICAgfVxuXG4gICAgaW5pdCgpXG4gICAge1xuICAgICAgICB0aGlzLmhhbmRsZSA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fc2hvd01vZGFsKGV2ZW50LmN1cnJlbnRUYXJnZXQpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgbGluayBvZiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHRoaXMuX3NlbGVjdG9yKSkge1xuICAgICAgICAgICAgbGluay5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGFuZGxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tpbWFpLmNsb3NlUmVtb3RlTW9kYWwnLCAoKSA9PiB7IHRoaXMuX2hpZGUoKTsgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2luaXRFbGVtZW50KGVsZW1lbnQpXG4gICAge1xuICAgICAgICBmb3IgKGxldCBsaW5rIG9mIGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnYS5yZW1vdGUtbW9kYWwtcmVsb2FkJykpIHtcbiAgICAgICAgICAgIGxpbmsuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmhhbmRsZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfaGlkZSgpXG4gICAge1xuICAgICAgICB0aGlzLl9nZXRNb2RhbCgpLmhpZGUoKTtcbiAgICB9XG5cbiAgICBfZ2V0TW9kYWxFbGVtZW50KClcbiAgICB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmVtb3RlX21vZGFsJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge01vZGFsfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldE1vZGFsKClcbiAgICB7XG4gICAgICAgIHJldHVybiBNb2RhbC5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMuX2dldE1vZGFsRWxlbWVudCgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0hUTUxMaW5rRWxlbWVudH0gZWxlbWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Nob3dNb2RhbChlbGVtZW50KVxuICAgIHtcbiAgICAgICAgdGhpcy5mZXRjaChlbGVtZW50LmhyZWYsIHttZXRob2Q6ICdHRVQnfSlcbiAgICAgICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpLnRoZW4oaHRtbCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0Zvcm1IdG1sID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgICAgIG5ld0Zvcm1IdG1sLmNsYXNzTGlzdC5hZGQoJ21vZGFsLWJvZHknKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3Rm9ybUh0bWwuY2xhc3NMaXN0LmFkZCgncC0wJyk7XG4gICAgICAgICAgICAgICAgICAgIG5ld0Zvcm1IdG1sLmlubmVySFRNTCA9IGh0bWw7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdEVsZW1lbnQobmV3Rm9ybUh0bWwpO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1vZGFsID0gdGhpcy5fZ2V0TW9kYWxFbGVtZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIG1vZGFsLnF1ZXJ5U2VsZWN0b3IoJy5tb2RhbC1ib2R5JykucmVwbGFjZVdpdGgobmV3Rm9ybUh0bWwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5kYXRhc2V0Wydtb2RhbFRpdGxlJ10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kYWwucXVlcnlTZWxlY3RvcignLm1vZGFsLXRpdGxlJykudGV4dENvbnRlbnQgPSBlbGVtZW50LmRhdGFzZXRbJ21vZGFsVGl0bGUnXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dldE1vZGFsKCkuc2hvdygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgocmVhc29uKSA9PiAge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGYWlsZWQgdG8gbG9hZCByZW1vdGUgbW9kYWwnLCByZWFzb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHRoZSBLaW1haSB0aW1lLXRyYWNraW5nIGFwcC5cbiAqXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXG4gKi9cblxuLyohXG4gKiBbS0lNQUldIEtpbWFpVGhlbWVJbml0aWFsaXplcjogaW5pdGlhbGl6ZSB0aGVtZSBmdW5jdGlvbmFsaXR5XG4gKi9cblxuaW1wb3J0IHsgVG9vbHRpcCB9IGZyb20gJ2Jvb3RzdHJhcCc7XG5pbXBvcnQgS2ltYWlQbHVnaW4gZnJvbSAnLi4vS2ltYWlQbHVnaW4nO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBLaW1haVRoZW1lSW5pdGlhbGl6ZXIgZXh0ZW5kcyBLaW1haVBsdWdpbiB7XG5cbiAgICBpbml0KClcbiAgICB7XG4gICAgICAgIC8vIHRoZSB0b29sdGlwIGRvIG5vdCB1c2UgZGF0YS1icy10b2dnbGU9XCJ0b29sdGlwXCIgc28gdGhleSBjYW4gYmUgbWl4ZWQgd2l0aCBkYXRhLXRvZ2dsZT1cIm1vZGFsXCJcbiAgICAgICAgW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS10b2dnbGU9XCJ0b29sdGlwXCJdJykpLm1hcChmdW5jdGlvbiAodG9vbHRpcFRyaWdnZXJFbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUb29sdGlwKHRvb2x0aXBUcmlnZ2VyRWwpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBhY3RpdmF0ZSBhbGwgZm9ybSBwbHVnaW5zXG4gICAgICAgIC8qKiBAdHlwZSB7S2ltYWlGb3JtfSBGT1JNUyAqL1xuICAgICAgICBjb25zdCBGT1JNUyA9IHRoaXMuZ2V0Q29udGFpbmVyKCkuZ2V0UGx1Z2luKCdmb3JtJyk7XG4gICAgICAgIEZPUk1TLmFjdGl2YXRlRm9ybSgnZGl2LnBhZ2Utd3JhcHBlciBmb3JtJyk7XG5cbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJNb2RhbEF1dG9mb2N1cygnI3JlbW90ZV9mb3JtX21vZGFsJyk7XG5cbiAgICAgICAgdGhpcy5vdmVybGF5ID0gbnVsbDtcblxuICAgICAgICAvLyByZWdpc3RlciBhIGdsb2JhbCBldmVudCBsaXN0ZW5lciwgd2hpY2ggZGlzcGxheXMgYW4gb3ZlcmxheXMgdXBvbiBub3RpZmljYXRpb25cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2ltYWkucmVsb2FkQ29udGVudCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgLy8gZG8gbm90IGFsbG93IG1vcmUgdGhhbiBvbmUgbG9hZGluZyBzY3JlZW4gYXQgYSB0aW1lXG4gICAgICAgICAgICBpZiAodGhpcy5vdmVybGF5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBhdCB3aGljaCBlbGVtZW50IHdlIGFwcGVuZCB0aGUgbG9hZGluZyBzY3JlZW5cbiAgICAgICAgICAgIGxldCBjb250YWluZXIgPSAnYm9keSc7XG4gICAgICAgICAgICBpZiAoZXZlbnQuZGV0YWlsICE9PSB1bmRlZmluZWQgJiYgZXZlbnQuZGV0YWlsICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB0ZW1wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICB0ZW1wLmlubmVySFRNTCA9ICc8ZGl2IGNsYXNzPVwib3ZlcmxheVwiPjxkaXYgY2xhc3M9XCJmYXMgZmEtc3luYyBmYS1zcGluXCI+PC9kaXY+PC9kaXY+JztcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheSA9IHRlbXAuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGNvbnRhaW5lcikuYXBwZW5kKHRoaXMub3ZlcmxheSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHJlZ2lzdGVyIGEgZ2xvYmFsIGV2ZW50IGxpc3RlbmVyLCB3aGljaCBoaWRlcyBhbiBvdmVybGF5IHVwb24gbm90aWZpY2F0aW9uXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tpbWFpLnJlbG9hZGVkQ29udGVudCcsICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLm92ZXJsYXkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm92ZXJsYXkucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5vdmVybGF5ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGVscHMgdG8gc2V0IHRoZSBhdXRvZm9jdXMgb24gbW9kYWxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yXG4gICAgICovXG4gICAgX3JlZ2lzdGVyTW9kYWxBdXRvZm9jdXMoc2VsZWN0b3IpIHtcbiAgICAgICAgLy8gb24gbW9iaWxlIHlvdSBkbyBub3Qgd2FudCB0byB0cmlnZ2VyIHRoZSB2aXJ0dWFsIGtleWJvYXJkIHVwb24gbW9kYWwgb3BlblxuICAgICAgICBpZiAodGhpcy5pc01vYmlsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtb2RhbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgICBpZiAobW9kYWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG1vZGFsLmFkZEV2ZW50TGlzdGVuZXIoJ3Nob3duLmJzLm1vZGFsJywgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZm9ybSA9IG1vZGFsLnF1ZXJ5U2VsZWN0b3IoJ2Zvcm0nKTtcbiAgICAgICAgICAgIGxldCBmb3JtQXV0b2ZvY3VzID0gZm9ybS5xdWVyeVNlbGVjdG9yQWxsKCdbYXV0b2ZvY3VzXScpO1xuICAgICAgICAgICAgaWYgKGZvcm1BdXRvZm9jdXMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgICAgIGZvcm1BdXRvZm9jdXMgPSBmb3JtLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W3R5cGU9dGV4dF0saW5wdXRbdHlwZT1kYXRlXSx0ZXh0YXJlYSxzZWxlY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3JtQXV0b2ZvY3VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3JtQXV0b2ZvY3VzWzBdLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiB0aGUgS2ltYWkgdGltZS10cmFja2luZyBhcHAuXG4gKlxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxuICovXG5cbi8qIVxuICogW0tJTUFJXSBLaW1haVRvb2xiYXI6IHNvbWUgZXZlbnQgbGlzdGVuZXIgdG8gaGFuZGxlIHRoZSB0b29sYmFyL2RhdGEtdGFibGUgZmlsdGVyLCB0b29sYmFyIGFuZCBuYXZpZ2F0aW9uXG4gKi9cblxuaW1wb3J0IEtpbWFpUGx1Z2luIGZyb20gXCIuLi9LaW1haVBsdWdpblwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBLaW1haVRvb2xiYXIgZXh0ZW5kcyBLaW1haVBsdWdpbiB7XG5cbiAgICBjb25zdHJ1Y3Rvcihmb3JtU2VsZWN0b3IsIGZvcm1TdWJtaXRBY3Rpb25DbGFzcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9mb3JtU2VsZWN0b3IgPSBmb3JtU2VsZWN0b3I7XG4gICAgICAgIHRoaXMuX2FjdGlvbkNsYXNzID0gZm9ybVN1Ym1pdEFjdGlvbkNsYXNzO1xuICAgIH1cblxuICAgIGdldElkKCkge1xuICAgICAgICByZXR1cm4gJ3Rvb2xiYXInO1xuICAgIH1cblxuICAgIGluaXQoKSB7XG4gICAgICAgIGNvbnN0IGZvcm1TZWxlY3RvciA9IHRoaXMuZ2V0U2VsZWN0b3IoKTtcblxuICAgICAgICB0aGlzLl9yZWdpc3RlclBhZ2luYXRpb24oZm9ybVNlbGVjdG9yKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJTb3J0YWJsZVRhYmxlcyhmb3JtU2VsZWN0b3IpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckFsdGVybmF0aXZlU3VibWl0QWN0aW9ucyhmb3JtU2VsZWN0b3IsIHRoaXMuX2FjdGlvbkNsYXNzKTtcblxuICAgICAgICAvLyBSZXNldCB0aGUgcGFnZSBpZiBmaWx0ZXIgdmFsdWVzIGFyZSBjaGFuZ2VkLCBvdGhlcndpc2Ugd2UgbWlnaHQgZW5kIHVwIHdpdGggYSBsaW1pdGVkIHNldCBvZiBkYXRhLFxuICAgICAgICAvLyB3aGljaCBkb2VzIG5vdCBzdXBwb3J0IHRoZSBnaXZlbiBwYWdlIC0gYW5kIGl0IHdvdWxkIGJlIGp1c3Qgd3JvbmcgdG8gc3RheSBpbiB0aGUgc2FtZSBwYWdlXG4gICAgICAgIFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChmb3JtU2VsZWN0b3IgKyAnIGlucHV0JykpLm1hcCgoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGV2ZW50LnRhcmdldC5pZCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdvcmRlcic6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ29yZGVyQnknOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdwYWdlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihmb3JtU2VsZWN0b3IgKyAnIGlucHV0I3BhZ2UnKS52YWx1ZSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlckNoYW5nZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyB3aGVuIHVzZXIgc2VsZWN0ZWQgYSBuZXcgY3VzdG9tZXIgb3IgcHJvamVjdCwgcmVzZXQgdGhlIHBhZ2luYXRpb24gYmFjayB0byAxXG4gICAgICAgIC8vIGFuZCB0aGVuIGZpbmQgb3V0IGlmIHRoZSByZXN1bHRzIHNob3VsZCBiZSByZWxvYWRlZFxuICAgICAgICBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZm9ybVNlbGVjdG9yICsgJyBzZWxlY3QnKSkubWFwKChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCByZWxvYWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZXZlbnQudGFyZ2V0LmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2N1c3RvbWVyJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGZvcm1TZWxlY3RvciArICcgc2VsZWN0I3Byb2plY3QnKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbG9hZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncHJvamVjdCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihmb3JtU2VsZWN0b3IgKyAnIHNlbGVjdCNhY3Rpdml0eScpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsb2FkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihmb3JtU2VsZWN0b3IgKyAnIGlucHV0I3BhZ2UnKS52YWx1ZSA9IDE7XG5cbiAgICAgICAgICAgICAgICBpZiAocmVsb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlckNoYW5nZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTb21lIGFjdGlvbnMgdXRpbGl6ZSB0aGUgZmlsdGVyIGZyb20gdGhlIHNlYXJjaCBmb3JtIGFuZCBzdWJtaXQgaXQgdG8gYW5vdGhlciBVUkwuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVnaXN0ZXJBbHRlcm5hdGl2ZVN1Ym1pdEFjdGlvbnModG9vbGJhclNlbGVjdG9yLCBhY3Rpb25CdG5DbGFzcykge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgd2hpbGUgKHRhcmdldCAhPT0gbnVsbCAmJiB0eXBlb2YgdGFyZ2V0Lm1hdGNoZXMgPT09IFwiZnVuY3Rpb25cIiAmJiAhdGFyZ2V0Lm1hdGNoZXMoJ2JvZHknKSkge1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKGFjdGlvbkJ0bkNsYXNzKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmb3JtID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0b29sYmFyU2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm9ybSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZBY3Rpb24gPSBmb3JtLmdldEF0dHJpYnV0ZSgnYWN0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZNZXRob2QgPSBmb3JtLmdldEF0dHJpYnV0ZSgnbWV0aG9kJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuZGF0YXNldC50YXJnZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybS50YXJnZXQgPSB0YXJnZXQuZGF0YXNldC50YXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9ybS5hY3Rpb24gPSB0YXJnZXQuaHJlZjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldC5kYXRhc2V0Lm1ldGhvZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtLm1ldGhvZCA9IHRhcmdldC5kYXRhc2V0Lm1ldGhvZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3JtLnN1Ym1pdCgpO1xuICAgICAgICAgICAgICAgICAgICBmb3JtLnRhcmdldCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBmb3JtLmFjdGlvbiA9IHByZXZBY3Rpb247XG4gICAgICAgICAgICAgICAgICAgIGZvcm0ubWV0aG9kID0gcHJldk1ldGhvZDtcblxuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU29ydGFibGUgZGF0YXRhYmxlcyB1c2UgaGlkZGVuIGZpZWxkcyBpbiB0aGUgdG9vbGJhciBmaWx0ZXIvc2VhcmNoIGZvcm1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZWdpc3RlclNvcnRhYmxlVGFibGVzKGZvcm1TZWxlY3Rvcikge1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWV2ZW50LnRhcmdldC5tYXRjaGVzKCd0aC5zb3J0YWJsZScpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG9yZGVyID0gJ0RFU0MnO1xuICAgICAgICAgICAgbGV0IG9yZGVyQnkgPSBldmVudC50YXJnZXQuZGF0YXNldFsnb3JkZXInXTtcbiAgICAgICAgICAgIGlmIChldmVudC50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdzb3J0aW5nX2Rlc2MnKSkge1xuICAgICAgICAgICAgICAgIG9yZGVyID0gJ0FTQyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZm9ybVNlbGVjdG9yICsgJyAjb3JkZXJCeScpLnZhbHVlID0gb3JkZXJCeTtcbiAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZm9ybVNlbGVjdG9yICsgJyAjb3JkZXInKS52YWx1ZSA9IG9yZGVyO1xuXG4gICAgICAgICAgICAvLyByZS1yZW5kZXIgdGhlIHNlbGVjdGJveFxuICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihmb3JtU2VsZWN0b3IgKyAnICNvcmRlckJ5JykuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2NoYW5nZScpKTtcbiAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZm9ybVNlbGVjdG9yICsgJyAjb3JkZXInKS5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnY2hhbmdlJykpO1xuXG4gICAgICAgICAgICAvLyB0cmlnZ2VycyB0aGUgZGF0YXRhYmxlIHJlbG9hZCAtIHNlYXJjaCBmb3IgdGhlIGV2ZW50IG5hbWVcbiAgICAgICAgICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdmaWx0ZXItY2hhbmdlJykpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogVGhpcyBjYXRjaGVzIGFsbCBjbGlja3Mgb24gdGhlIHBhZ2luYXRpb24gYW5kIHByZXZlbnRzIHRoZSBkZWZhdWx0IGFjdGlvbixcbiAgICAgKiBhcyB3ZSB3YW50IHRvIHJlbG9hZCB0aGUgcGFnZSB2aWEgSlMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZWdpc3RlclBhZ2luYXRpb24oZm9ybVNlbGVjdG9yKSB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmICghZXZlbnQudGFyZ2V0Lm1hdGNoZXMoJ3VsLnBhZ2luYXRpb24gbGkgYScpICYmIChldmVudC50YXJnZXQucGFyZW50Tm9kZSA9PT0gbnVsbCB8fCAhZXZlbnQudGFyZ2V0LnBhcmVudE5vZGUubWF0Y2hlcygndWwucGFnaW5hdGlvbiBsaSBhJykpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgcGFnZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGZvcm1TZWxlY3RvciArIFwiIGlucHV0I3BhZ2VcIik7XG4gICAgICAgICAgICBpZiAocGFnZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuXG4gICAgICAgICAgICAvLyB0aGlzIGhhcHBlbnMgZm9yIHRoZSBhcnJvd3MsIHdoaWNoIGNhbiBiZSBhbiBpY29uIDxpPiBlbGVtZW50XG4gICAgICAgICAgICBpZiAoIXRhcmdldC5tYXRjaGVzKCdhJykpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgbGV0IHVybFBhcnRzID0gdGFyZ2V0LmhyZWYuc3BsaXQoJy8nKTtcbiAgICAgICAgICAgIGxldCBwYWdlTnVtYmVyID0gdXJsUGFydHNbdXJsUGFydHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAvLyBwYWdlIG51bWJlciB1c3VhbGx5IGlzIHRoZSBkZWZhdWx0IHZhbHVlIGFuZCBpcyB0aGVyZWZvciBtaXNzaW5nIGZyb20gdGhlIFVSTFxuICAgICAgICAgICAgaWYgKCEvXFxkLy50ZXN0KHBhZ2VOdW1iZXIpKSB7XG4gICAgICAgICAgICAgICAgcGFnZU51bWJlciA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYWdlci52YWx1ZSA9IHBhZ2VOdW1iZXI7XG4gICAgICAgICAgICBwYWdlci5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnY2hhbmdlJykpO1xuICAgICAgICAgICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ3BhZ2luYXRpb24tY2hhbmdlJykpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcblxuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBUcmlnZ2VycyBhbiBldmVudCwgdGhhdCBldmVyeW9uZSBjYW4gbGlzdGVuIGZvci5cbiAgICAgKi9cbiAgICB0cmlnZ2VyQ2hhbmdlKCkge1xuICAgICAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgndG9vbGJhci1jaGFuZ2UnKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgQ1NTIHNlbGVjdG9yIHRvIHRhcmdldCB0aGUgdG9vbGJhciBmb3JtLlxuICAgICAqIFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0U2VsZWN0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mb3JtU2VsZWN0b3I7XG4gICAgfVxuXG59XG4iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgdGhlIEtpbWFpIHRpbWUtdHJhY2tpbmcgYXBwLlxuICpcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cbiAqL1xuXG4vKiFcbiAqIFtLSU1BSV0gS2ltYWlVc2VyOiBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY3VycmVudCB1c2VyXG4gKi9cblxuaW1wb3J0IEtpbWFpUGx1Z2luIGZyb20gXCIuLi9LaW1haVBsdWdpblwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBLaW1haVVzZXIgZXh0ZW5kcyBLaW1haVBsdWdpbiB7XG5cbiAgICBnZXRJZCgpIHtcbiAgICAgICAgcmV0dXJuICd1c2VyJztcbiAgICB9XG5cbiAgICBpbml0KCkge1xuICAgICAgICB0aGlzLnVzZXIgPSB0aGlzLmdldENvbmZpZ3VyYXRpb25zKCkuZ2V0KCd1c2VyJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRVc2VySWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVzZXIuaWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXROYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51c2VyLm5hbWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNBZG1pbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXNlci5hZG1pbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1N1cGVyQWRtaW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVzZXIuc3VwZXJBZG1pbjtcbiAgICB9XG5cbn1cbiIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiB0aGUgS2ltYWkgdGltZS10cmFja2luZyBhcHAuXG4gKlxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxuICovXG5cbi8qIVxuICogW0tJTUFJXSBLaW1haUNvbG9yOiBoYW5kbGUgY29sb3JzXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgS2ltYWlDb2xvciB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaGV4Y29sb3JcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gICAgc3RhdGljIGNhbGN1bGF0ZUNvbnRyYXN0Q29sb3IoaGV4Y29sb3IpXG4gICAge1xuICAgICAgICBpZiAoaGV4Y29sb3Iuc2xpY2UoMCwgMSkgPT09ICcjJykge1xuICAgICAgICAgICAgaGV4Y29sb3IgPSBoZXhjb2xvci5zbGljZSgxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoZXhjb2xvci5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgIGhleGNvbG9yID0gaGV4Y29sb3Iuc3BsaXQoJycpLm1hcChmdW5jdGlvbiAoaGV4KSB7IHJldHVybiBoZXggKyBoZXg7IH0pLmpvaW4oJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgciA9IHBhcnNlSW50KGhleGNvbG9yLnN1YnN0cmluZygwLDIpLDE2KTtcbiAgICAgICAgY29uc3QgZyA9IHBhcnNlSW50KGhleGNvbG9yLnN1YnN0cmluZygyLDQpLDE2KTtcbiAgICAgICAgY29uc3QgYiA9IHBhcnNlSW50KGhleGNvbG9yLnN1YnN0cmluZyg0LDYpLDE2KTtcblxuICAgICAgICAvLyBodHRwczovL2dvbWFrZXRoaW5ncy5jb20vZHluYW1pY2FsbHktY2hhbmdpbmctdGhlLXRleHQtY29sb3ItYmFzZWQtb24tYmFja2dyb3VuZC1jb2xvci1jb250cmFzdC13aXRoLXZhbmlsbGEtanMvXG4gICAgICAgIGNvbnN0IHlpcSA9ICgociAqIDI5OSkgKyAoZyAqIDU4NykgKyAoYiAqIDExNCkpIC8gMTAwMDtcblxuICAgICAgICByZXR1cm4gKHlpcSA+PSAxMjgpID8gJyMwMDAwMDAnIDogJyNmZmZmZmYnO1xuICAgIH1cblxufVxuIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHRoZSBLaW1haSB0aW1lLXRyYWNraW5nIGFwcC5cbiAqXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXG4gKi9cblxuLyohXG4gKiBbS0lNQUldIEtpbWFpQ29udGV4dE1lbnU6IGhlbHAgdG8gY3JlYXRlLCBwb3NpdGlvbiBhbmQgZGlzcGxheSBjb250ZXh0IG1lbnVzXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgS2ltYWlDb250ZXh0TWVudSB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihpZClcbiAgICB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gICAgICovXG4gICAgZ2V0Q29udGV4dE1lbnVFbGVtZW50KClcbiAgICB7XG4gICAgICAgIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmlkKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgdGVtcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgdGVtcC5pZCA9IHRoaXMuaWQ7XG4gICAgICAgICAgICB0ZW1wLmNsYXNzTGlzdC5hZGQoJ2Ryb3Bkb3duLW1lbnUnLCAnZC1ub25lJyk7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRlbXApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuaWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0ganNvblxuICAgICAqL1xuICAgIGNyZWF0ZUZyb21BcGkoZXZlbnQsIGpzb24pXG4gICAge1xuICAgICAgICBsZXQgaHRtbCA9ICcnO1xuXG4gICAgICAgIGZvciAoY29uc3Qgb3B0aW9ucyBvZiBqc29uKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9uc1snZGl2aWRlciddID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgaHRtbCArPSAnPGRpdiBjbGFzcz1cImRyb3Bkb3duLWRpdmlkZXJcIj48L2Rpdj4nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob3B0aW9uc1sndXJsJ10gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBodG1sICs9ICc8YSBjbGFzcz1cImRyb3Bkb3duLWl0ZW0gJyArIChvcHRpb25zWydjbGFzcyddICE9PSBudWxsID8gb3B0aW9uc1snY2xhc3MnXSA6ICcnKSArICdcIiBocmVmPVwiJyArIG9wdGlvbnNbJ3VybCddICsgJ1wiJztcblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zWydhdHRyJ10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGF0dHJOYW1lIGluIG9wdGlvbnNbJ2F0dHInXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbCArPSAnICcgKyBhdHRyTmFtZSArICc9XCInICsgb3B0aW9uc1snYXR0ciddW2F0dHJOYW1lXS5yZXBsYWNlQWxsKCdcIicsICcmcXVvdDsnKSArICdcIic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaHRtbCArPSAnPicgKyBvcHRpb25zWyd0aXRsZSddICsgJzwvYT4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jcmVhdGVGcm9tQ2xpY2tFdmVudChldmVudCwgaHRtbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG4gICAgICovXG4gICAgY3JlYXRlRnJvbUNsaWNrRXZlbnQoZXZlbnQsIGh0bWwpXG4gICAge1xuICAgICAgICBjb25zdCBkcm9wZG93bkVsZW1lbnQgPSB0aGlzLmdldENvbnRleHRNZW51RWxlbWVudCgpO1xuXG4gICAgICAgIGRyb3Bkb3duRWxlbWVudC5zdHlsZS56SW5kZXggPSAnMTAyMSc7IC8vIHN0YXkgb24gdG9wIG9mIHN0aWNreSBlbGVtZW50cyAobGlrZSB0YWJsZSBoZWFkZXIpXG4gICAgICAgIGRyb3Bkb3duRWxlbWVudC5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgICBkcm9wZG93bkVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICAgICAgICBkcm9wZG93bkVsZW1lbnQuc3R5bGUudG9wID0gKGV2ZW50LmNsaWVudFkpICsgJ3B4JztcbiAgICAgICAgZHJvcGRvd25FbGVtZW50LnN0eWxlLmxlZnQgPSAoZXZlbnQuY2xpZW50WCkgKyAncHgnO1xuXG4gICAgICAgIGNvbnN0IGRyb3Bkb3duTGlzdGVuZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdkcm9wZG93bi10b2dnbGUnKSB8fCBldmVudC50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdkcm9wZG93bi1kaXZpZGVyJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkcm9wZG93bkVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnZC1ibG9jaycpO1xuICAgICAgICAgICAgaWYgKCFkcm9wZG93bkVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdkLW5vbmUnKSkge1xuICAgICAgICAgICAgICAgIGRyb3Bkb3duRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdkLW5vbmUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRyb3Bkb3duRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGRyb3Bkb3duTGlzdGVuZXIpO1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBkcm9wZG93bkxpc3RlbmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRyb3Bkb3duRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGRyb3Bkb3duTGlzdGVuZXIpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGRyb3Bkb3duTGlzdGVuZXIpO1xuXG4gICAgICAgIGRyb3Bkb3duRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdkLW5vbmUnKTtcbiAgICAgICAgaWYgKCFkcm9wZG93bkVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdkLWJsb2NrJykpIHtcbiAgICAgICAgICAgIGRyb3Bkb3duRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdkLWJsb2NrJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlRm9yRGF0YVRhYmxlKHNlbGVjdG9yKVxuICAgIHtcbiAgICAgICAgW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSkubWFwKChkYXRhVGFibGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFjdGlvbnMgPSBkYXRhVGFibGUucXVlcnlTZWxlY3RvcigndGQuYWN0aW9ucyBkaXYuZHJvcGRvd24tbWVudScpO1xuICAgICAgICAgICAgaWYgKGFjdGlvbnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhdGFUYWJsZS5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIChqc0V2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHRhcmdldCA9IGpzRXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgICAgIHdoaWxlICh0YXJnZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFnTmFtZSA9IHRhcmdldC50YWdOYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWdOYW1lID09PSAnVEgnIHx8IHRhZ05hbWUgPT09ICdUQUJMRScgfHwgdGFnTmFtZSA9PT0gJ0JPRFknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ1RSJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ID09PSBudWxsIHx8ICF0YXJnZXQubWF0Y2hlcygndGFibGUuZGF0YVRhYmxlIHRib2R5IHRyJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IGFjdGlvbnMgPSB0YXJnZXQucXVlcnlTZWxlY3RvcigndGQuYWN0aW9ucyBkaXYuZHJvcGRvd24tbWVudScpO1xuICAgICAgICAgICAgICAgIGlmIChhY3Rpb25zID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBqc0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZXh0TWVudSA9IG5ldyBLaW1haUNvbnRleHRNZW51KGRhdGFUYWJsZS5kYXRhc2V0Wydjb250ZXh0TWVudSddKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0TWVudS5jcmVhdGVGcm9tQ2xpY2tFdmVudChqc0V2ZW50LCBhY3Rpb25zLmlubmVySFRNTCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHRoZSBLaW1haSB0aW1lLXRyYWNraW5nIGFwcC5cbiAqXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXG4gKi9cblxuLyohXG4gKiBbS0lNQUldIEtpbWFpUGFnaW5hdGVkQm94V2lkZ2V0OiBoYW5kbGVzIGJveCB3aWRnZXRzIHRoYXQgaGF2ZSBhIHBhZ2luYXRpb25cbiAqL1xuXG5pbXBvcnQgS2ltYWlDb250ZXh0TWVudSBmcm9tIFwiLi9LaW1haUNvbnRleHRNZW51XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEtpbWFpUGFnaW5hdGVkQm94V2lkZ2V0IHtcblxuICAgIGNvbnN0cnVjdG9yKGJveElkKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSBib3hJZDtcbiAgICAgICAgY29uc3Qgd2lkZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0aGlzLnNlbGVjdG9yKTtcbiAgICAgICAgdGhpcy5ocmVmID0gd2lkZ2V0LmRhdGFzZXRbJ2hyZWYnXTtcblxuICAgICAgICBpZiAod2lkZ2V0LmRhdGFzZXRbJ3JlbG9hZCddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzID0gd2lkZ2V0LmRhdGFzZXRbJ3JlbG9hZCddLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICBjb25zdCByZWxvYWRQYWdlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCB1cmwgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRoaXMuc2VsZWN0b3IpLmRhdGFzZXRbJ3JlbG9hZEhyZWYnXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHVybCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5zZWxlY3RvcikuZGF0YXNldFsncmVsb2FkSHJlZiddO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHVybCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5zZWxlY3RvciArICcgdWwucGFnaW5hdGlvbiBsaS5hY3RpdmUgYScpLmhyZWY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubG9hZFBhZ2UodXJsKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgZXZlbnROYW1lIG9mIHRoaXMuZXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHJlbG9hZFBhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgbGV0IGxpbmsgPSBldmVudC50YXJnZXQ7XG4gICAgICAgICAgICAvLyBjb3VsZCBiZSBhbiBpY29uXG4gICAgICAgICAgICBpZiAoIWxpbmsubWF0Y2hlcyh0aGlzLnNlbGVjdG9yICsgJyBhLnBhZ2luYXRpb24tbGluaycpKSB7XG4gICAgICAgICAgICAgICAgbGluayA9IGxpbmsucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaW5rLm1hdGNoZXModGhpcy5zZWxlY3RvciArICcgYS5wYWdpbmF0aW9uLWxpbmsnKSkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkUGFnZShsaW5rLmhyZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgc3RhdGljIGNyZWF0ZShlbGVtZW50SWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBLaW1haVBhZ2luYXRlZEJveFdpZGdldChlbGVtZW50SWQpO1xuICAgIH1cbiAgICBcbiAgICBsb2FkUGFnZSh1cmwpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yO1xuXG4gICAgICAgIC8vIHRoaXMgZXZlbnQgd2lsbCByZW5kZXIgYSBzcGlubmluZyBsb2FkZXJcbiAgICAgICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2tpbWFpLnJlbG9hZENvbnRlbnQnLCB7ZGV0YWlsOiB0aGlzLnNlbGVjdG9yfSkpO1xuXG4gICAgICAgIC8vIGFuZCB0aGlzIGV2ZW50IHdpbGwgaGlkZSBpdCBhZnRlcndhcmRzXG4gICAgICAgIGNvbnN0IGhpZGVPdmVybGF5ID0gKCkgPT4ge1xuICAgICAgICAgICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2tpbWFpLnJlbG9hZGVkQ29udGVudCcpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdpbmRvdy5raW1haS5nZXRQbHVnaW4oJ2ZldGNoJykuZmV0Y2godXJsKVxuICAgICAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlLnRleHQoKS50aGVuKCh0ZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlbXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICAgICAgdGVtcC5pbm5lckhUTUwgPSB0ZXh0O1xuICAgICAgICAgICAgICAgICAgICAvLyBwcmV2aW91c2x5IHRoZSBwYXJ0cyAuY2FyZC1oZWFkZXIgLmNhcmQtYm9keSAuY2FyZC10aXRsZSAuY2FyZC1mb290ZXIgd2VyZSByZXBsYWNlZFxuICAgICAgICAgICAgICAgICAgICAvLyBidXQgdGhlIGxheW91dCBhbGxvd3MgZWcuIFwiLmxpc3QtZ3JvdXAgLmxpc3QtZ3JvdXAtZmx1c2hcIiBpbnN0ZWFkIG9mIC5jYXJkLWJvZHlcbiAgICAgICAgICAgICAgICAgICAgLy8gc28gd2UgZGlyZWN0bHkgcmVwbGFjZSB0aGUgZW50aXJlIEhUTUxcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIEhUTUwgbmVlZHMgdG8gYmUgcGFyc2VkIGZvciBzY3JpcHQgdGFncywgd2hpY2ggY2FuIGJlIGluY2x1ZGVkIChlLmcuIHBhZ2luYXRlZCBjaGFydCB3aWRnZXQpXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpLnJlcGxhY2VXaXRoKHRoaXMuX21ha2VTY3JpcHRFeGVjdXRhYmxlKHRlbXAuZmlyc3RFbGVtZW50Q2hpbGQpKTtcbiAgICAgICAgICAgICAgICAgICAgS2ltYWlDb250ZXh0TWVudS5jcmVhdGVGb3JEYXRhVGFibGUoc2VsZWN0b3IgKyAnIHRhYmxlLmRhdGFUYWJsZScpO1xuICAgICAgICAgICAgICAgICAgICBoaWRlT3ZlcmxheSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBub3QgeWV0IGEgcGx1Z2luLCBzbyB0aGUgYWxlcnQgaXMgbm90IGF2YWlsYWJsZSBoZXJlXG4gICAgICAgICAgICAgICAgd2luZG93LmtpbWFpLmdldFBsdWdpbignYWxlcnQnKS5lcnJvcignRmFpbGVkIGxvYWRpbmcgc2VsZWN0ZWQgcGFnZScpO1xuICAgICAgICAgICAgICAgIGhpZGVPdmVybGF5KCk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR8Q2hpbGROb2RlfSBub2RlXG4gICAgICogQHJldHVybnMge0VsZW1lbnR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVNjcmlwdEV4ZWN1dGFibGUobm9kZSkge1xuICAgICAgICBpZiAobm9kZS50YWdOYW1lICE9PSB1bmRlZmluZWQgJiYgbm9kZS50YWdOYW1lID09PSAnU0NSSVBUJykge1xuICAgICAgICAgICAgY29uc3Qgc2NyaXB0ICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICAgICAgc2NyaXB0LnRleHQgPSBub2RlLmlubmVySFRNTDtcbiAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoc2NyaXB0LCBub2RlICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIG5vZGUuY2hpbGROb2Rlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX21ha2VTY3JpcHRFeGVjdXRhYmxlKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbn1cbiIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiB0aGUgS2ltYWkgdGltZS10cmFja2luZyBhcHAuXG4gKlxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxuICovXG5cbi8qIVxuICogW0tJTUFJXSBLaW1haVJlbG9hZFBhZ2VXaWRnZXQ6IGEgc2ltcGxlIGhlbHBlciB0byByZWxvYWQgdGhlIHBhZ2Ugb24gZXZlbnRzXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgS2ltYWlSZWxvYWRQYWdlV2lkZ2V0IHtcblxuICAgIGNvbnN0cnVjdG9yKGV2ZW50cywgZnVsbFJlbG9hZCkge1xuICAgICAgICBjb25zdCByZWxvYWRQYWdlID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGZ1bGxSZWxvYWQpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9hZFBhZ2UoZG9jdW1lbnQubG9jYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAoY29uc3QgZXZlbnROYW1lIG9mIGV2ZW50cy5zcGxpdCgnICcpKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgcmVsb2FkUGFnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgc3RhdGljIGNyZWF0ZShldmVudHMsIGZ1bGxSZWxvYWQpIHtcbiAgICAgICAgaWYgKGZ1bGxSZWxvYWQgPT09IHVuZGVmaW5lZCB8fCBmdWxsUmVsb2FkID09PSBudWxsKSB7XG4gICAgICAgICAgICBmdWxsUmVsb2FkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBLaW1haVJlbG9hZFBhZ2VXaWRnZXQoZXZlbnRzLCBmdWxsUmVsb2FkKTtcbiAgICB9XG4gICAgXG4gICAgX3Nob3dPdmVybGF5KCkge1xuICAgICAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgna2ltYWkucmVsb2FkQ29udGVudCcsIHtkZXRhaWw6ICdkaXYucGFnZS13cmFwcGVyJ30pKTtcbiAgICB9XG5cbiAgICBfaGlkZU92ZXJsYXkoKSB7XG4gICAgICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdraW1haS5yZWxvYWRlZENvbnRlbnQnKSk7XG4gICAgfVxuXG4gICAgX2xvYWRQYWdlKHVybCkge1xuICAgICAgICB0aGlzLl9zaG93T3ZlcmxheSgpO1xuXG4gICAgICAgIHdpbmRvdy5raW1haS5nZXRQbHVnaW4oJ2ZldGNoJykuZmV0Y2godXJsKVxuICAgICAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlLnRleHQoKS50aGVuKCh0ZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlbXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICAgICAgdGVtcC5pbm5lckhUTUwgPSB0ZXh0O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdDb250ZW50ID0gdGVtcC5xdWVyeVNlbGVjdG9yKCdzZWN0aW9uLmNvbnRlbnQnKTtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc2VjdGlvbi5jb250ZW50JykucmVwbGFjZVdpdGgobmV3Q29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdraW1haS5yZWxvYWRQYWdlJykpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oaWRlT3ZlcmxheSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5faGlkZU92ZXJsYXkoKTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5sb2NhdGlvbiA9IHVybDtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxufVxuIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHRoZSBLaW1haSB0aW1lLXRyYWNraW5nIGFwcC5cbiAqXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXG4gKi9cblxuLyohXG4gKiBbS0lNQUldIEtpbWFpU3RvcmFnZTogc2ltcGxlIHdyYXBwZXIgdG8gaGFuZGxlIGxvY2FsU3RvcmFnZSBhY2Nlc3NcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBLaW1haVN0b3JhZ2Uge1xuXG4gICAgc3RhdGljIHNldChuYW1lLCB2YWx1ZXMpIHtcbiAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKG5hbWUsIEpTT04uc3RyaW5naWZ5KHZhbHVlcykpO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXQobmFtZSkge1xuICAgICAgICBsZXQgdmFsdWUgPSB3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0obmFtZSk7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgc3RhdGljIHJlbW92ZShuYW1lKSB7XG4gICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShuYW1lKTtcbiAgICB9XG5cbn1cbiIsIi8qIVxuICAqIEJvb3RzdHJhcCB2NS4zLjAtYWxwaGEzIChodHRwczovL2dldGJvb3RzdHJhcC5jb20vKVxuICAqIENvcHlyaWdodCAyMDExLTIwMjMgVGhlIEJvb3RzdHJhcCBBdXRob3JzIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvZ3JhcGhzL2NvbnRyaWJ1dG9ycylcbiAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAgKi9cbmltcG9ydCAqIGFzIFBvcHBlciBmcm9tICdAcG9wcGVyanMvY29yZSc7XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCBkb20vZGF0YS5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbi8qKlxuICogQ29uc3RhbnRzXG4gKi9cblxuY29uc3QgZWxlbWVudE1hcCA9IG5ldyBNYXAoKTtcbmNvbnN0IERhdGEgPSB7XG4gIHNldChlbGVtZW50LCBrZXksIGluc3RhbmNlKSB7XG4gICAgaWYgKCFlbGVtZW50TWFwLmhhcyhlbGVtZW50KSkge1xuICAgICAgZWxlbWVudE1hcC5zZXQoZWxlbWVudCwgbmV3IE1hcCgpKTtcbiAgICB9XG4gICAgY29uc3QgaW5zdGFuY2VNYXAgPSBlbGVtZW50TWFwLmdldChlbGVtZW50KTtcblxuICAgIC8vIG1ha2UgaXQgY2xlYXIgd2Ugb25seSB3YW50IG9uZSBpbnN0YW5jZSBwZXIgZWxlbWVudFxuICAgIC8vIGNhbiBiZSByZW1vdmVkIGxhdGVyIHdoZW4gbXVsdGlwbGUga2V5L2luc3RhbmNlcyBhcmUgZmluZSB0byBiZSB1c2VkXG4gICAgaWYgKCFpbnN0YW5jZU1hcC5oYXMoa2V5KSAmJiBpbnN0YW5jZU1hcC5zaXplICE9PSAwKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS5lcnJvcihgQm9vdHN0cmFwIGRvZXNuJ3QgYWxsb3cgbW9yZSB0aGFuIG9uZSBpbnN0YW5jZSBwZXIgZWxlbWVudC4gQm91bmQgaW5zdGFuY2U6ICR7QXJyYXkuZnJvbShpbnN0YW5jZU1hcC5rZXlzKCkpWzBdfS5gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW5zdGFuY2VNYXAuc2V0KGtleSwgaW5zdGFuY2UpO1xuICB9LFxuICBnZXQoZWxlbWVudCwga2V5KSB7XG4gICAgaWYgKGVsZW1lbnRNYXAuaGFzKGVsZW1lbnQpKSB7XG4gICAgICByZXR1cm4gZWxlbWVudE1hcC5nZXQoZWxlbWVudCkuZ2V0KGtleSkgfHwgbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG4gIHJlbW92ZShlbGVtZW50LCBrZXkpIHtcbiAgICBpZiAoIWVsZW1lbnRNYXAuaGFzKGVsZW1lbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGluc3RhbmNlTWFwID0gZWxlbWVudE1hcC5nZXQoZWxlbWVudCk7XG4gICAgaW5zdGFuY2VNYXAuZGVsZXRlKGtleSk7XG5cbiAgICAvLyBmcmVlIHVwIGVsZW1lbnQgcmVmZXJlbmNlcyBpZiB0aGVyZSBhcmUgbm8gaW5zdGFuY2VzIGxlZnQgZm9yIGFuIGVsZW1lbnRcbiAgICBpZiAoaW5zdGFuY2VNYXAuc2l6ZSA9PT0gMCkge1xuICAgICAgZWxlbWVudE1hcC5kZWxldGUoZWxlbWVudCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgdXRpbC9pbmRleC5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNvbnN0IE1BWF9VSUQgPSAxMDAwMDAwO1xuY29uc3QgTUlMTElTRUNPTkRTX01VTFRJUExJRVIgPSAxMDAwO1xuY29uc3QgVFJBTlNJVElPTl9FTkQgPSAndHJhbnNpdGlvbmVuZCc7XG5cbi8qKlxuICogUHJvcGVybHkgZXNjYXBlIElEcyBzZWxlY3RvcnMgdG8gaGFuZGxlIHdlaXJkIElEc1xuICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5jb25zdCBwYXJzZVNlbGVjdG9yID0gc2VsZWN0b3IgPT4ge1xuICBpZiAoc2VsZWN0b3IgJiYgd2luZG93LkNTUyAmJiB3aW5kb3cuQ1NTLmVzY2FwZSkge1xuICAgIC8vIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IgbmVlZHMgZXNjYXBpbmcgdG8gaGFuZGxlIElEcyAoaHRtbDUrKSBjb250YWluaW5nIGZvciBpbnN0YW5jZSAvXG4gICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5yZXBsYWNlKC8jKFteXFxzXCIjJ10rKS9nLCAobWF0Y2gsIGlkKSA9PiBgIyR7Q1NTLmVzY2FwZShpZCl9YCk7XG4gIH1cbiAgcmV0dXJuIHNlbGVjdG9yO1xufTtcblxuLy8gU2hvdXQtb3V0IEFuZ3VzIENyb2xsIChodHRwczovL2dvby5nbC9weHdRR3ApXG5jb25zdCB0b1R5cGUgPSBvYmplY3QgPT4ge1xuICBpZiAob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGAke29iamVjdH1gO1xuICB9XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KS5tYXRjaCgvXFxzKFthLXpdKykvaSlbMV0udG9Mb3dlckNhc2UoKTtcbn07XG5cbi8qKlxuICogUHVibGljIFV0aWwgQVBJXG4gKi9cblxuY29uc3QgZ2V0VUlEID0gcHJlZml4ID0+IHtcbiAgZG8ge1xuICAgIHByZWZpeCArPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBNQVhfVUlEKTtcbiAgfSB3aGlsZSAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocHJlZml4KSk7XG4gIHJldHVybiBwcmVmaXg7XG59O1xuY29uc3QgZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQgPSBlbGVtZW50ID0+IHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvLyBHZXQgdHJhbnNpdGlvbi1kdXJhdGlvbiBvZiB0aGUgZWxlbWVudFxuICBsZXQge1xuICAgIHRyYW5zaXRpb25EdXJhdGlvbixcbiAgICB0cmFuc2l0aW9uRGVsYXlcbiAgfSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICBjb25zdCBmbG9hdFRyYW5zaXRpb25EdXJhdGlvbiA9IE51bWJlci5wYXJzZUZsb2F0KHRyYW5zaXRpb25EdXJhdGlvbik7XG4gIGNvbnN0IGZsb2F0VHJhbnNpdGlvbkRlbGF5ID0gTnVtYmVyLnBhcnNlRmxvYXQodHJhbnNpdGlvbkRlbGF5KTtcblxuICAvLyBSZXR1cm4gMCBpZiBlbGVtZW50IG9yIHRyYW5zaXRpb24gZHVyYXRpb24gaXMgbm90IGZvdW5kXG4gIGlmICghZmxvYXRUcmFuc2l0aW9uRHVyYXRpb24gJiYgIWZsb2F0VHJhbnNpdGlvbkRlbGF5KSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvLyBJZiBtdWx0aXBsZSBkdXJhdGlvbnMgYXJlIGRlZmluZWQsIHRha2UgdGhlIGZpcnN0XG4gIHRyYW5zaXRpb25EdXJhdGlvbiA9IHRyYW5zaXRpb25EdXJhdGlvbi5zcGxpdCgnLCcpWzBdO1xuICB0cmFuc2l0aW9uRGVsYXkgPSB0cmFuc2l0aW9uRGVsYXkuc3BsaXQoJywnKVswXTtcbiAgcmV0dXJuIChOdW1iZXIucGFyc2VGbG9hdCh0cmFuc2l0aW9uRHVyYXRpb24pICsgTnVtYmVyLnBhcnNlRmxvYXQodHJhbnNpdGlvbkRlbGF5KSkgKiBNSUxMSVNFQ09ORFNfTVVMVElQTElFUjtcbn07XG5jb25zdCB0cmlnZ2VyVHJhbnNpdGlvbkVuZCA9IGVsZW1lbnQgPT4ge1xuICBlbGVtZW50LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFRSQU5TSVRJT05fRU5EKSk7XG59O1xuY29uc3QgaXNFbGVtZW50ID0gb2JqZWN0ID0+IHtcbiAgaWYgKCFvYmplY3QgfHwgdHlwZW9mIG9iamVjdCAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBvYmplY3QuanF1ZXJ5ICE9PSAndW5kZWZpbmVkJykge1xuICAgIG9iamVjdCA9IG9iamVjdFswXTtcbiAgfVxuICByZXR1cm4gdHlwZW9mIG9iamVjdC5ub2RlVHlwZSAhPT0gJ3VuZGVmaW5lZCc7XG59O1xuY29uc3QgZ2V0RWxlbWVudCA9IG9iamVjdCA9PiB7XG4gIC8vIGl0J3MgYSBqUXVlcnkgb2JqZWN0IG9yIGEgbm9kZSBlbGVtZW50XG4gIGlmIChpc0VsZW1lbnQob2JqZWN0KSkge1xuICAgIHJldHVybiBvYmplY3QuanF1ZXJ5ID8gb2JqZWN0WzBdIDogb2JqZWN0O1xuICB9XG4gIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnc3RyaW5nJyAmJiBvYmplY3QubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHBhcnNlU2VsZWN0b3Iob2JqZWN0KSk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuY29uc3QgaXNWaXNpYmxlID0gZWxlbWVudCA9PiB7XG4gIGlmICghaXNFbGVtZW50KGVsZW1lbnQpIHx8IGVsZW1lbnQuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgZWxlbWVudElzVmlzaWJsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZSgndmlzaWJpbGl0eScpID09PSAndmlzaWJsZSc7XG4gIC8vIEhhbmRsZSBgZGV0YWlsc2AgZWxlbWVudCBhcyBpdHMgY29udGVudCBtYXkgZmFsc2llIGFwcGVhciB2aXNpYmxlIHdoZW4gaXQgaXMgY2xvc2VkXG4gIGNvbnN0IGNsb3NlZERldGFpbHMgPSBlbGVtZW50LmNsb3Nlc3QoJ2RldGFpbHM6bm90KFtvcGVuXSknKTtcbiAgaWYgKCFjbG9zZWREZXRhaWxzKSB7XG4gICAgcmV0dXJuIGVsZW1lbnRJc1Zpc2libGU7XG4gIH1cbiAgaWYgKGNsb3NlZERldGFpbHMgIT09IGVsZW1lbnQpIHtcbiAgICBjb25zdCBzdW1tYXJ5ID0gZWxlbWVudC5jbG9zZXN0KCdzdW1tYXJ5Jyk7XG4gICAgaWYgKHN1bW1hcnkgJiYgc3VtbWFyeS5wYXJlbnROb2RlICE9PSBjbG9zZWREZXRhaWxzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChzdW1tYXJ5ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBlbGVtZW50SXNWaXNpYmxlO1xufTtcbmNvbnN0IGlzRGlzYWJsZWQgPSBlbGVtZW50ID0+IHtcbiAgaWYgKCFlbGVtZW50IHx8IGVsZW1lbnQubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdkaXNhYmxlZCcpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHR5cGVvZiBlbGVtZW50LmRpc2FibGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBlbGVtZW50LmRpc2FibGVkO1xuICB9XG4gIHJldHVybiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSAmJiBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGlzYWJsZWQnKSAhPT0gJ2ZhbHNlJztcbn07XG5jb25zdCBmaW5kU2hhZG93Um9vdCA9IGVsZW1lbnQgPT4ge1xuICBpZiAoIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hdHRhY2hTaGFkb3cpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIENhbiBmaW5kIHRoZSBzaGFkb3cgcm9vdCBvdGhlcndpc2UgaXQnbGwgcmV0dXJuIHRoZSBkb2N1bWVudFxuICBpZiAodHlwZW9mIGVsZW1lbnQuZ2V0Um9vdE5vZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zdCByb290ID0gZWxlbWVudC5nZXRSb290Tm9kZSgpO1xuICAgIHJldHVybiByb290IGluc3RhbmNlb2YgU2hhZG93Um9vdCA/IHJvb3QgOiBudWxsO1xuICB9XG4gIGlmIChlbGVtZW50IGluc3RhbmNlb2YgU2hhZG93Um9vdCkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgLy8gd2hlbiB3ZSBkb24ndCBmaW5kIGEgc2hhZG93IHJvb3RcbiAgaWYgKCFlbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gZmluZFNoYWRvd1Jvb3QoZWxlbWVudC5wYXJlbnROb2RlKTtcbn07XG5jb25zdCBub29wID0gKCkgPT4ge307XG5cbi8qKlxuICogVHJpY2sgdG8gcmVzdGFydCBhbiBlbGVtZW50J3MgYW5pbWF0aW9uXG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybiB2b2lkXG4gKlxuICogQHNlZSBodHRwczovL3d3dy5jaGFyaXN0aGVvLmlvL2Jsb2cvMjAyMS8wMi9yZXN0YXJ0LWEtY3NzLWFuaW1hdGlvbi13aXRoLWphdmFzY3JpcHQvI3Jlc3RhcnRpbmctYS1jc3MtYW5pbWF0aW9uXG4gKi9cbmNvbnN0IHJlZmxvdyA9IGVsZW1lbnQgPT4ge1xuICBlbGVtZW50Lm9mZnNldEhlaWdodDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcbn07XG5cbmNvbnN0IGdldGpRdWVyeSA9ICgpID0+IHtcbiAgaWYgKHdpbmRvdy5qUXVlcnkgJiYgIWRvY3VtZW50LmJvZHkuaGFzQXR0cmlidXRlKCdkYXRhLWJzLW5vLWpxdWVyeScpKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5qUXVlcnk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuY29uc3QgRE9NQ29udGVudExvYWRlZENhbGxiYWNrcyA9IFtdO1xuY29uc3Qgb25ET01Db250ZW50TG9hZGVkID0gY2FsbGJhY2sgPT4ge1xuICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2xvYWRpbmcnKSB7XG4gICAgLy8gYWRkIGxpc3RlbmVyIG9uIHRoZSBmaXJzdCBjYWxsIHdoZW4gdGhlIGRvY3VtZW50IGlzIGluIGxvYWRpbmcgc3RhdGVcbiAgICBpZiAoIURPTUNvbnRlbnRMb2FkZWRDYWxsYmFja3MubGVuZ3RoKSB7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIERPTUNvbnRlbnRMb2FkZWRDYWxsYmFja3MpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgRE9NQ29udGVudExvYWRlZENhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgfSBlbHNlIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG59O1xuY29uc3QgaXNSVEwgPSAoKSA9PiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZGlyID09PSAncnRsJztcbmNvbnN0IGRlZmluZUpRdWVyeVBsdWdpbiA9IHBsdWdpbiA9PiB7XG4gIG9uRE9NQ29udGVudExvYWRlZCgoKSA9PiB7XG4gICAgY29uc3QgJCA9IGdldGpRdWVyeSgpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICgkKSB7XG4gICAgICBjb25zdCBuYW1lID0gcGx1Z2luLk5BTUU7XG4gICAgICBjb25zdCBKUVVFUllfTk9fQ09ORkxJQ1QgPSAkLmZuW25hbWVdO1xuICAgICAgJC5mbltuYW1lXSA9IHBsdWdpbi5qUXVlcnlJbnRlcmZhY2U7XG4gICAgICAkLmZuW25hbWVdLkNvbnN0cnVjdG9yID0gcGx1Z2luO1xuICAgICAgJC5mbltuYW1lXS5ub0NvbmZsaWN0ID0gKCkgPT4ge1xuICAgICAgICAkLmZuW25hbWVdID0gSlFVRVJZX05PX0NPTkZMSUNUO1xuICAgICAgICByZXR1cm4gcGx1Z2luLmpRdWVyeUludGVyZmFjZTtcbiAgICAgIH07XG4gICAgfVxuICB9KTtcbn07XG5jb25zdCBleGVjdXRlID0gKHBvc3NpYmxlQ2FsbGJhY2ssIGFyZ3MgPSBbXSwgZGVmYXVsdFZhbHVlID0gcG9zc2libGVDYWxsYmFjaykgPT4ge1xuICByZXR1cm4gdHlwZW9mIHBvc3NpYmxlQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicgPyBwb3NzaWJsZUNhbGxiYWNrKC4uLmFyZ3MpIDogZGVmYXVsdFZhbHVlO1xufTtcbmNvbnN0IGV4ZWN1dGVBZnRlclRyYW5zaXRpb24gPSAoY2FsbGJhY2ssIHRyYW5zaXRpb25FbGVtZW50LCB3YWl0Rm9yVHJhbnNpdGlvbiA9IHRydWUpID0+IHtcbiAgaWYgKCF3YWl0Rm9yVHJhbnNpdGlvbikge1xuICAgIGV4ZWN1dGUoY2FsbGJhY2spO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBkdXJhdGlvblBhZGRpbmcgPSA1O1xuICBjb25zdCBlbXVsYXRlZER1cmF0aW9uID0gZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQodHJhbnNpdGlvbkVsZW1lbnQpICsgZHVyYXRpb25QYWRkaW5nO1xuICBsZXQgY2FsbGVkID0gZmFsc2U7XG4gIGNvbnN0IGhhbmRsZXIgPSAoe1xuICAgIHRhcmdldFxuICB9KSA9PiB7XG4gICAgaWYgKHRhcmdldCAhPT0gdHJhbnNpdGlvbkVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICB0cmFuc2l0aW9uRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFRSQU5TSVRJT05fRU5ELCBoYW5kbGVyKTtcbiAgICBleGVjdXRlKGNhbGxiYWNrKTtcbiAgfTtcbiAgdHJhbnNpdGlvbkVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihUUkFOU0lUSU9OX0VORCwgaGFuZGxlcik7XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICB0cmlnZ2VyVHJhbnNpdGlvbkVuZCh0cmFuc2l0aW9uRWxlbWVudCk7XG4gICAgfVxuICB9LCBlbXVsYXRlZER1cmF0aW9uKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBwcmV2aW91cy9uZXh0IGVsZW1lbnQgb2YgYSBsaXN0LlxuICpcbiAqIEBwYXJhbSB7YXJyYXl9IGxpc3QgICAgVGhlIGxpc3Qgb2YgZWxlbWVudHNcbiAqIEBwYXJhbSBhY3RpdmVFbGVtZW50ICAgVGhlIGFjdGl2ZSBlbGVtZW50XG4gKiBAcGFyYW0gc2hvdWxkR2V0TmV4dCAgIENob29zZSB0byBnZXQgbmV4dCBvciBwcmV2aW91cyBlbGVtZW50XG4gKiBAcGFyYW0gaXNDeWNsZUFsbG93ZWRcbiAqIEByZXR1cm4ge0VsZW1lbnR8ZWxlbX0gVGhlIHByb3BlciBlbGVtZW50XG4gKi9cbmNvbnN0IGdldE5leHRBY3RpdmVFbGVtZW50ID0gKGxpc3QsIGFjdGl2ZUVsZW1lbnQsIHNob3VsZEdldE5leHQsIGlzQ3ljbGVBbGxvd2VkKSA9PiB7XG4gIGNvbnN0IGxpc3RMZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgbGV0IGluZGV4ID0gbGlzdC5pbmRleE9mKGFjdGl2ZUVsZW1lbnQpO1xuXG4gIC8vIGlmIHRoZSBlbGVtZW50IGRvZXMgbm90IGV4aXN0IGluIHRoZSBsaXN0IHJldHVybiBhbiBlbGVtZW50XG4gIC8vIGRlcGVuZGluZyBvbiB0aGUgZGlyZWN0aW9uIGFuZCBpZiBjeWNsZSBpcyBhbGxvd2VkXG4gIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICByZXR1cm4gIXNob3VsZEdldE5leHQgJiYgaXNDeWNsZUFsbG93ZWQgPyBsaXN0W2xpc3RMZW5ndGggLSAxXSA6IGxpc3RbMF07XG4gIH1cbiAgaW5kZXggKz0gc2hvdWxkR2V0TmV4dCA/IDEgOiAtMTtcbiAgaWYgKGlzQ3ljbGVBbGxvd2VkKSB7XG4gICAgaW5kZXggPSAoaW5kZXggKyBsaXN0TGVuZ3RoKSAlIGxpc3RMZW5ndGg7XG4gIH1cbiAgcmV0dXJuIGxpc3RbTWF0aC5tYXgoMCwgTWF0aC5taW4oaW5kZXgsIGxpc3RMZW5ndGggLSAxKSldO1xufTtcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwIGRvbS9ldmVudC1oYW5kbGVyLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuLyoqXG4gKiBDb25zdGFudHNcbiAqL1xuXG5jb25zdCBuYW1lc3BhY2VSZWdleCA9IC9bXi5dKig/PVxcLi4qKVxcLnwuKi87XG5jb25zdCBzdHJpcE5hbWVSZWdleCA9IC9cXC4uKi87XG5jb25zdCBzdHJpcFVpZFJlZ2V4ID0gLzo6XFxkKyQvO1xuY29uc3QgZXZlbnRSZWdpc3RyeSA9IHt9OyAvLyBFdmVudHMgc3RvcmFnZVxubGV0IHVpZEV2ZW50ID0gMTtcbmNvbnN0IGN1c3RvbUV2ZW50cyA9IHtcbiAgbW91c2VlbnRlcjogJ21vdXNlb3ZlcicsXG4gIG1vdXNlbGVhdmU6ICdtb3VzZW91dCdcbn07XG5jb25zdCBuYXRpdmVFdmVudHMgPSBuZXcgU2V0KFsnY2xpY2snLCAnZGJsY2xpY2snLCAnbW91c2V1cCcsICdtb3VzZWRvd24nLCAnY29udGV4dG1lbnUnLCAnbW91c2V3aGVlbCcsICdET01Nb3VzZVNjcm9sbCcsICdtb3VzZW92ZXInLCAnbW91c2VvdXQnLCAnbW91c2Vtb3ZlJywgJ3NlbGVjdHN0YXJ0JywgJ3NlbGVjdGVuZCcsICdrZXlkb3duJywgJ2tleXByZXNzJywgJ2tleXVwJywgJ29yaWVudGF0aW9uY2hhbmdlJywgJ3RvdWNoc3RhcnQnLCAndG91Y2htb3ZlJywgJ3RvdWNoZW5kJywgJ3RvdWNoY2FuY2VsJywgJ3BvaW50ZXJkb3duJywgJ3BvaW50ZXJtb3ZlJywgJ3BvaW50ZXJ1cCcsICdwb2ludGVybGVhdmUnLCAncG9pbnRlcmNhbmNlbCcsICdnZXN0dXJlc3RhcnQnLCAnZ2VzdHVyZWNoYW5nZScsICdnZXN0dXJlZW5kJywgJ2ZvY3VzJywgJ2JsdXInLCAnY2hhbmdlJywgJ3Jlc2V0JywgJ3NlbGVjdCcsICdzdWJtaXQnLCAnZm9jdXNpbicsICdmb2N1c291dCcsICdsb2FkJywgJ3VubG9hZCcsICdiZWZvcmV1bmxvYWQnLCAncmVzaXplJywgJ21vdmUnLCAnRE9NQ29udGVudExvYWRlZCcsICdyZWFkeXN0YXRlY2hhbmdlJywgJ2Vycm9yJywgJ2Fib3J0JywgJ3Njcm9sbCddKTtcblxuLyoqXG4gKiBQcml2YXRlIG1ldGhvZHNcbiAqL1xuXG5mdW5jdGlvbiBtYWtlRXZlbnRVaWQoZWxlbWVudCwgdWlkKSB7XG4gIHJldHVybiB1aWQgJiYgYCR7dWlkfTo6JHt1aWRFdmVudCsrfWAgfHwgZWxlbWVudC51aWRFdmVudCB8fCB1aWRFdmVudCsrO1xufVxuZnVuY3Rpb24gZ2V0RWxlbWVudEV2ZW50cyhlbGVtZW50KSB7XG4gIGNvbnN0IHVpZCA9IG1ha2VFdmVudFVpZChlbGVtZW50KTtcbiAgZWxlbWVudC51aWRFdmVudCA9IHVpZDtcbiAgZXZlbnRSZWdpc3RyeVt1aWRdID0gZXZlbnRSZWdpc3RyeVt1aWRdIHx8IHt9O1xuICByZXR1cm4gZXZlbnRSZWdpc3RyeVt1aWRdO1xufVxuZnVuY3Rpb24gYm9vdHN0cmFwSGFuZGxlcihlbGVtZW50LCBmbikge1xuICByZXR1cm4gZnVuY3Rpb24gaGFuZGxlcihldmVudCkge1xuICAgIGh5ZHJhdGVPYmooZXZlbnQsIHtcbiAgICAgIGRlbGVnYXRlVGFyZ2V0OiBlbGVtZW50XG4gICAgfSk7XG4gICAgaWYgKGhhbmRsZXIub25lT2ZmKSB7XG4gICAgICBFdmVudEhhbmRsZXIub2ZmKGVsZW1lbnQsIGV2ZW50LnR5cGUsIGZuKTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KGVsZW1lbnQsIFtldmVudF0pO1xuICB9O1xufVxuZnVuY3Rpb24gYm9vdHN0cmFwRGVsZWdhdGlvbkhhbmRsZXIoZWxlbWVudCwgc2VsZWN0b3IsIGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiBoYW5kbGVyKGV2ZW50KSB7XG4gICAgY29uc3QgZG9tRWxlbWVudHMgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgIGZvciAobGV0IHtcbiAgICAgIHRhcmdldFxuICAgIH0gPSBldmVudDsgdGFyZ2V0ICYmIHRhcmdldCAhPT0gdGhpczsgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGUpIHtcbiAgICAgIGZvciAoY29uc3QgZG9tRWxlbWVudCBvZiBkb21FbGVtZW50cykge1xuICAgICAgICBpZiAoZG9tRWxlbWVudCAhPT0gdGFyZ2V0KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaHlkcmF0ZU9iaihldmVudCwge1xuICAgICAgICAgIGRlbGVnYXRlVGFyZ2V0OiB0YXJnZXRcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChoYW5kbGVyLm9uZU9mZikge1xuICAgICAgICAgIEV2ZW50SGFuZGxlci5vZmYoZWxlbWVudCwgZXZlbnQudHlwZSwgc2VsZWN0b3IsIGZuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGFyZ2V0LCBbZXZlbnRdKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBmaW5kSGFuZGxlcihldmVudHMsIGNhbGxhYmxlLCBkZWxlZ2F0aW9uU2VsZWN0b3IgPSBudWxsKSB7XG4gIHJldHVybiBPYmplY3QudmFsdWVzKGV2ZW50cykuZmluZChldmVudCA9PiBldmVudC5jYWxsYWJsZSA9PT0gY2FsbGFibGUgJiYgZXZlbnQuZGVsZWdhdGlvblNlbGVjdG9yID09PSBkZWxlZ2F0aW9uU2VsZWN0b3IpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUGFyYW1ldGVycyhvcmlnaW5hbFR5cGVFdmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZ1bmN0aW9uKSB7XG4gIGNvbnN0IGlzRGVsZWdhdGVkID0gdHlwZW9mIGhhbmRsZXIgPT09ICdzdHJpbmcnO1xuICAvLyBUT0RPOiB0b29sdGlwIHBhc3NlcyBgZmFsc2VgIGluc3RlYWQgb2Ygc2VsZWN0b3IsIHNvIHdlIG5lZWQgdG8gY2hlY2tcbiAgY29uc3QgY2FsbGFibGUgPSBpc0RlbGVnYXRlZCA/IGRlbGVnYXRpb25GdW5jdGlvbiA6IGhhbmRsZXIgfHwgZGVsZWdhdGlvbkZ1bmN0aW9uO1xuICBsZXQgdHlwZUV2ZW50ID0gZ2V0VHlwZUV2ZW50KG9yaWdpbmFsVHlwZUV2ZW50KTtcbiAgaWYgKCFuYXRpdmVFdmVudHMuaGFzKHR5cGVFdmVudCkpIHtcbiAgICB0eXBlRXZlbnQgPSBvcmlnaW5hbFR5cGVFdmVudDtcbiAgfVxuICByZXR1cm4gW2lzRGVsZWdhdGVkLCBjYWxsYWJsZSwgdHlwZUV2ZW50XTtcbn1cbmZ1bmN0aW9uIGFkZEhhbmRsZXIoZWxlbWVudCwgb3JpZ2luYWxUeXBlRXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25GdW5jdGlvbiwgb25lT2ZmKSB7XG4gIGlmICh0eXBlb2Ygb3JpZ2luYWxUeXBlRXZlbnQgIT09ICdzdHJpbmcnIHx8ICFlbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBbaXNEZWxlZ2F0ZWQsIGNhbGxhYmxlLCB0eXBlRXZlbnRdID0gbm9ybWFsaXplUGFyYW1ldGVycyhvcmlnaW5hbFR5cGVFdmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZ1bmN0aW9uKTtcblxuICAvLyBpbiBjYXNlIG9mIG1vdXNlZW50ZXIgb3IgbW91c2VsZWF2ZSB3cmFwIHRoZSBoYW5kbGVyIHdpdGhpbiBhIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGZvciBpdHMgRE9NIHBvc2l0aW9uXG4gIC8vIHRoaXMgcHJldmVudHMgdGhlIGhhbmRsZXIgZnJvbSBiZWluZyBkaXNwYXRjaGVkIHRoZSBzYW1lIHdheSBhcyBtb3VzZW92ZXIgb3IgbW91c2VvdXQgZG9lc1xuICBpZiAob3JpZ2luYWxUeXBlRXZlbnQgaW4gY3VzdG9tRXZlbnRzKSB7XG4gICAgY29uc3Qgd3JhcEZ1bmN0aW9uID0gZm4gPT4ge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoIWV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgZXZlbnQucmVsYXRlZFRhcmdldCAhPT0gZXZlbnQuZGVsZWdhdGVUYXJnZXQgJiYgIWV2ZW50LmRlbGVnYXRlVGFyZ2V0LmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQpKSB7XG4gICAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gICAgY2FsbGFibGUgPSB3cmFwRnVuY3Rpb24oY2FsbGFibGUpO1xuICB9XG4gIGNvbnN0IGV2ZW50cyA9IGdldEVsZW1lbnRFdmVudHMoZWxlbWVudCk7XG4gIGNvbnN0IGhhbmRsZXJzID0gZXZlbnRzW3R5cGVFdmVudF0gfHwgKGV2ZW50c1t0eXBlRXZlbnRdID0ge30pO1xuICBjb25zdCBwcmV2aW91c0Z1bmN0aW9uID0gZmluZEhhbmRsZXIoaGFuZGxlcnMsIGNhbGxhYmxlLCBpc0RlbGVnYXRlZCA/IGhhbmRsZXIgOiBudWxsKTtcbiAgaWYgKHByZXZpb3VzRnVuY3Rpb24pIHtcbiAgICBwcmV2aW91c0Z1bmN0aW9uLm9uZU9mZiA9IHByZXZpb3VzRnVuY3Rpb24ub25lT2ZmICYmIG9uZU9mZjtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdWlkID0gbWFrZUV2ZW50VWlkKGNhbGxhYmxlLCBvcmlnaW5hbFR5cGVFdmVudC5yZXBsYWNlKG5hbWVzcGFjZVJlZ2V4LCAnJykpO1xuICBjb25zdCBmbiA9IGlzRGVsZWdhdGVkID8gYm9vdHN0cmFwRGVsZWdhdGlvbkhhbmRsZXIoZWxlbWVudCwgaGFuZGxlciwgY2FsbGFibGUpIDogYm9vdHN0cmFwSGFuZGxlcihlbGVtZW50LCBjYWxsYWJsZSk7XG4gIGZuLmRlbGVnYXRpb25TZWxlY3RvciA9IGlzRGVsZWdhdGVkID8gaGFuZGxlciA6IG51bGw7XG4gIGZuLmNhbGxhYmxlID0gY2FsbGFibGU7XG4gIGZuLm9uZU9mZiA9IG9uZU9mZjtcbiAgZm4udWlkRXZlbnQgPSB1aWQ7XG4gIGhhbmRsZXJzW3VpZF0gPSBmbjtcbiAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGVFdmVudCwgZm4sIGlzRGVsZWdhdGVkKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUhhbmRsZXIoZWxlbWVudCwgZXZlbnRzLCB0eXBlRXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25TZWxlY3Rvcikge1xuICBjb25zdCBmbiA9IGZpbmRIYW5kbGVyKGV2ZW50c1t0eXBlRXZlbnRdLCBoYW5kbGVyLCBkZWxlZ2F0aW9uU2VsZWN0b3IpO1xuICBpZiAoIWZuKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlRXZlbnQsIGZuLCBCb29sZWFuKGRlbGVnYXRpb25TZWxlY3RvcikpO1xuICBkZWxldGUgZXZlbnRzW3R5cGVFdmVudF1bZm4udWlkRXZlbnRdO1xufVxuZnVuY3Rpb24gcmVtb3ZlTmFtZXNwYWNlZEhhbmRsZXJzKGVsZW1lbnQsIGV2ZW50cywgdHlwZUV2ZW50LCBuYW1lc3BhY2UpIHtcbiAgY29uc3Qgc3RvcmVFbGVtZW50RXZlbnQgPSBldmVudHNbdHlwZUV2ZW50XSB8fCB7fTtcbiAgZm9yIChjb25zdCBbaGFuZGxlcktleSwgZXZlbnRdIG9mIE9iamVjdC5lbnRyaWVzKHN0b3JlRWxlbWVudEV2ZW50KSkge1xuICAgIGlmIChoYW5kbGVyS2V5LmluY2x1ZGVzKG5hbWVzcGFjZSkpIHtcbiAgICAgIHJlbW92ZUhhbmRsZXIoZWxlbWVudCwgZXZlbnRzLCB0eXBlRXZlbnQsIGV2ZW50LmNhbGxhYmxlLCBldmVudC5kZWxlZ2F0aW9uU2VsZWN0b3IpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0VHlwZUV2ZW50KGV2ZW50KSB7XG4gIC8vIGFsbG93IHRvIGdldCB0aGUgbmF0aXZlIGV2ZW50cyBmcm9tIG5hbWVzcGFjZWQgZXZlbnRzICgnY2xpY2suYnMuYnV0dG9uJyAtLT4gJ2NsaWNrJylcbiAgZXZlbnQgPSBldmVudC5yZXBsYWNlKHN0cmlwTmFtZVJlZ2V4LCAnJyk7XG4gIHJldHVybiBjdXN0b21FdmVudHNbZXZlbnRdIHx8IGV2ZW50O1xufVxuY29uc3QgRXZlbnRIYW5kbGVyID0ge1xuICBvbihlbGVtZW50LCBldmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZ1bmN0aW9uKSB7XG4gICAgYWRkSGFuZGxlcihlbGVtZW50LCBldmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZ1bmN0aW9uLCBmYWxzZSk7XG4gIH0sXG4gIG9uZShlbGVtZW50LCBldmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZ1bmN0aW9uKSB7XG4gICAgYWRkSGFuZGxlcihlbGVtZW50LCBldmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZ1bmN0aW9uLCB0cnVlKTtcbiAgfSxcbiAgb2ZmKGVsZW1lbnQsIG9yaWdpbmFsVHlwZUV2ZW50LCBoYW5kbGVyLCBkZWxlZ2F0aW9uRnVuY3Rpb24pIHtcbiAgICBpZiAodHlwZW9mIG9yaWdpbmFsVHlwZUV2ZW50ICE9PSAnc3RyaW5nJyB8fCAhZWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBbaXNEZWxlZ2F0ZWQsIGNhbGxhYmxlLCB0eXBlRXZlbnRdID0gbm9ybWFsaXplUGFyYW1ldGVycyhvcmlnaW5hbFR5cGVFdmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZ1bmN0aW9uKTtcbiAgICBjb25zdCBpbk5hbWVzcGFjZSA9IHR5cGVFdmVudCAhPT0gb3JpZ2luYWxUeXBlRXZlbnQ7XG4gICAgY29uc3QgZXZlbnRzID0gZ2V0RWxlbWVudEV2ZW50cyhlbGVtZW50KTtcbiAgICBjb25zdCBzdG9yZUVsZW1lbnRFdmVudCA9IGV2ZW50c1t0eXBlRXZlbnRdIHx8IHt9O1xuICAgIGNvbnN0IGlzTmFtZXNwYWNlID0gb3JpZ2luYWxUeXBlRXZlbnQuc3RhcnRzV2l0aCgnLicpO1xuICAgIGlmICh0eXBlb2YgY2FsbGFibGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBTaW1wbGVzdCBjYXNlOiBoYW5kbGVyIGlzIHBhc3NlZCwgcmVtb3ZlIHRoYXQgbGlzdGVuZXIgT05MWS5cbiAgICAgIGlmICghT2JqZWN0LmtleXMoc3RvcmVFbGVtZW50RXZlbnQpLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZW1vdmVIYW5kbGVyKGVsZW1lbnQsIGV2ZW50cywgdHlwZUV2ZW50LCBjYWxsYWJsZSwgaXNEZWxlZ2F0ZWQgPyBoYW5kbGVyIDogbnVsbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc05hbWVzcGFjZSkge1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50RXZlbnQgb2YgT2JqZWN0LmtleXMoZXZlbnRzKSkge1xuICAgICAgICByZW1vdmVOYW1lc3BhY2VkSGFuZGxlcnMoZWxlbWVudCwgZXZlbnRzLCBlbGVtZW50RXZlbnQsIG9yaWdpbmFsVHlwZUV2ZW50LnNsaWNlKDEpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBba2V5SGFuZGxlcnMsIGV2ZW50XSBvZiBPYmplY3QuZW50cmllcyhzdG9yZUVsZW1lbnRFdmVudCkpIHtcbiAgICAgIGNvbnN0IGhhbmRsZXJLZXkgPSBrZXlIYW5kbGVycy5yZXBsYWNlKHN0cmlwVWlkUmVnZXgsICcnKTtcbiAgICAgIGlmICghaW5OYW1lc3BhY2UgfHwgb3JpZ2luYWxUeXBlRXZlbnQuaW5jbHVkZXMoaGFuZGxlcktleSkpIHtcbiAgICAgICAgcmVtb3ZlSGFuZGxlcihlbGVtZW50LCBldmVudHMsIHR5cGVFdmVudCwgZXZlbnQuY2FsbGFibGUsIGV2ZW50LmRlbGVnYXRpb25TZWxlY3Rvcik7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICB0cmlnZ2VyKGVsZW1lbnQsIGV2ZW50LCBhcmdzKSB7XG4gICAgaWYgKHR5cGVvZiBldmVudCAhPT0gJ3N0cmluZycgfHwgIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCAkID0gZ2V0alF1ZXJ5KCk7XG4gICAgY29uc3QgdHlwZUV2ZW50ID0gZ2V0VHlwZUV2ZW50KGV2ZW50KTtcbiAgICBjb25zdCBpbk5hbWVzcGFjZSA9IGV2ZW50ICE9PSB0eXBlRXZlbnQ7XG4gICAgbGV0IGpRdWVyeUV2ZW50ID0gbnVsbDtcbiAgICBsZXQgYnViYmxlcyA9IHRydWU7XG4gICAgbGV0IG5hdGl2ZURpc3BhdGNoID0gdHJ1ZTtcbiAgICBsZXQgZGVmYXVsdFByZXZlbnRlZCA9IGZhbHNlO1xuICAgIGlmIChpbk5hbWVzcGFjZSAmJiAkKSB7XG4gICAgICBqUXVlcnlFdmVudCA9ICQuRXZlbnQoZXZlbnQsIGFyZ3MpO1xuICAgICAgJChlbGVtZW50KS50cmlnZ2VyKGpRdWVyeUV2ZW50KTtcbiAgICAgIGJ1YmJsZXMgPSAhalF1ZXJ5RXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKTtcbiAgICAgIG5hdGl2ZURpc3BhdGNoID0gIWpRdWVyeUV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCk7XG4gICAgICBkZWZhdWx0UHJldmVudGVkID0galF1ZXJ5RXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCk7XG4gICAgfVxuICAgIGNvbnN0IGV2dCA9IGh5ZHJhdGVPYmoobmV3IEV2ZW50KGV2ZW50LCB7XG4gICAgICBidWJibGVzLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgIH0pLCBhcmdzKTtcbiAgICBpZiAoZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIGlmIChuYXRpdmVEaXNwYXRjaCkge1xuICAgICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gICAgfVxuICAgIGlmIChldnQuZGVmYXVsdFByZXZlbnRlZCAmJiBqUXVlcnlFdmVudCkge1xuICAgICAgalF1ZXJ5RXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGV2dDtcbiAgfVxufTtcbmZ1bmN0aW9uIGh5ZHJhdGVPYmoob2JqLCBtZXRhID0ge30pIHtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMobWV0YSkpIHtcbiAgICB0cnkge1xuICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9IGNhdGNoIChfdW51c2VkKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwIGRvbS9tYW5pcHVsYXRvci5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZURhdGEodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSAndHJ1ZScpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT09ICdmYWxzZScpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHZhbHVlID09PSBOdW1iZXIodmFsdWUpLnRvU3RyaW5nKCkpIHtcbiAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcbiAgfVxuICBpZiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSAnbnVsbCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xuICB9IGNhdGNoIChfdW51c2VkKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5mdW5jdGlvbiBub3JtYWxpemVEYXRhS2V5KGtleSkge1xuICByZXR1cm4ga2V5LnJlcGxhY2UoL1tBLVpdL2csIGNociA9PiBgLSR7Y2hyLnRvTG93ZXJDYXNlKCl9YCk7XG59XG5jb25zdCBNYW5pcHVsYXRvciA9IHtcbiAgc2V0RGF0YUF0dHJpYnV0ZShlbGVtZW50LCBrZXksIHZhbHVlKSB7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoYGRhdGEtYnMtJHtub3JtYWxpemVEYXRhS2V5KGtleSl9YCwgdmFsdWUpO1xuICB9LFxuICByZW1vdmVEYXRhQXR0cmlidXRlKGVsZW1lbnQsIGtleSkge1xuICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGBkYXRhLWJzLSR7bm9ybWFsaXplRGF0YUtleShrZXkpfWApO1xuICB9LFxuICBnZXREYXRhQXR0cmlidXRlcyhlbGVtZW50KSB7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB7fTtcbiAgICBjb25zdCBic0tleXMgPSBPYmplY3Qua2V5cyhlbGVtZW50LmRhdGFzZXQpLmZpbHRlcihrZXkgPT4ga2V5LnN0YXJ0c1dpdGgoJ2JzJykgJiYgIWtleS5zdGFydHNXaXRoKCdic0NvbmZpZycpKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBic0tleXMpIHtcbiAgICAgIGxldCBwdXJlS2V5ID0ga2V5LnJlcGxhY2UoL15icy8sICcnKTtcbiAgICAgIHB1cmVLZXkgPSBwdXJlS2V5LmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgcHVyZUtleS5zbGljZSgxLCBwdXJlS2V5Lmxlbmd0aCk7XG4gICAgICBhdHRyaWJ1dGVzW3B1cmVLZXldID0gbm9ybWFsaXplRGF0YShlbGVtZW50LmRhdGFzZXRba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICB9LFxuICBnZXREYXRhQXR0cmlidXRlKGVsZW1lbnQsIGtleSkge1xuICAgIHJldHVybiBub3JtYWxpemVEYXRhKGVsZW1lbnQuZ2V0QXR0cmlidXRlKGBkYXRhLWJzLSR7bm9ybWFsaXplRGF0YUtleShrZXkpfWApKTtcbiAgfVxufTtcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwIHV0aWwvY29uZmlnLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuLyoqXG4gKiBDbGFzcyBkZWZpbml0aW9uXG4gKi9cblxuY2xhc3MgQ29uZmlnIHtcbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBoYXZlIHRvIGltcGxlbWVudCB0aGUgc3RhdGljIG1ldGhvZCBcIk5BTUVcIiwgZm9yIGVhY2ggY29tcG9uZW50IScpO1xuICB9XG4gIF9nZXRDb25maWcoY29uZmlnKSB7XG4gICAgY29uZmlnID0gdGhpcy5fbWVyZ2VDb25maWdPYmooY29uZmlnKTtcbiAgICBjb25maWcgPSB0aGlzLl9jb25maWdBZnRlck1lcmdlKGNvbmZpZyk7XG4gICAgdGhpcy5fdHlwZUNoZWNrQ29uZmlnKGNvbmZpZyk7XG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfVxuICBfY29uZmlnQWZ0ZXJNZXJnZShjb25maWcpIHtcbiAgICByZXR1cm4gY29uZmlnO1xuICB9XG4gIF9tZXJnZUNvbmZpZ09iaihjb25maWcsIGVsZW1lbnQpIHtcbiAgICBjb25zdCBqc29uQ29uZmlnID0gaXNFbGVtZW50KGVsZW1lbnQpID8gTWFuaXB1bGF0b3IuZ2V0RGF0YUF0dHJpYnV0ZShlbGVtZW50LCAnY29uZmlnJykgOiB7fTsgLy8gdHJ5IHRvIHBhcnNlXG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4udGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0LFxuICAgICAgLi4uKHR5cGVvZiBqc29uQ29uZmlnID09PSAnb2JqZWN0JyA/IGpzb25Db25maWcgOiB7fSksXG4gICAgICAuLi4oaXNFbGVtZW50KGVsZW1lbnQpID8gTWFuaXB1bGF0b3IuZ2V0RGF0YUF0dHJpYnV0ZXMoZWxlbWVudCkgOiB7fSksXG4gICAgICAuLi4odHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcgPyBjb25maWcgOiB7fSlcbiAgICB9O1xuICB9XG4gIF90eXBlQ2hlY2tDb25maWcoY29uZmlnLCBjb25maWdUeXBlcyA9IHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFR5cGUpIHtcbiAgICBmb3IgKGNvbnN0IFtwcm9wZXJ0eSwgZXhwZWN0ZWRUeXBlc10gb2YgT2JqZWN0LmVudHJpZXMoY29uZmlnVHlwZXMpKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGNvbmZpZ1twcm9wZXJ0eV07XG4gICAgICBjb25zdCB2YWx1ZVR5cGUgPSBpc0VsZW1lbnQodmFsdWUpID8gJ2VsZW1lbnQnIDogdG9UeXBlKHZhbHVlKTtcbiAgICAgIGlmICghbmV3IFJlZ0V4cChleHBlY3RlZFR5cGVzKS50ZXN0KHZhbHVlVHlwZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHt0aGlzLmNvbnN0cnVjdG9yLk5BTUUudG9VcHBlckNhc2UoKX06IE9wdGlvbiBcIiR7cHJvcGVydHl9XCIgcHJvdmlkZWQgdHlwZSBcIiR7dmFsdWVUeXBlfVwiIGJ1dCBleHBlY3RlZCB0eXBlIFwiJHtleHBlY3RlZFR5cGVzfVwiLmApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgYmFzZS1jb21wb25lbnQuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG4vKipcbiAqIENvbnN0YW50c1xuICovXG5cbmNvbnN0IFZFUlNJT04gPSAnNS4zLjAtYWxwaGEyJztcblxuLyoqXG4gKiBDbGFzcyBkZWZpbml0aW9uXG4gKi9cblxuY2xhc3MgQmFzZUNvbXBvbmVudCBleHRlbmRzIENvbmZpZyB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZykge1xuICAgIHN1cGVyKCk7XG4gICAgZWxlbWVudCA9IGdldEVsZW1lbnQoZWxlbWVudCk7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpO1xuICAgIERhdGEuc2V0KHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuREFUQV9LRVksIHRoaXMpO1xuICB9XG5cbiAgLy8gUHVibGljXG4gIGRpc3Bvc2UoKSB7XG4gICAgRGF0YS5yZW1vdmUodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5EQVRBX0tFWSk7XG4gICAgRXZlbnRIYW5kbGVyLm9mZih0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkVWRU5UX0tFWSk7XG4gICAgZm9yIChjb25zdCBwcm9wZXJ0eU5hbWUgb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykpIHtcbiAgICAgIHRoaXNbcHJvcGVydHlOYW1lXSA9IG51bGw7XG4gICAgfVxuICB9XG4gIF9xdWV1ZUNhbGxiYWNrKGNhbGxiYWNrLCBlbGVtZW50LCBpc0FuaW1hdGVkID0gdHJ1ZSkge1xuICAgIGV4ZWN1dGVBZnRlclRyYW5zaXRpb24oY2FsbGJhY2ssIGVsZW1lbnQsIGlzQW5pbWF0ZWQpO1xuICB9XG4gIF9nZXRDb25maWcoY29uZmlnKSB7XG4gICAgY29uZmlnID0gdGhpcy5fbWVyZ2VDb25maWdPYmooY29uZmlnLCB0aGlzLl9lbGVtZW50KTtcbiAgICBjb25maWcgPSB0aGlzLl9jb25maWdBZnRlck1lcmdlKGNvbmZpZyk7XG4gICAgdGhpcy5fdHlwZUNoZWNrQ29uZmlnKGNvbmZpZyk7XG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfVxuXG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgZ2V0SW5zdGFuY2UoZWxlbWVudCkge1xuICAgIHJldHVybiBEYXRhLmdldChnZXRFbGVtZW50KGVsZW1lbnQpLCB0aGlzLkRBVEFfS0VZKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZShlbGVtZW50LCBjb25maWcgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKGVsZW1lbnQpIHx8IG5ldyB0aGlzKGVsZW1lbnQsIHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnID8gY29uZmlnIDogbnVsbCk7XG4gIH1cbiAgc3RhdGljIGdldCBWRVJTSU9OKCkge1xuICAgIHJldHVybiBWRVJTSU9OO1xuICB9XG4gIHN0YXRpYyBnZXQgREFUQV9LRVkoKSB7XG4gICAgcmV0dXJuIGBicy4ke3RoaXMuTkFNRX1gO1xuICB9XG4gIHN0YXRpYyBnZXQgRVZFTlRfS0VZKCkge1xuICAgIHJldHVybiBgLiR7dGhpcy5EQVRBX0tFWX1gO1xuICB9XG4gIHN0YXRpYyBldmVudE5hbWUobmFtZSkge1xuICAgIHJldHVybiBgJHtuYW1lfSR7dGhpcy5FVkVOVF9LRVl9YDtcbiAgfVxufVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgZG9tL3NlbGVjdG9yLWVuZ2luZS5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5jb25zdCBnZXRTZWxlY3RvciA9IGVsZW1lbnQgPT4ge1xuICBsZXQgc2VsZWN0b3IgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1icy10YXJnZXQnKTtcbiAgaWYgKCFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gJyMnKSB7XG4gICAgbGV0IGhyZWZBdHRyaWJ1dGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuXG4gICAgLy8gVGhlIG9ubHkgdmFsaWQgY29udGVudCB0aGF0IGNvdWxkIGRvdWJsZSBhcyBhIHNlbGVjdG9yIGFyZSBJRHMgb3IgY2xhc3NlcyxcbiAgICAvLyBzbyBldmVyeXRoaW5nIHN0YXJ0aW5nIHdpdGggYCNgIG9yIGAuYC4gSWYgYSBcInJlYWxcIiBVUkwgaXMgdXNlZCBhcyB0aGUgc2VsZWN0b3IsXG4gICAgLy8gYGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JgIHdpbGwgcmlnaHRmdWxseSBjb21wbGFpbiBpdCBpcyBpbnZhbGlkLlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvaXNzdWVzLzMyMjczXG4gICAgaWYgKCFocmVmQXR0cmlidXRlIHx8ICFocmVmQXR0cmlidXRlLmluY2x1ZGVzKCcjJykgJiYgIWhyZWZBdHRyaWJ1dGUuc3RhcnRzV2l0aCgnLicpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBKdXN0IGluIGNhc2Ugc29tZSBDTVMgcHV0cyBvdXQgYSBmdWxsIFVSTCB3aXRoIHRoZSBhbmNob3IgYXBwZW5kZWRcbiAgICBpZiAoaHJlZkF0dHJpYnV0ZS5pbmNsdWRlcygnIycpICYmICFocmVmQXR0cmlidXRlLnN0YXJ0c1dpdGgoJyMnKSkge1xuICAgICAgaHJlZkF0dHJpYnV0ZSA9IGAjJHtocmVmQXR0cmlidXRlLnNwbGl0KCcjJylbMV19YDtcbiAgICB9XG4gICAgc2VsZWN0b3IgPSBocmVmQXR0cmlidXRlICYmIGhyZWZBdHRyaWJ1dGUgIT09ICcjJyA/IGhyZWZBdHRyaWJ1dGUudHJpbSgpIDogbnVsbDtcbiAgfVxuICByZXR1cm4gcGFyc2VTZWxlY3RvcihzZWxlY3Rvcik7XG59O1xuY29uc3QgU2VsZWN0b3JFbmdpbmUgPSB7XG4gIGZpbmQoc2VsZWN0b3IsIGVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICByZXR1cm4gW10uY29uY2F0KC4uLkVsZW1lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3JBbGwuY2FsbChlbGVtZW50LCBzZWxlY3RvcikpO1xuICB9LFxuICBmaW5kT25lKHNlbGVjdG9yLCBlbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgcmV0dXJuIEVsZW1lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3IuY2FsbChlbGVtZW50LCBzZWxlY3Rvcik7XG4gIH0sXG4gIGNoaWxkcmVuKGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdCguLi5lbGVtZW50LmNoaWxkcmVuKS5maWx0ZXIoY2hpbGQgPT4gY2hpbGQubWF0Y2hlcyhzZWxlY3RvcikpO1xuICB9LFxuICBwYXJlbnRzKGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gICAgY29uc3QgcGFyZW50cyA9IFtdO1xuICAgIGxldCBhbmNlc3RvciA9IGVsZW1lbnQucGFyZW50Tm9kZS5jbG9zZXN0KHNlbGVjdG9yKTtcbiAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgIHBhcmVudHMucHVzaChhbmNlc3Rvcik7XG4gICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudE5vZGUuY2xvc2VzdChzZWxlY3Rvcik7XG4gICAgfVxuICAgIHJldHVybiBwYXJlbnRzO1xuICB9LFxuICBwcmV2KGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gICAgbGV0IHByZXZpb3VzID0gZWxlbWVudC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICAgIHdoaWxlIChwcmV2aW91cykge1xuICAgICAgaWYgKHByZXZpb3VzLm1hdGNoZXMoc2VsZWN0b3IpKSB7XG4gICAgICAgIHJldHVybiBbcHJldmlvdXNdO1xuICAgICAgfVxuICAgICAgcHJldmlvdXMgPSBwcmV2aW91cy5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH0sXG4gIC8vIFRPRE86IHRoaXMgaXMgbm93IHVudXNlZDsgcmVtb3ZlIGxhdGVyIGFsb25nIHdpdGggcHJldigpXG4gIG5leHQoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICBsZXQgbmV4dCA9IGVsZW1lbnQubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgIHdoaWxlIChuZXh0KSB7XG4gICAgICBpZiAobmV4dC5tYXRjaGVzKHNlbGVjdG9yKSkge1xuICAgICAgICByZXR1cm4gW25leHRdO1xuICAgICAgfVxuICAgICAgbmV4dCA9IG5leHQubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH0sXG4gIGZvY3VzYWJsZUNoaWxkcmVuKGVsZW1lbnQpIHtcbiAgICBjb25zdCBmb2N1c2FibGVzID0gWydhJywgJ2J1dHRvbicsICdpbnB1dCcsICd0ZXh0YXJlYScsICdzZWxlY3QnLCAnZGV0YWlscycsICdbdGFiaW5kZXhdJywgJ1tjb250ZW50ZWRpdGFibGU9XCJ0cnVlXCJdJ10ubWFwKHNlbGVjdG9yID0+IGAke3NlbGVjdG9yfTpub3QoW3RhYmluZGV4Xj1cIi1cIl0pYCkuam9pbignLCcpO1xuICAgIHJldHVybiB0aGlzLmZpbmQoZm9jdXNhYmxlcywgZWxlbWVudCkuZmlsdGVyKGVsID0+ICFpc0Rpc2FibGVkKGVsKSAmJiBpc1Zpc2libGUoZWwpKTtcbiAgfSxcbiAgZ2V0U2VsZWN0b3JGcm9tRWxlbWVudChlbGVtZW50KSB7XG4gICAgY29uc3Qgc2VsZWN0b3IgPSBnZXRTZWxlY3RvcihlbGVtZW50KTtcbiAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiBTZWxlY3RvckVuZ2luZS5maW5kT25lKHNlbGVjdG9yKSA/IHNlbGVjdG9yIDogbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG4gIGdldEVsZW1lbnRGcm9tU2VsZWN0b3IoZWxlbWVudCkge1xuICAgIGNvbnN0IHNlbGVjdG9yID0gZ2V0U2VsZWN0b3IoZWxlbWVudCk7XG4gICAgcmV0dXJuIHNlbGVjdG9yID8gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShzZWxlY3RvcikgOiBudWxsO1xuICB9LFxuICBnZXRNdWx0aXBsZUVsZW1lbnRzRnJvbVNlbGVjdG9yKGVsZW1lbnQpIHtcbiAgICBjb25zdCBzZWxlY3RvciA9IGdldFNlbGVjdG9yKGVsZW1lbnQpO1xuICAgIHJldHVybiBzZWxlY3RvciA/IFNlbGVjdG9yRW5naW5lLmZpbmQoc2VsZWN0b3IpIDogW107XG4gIH1cbn07XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCB1dGlsL2NvbXBvbmVudC1mdW5jdGlvbnMuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuY29uc3QgZW5hYmxlRGlzbWlzc1RyaWdnZXIgPSAoY29tcG9uZW50LCBtZXRob2QgPSAnaGlkZScpID0+IHtcbiAgY29uc3QgY2xpY2tFdmVudCA9IGBjbGljay5kaXNtaXNzJHtjb21wb25lbnQuRVZFTlRfS0VZfWA7XG4gIGNvbnN0IG5hbWUgPSBjb21wb25lbnQuTkFNRTtcbiAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBjbGlja0V2ZW50LCBgW2RhdGEtYnMtZGlzbWlzcz1cIiR7bmFtZX1cIl1gLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoWydBJywgJ0FSRUEnXS5pbmNsdWRlcyh0aGlzLnRhZ05hbWUpKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICBpZiAoaXNEaXNhYmxlZCh0aGlzKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXQgPSBTZWxlY3RvckVuZ2luZS5nZXRFbGVtZW50RnJvbVNlbGVjdG9yKHRoaXMpIHx8IHRoaXMuY2xvc2VzdChgLiR7bmFtZX1gKTtcbiAgICBjb25zdCBpbnN0YW5jZSA9IGNvbXBvbmVudC5nZXRPckNyZWF0ZUluc3RhbmNlKHRhcmdldCk7XG5cbiAgICAvLyBNZXRob2QgYXJndW1lbnQgaXMgbGVmdCwgZm9yIEFsZXJ0IGFuZCBvbmx5LCBhcyBpdCBkb2Vzbid0IGltcGxlbWVudCB0aGUgJ2hpZGUnIG1ldGhvZFxuICAgIGluc3RhbmNlW21ldGhvZF0oKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgYWxlcnQuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG4vKipcbiAqIENvbnN0YW50c1xuICovXG5cbmNvbnN0IE5BTUUkZiA9ICdhbGVydCc7XG5jb25zdCBEQVRBX0tFWSRhID0gJ2JzLmFsZXJ0JztcbmNvbnN0IEVWRU5UX0tFWSRiID0gYC4ke0RBVEFfS0VZJGF9YDtcbmNvbnN0IEVWRU5UX0NMT1NFID0gYGNsb3NlJHtFVkVOVF9LRVkkYn1gO1xuY29uc3QgRVZFTlRfQ0xPU0VEID0gYGNsb3NlZCR7RVZFTlRfS0VZJGJ9YDtcbmNvbnN0IENMQVNTX05BTUVfRkFERSQ1ID0gJ2ZhZGUnO1xuY29uc3QgQ0xBU1NfTkFNRV9TSE9XJDggPSAnc2hvdyc7XG5cbi8qKlxuICogQ2xhc3MgZGVmaW5pdGlvblxuICovXG5cbmNsYXNzIEFsZXJ0IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBOQU1FJGY7XG4gIH1cblxuICAvLyBQdWJsaWNcbiAgY2xvc2UoKSB7XG4gICAgY29uc3QgY2xvc2VFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0NMT1NFKTtcbiAgICBpZiAoY2xvc2VFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1ckOCk7XG4gICAgY29uc3QgaXNBbmltYXRlZCA9IHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRkFERSQ1KTtcbiAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKCgpID0+IHRoaXMuX2Rlc3Ryb3lFbGVtZW50KCksIHRoaXMuX2VsZW1lbnQsIGlzQW5pbWF0ZWQpO1xuICB9XG5cbiAgLy8gUHJpdmF0ZVxuICBfZGVzdHJveUVsZW1lbnQoKSB7XG4gICAgdGhpcy5fZWxlbWVudC5yZW1vdmUoKTtcbiAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9DTE9TRUQpO1xuICAgIHRoaXMuZGlzcG9zZSgpO1xuICB9XG5cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCBkYXRhID0gQWxlcnQuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzKTtcbiAgICAgIGlmICh0eXBlb2YgY29uZmlnICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZGF0YVtjb25maWddID09PSB1bmRlZmluZWQgfHwgY29uZmlnLnN0YXJ0c1dpdGgoJ18nKSB8fCBjb25maWcgPT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKTtcbiAgICAgIH1cbiAgICAgIGRhdGFbY29uZmlnXSh0aGlzKTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIERhdGEgQVBJIGltcGxlbWVudGF0aW9uXG4gKi9cblxuZW5hYmxlRGlzbWlzc1RyaWdnZXIoQWxlcnQsICdjbG9zZScpO1xuXG4vKipcbiAqIGpRdWVyeVxuICovXG5cbmRlZmluZUpRdWVyeVBsdWdpbihBbGVydCk7XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCBidXR0b24uanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG4vKipcbiAqIENvbnN0YW50c1xuICovXG5cbmNvbnN0IE5BTUUkZSA9ICdidXR0b24nO1xuY29uc3QgREFUQV9LRVkkOSA9ICdicy5idXR0b24nO1xuY29uc3QgRVZFTlRfS0VZJGEgPSBgLiR7REFUQV9LRVkkOX1gO1xuY29uc3QgREFUQV9BUElfS0VZJDYgPSAnLmRhdGEtYXBpJztcbmNvbnN0IENMQVNTX05BTUVfQUNUSVZFJDMgPSAnYWN0aXZlJztcbmNvbnN0IFNFTEVDVE9SX0RBVEFfVE9HR0xFJDUgPSAnW2RhdGEtYnMtdG9nZ2xlPVwiYnV0dG9uXCJdJztcbmNvbnN0IEVWRU5UX0NMSUNLX0RBVEFfQVBJJDYgPSBgY2xpY2ske0VWRU5UX0tFWSRhfSR7REFUQV9BUElfS0VZJDZ9YDtcblxuLyoqXG4gKiBDbGFzcyBkZWZpbml0aW9uXG4gKi9cblxuY2xhc3MgQnV0dG9uIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBOQU1FJGU7XG4gIH1cblxuICAvLyBQdWJsaWNcbiAgdG9nZ2xlKCkge1xuICAgIC8vIFRvZ2dsZSBjbGFzcyBhbmQgc3luYyB0aGUgYGFyaWEtcHJlc3NlZGAgYXR0cmlidXRlIHdpdGggdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgYC50b2dnbGUoKWAgbWV0aG9kXG4gICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtcHJlc3NlZCcsIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZShDTEFTU19OQU1FX0FDVElWRSQzKSk7XG4gIH1cblxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBCdXR0b24uZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzKTtcbiAgICAgIGlmIChjb25maWcgPT09ICd0b2dnbGUnKSB7XG4gICAgICAgIGRhdGFbY29uZmlnXSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogRGF0YSBBUEkgaW1wbGVtZW50YXRpb25cbiAqL1xuXG5FdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJJDYsIFNFTEVDVE9SX0RBVEFfVE9HR0xFJDUsIGV2ZW50ID0+IHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgY29uc3QgYnV0dG9uID0gZXZlbnQudGFyZ2V0LmNsb3Nlc3QoU0VMRUNUT1JfREFUQV9UT0dHTEUkNSk7XG4gIGNvbnN0IGRhdGEgPSBCdXR0b24uZ2V0T3JDcmVhdGVJbnN0YW5jZShidXR0b24pO1xuICBkYXRhLnRvZ2dsZSgpO1xufSk7XG5cbi8qKlxuICogalF1ZXJ5XG4gKi9cblxuZGVmaW5lSlF1ZXJ5UGx1Z2luKEJ1dHRvbik7XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCB1dGlsL3N3aXBlLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuLyoqXG4gKiBDb25zdGFudHNcbiAqL1xuXG5jb25zdCBOQU1FJGQgPSAnc3dpcGUnO1xuY29uc3QgRVZFTlRfS0VZJDkgPSAnLmJzLnN3aXBlJztcbmNvbnN0IEVWRU5UX1RPVUNIU1RBUlQgPSBgdG91Y2hzdGFydCR7RVZFTlRfS0VZJDl9YDtcbmNvbnN0IEVWRU5UX1RPVUNITU9WRSA9IGB0b3VjaG1vdmUke0VWRU5UX0tFWSQ5fWA7XG5jb25zdCBFVkVOVF9UT1VDSEVORCA9IGB0b3VjaGVuZCR7RVZFTlRfS0VZJDl9YDtcbmNvbnN0IEVWRU5UX1BPSU5URVJET1dOID0gYHBvaW50ZXJkb3duJHtFVkVOVF9LRVkkOX1gO1xuY29uc3QgRVZFTlRfUE9JTlRFUlVQID0gYHBvaW50ZXJ1cCR7RVZFTlRfS0VZJDl9YDtcbmNvbnN0IFBPSU5URVJfVFlQRV9UT1VDSCA9ICd0b3VjaCc7XG5jb25zdCBQT0lOVEVSX1RZUEVfUEVOID0gJ3Blbic7XG5jb25zdCBDTEFTU19OQU1FX1BPSU5URVJfRVZFTlQgPSAncG9pbnRlci1ldmVudCc7XG5jb25zdCBTV0lQRV9USFJFU0hPTEQgPSA0MDtcbmNvbnN0IERlZmF1bHQkYyA9IHtcbiAgZW5kQ2FsbGJhY2s6IG51bGwsXG4gIGxlZnRDYWxsYmFjazogbnVsbCxcbiAgcmlnaHRDYWxsYmFjazogbnVsbFxufTtcbmNvbnN0IERlZmF1bHRUeXBlJGMgPSB7XG4gIGVuZENhbGxiYWNrOiAnKGZ1bmN0aW9ufG51bGwpJyxcbiAgbGVmdENhbGxiYWNrOiAnKGZ1bmN0aW9ufG51bGwpJyxcbiAgcmlnaHRDYWxsYmFjazogJyhmdW5jdGlvbnxudWxsKSdcbn07XG5cbi8qKlxuICogQ2xhc3MgZGVmaW5pdGlvblxuICovXG5cbmNsYXNzIFN3aXBlIGV4dGVuZHMgQ29uZmlnIHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcbiAgICBpZiAoIWVsZW1lbnQgfHwgIVN3aXBlLmlzU3VwcG9ydGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZyk7XG4gICAgdGhpcy5fZGVsdGFYID0gMDtcbiAgICB0aGlzLl9zdXBwb3J0UG9pbnRlckV2ZW50cyA9IEJvb2xlYW4od2luZG93LlBvaW50ZXJFdmVudCk7XG4gICAgdGhpcy5faW5pdEV2ZW50cygpO1xuICB9XG5cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIERlZmF1bHQkYztcbiAgfVxuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgIHJldHVybiBEZWZhdWx0VHlwZSRjO1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gTkFNRSRkO1xuICB9XG5cbiAgLy8gUHVibGljXG4gIGRpc3Bvc2UoKSB7XG4gICAgRXZlbnRIYW5kbGVyLm9mZih0aGlzLl9lbGVtZW50LCBFVkVOVF9LRVkkOSk7XG4gIH1cblxuICAvLyBQcml2YXRlXG4gIF9zdGFydChldmVudCkge1xuICAgIGlmICghdGhpcy5fc3VwcG9ydFBvaW50ZXJFdmVudHMpIHtcbiAgICAgIHRoaXMuX2RlbHRhWCA9IGV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2V2ZW50SXNQb2ludGVyUGVuVG91Y2goZXZlbnQpKSB7XG4gICAgICB0aGlzLl9kZWx0YVggPSBldmVudC5jbGllbnRYO1xuICAgIH1cbiAgfVxuICBfZW5kKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuX2V2ZW50SXNQb2ludGVyUGVuVG91Y2goZXZlbnQpKSB7XG4gICAgICB0aGlzLl9kZWx0YVggPSBldmVudC5jbGllbnRYIC0gdGhpcy5fZGVsdGFYO1xuICAgIH1cbiAgICB0aGlzLl9oYW5kbGVTd2lwZSgpO1xuICAgIGV4ZWN1dGUodGhpcy5fY29uZmlnLmVuZENhbGxiYWNrKTtcbiAgfVxuICBfbW92ZShldmVudCkge1xuICAgIHRoaXMuX2RlbHRhWCA9IGV2ZW50LnRvdWNoZXMgJiYgZXZlbnQudG91Y2hlcy5sZW5ndGggPiAxID8gMCA6IGV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WCAtIHRoaXMuX2RlbHRhWDtcbiAgfVxuICBfaGFuZGxlU3dpcGUoKSB7XG4gICAgY29uc3QgYWJzRGVsdGFYID0gTWF0aC5hYnModGhpcy5fZGVsdGFYKTtcbiAgICBpZiAoYWJzRGVsdGFYIDw9IFNXSVBFX1RIUkVTSE9MRCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkaXJlY3Rpb24gPSBhYnNEZWx0YVggLyB0aGlzLl9kZWx0YVg7XG4gICAgdGhpcy5fZGVsdGFYID0gMDtcbiAgICBpZiAoIWRpcmVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBleGVjdXRlKGRpcmVjdGlvbiA+IDAgPyB0aGlzLl9jb25maWcucmlnaHRDYWxsYmFjayA6IHRoaXMuX2NvbmZpZy5sZWZ0Q2FsbGJhY2spO1xuICB9XG4gIF9pbml0RXZlbnRzKCkge1xuICAgIGlmICh0aGlzLl9zdXBwb3J0UG9pbnRlckV2ZW50cykge1xuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1BPSU5URVJET1dOLCBldmVudCA9PiB0aGlzLl9zdGFydChldmVudCkpO1xuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1BPSU5URVJVUCwgZXZlbnQgPT4gdGhpcy5fZW5kKGV2ZW50KSk7XG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9QT0lOVEVSX0VWRU5UKTtcbiAgICB9IGVsc2Uge1xuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1RPVUNIU1RBUlQsIGV2ZW50ID0+IHRoaXMuX3N0YXJ0KGV2ZW50KSk7XG4gICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfVE9VQ0hNT1ZFLCBldmVudCA9PiB0aGlzLl9tb3ZlKGV2ZW50KSk7XG4gICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfVE9VQ0hFTkQsIGV2ZW50ID0+IHRoaXMuX2VuZChldmVudCkpO1xuICAgIH1cbiAgfVxuICBfZXZlbnRJc1BvaW50ZXJQZW5Ub3VjaChldmVudCkge1xuICAgIHJldHVybiB0aGlzLl9zdXBwb3J0UG9pbnRlckV2ZW50cyAmJiAoZXZlbnQucG9pbnRlclR5cGUgPT09IFBPSU5URVJfVFlQRV9QRU4gfHwgZXZlbnQucG9pbnRlclR5cGUgPT09IFBPSU5URVJfVFlQRV9UT1VDSCk7XG4gIH1cblxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGlzU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiAnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgfHwgbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMDtcbiAgfVxufVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgY2Fyb3VzZWwuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG4vKipcbiAqIENvbnN0YW50c1xuICovXG5cbmNvbnN0IE5BTUUkYyA9ICdjYXJvdXNlbCc7XG5jb25zdCBEQVRBX0tFWSQ4ID0gJ2JzLmNhcm91c2VsJztcbmNvbnN0IEVWRU5UX0tFWSQ4ID0gYC4ke0RBVEFfS0VZJDh9YDtcbmNvbnN0IERBVEFfQVBJX0tFWSQ1ID0gJy5kYXRhLWFwaSc7XG5jb25zdCBBUlJPV19MRUZUX0tFWSQxID0gJ0Fycm93TGVmdCc7XG5jb25zdCBBUlJPV19SSUdIVF9LRVkkMSA9ICdBcnJvd1JpZ2h0JztcbmNvbnN0IFRPVUNIRVZFTlRfQ09NUEFUX1dBSVQgPSA1MDA7IC8vIFRpbWUgZm9yIG1vdXNlIGNvbXBhdCBldmVudHMgdG8gZmlyZSBhZnRlciB0b3VjaFxuXG5jb25zdCBPUkRFUl9ORVhUID0gJ25leHQnO1xuY29uc3QgT1JERVJfUFJFViA9ICdwcmV2JztcbmNvbnN0IERJUkVDVElPTl9MRUZUID0gJ2xlZnQnO1xuY29uc3QgRElSRUNUSU9OX1JJR0hUID0gJ3JpZ2h0JztcbmNvbnN0IEVWRU5UX1NMSURFID0gYHNsaWRlJHtFVkVOVF9LRVkkOH1gO1xuY29uc3QgRVZFTlRfU0xJRCA9IGBzbGlkJHtFVkVOVF9LRVkkOH1gO1xuY29uc3QgRVZFTlRfS0VZRE9XTiQxID0gYGtleWRvd24ke0VWRU5UX0tFWSQ4fWA7XG5jb25zdCBFVkVOVF9NT1VTRUVOVEVSJDEgPSBgbW91c2VlbnRlciR7RVZFTlRfS0VZJDh9YDtcbmNvbnN0IEVWRU5UX01PVVNFTEVBVkUkMSA9IGBtb3VzZWxlYXZlJHtFVkVOVF9LRVkkOH1gO1xuY29uc3QgRVZFTlRfRFJBR19TVEFSVCA9IGBkcmFnc3RhcnQke0VWRU5UX0tFWSQ4fWA7XG5jb25zdCBFVkVOVF9MT0FEX0RBVEFfQVBJJDMgPSBgbG9hZCR7RVZFTlRfS0VZJDh9JHtEQVRBX0FQSV9LRVkkNX1gO1xuY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNSA9IGBjbGljayR7RVZFTlRfS0VZJDh9JHtEQVRBX0FQSV9LRVkkNX1gO1xuY29uc3QgQ0xBU1NfTkFNRV9DQVJPVVNFTCA9ICdjYXJvdXNlbCc7XG5jb25zdCBDTEFTU19OQU1FX0FDVElWRSQyID0gJ2FjdGl2ZSc7XG5jb25zdCBDTEFTU19OQU1FX1NMSURFID0gJ3NsaWRlJztcbmNvbnN0IENMQVNTX05BTUVfRU5EID0gJ2Nhcm91c2VsLWl0ZW0tZW5kJztcbmNvbnN0IENMQVNTX05BTUVfU1RBUlQgPSAnY2Fyb3VzZWwtaXRlbS1zdGFydCc7XG5jb25zdCBDTEFTU19OQU1FX05FWFQgPSAnY2Fyb3VzZWwtaXRlbS1uZXh0JztcbmNvbnN0IENMQVNTX05BTUVfUFJFViA9ICdjYXJvdXNlbC1pdGVtLXByZXYnO1xuY29uc3QgU0VMRUNUT1JfQUNUSVZFID0gJy5hY3RpdmUnO1xuY29uc3QgU0VMRUNUT1JfSVRFTSA9ICcuY2Fyb3VzZWwtaXRlbSc7XG5jb25zdCBTRUxFQ1RPUl9BQ1RJVkVfSVRFTSA9IFNFTEVDVE9SX0FDVElWRSArIFNFTEVDVE9SX0lURU07XG5jb25zdCBTRUxFQ1RPUl9JVEVNX0lNRyA9ICcuY2Fyb3VzZWwtaXRlbSBpbWcnO1xuY29uc3QgU0VMRUNUT1JfSU5ESUNBVE9SUyA9ICcuY2Fyb3VzZWwtaW5kaWNhdG9ycyc7XG5jb25zdCBTRUxFQ1RPUl9EQVRBX1NMSURFID0gJ1tkYXRhLWJzLXNsaWRlXSwgW2RhdGEtYnMtc2xpZGUtdG9dJztcbmNvbnN0IFNFTEVDVE9SX0RBVEFfUklERSA9ICdbZGF0YS1icy1yaWRlPVwiY2Fyb3VzZWxcIl0nO1xuY29uc3QgS0VZX1RPX0RJUkVDVElPTiA9IHtcbiAgW0FSUk9XX0xFRlRfS0VZJDFdOiBESVJFQ1RJT05fUklHSFQsXG4gIFtBUlJPV19SSUdIVF9LRVkkMV06IERJUkVDVElPTl9MRUZUXG59O1xuY29uc3QgRGVmYXVsdCRiID0ge1xuICBpbnRlcnZhbDogNTAwMCxcbiAga2V5Ym9hcmQ6IHRydWUsXG4gIHBhdXNlOiAnaG92ZXInLFxuICByaWRlOiBmYWxzZSxcbiAgdG91Y2g6IHRydWUsXG4gIHdyYXA6IHRydWVcbn07XG5jb25zdCBEZWZhdWx0VHlwZSRiID0ge1xuICBpbnRlcnZhbDogJyhudW1iZXJ8Ym9vbGVhbiknLFxuICAvLyBUT0RPOnY2IHJlbW92ZSBib29sZWFuIHN1cHBvcnRcbiAga2V5Ym9hcmQ6ICdib29sZWFuJyxcbiAgcGF1c2U6ICcoc3RyaW5nfGJvb2xlYW4pJyxcbiAgcmlkZTogJyhib29sZWFufHN0cmluZyknLFxuICB0b3VjaDogJ2Jvb2xlYW4nLFxuICB3cmFwOiAnYm9vbGVhbidcbn07XG5cbi8qKlxuICogQ2xhc3MgZGVmaW5pdGlvblxuICovXG5cbmNsYXNzIENhcm91c2VsIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZykge1xuICAgIHN1cGVyKGVsZW1lbnQsIGNvbmZpZyk7XG4gICAgdGhpcy5faW50ZXJ2YWwgPSBudWxsO1xuICAgIHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMuX2lzU2xpZGluZyA9IGZhbHNlO1xuICAgIHRoaXMudG91Y2hUaW1lb3V0ID0gbnVsbDtcbiAgICB0aGlzLl9zd2lwZUhlbHBlciA9IG51bGw7XG4gICAgdGhpcy5faW5kaWNhdG9yc0VsZW1lbnQgPSBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX0lORElDQVRPUlMsIHRoaXMuX2VsZW1lbnQpO1xuICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgaWYgKHRoaXMuX2NvbmZpZy5yaWRlID09PSBDTEFTU19OQU1FX0NBUk9VU0VMKSB7XG4gICAgICB0aGlzLmN5Y2xlKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIERlZmF1bHQkYjtcbiAgfVxuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgIHJldHVybiBEZWZhdWx0VHlwZSRiO1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gTkFNRSRjO1xuICB9XG5cbiAgLy8gUHVibGljXG4gIG5leHQoKSB7XG4gICAgdGhpcy5fc2xpZGUoT1JERVJfTkVYVCk7XG4gIH1cbiAgbmV4dFdoZW5WaXNpYmxlKCkge1xuICAgIC8vIEZJWE1FIFRPRE8gdXNlIGBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGVgXG4gICAgLy8gRG9uJ3QgY2FsbCBuZXh0IHdoZW4gdGhlIHBhZ2UgaXNuJ3QgdmlzaWJsZVxuICAgIC8vIG9yIHRoZSBjYXJvdXNlbCBvciBpdHMgcGFyZW50IGlzbid0IHZpc2libGVcbiAgICBpZiAoIWRvY3VtZW50LmhpZGRlbiAmJiBpc1Zpc2libGUodGhpcy5fZWxlbWVudCkpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgIH1cbiAgfVxuICBwcmV2KCkge1xuICAgIHRoaXMuX3NsaWRlKE9SREVSX1BSRVYpO1xuICB9XG4gIHBhdXNlKCkge1xuICAgIGlmICh0aGlzLl9pc1NsaWRpbmcpIHtcbiAgICAgIHRyaWdnZXJUcmFuc2l0aW9uRW5kKHRoaXMuX2VsZW1lbnQpO1xuICAgIH1cbiAgICB0aGlzLl9jbGVhckludGVydmFsKCk7XG4gIH1cbiAgY3ljbGUoKSB7XG4gICAgdGhpcy5fY2xlYXJJbnRlcnZhbCgpO1xuICAgIHRoaXMuX3VwZGF0ZUludGVydmFsKCk7XG4gICAgdGhpcy5faW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB0aGlzLm5leHRXaGVuVmlzaWJsZSgpLCB0aGlzLl9jb25maWcuaW50ZXJ2YWwpO1xuICB9XG4gIF9tYXliZUVuYWJsZUN5Y2xlKCkge1xuICAgIGlmICghdGhpcy5fY29uZmlnLnJpZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2lzU2xpZGluZykge1xuICAgICAgRXZlbnRIYW5kbGVyLm9uZSh0aGlzLl9lbGVtZW50LCBFVkVOVF9TTElELCAoKSA9PiB0aGlzLmN5Y2xlKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmN5Y2xlKCk7XG4gIH1cbiAgdG8oaW5kZXgpIHtcbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuX2dldEl0ZW1zKCk7XG4gICAgaWYgKGluZGV4ID4gaXRlbXMubGVuZ3RoIC0gMSB8fCBpbmRleCA8IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2lzU2xpZGluZykge1xuICAgICAgRXZlbnRIYW5kbGVyLm9uZSh0aGlzLl9lbGVtZW50LCBFVkVOVF9TTElELCAoKSA9PiB0aGlzLnRvKGluZGV4KSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGFjdGl2ZUluZGV4ID0gdGhpcy5fZ2V0SXRlbUluZGV4KHRoaXMuX2dldEFjdGl2ZSgpKTtcbiAgICBpZiAoYWN0aXZlSW5kZXggPT09IGluZGV4KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9yZGVyID0gaW5kZXggPiBhY3RpdmVJbmRleCA/IE9SREVSX05FWFQgOiBPUkRFUl9QUkVWO1xuICAgIHRoaXMuX3NsaWRlKG9yZGVyLCBpdGVtc1tpbmRleF0pO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgaWYgKHRoaXMuX3N3aXBlSGVscGVyKSB7XG4gICAgICB0aGlzLl9zd2lwZUhlbHBlci5kaXNwb3NlKCk7XG4gICAgfVxuICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgfVxuXG4gIC8vIFByaXZhdGVcbiAgX2NvbmZpZ0FmdGVyTWVyZ2UoY29uZmlnKSB7XG4gICAgY29uZmlnLmRlZmF1bHRJbnRlcnZhbCA9IGNvbmZpZy5pbnRlcnZhbDtcbiAgICByZXR1cm4gY29uZmlnO1xuICB9XG4gIF9hZGRFdmVudExpc3RlbmVycygpIHtcbiAgICBpZiAodGhpcy5fY29uZmlnLmtleWJvYXJkKSB7XG4gICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfS0VZRE9XTiQxLCBldmVudCA9PiB0aGlzLl9rZXlkb3duKGV2ZW50KSk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9jb25maWcucGF1c2UgPT09ICdob3ZlcicpIHtcbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9NT1VTRUVOVEVSJDEsICgpID0+IHRoaXMucGF1c2UoKSk7XG4gICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfTU9VU0VMRUFWRSQxLCAoKSA9PiB0aGlzLl9tYXliZUVuYWJsZUN5Y2xlKCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fY29uZmlnLnRvdWNoICYmIFN3aXBlLmlzU3VwcG9ydGVkKCkpIHtcbiAgICAgIHRoaXMuX2FkZFRvdWNoRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG4gIH1cbiAgX2FkZFRvdWNoRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgZm9yIChjb25zdCBpbWcgb2YgU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9JVEVNX0lNRywgdGhpcy5fZWxlbWVudCkpIHtcbiAgICAgIEV2ZW50SGFuZGxlci5vbihpbWcsIEVWRU5UX0RSQUdfU1RBUlQsIGV2ZW50ID0+IGV2ZW50LnByZXZlbnREZWZhdWx0KCkpO1xuICAgIH1cbiAgICBjb25zdCBlbmRDYWxsQmFjayA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLl9jb25maWcucGF1c2UgIT09ICdob3ZlcicpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBpdCdzIGEgdG91Y2gtZW5hYmxlZCBkZXZpY2UsIG1vdXNlZW50ZXIvbGVhdmUgYXJlIGZpcmVkIGFzXG4gICAgICAvLyBwYXJ0IG9mIHRoZSBtb3VzZSBjb21wYXRpYmlsaXR5IGV2ZW50cyBvbiBmaXJzdCB0YXAgLSB0aGUgY2Fyb3VzZWxcbiAgICAgIC8vIHdvdWxkIHN0b3AgY3ljbGluZyB1bnRpbCB1c2VyIHRhcHBlZCBvdXQgb2YgaXQ7XG4gICAgICAvLyBoZXJlLCB3ZSBsaXN0ZW4gZm9yIHRvdWNoZW5kLCBleHBsaWNpdGx5IHBhdXNlIHRoZSBjYXJvdXNlbFxuICAgICAgLy8gKGFzIGlmIGl0J3MgdGhlIHNlY29uZCB0aW1lIHdlIHRhcCBvbiBpdCwgbW91c2VlbnRlciBjb21wYXQgZXZlbnRcbiAgICAgIC8vIGlzIE5PVCBmaXJlZCkgYW5kIGFmdGVyIGEgdGltZW91dCAodG8gYWxsb3cgZm9yIG1vdXNlIGNvbXBhdGliaWxpdHlcbiAgICAgIC8vIGV2ZW50cyB0byBmaXJlKSB3ZSBleHBsaWNpdGx5IHJlc3RhcnQgY3ljbGluZ1xuXG4gICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICBpZiAodGhpcy50b3VjaFRpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudG91Y2hUaW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMudG91Y2hUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLl9tYXliZUVuYWJsZUN5Y2xlKCksIFRPVUNIRVZFTlRfQ09NUEFUX1dBSVQgKyB0aGlzLl9jb25maWcuaW50ZXJ2YWwpO1xuICAgIH07XG4gICAgY29uc3Qgc3dpcGVDb25maWcgPSB7XG4gICAgICBsZWZ0Q2FsbGJhY2s6ICgpID0+IHRoaXMuX3NsaWRlKHRoaXMuX2RpcmVjdGlvblRvT3JkZXIoRElSRUNUSU9OX0xFRlQpKSxcbiAgICAgIHJpZ2h0Q2FsbGJhY2s6ICgpID0+IHRoaXMuX3NsaWRlKHRoaXMuX2RpcmVjdGlvblRvT3JkZXIoRElSRUNUSU9OX1JJR0hUKSksXG4gICAgICBlbmRDYWxsYmFjazogZW5kQ2FsbEJhY2tcbiAgICB9O1xuICAgIHRoaXMuX3N3aXBlSGVscGVyID0gbmV3IFN3aXBlKHRoaXMuX2VsZW1lbnQsIHN3aXBlQ29uZmlnKTtcbiAgfVxuICBfa2V5ZG93bihldmVudCkge1xuICAgIGlmICgvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KGV2ZW50LnRhcmdldC50YWdOYW1lKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkaXJlY3Rpb24gPSBLRVlfVE9fRElSRUNUSU9OW2V2ZW50LmtleV07XG4gICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuX3NsaWRlKHRoaXMuX2RpcmVjdGlvblRvT3JkZXIoZGlyZWN0aW9uKSk7XG4gICAgfVxuICB9XG4gIF9nZXRJdGVtSW5kZXgoZWxlbWVudCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRJdGVtcygpLmluZGV4T2YoZWxlbWVudCk7XG4gIH1cbiAgX3NldEFjdGl2ZUluZGljYXRvckVsZW1lbnQoaW5kZXgpIHtcbiAgICBpZiAoIXRoaXMuX2luZGljYXRvcnNFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGFjdGl2ZUluZGljYXRvciA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfQUNUSVZFLCB0aGlzLl9pbmRpY2F0b3JzRWxlbWVudCk7XG4gICAgYWN0aXZlSW5kaWNhdG9yLmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9BQ1RJVkUkMik7XG4gICAgYWN0aXZlSW5kaWNhdG9yLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1jdXJyZW50Jyk7XG4gICAgY29uc3QgbmV3QWN0aXZlSW5kaWNhdG9yID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShgW2RhdGEtYnMtc2xpZGUtdG89XCIke2luZGV4fVwiXWAsIHRoaXMuX2luZGljYXRvcnNFbGVtZW50KTtcbiAgICBpZiAobmV3QWN0aXZlSW5kaWNhdG9yKSB7XG4gICAgICBuZXdBY3RpdmVJbmRpY2F0b3IuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0FDVElWRSQyKTtcbiAgICAgIG5ld0FjdGl2ZUluZGljYXRvci5zZXRBdHRyaWJ1dGUoJ2FyaWEtY3VycmVudCcsICd0cnVlJyk7XG4gICAgfVxuICB9XG4gIF91cGRhdGVJbnRlcnZhbCgpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fYWN0aXZlRWxlbWVudCB8fCB0aGlzLl9nZXRBY3RpdmUoKTtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZWxlbWVudEludGVydmFsID0gTnVtYmVyLnBhcnNlSW50KGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWJzLWludGVydmFsJyksIDEwKTtcbiAgICB0aGlzLl9jb25maWcuaW50ZXJ2YWwgPSBlbGVtZW50SW50ZXJ2YWwgfHwgdGhpcy5fY29uZmlnLmRlZmF1bHRJbnRlcnZhbDtcbiAgfVxuICBfc2xpZGUob3JkZXIsIGVsZW1lbnQgPSBudWxsKSB7XG4gICAgaWYgKHRoaXMuX2lzU2xpZGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhY3RpdmVFbGVtZW50ID0gdGhpcy5fZ2V0QWN0aXZlKCk7XG4gICAgY29uc3QgaXNOZXh0ID0gb3JkZXIgPT09IE9SREVSX05FWFQ7XG4gICAgY29uc3QgbmV4dEVsZW1lbnQgPSBlbGVtZW50IHx8IGdldE5leHRBY3RpdmVFbGVtZW50KHRoaXMuX2dldEl0ZW1zKCksIGFjdGl2ZUVsZW1lbnQsIGlzTmV4dCwgdGhpcy5fY29uZmlnLndyYXApO1xuICAgIGlmIChuZXh0RWxlbWVudCA9PT0gYWN0aXZlRWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuZXh0RWxlbWVudEluZGV4ID0gdGhpcy5fZ2V0SXRlbUluZGV4KG5leHRFbGVtZW50KTtcbiAgICBjb25zdCB0cmlnZ2VyRXZlbnQgPSBldmVudE5hbWUgPT4ge1xuICAgICAgcmV0dXJuIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGV2ZW50TmFtZSwge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiBuZXh0RWxlbWVudCxcbiAgICAgICAgZGlyZWN0aW9uOiB0aGlzLl9vcmRlclRvRGlyZWN0aW9uKG9yZGVyKSxcbiAgICAgICAgZnJvbTogdGhpcy5fZ2V0SXRlbUluZGV4KGFjdGl2ZUVsZW1lbnQpLFxuICAgICAgICB0bzogbmV4dEVsZW1lbnRJbmRleFxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBzbGlkZUV2ZW50ID0gdHJpZ2dlckV2ZW50KEVWRU5UX1NMSURFKTtcbiAgICBpZiAoc2xpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghYWN0aXZlRWxlbWVudCB8fCAhbmV4dEVsZW1lbnQpIHtcbiAgICAgIC8vIFNvbWUgd2VpcmRuZXNzIGlzIGhhcHBlbmluZywgc28gd2UgYmFpbFxuICAgICAgLy8gVE9ETzogY2hhbmdlIHRlc3RzIHRoYXQgdXNlIGVtcHR5IGRpdnMgdG8gYXZvaWQgdGhpcyBjaGVja1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpc0N5Y2xpbmcgPSBCb29sZWFuKHRoaXMuX2ludGVydmFsKTtcbiAgICB0aGlzLnBhdXNlKCk7XG4gICAgdGhpcy5faXNTbGlkaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl9zZXRBY3RpdmVJbmRpY2F0b3JFbGVtZW50KG5leHRFbGVtZW50SW5kZXgpO1xuICAgIHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSBuZXh0RWxlbWVudDtcbiAgICBjb25zdCBkaXJlY3Rpb25hbENsYXNzTmFtZSA9IGlzTmV4dCA/IENMQVNTX05BTUVfU1RBUlQgOiBDTEFTU19OQU1FX0VORDtcbiAgICBjb25zdCBvcmRlckNsYXNzTmFtZSA9IGlzTmV4dCA/IENMQVNTX05BTUVfTkVYVCA6IENMQVNTX05BTUVfUFJFVjtcbiAgICBuZXh0RWxlbWVudC5jbGFzc0xpc3QuYWRkKG9yZGVyQ2xhc3NOYW1lKTtcbiAgICByZWZsb3cobmV4dEVsZW1lbnQpO1xuICAgIGFjdGl2ZUVsZW1lbnQuY2xhc3NMaXN0LmFkZChkaXJlY3Rpb25hbENsYXNzTmFtZSk7XG4gICAgbmV4dEVsZW1lbnQuY2xhc3NMaXN0LmFkZChkaXJlY3Rpb25hbENsYXNzTmFtZSk7XG4gICAgY29uc3QgY29tcGxldGVDYWxsQmFjayA9ICgpID0+IHtcbiAgICAgIG5leHRFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoZGlyZWN0aW9uYWxDbGFzc05hbWUsIG9yZGVyQ2xhc3NOYW1lKTtcbiAgICAgIG5leHRFbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9BQ1RJVkUkMik7XG4gICAgICBhY3RpdmVFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9BQ1RJVkUkMiwgb3JkZXJDbGFzc05hbWUsIGRpcmVjdGlvbmFsQ2xhc3NOYW1lKTtcbiAgICAgIHRoaXMuX2lzU2xpZGluZyA9IGZhbHNlO1xuICAgICAgdHJpZ2dlckV2ZW50KEVWRU5UX1NMSUQpO1xuICAgIH07XG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZUNhbGxCYWNrLCBhY3RpdmVFbGVtZW50LCB0aGlzLl9pc0FuaW1hdGVkKCkpO1xuICAgIGlmIChpc0N5Y2xpbmcpIHtcbiAgICAgIHRoaXMuY3ljbGUoKTtcbiAgICB9XG4gIH1cbiAgX2lzQW5pbWF0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfU0xJREUpO1xuICB9XG4gIF9nZXRBY3RpdmUoKSB7XG4gICAgcmV0dXJuIFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfQUNUSVZFX0lURU0sIHRoaXMuX2VsZW1lbnQpO1xuICB9XG4gIF9nZXRJdGVtcygpIHtcbiAgICByZXR1cm4gU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9JVEVNLCB0aGlzLl9lbGVtZW50KTtcbiAgfVxuICBfY2xlYXJJbnRlcnZhbCgpIHtcbiAgICBpZiAodGhpcy5faW50ZXJ2YWwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpO1xuICAgICAgdGhpcy5faW50ZXJ2YWwgPSBudWxsO1xuICAgIH1cbiAgfVxuICBfZGlyZWN0aW9uVG9PcmRlcihkaXJlY3Rpb24pIHtcbiAgICBpZiAoaXNSVEwoKSkge1xuICAgICAgcmV0dXJuIGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OX0xFRlQgPyBPUkRFUl9QUkVWIDogT1JERVJfTkVYVDtcbiAgICB9XG4gICAgcmV0dXJuIGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OX0xFRlQgPyBPUkRFUl9ORVhUIDogT1JERVJfUFJFVjtcbiAgfVxuICBfb3JkZXJUb0RpcmVjdGlvbihvcmRlcikge1xuICAgIGlmIChpc1JUTCgpKSB7XG4gICAgICByZXR1cm4gb3JkZXIgPT09IE9SREVSX1BSRVYgPyBESVJFQ1RJT05fTEVGVCA6IERJUkVDVElPTl9SSUdIVDtcbiAgICB9XG4gICAgcmV0dXJuIG9yZGVyID09PSBPUkRFUl9QUkVWID8gRElSRUNUSU9OX1JJR0hUIDogRElSRUNUSU9OX0xFRlQ7XG4gIH1cblxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBDYXJvdXNlbC5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIGNvbmZpZyk7XG4gICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgZGF0YS50byhjb25maWcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGRhdGFbY29uZmlnXSA9PT0gdW5kZWZpbmVkIHx8IGNvbmZpZy5zdGFydHNXaXRoKCdfJykgfHwgY29uZmlnID09PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICBkYXRhW2NvbmZpZ10oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIERhdGEgQVBJIGltcGxlbWVudGF0aW9uXG4gKi9cblxuRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9DTElDS19EQVRBX0FQSSQ1LCBTRUxFQ1RPUl9EQVRBX1NMSURFLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgY29uc3QgdGFyZ2V0ID0gU2VsZWN0b3JFbmdpbmUuZ2V0RWxlbWVudEZyb21TZWxlY3Rvcih0aGlzKTtcbiAgaWYgKCF0YXJnZXQgfHwgIXRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9DQVJPVVNFTCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgY29uc3QgY2Fyb3VzZWwgPSBDYXJvdXNlbC5nZXRPckNyZWF0ZUluc3RhbmNlKHRhcmdldCk7XG4gIGNvbnN0IHNsaWRlSW5kZXggPSB0aGlzLmdldEF0dHJpYnV0ZSgnZGF0YS1icy1zbGlkZS10bycpO1xuICBpZiAoc2xpZGVJbmRleCkge1xuICAgIGNhcm91c2VsLnRvKHNsaWRlSW5kZXgpO1xuICAgIGNhcm91c2VsLl9tYXliZUVuYWJsZUN5Y2xlKCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChNYW5pcHVsYXRvci5nZXREYXRhQXR0cmlidXRlKHRoaXMsICdzbGlkZScpID09PSAnbmV4dCcpIHtcbiAgICBjYXJvdXNlbC5uZXh0KCk7XG4gICAgY2Fyb3VzZWwuX21heWJlRW5hYmxlQ3ljbGUoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY2Fyb3VzZWwucHJldigpO1xuICBjYXJvdXNlbC5fbWF5YmVFbmFibGVDeWNsZSgpO1xufSk7XG5FdmVudEhhbmRsZXIub24od2luZG93LCBFVkVOVF9MT0FEX0RBVEFfQVBJJDMsICgpID0+IHtcbiAgY29uc3QgY2Fyb3VzZWxzID0gU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9EQVRBX1JJREUpO1xuICBmb3IgKGNvbnN0IGNhcm91c2VsIG9mIGNhcm91c2Vscykge1xuICAgIENhcm91c2VsLmdldE9yQ3JlYXRlSW5zdGFuY2UoY2Fyb3VzZWwpO1xuICB9XG59KTtcblxuLyoqXG4gKiBqUXVlcnlcbiAqL1xuXG5kZWZpbmVKUXVlcnlQbHVnaW4oQ2Fyb3VzZWwpO1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgY29sbGFwc2UuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG4vKipcbiAqIENvbnN0YW50c1xuICovXG5cbmNvbnN0IE5BTUUkYiA9ICdjb2xsYXBzZSc7XG5jb25zdCBEQVRBX0tFWSQ3ID0gJ2JzLmNvbGxhcHNlJztcbmNvbnN0IEVWRU5UX0tFWSQ3ID0gYC4ke0RBVEFfS0VZJDd9YDtcbmNvbnN0IERBVEFfQVBJX0tFWSQ0ID0gJy5kYXRhLWFwaSc7XG5jb25zdCBFVkVOVF9TSE9XJDYgPSBgc2hvdyR7RVZFTlRfS0VZJDd9YDtcbmNvbnN0IEVWRU5UX1NIT1dOJDYgPSBgc2hvd24ke0VWRU5UX0tFWSQ3fWA7XG5jb25zdCBFVkVOVF9ISURFJDYgPSBgaGlkZSR7RVZFTlRfS0VZJDd9YDtcbmNvbnN0IEVWRU5UX0hJRERFTiQ2ID0gYGhpZGRlbiR7RVZFTlRfS0VZJDd9YDtcbmNvbnN0IEVWRU5UX0NMSUNLX0RBVEFfQVBJJDQgPSBgY2xpY2ske0VWRU5UX0tFWSQ3fSR7REFUQV9BUElfS0VZJDR9YDtcbmNvbnN0IENMQVNTX05BTUVfU0hPVyQ3ID0gJ3Nob3cnO1xuY29uc3QgQ0xBU1NfTkFNRV9DT0xMQVBTRSA9ICdjb2xsYXBzZSc7XG5jb25zdCBDTEFTU19OQU1FX0NPTExBUFNJTkcgPSAnY29sbGFwc2luZyc7XG5jb25zdCBDTEFTU19OQU1FX0NPTExBUFNFRCA9ICdjb2xsYXBzZWQnO1xuY29uc3QgQ0xBU1NfTkFNRV9ERUVQRVJfQ0hJTERSRU4gPSBgOnNjb3BlIC4ke0NMQVNTX05BTUVfQ09MTEFQU0V9IC4ke0NMQVNTX05BTUVfQ09MTEFQU0V9YDtcbmNvbnN0IENMQVNTX05BTUVfSE9SSVpPTlRBTCA9ICdjb2xsYXBzZS1ob3Jpem9udGFsJztcbmNvbnN0IFdJRFRIID0gJ3dpZHRoJztcbmNvbnN0IEhFSUdIVCA9ICdoZWlnaHQnO1xuY29uc3QgU0VMRUNUT1JfQUNUSVZFUyA9ICcuY29sbGFwc2Uuc2hvdywgLmNvbGxhcHNlLmNvbGxhcHNpbmcnO1xuY29uc3QgU0VMRUNUT1JfREFUQV9UT0dHTEUkNCA9ICdbZGF0YS1icy10b2dnbGU9XCJjb2xsYXBzZVwiXSc7XG5jb25zdCBEZWZhdWx0JGEgPSB7XG4gIHBhcmVudDogbnVsbCxcbiAgdG9nZ2xlOiB0cnVlXG59O1xuY29uc3QgRGVmYXVsdFR5cGUkYSA9IHtcbiAgcGFyZW50OiAnKG51bGx8ZWxlbWVudCknLFxuICB0b2dnbGU6ICdib29sZWFuJ1xufTtcblxuLyoqXG4gKiBDbGFzcyBkZWZpbml0aW9uXG4gKi9cblxuY2xhc3MgQ29sbGFwc2UgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgc3VwZXIoZWxlbWVudCwgY29uZmlnKTtcbiAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcbiAgICB0aGlzLl90cmlnZ2VyQXJyYXkgPSBbXTtcbiAgICBjb25zdCB0b2dnbGVMaXN0ID0gU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9EQVRBX1RPR0dMRSQ0KTtcbiAgICBmb3IgKGNvbnN0IGVsZW0gb2YgdG9nZ2xlTGlzdCkge1xuICAgICAgY29uc3Qgc2VsZWN0b3IgPSBTZWxlY3RvckVuZ2luZS5nZXRTZWxlY3RvckZyb21FbGVtZW50KGVsZW0pO1xuICAgICAgY29uc3QgZmlsdGVyRWxlbWVudCA9IFNlbGVjdG9yRW5naW5lLmZpbmQoc2VsZWN0b3IpLmZpbHRlcihmb3VuZEVsZW1lbnQgPT4gZm91bmRFbGVtZW50ID09PSB0aGlzLl9lbGVtZW50KTtcbiAgICAgIGlmIChzZWxlY3RvciAhPT0gbnVsbCAmJiBmaWx0ZXJFbGVtZW50Lmxlbmd0aCkge1xuICAgICAgICB0aGlzLl90cmlnZ2VyQXJyYXkucHVzaChlbGVtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5faW5pdGlhbGl6ZUNoaWxkcmVuKCk7XG4gICAgaWYgKCF0aGlzLl9jb25maWcucGFyZW50KSB7XG4gICAgICB0aGlzLl9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3ModGhpcy5fdHJpZ2dlckFycmF5LCB0aGlzLl9pc1Nob3duKCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fY29uZmlnLnRvZ2dsZSkge1xuICAgICAgdGhpcy50b2dnbGUoKTtcbiAgICB9XG4gIH1cblxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gRGVmYXVsdCRhO1xuICB9XG4gIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgcmV0dXJuIERlZmF1bHRUeXBlJGE7XG4gIH1cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBOQU1FJGI7XG4gIH1cblxuICAvLyBQdWJsaWNcbiAgdG9nZ2xlKCkge1xuICAgIGlmICh0aGlzLl9pc1Nob3duKCkpIHtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNob3coKTtcbiAgICB9XG4gIH1cbiAgc2hvdygpIHtcbiAgICBpZiAodGhpcy5faXNUcmFuc2l0aW9uaW5nIHx8IHRoaXMuX2lzU2hvd24oKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgYWN0aXZlQ2hpbGRyZW4gPSBbXTtcblxuICAgIC8vIGZpbmQgYWN0aXZlIGNoaWxkcmVuXG4gICAgaWYgKHRoaXMuX2NvbmZpZy5wYXJlbnQpIHtcbiAgICAgIGFjdGl2ZUNoaWxkcmVuID0gdGhpcy5fZ2V0Rmlyc3RMZXZlbENoaWxkcmVuKFNFTEVDVE9SX0FDVElWRVMpLmZpbHRlcihlbGVtZW50ID0+IGVsZW1lbnQgIT09IHRoaXMuX2VsZW1lbnQpLm1hcChlbGVtZW50ID0+IENvbGxhcHNlLmdldE9yQ3JlYXRlSW5zdGFuY2UoZWxlbWVudCwge1xuICAgICAgICB0b2dnbGU6IGZhbHNlXG4gICAgICB9KSk7XG4gICAgfVxuICAgIGlmIChhY3RpdmVDaGlsZHJlbi5sZW5ndGggJiYgYWN0aXZlQ2hpbGRyZW5bMF0uX2lzVHJhbnNpdGlvbmluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzdGFydEV2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPVyQ2KTtcbiAgICBpZiAoc3RhcnRFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgYWN0aXZlSW5zdGFuY2Ugb2YgYWN0aXZlQ2hpbGRyZW4pIHtcbiAgICAgIGFjdGl2ZUluc3RhbmNlLmhpZGUoKTtcbiAgICB9XG4gICAgY29uc3QgZGltZW5zaW9uID0gdGhpcy5fZ2V0RGltZW5zaW9uKCk7XG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQ09MTEFQU0UpO1xuICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0NPTExBUFNJTkcpO1xuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbZGltZW5zaW9uXSA9IDA7XG4gICAgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKHRoaXMuX3RyaWdnZXJBcnJheSwgdHJ1ZSk7XG4gICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gdHJ1ZTtcbiAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQ09MTEFQU0lORyk7XG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9DT0xMQVBTRSwgQ0xBU1NfTkFNRV9TSE9XJDcpO1xuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gJyc7XG4gICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XTiQ2KTtcbiAgICB9O1xuICAgIGNvbnN0IGNhcGl0YWxpemVkRGltZW5zaW9uID0gZGltZW5zaW9uWzBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoMSk7XG4gICAgY29uc3Qgc2Nyb2xsU2l6ZSA9IGBzY3JvbGwke2NhcGl0YWxpemVkRGltZW5zaW9ufWA7XG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZSwgdGhpcy5fZWxlbWVudCwgdHJ1ZSk7XG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gYCR7dGhpcy5fZWxlbWVudFtzY3JvbGxTaXplXX1weGA7XG4gIH1cbiAgaGlkZSgpIHtcbiAgICBpZiAodGhpcy5faXNUcmFuc2l0aW9uaW5nIHx8ICF0aGlzLl9pc1Nob3duKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJREUkNik7XG4gICAgaWYgKHN0YXJ0RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkaW1lbnNpb24gPSB0aGlzLl9nZXREaW1lbnNpb24oKTtcbiAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2RpbWVuc2lvbl0gPSBgJHt0aGlzLl9lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2RpbWVuc2lvbl19cHhgO1xuICAgIHJlZmxvdyh0aGlzLl9lbGVtZW50KTtcbiAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9DT0xMQVBTSU5HKTtcbiAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9DT0xMQVBTRSwgQ0xBU1NfTkFNRV9TSE9XJDcpO1xuICAgIGZvciAoY29uc3QgdHJpZ2dlciBvZiB0aGlzLl90cmlnZ2VyQXJyYXkpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBTZWxlY3RvckVuZ2luZS5nZXRFbGVtZW50RnJvbVNlbGVjdG9yKHRyaWdnZXIpO1xuICAgICAgaWYgKGVsZW1lbnQgJiYgIXRoaXMuX2lzU2hvd24oZWxlbWVudCkpIHtcbiAgICAgICAgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKFt0cmlnZ2VyXSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSB0cnVlO1xuICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9DT0xMQVBTSU5HKTtcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0NPTExBUFNFKTtcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJRERFTiQ2KTtcbiAgICB9O1xuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbZGltZW5zaW9uXSA9ICcnO1xuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGUsIHRoaXMuX2VsZW1lbnQsIHRydWUpO1xuICB9XG4gIF9pc1Nob3duKGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfU0hPVyQ3KTtcbiAgfVxuXG4gIC8vIFByaXZhdGVcbiAgX2NvbmZpZ0FmdGVyTWVyZ2UoY29uZmlnKSB7XG4gICAgY29uZmlnLnRvZ2dsZSA9IEJvb2xlYW4oY29uZmlnLnRvZ2dsZSk7IC8vIENvZXJjZSBzdHJpbmcgdmFsdWVzXG4gICAgY29uZmlnLnBhcmVudCA9IGdldEVsZW1lbnQoY29uZmlnLnBhcmVudCk7XG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfVxuICBfZ2V0RGltZW5zaW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0hPUklaT05UQUwpID8gV0lEVEggOiBIRUlHSFQ7XG4gIH1cbiAgX2luaXRpYWxpemVDaGlsZHJlbigpIHtcbiAgICBpZiAoIXRoaXMuX2NvbmZpZy5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLl9nZXRGaXJzdExldmVsQ2hpbGRyZW4oU0VMRUNUT1JfREFUQV9UT0dHTEUkNCk7XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGNoaWxkcmVuKSB7XG4gICAgICBjb25zdCBzZWxlY3RlZCA9IFNlbGVjdG9yRW5naW5lLmdldEVsZW1lbnRGcm9tU2VsZWN0b3IoZWxlbWVudCk7XG4gICAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKFtlbGVtZW50XSwgdGhpcy5faXNTaG93bihzZWxlY3RlZCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBfZ2V0Rmlyc3RMZXZlbENoaWxkcmVuKHNlbGVjdG9yKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBTZWxlY3RvckVuZ2luZS5maW5kKENMQVNTX05BTUVfREVFUEVSX0NISUxEUkVOLCB0aGlzLl9jb25maWcucGFyZW50KTtcbiAgICAvLyByZW1vdmUgY2hpbGRyZW4gaWYgZ3JlYXRlciBkZXB0aFxuICAgIHJldHVybiBTZWxlY3RvckVuZ2luZS5maW5kKHNlbGVjdG9yLCB0aGlzLl9jb25maWcucGFyZW50KS5maWx0ZXIoZWxlbWVudCA9PiAhY2hpbGRyZW4uaW5jbHVkZXMoZWxlbWVudCkpO1xuICB9XG4gIF9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3ModHJpZ2dlckFycmF5LCBpc09wZW4pIHtcbiAgICBpZiAoIXRyaWdnZXJBcnJheS5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRyaWdnZXJBcnJheSkge1xuICAgICAgZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKENMQVNTX05BTUVfQ09MTEFQU0VELCAhaXNPcGVuKTtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgaXNPcGVuKTtcbiAgICB9XG4gIH1cblxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICBjb25zdCBfY29uZmlnID0ge307XG4gICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnICYmIC9zaG93fGhpZGUvLnRlc3QoY29uZmlnKSkge1xuICAgICAgX2NvbmZpZy50b2dnbGUgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCBkYXRhID0gQ29sbGFwc2UuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCBfY29uZmlnKTtcbiAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApO1xuICAgICAgICB9XG4gICAgICAgIGRhdGFbY29uZmlnXSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogRGF0YSBBUEkgaW1wbGVtZW50YXRpb25cbiAqL1xuXG5FdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJJDQsIFNFTEVDVE9SX0RBVEFfVE9HR0xFJDQsIGZ1bmN0aW9uIChldmVudCkge1xuICAvLyBwcmV2ZW50RGVmYXVsdCBvbmx5IGZvciA8YT4gZWxlbWVudHMgKHdoaWNoIGNoYW5nZSB0aGUgVVJMKSBub3QgaW5zaWRlIHRoZSBjb2xsYXBzaWJsZSBlbGVtZW50XG4gIGlmIChldmVudC50YXJnZXQudGFnTmFtZSA9PT0gJ0EnIHx8IGV2ZW50LmRlbGVnYXRlVGFyZ2V0ICYmIGV2ZW50LmRlbGVnYXRlVGFyZ2V0LnRhZ05hbWUgPT09ICdBJykge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgZm9yIChjb25zdCBlbGVtZW50IG9mIFNlbGVjdG9yRW5naW5lLmdldE11bHRpcGxlRWxlbWVudHNGcm9tU2VsZWN0b3IodGhpcykpIHtcbiAgICBDb2xsYXBzZS5nZXRPckNyZWF0ZUluc3RhbmNlKGVsZW1lbnQsIHtcbiAgICAgIHRvZ2dsZTogZmFsc2VcbiAgICB9KS50b2dnbGUoKTtcbiAgfVxufSk7XG5cbi8qKlxuICogalF1ZXJ5XG4gKi9cblxuZGVmaW5lSlF1ZXJ5UGx1Z2luKENvbGxhcHNlKTtcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwIGRyb3Bkb3duLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuLyoqXG4gKiBDb25zdGFudHNcbiAqL1xuXG5jb25zdCBOQU1FJGEgPSAnZHJvcGRvd24nO1xuY29uc3QgREFUQV9LRVkkNiA9ICdicy5kcm9wZG93bic7XG5jb25zdCBFVkVOVF9LRVkkNiA9IGAuJHtEQVRBX0tFWSQ2fWA7XG5jb25zdCBEQVRBX0FQSV9LRVkkMyA9ICcuZGF0YS1hcGknO1xuY29uc3QgRVNDQVBFX0tFWSQyID0gJ0VzY2FwZSc7XG5jb25zdCBUQUJfS0VZJDEgPSAnVGFiJztcbmNvbnN0IEFSUk9XX1VQX0tFWSQxID0gJ0Fycm93VXAnO1xuY29uc3QgQVJST1dfRE9XTl9LRVkkMSA9ICdBcnJvd0Rvd24nO1xuY29uc3QgUklHSFRfTU9VU0VfQlVUVE9OID0gMjsgLy8gTW91c2VFdmVudC5idXR0b24gdmFsdWUgZm9yIHRoZSBzZWNvbmRhcnkgYnV0dG9uLCB1c3VhbGx5IHRoZSByaWdodCBidXR0b25cblxuY29uc3QgRVZFTlRfSElERSQ1ID0gYGhpZGUke0VWRU5UX0tFWSQ2fWA7XG5jb25zdCBFVkVOVF9ISURERU4kNSA9IGBoaWRkZW4ke0VWRU5UX0tFWSQ2fWA7XG5jb25zdCBFVkVOVF9TSE9XJDUgPSBgc2hvdyR7RVZFTlRfS0VZJDZ9YDtcbmNvbnN0IEVWRU5UX1NIT1dOJDUgPSBgc2hvd24ke0VWRU5UX0tFWSQ2fWA7XG5jb25zdCBFVkVOVF9DTElDS19EQVRBX0FQSSQzID0gYGNsaWNrJHtFVkVOVF9LRVkkNn0ke0RBVEFfQVBJX0tFWSQzfWA7XG5jb25zdCBFVkVOVF9LRVlET1dOX0RBVEFfQVBJID0gYGtleWRvd24ke0VWRU5UX0tFWSQ2fSR7REFUQV9BUElfS0VZJDN9YDtcbmNvbnN0IEVWRU5UX0tFWVVQX0RBVEFfQVBJID0gYGtleXVwJHtFVkVOVF9LRVkkNn0ke0RBVEFfQVBJX0tFWSQzfWA7XG5jb25zdCBDTEFTU19OQU1FX1NIT1ckNiA9ICdzaG93JztcbmNvbnN0IENMQVNTX05BTUVfRFJPUFVQID0gJ2Ryb3B1cCc7XG5jb25zdCBDTEFTU19OQU1FX0RST1BFTkQgPSAnZHJvcGVuZCc7XG5jb25zdCBDTEFTU19OQU1FX0RST1BTVEFSVCA9ICdkcm9wc3RhcnQnO1xuY29uc3QgQ0xBU1NfTkFNRV9EUk9QVVBfQ0VOVEVSID0gJ2Ryb3B1cC1jZW50ZXInO1xuY29uc3QgQ0xBU1NfTkFNRV9EUk9QRE9XTl9DRU5URVIgPSAnZHJvcGRvd24tY2VudGVyJztcbmNvbnN0IFNFTEVDVE9SX0RBVEFfVE9HR0xFJDMgPSAnW2RhdGEtYnMtdG9nZ2xlPVwiZHJvcGRvd25cIl06bm90KC5kaXNhYmxlZCk6bm90KDpkaXNhYmxlZCknO1xuY29uc3QgU0VMRUNUT1JfREFUQV9UT0dHTEVfU0hPV04gPSBgJHtTRUxFQ1RPUl9EQVRBX1RPR0dMRSQzfS4ke0NMQVNTX05BTUVfU0hPVyQ2fWA7XG5jb25zdCBTRUxFQ1RPUl9NRU5VID0gJy5kcm9wZG93bi1tZW51JztcbmNvbnN0IFNFTEVDVE9SX05BVkJBUiA9ICcubmF2YmFyJztcbmNvbnN0IFNFTEVDVE9SX05BVkJBUl9OQVYgPSAnLm5hdmJhci1uYXYnO1xuY29uc3QgU0VMRUNUT1JfVklTSUJMRV9JVEVNUyA9ICcuZHJvcGRvd24tbWVudSAuZHJvcGRvd24taXRlbTpub3QoLmRpc2FibGVkKTpub3QoOmRpc2FibGVkKSc7XG5jb25zdCBQTEFDRU1FTlRfVE9QID0gaXNSVEwoKSA/ICd0b3AtZW5kJyA6ICd0b3Atc3RhcnQnO1xuY29uc3QgUExBQ0VNRU5UX1RPUEVORCA9IGlzUlRMKCkgPyAndG9wLXN0YXJ0JyA6ICd0b3AtZW5kJztcbmNvbnN0IFBMQUNFTUVOVF9CT1RUT00gPSBpc1JUTCgpID8gJ2JvdHRvbS1lbmQnIDogJ2JvdHRvbS1zdGFydCc7XG5jb25zdCBQTEFDRU1FTlRfQk9UVE9NRU5EID0gaXNSVEwoKSA/ICdib3R0b20tc3RhcnQnIDogJ2JvdHRvbS1lbmQnO1xuY29uc3QgUExBQ0VNRU5UX1JJR0hUID0gaXNSVEwoKSA/ICdsZWZ0LXN0YXJ0JyA6ICdyaWdodC1zdGFydCc7XG5jb25zdCBQTEFDRU1FTlRfTEVGVCA9IGlzUlRMKCkgPyAncmlnaHQtc3RhcnQnIDogJ2xlZnQtc3RhcnQnO1xuY29uc3QgUExBQ0VNRU5UX1RPUENFTlRFUiA9ICd0b3AnO1xuY29uc3QgUExBQ0VNRU5UX0JPVFRPTUNFTlRFUiA9ICdib3R0b20nO1xuY29uc3QgRGVmYXVsdCQ5ID0ge1xuICBhdXRvQ2xvc2U6IHRydWUsXG4gIGJvdW5kYXJ5OiAnY2xpcHBpbmdQYXJlbnRzJyxcbiAgZGlzcGxheTogJ2R5bmFtaWMnLFxuICBvZmZzZXQ6IFswLCAyXSxcbiAgcG9wcGVyQ29uZmlnOiBudWxsLFxuICByZWZlcmVuY2U6ICd0b2dnbGUnXG59O1xuY29uc3QgRGVmYXVsdFR5cGUkOSA9IHtcbiAgYXV0b0Nsb3NlOiAnKGJvb2xlYW58c3RyaW5nKScsXG4gIGJvdW5kYXJ5OiAnKHN0cmluZ3xlbGVtZW50KScsXG4gIGRpc3BsYXk6ICdzdHJpbmcnLFxuICBvZmZzZXQ6ICcoYXJyYXl8c3RyaW5nfGZ1bmN0aW9uKScsXG4gIHBvcHBlckNvbmZpZzogJyhudWxsfG9iamVjdHxmdW5jdGlvbiknLFxuICByZWZlcmVuY2U6ICcoc3RyaW5nfGVsZW1lbnR8b2JqZWN0KSdcbn07XG5cbi8qKlxuICogQ2xhc3MgZGVmaW5pdGlvblxuICovXG5cbmNsYXNzIERyb3Bkb3duIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZykge1xuICAgIHN1cGVyKGVsZW1lbnQsIGNvbmZpZyk7XG4gICAgdGhpcy5fcG9wcGVyID0gbnVsbDtcbiAgICB0aGlzLl9wYXJlbnQgPSB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGU7IC8vIGRyb3Bkb3duIHdyYXBwZXJcbiAgICAvLyBUT0RPOiB2NiByZXZlcnQgIzM3MDExICYgY2hhbmdlIG1hcmt1cCBodHRwczovL2dldGJvb3RzdHJhcC5jb20vZG9jcy81LjMvZm9ybXMvaW5wdXQtZ3JvdXAvXG4gICAgdGhpcy5fbWVudSA9IFNlbGVjdG9yRW5naW5lLm5leHQodGhpcy5fZWxlbWVudCwgU0VMRUNUT1JfTUVOVSlbMF0gfHwgU2VsZWN0b3JFbmdpbmUucHJldih0aGlzLl9lbGVtZW50LCBTRUxFQ1RPUl9NRU5VKVswXSB8fCBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX01FTlUsIHRoaXMuX3BhcmVudCk7XG4gICAgdGhpcy5faW5OYXZiYXIgPSB0aGlzLl9kZXRlY3ROYXZiYXIoKTtcbiAgfVxuXG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBEZWZhdWx0JDk7XG4gIH1cbiAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICByZXR1cm4gRGVmYXVsdFR5cGUkOTtcbiAgfVxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIE5BTUUkYTtcbiAgfVxuXG4gIC8vIFB1YmxpY1xuICB0b2dnbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzU2hvd24oKSA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG93KCk7XG4gIH1cbiAgc2hvdygpIHtcbiAgICBpZiAoaXNEaXNhYmxlZCh0aGlzLl9lbGVtZW50KSB8fCB0aGlzLl9pc1Nob3duKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVsYXRlZFRhcmdldCA9IHtcbiAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRoaXMuX2VsZW1lbnRcbiAgICB9O1xuICAgIGNvbnN0IHNob3dFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1ckNSwgcmVsYXRlZFRhcmdldCk7XG4gICAgaWYgKHNob3dFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2NyZWF0ZVBvcHBlcigpO1xuXG4gICAgLy8gSWYgdGhpcyBpcyBhIHRvdWNoLWVuYWJsZWQgZGV2aWNlIHdlIGFkZCBleHRyYVxuICAgIC8vIGVtcHR5IG1vdXNlb3ZlciBsaXN0ZW5lcnMgdG8gdGhlIGJvZHkncyBpbW1lZGlhdGUgY2hpbGRyZW47XG4gICAgLy8gb25seSBuZWVkZWQgYmVjYXVzZSBvZiBicm9rZW4gZXZlbnQgZGVsZWdhdGlvbiBvbiBpT1NcbiAgICAvLyBodHRwczovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTQvMDIvbW91c2VfZXZlbnRfYnViLmh0bWxcbiAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmICF0aGlzLl9wYXJlbnQuY2xvc2VzdChTRUxFQ1RPUl9OQVZCQVJfTkFWKSkge1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIFtdLmNvbmNhdCguLi5kb2N1bWVudC5ib2R5LmNoaWxkcmVuKSkge1xuICAgICAgICBFdmVudEhhbmRsZXIub24oZWxlbWVudCwgJ21vdXNlb3ZlcicsIG5vb3ApO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9lbGVtZW50LmZvY3VzKCk7XG4gICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCB0cnVlKTtcbiAgICB0aGlzLl9tZW51LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XJDYpO1xuICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1ckNik7XG4gICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPV04kNSwgcmVsYXRlZFRhcmdldCk7XG4gIH1cbiAgaGlkZSgpIHtcbiAgICBpZiAoaXNEaXNhYmxlZCh0aGlzLl9lbGVtZW50KSB8fCAhdGhpcy5faXNTaG93bigpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlbGF0ZWRUYXJnZXQgPSB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiB0aGlzLl9lbGVtZW50XG4gICAgfTtcbiAgICB0aGlzLl9jb21wbGV0ZUhpZGUocmVsYXRlZFRhcmdldCk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBpZiAodGhpcy5fcG9wcGVyKSB7XG4gICAgICB0aGlzLl9wb3BwZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICBzdXBlci5kaXNwb3NlKCk7XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIHRoaXMuX2luTmF2YmFyID0gdGhpcy5fZGV0ZWN0TmF2YmFyKCk7XG4gICAgaWYgKHRoaXMuX3BvcHBlcikge1xuICAgICAgdGhpcy5fcG9wcGVyLnVwZGF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFByaXZhdGVcbiAgX2NvbXBsZXRlSGlkZShyZWxhdGVkVGFyZ2V0KSB7XG4gICAgY29uc3QgaGlkZUV2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElERSQ1LCByZWxhdGVkVGFyZ2V0KTtcbiAgICBpZiAoaGlkZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGlzIGlzIGEgdG91Y2gtZW5hYmxlZCBkZXZpY2Ugd2UgcmVtb3ZlIHRoZSBleHRyYVxuICAgIC8vIGVtcHR5IG1vdXNlb3ZlciBsaXN0ZW5lcnMgd2UgYWRkZWQgZm9yIGlPUyBzdXBwb3J0XG4gICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIFtdLmNvbmNhdCguLi5kb2N1bWVudC5ib2R5LmNoaWxkcmVuKSkge1xuICAgICAgICBFdmVudEhhbmRsZXIub2ZmKGVsZW1lbnQsICdtb3VzZW92ZXInLCBub29wKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuX3BvcHBlcikge1xuICAgICAgdGhpcy5fcG9wcGVyLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5fbWVudS5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVyQ2KTtcbiAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XJDYpO1xuICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgJ2ZhbHNlJyk7XG4gICAgTWFuaXB1bGF0b3IucmVtb3ZlRGF0YUF0dHJpYnV0ZSh0aGlzLl9tZW51LCAncG9wcGVyJyk7XG4gICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElEREVOJDUsIHJlbGF0ZWRUYXJnZXQpO1xuICB9XG4gIF9nZXRDb25maWcoY29uZmlnKSB7XG4gICAgY29uZmlnID0gc3VwZXIuX2dldENvbmZpZyhjb25maWcpO1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZmVyZW5jZSA9PT0gJ29iamVjdCcgJiYgIWlzRWxlbWVudChjb25maWcucmVmZXJlbmNlKSAmJiB0eXBlb2YgY29uZmlnLnJlZmVyZW5jZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIFBvcHBlciB2aXJ0dWFsIGVsZW1lbnRzIHJlcXVpcmUgYSBnZXRCb3VuZGluZ0NsaWVudFJlY3QgbWV0aG9kXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke05BTUUkYS50b1VwcGVyQ2FzZSgpfTogT3B0aW9uIFwicmVmZXJlbmNlXCIgcHJvdmlkZWQgdHlwZSBcIm9iamVjdFwiIHdpdGhvdXQgYSByZXF1aXJlZCBcImdldEJvdW5kaW5nQ2xpZW50UmVjdFwiIG1ldGhvZC5gKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfVxuICBfY3JlYXRlUG9wcGVyKCkge1xuICAgIGlmICh0eXBlb2YgUG9wcGVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9vdHN0cmFwXFwncyBkcm9wZG93bnMgcmVxdWlyZSBQb3BwZXIgKGh0dHBzOi8vcG9wcGVyLmpzLm9yZyknKTtcbiAgICB9XG4gICAgbGV0IHJlZmVyZW5jZUVsZW1lbnQgPSB0aGlzLl9lbGVtZW50O1xuICAgIGlmICh0aGlzLl9jb25maWcucmVmZXJlbmNlID09PSAncGFyZW50Jykge1xuICAgICAgcmVmZXJlbmNlRWxlbWVudCA9IHRoaXMuX3BhcmVudDtcbiAgICB9IGVsc2UgaWYgKGlzRWxlbWVudCh0aGlzLl9jb25maWcucmVmZXJlbmNlKSkge1xuICAgICAgcmVmZXJlbmNlRWxlbWVudCA9IGdldEVsZW1lbnQodGhpcy5fY29uZmlnLnJlZmVyZW5jZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5fY29uZmlnLnJlZmVyZW5jZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJlZmVyZW5jZUVsZW1lbnQgPSB0aGlzLl9jb25maWcucmVmZXJlbmNlO1xuICAgIH1cbiAgICBjb25zdCBwb3BwZXJDb25maWcgPSB0aGlzLl9nZXRQb3BwZXJDb25maWcoKTtcbiAgICB0aGlzLl9wb3BwZXIgPSBQb3BwZXIuY3JlYXRlUG9wcGVyKHJlZmVyZW5jZUVsZW1lbnQsIHRoaXMuX21lbnUsIHBvcHBlckNvbmZpZyk7XG4gIH1cbiAgX2lzU2hvd24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21lbnUuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfU0hPVyQ2KTtcbiAgfVxuICBfZ2V0UGxhY2VtZW50KCkge1xuICAgIGNvbnN0IHBhcmVudERyb3Bkb3duID0gdGhpcy5fcGFyZW50O1xuICAgIGlmIChwYXJlbnREcm9wZG93bi5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9EUk9QRU5EKSkge1xuICAgICAgcmV0dXJuIFBMQUNFTUVOVF9SSUdIVDtcbiAgICB9XG4gICAgaWYgKHBhcmVudERyb3Bkb3duLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0RST1BTVEFSVCkpIHtcbiAgICAgIHJldHVybiBQTEFDRU1FTlRfTEVGVDtcbiAgICB9XG4gICAgaWYgKHBhcmVudERyb3Bkb3duLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0RST1BVUF9DRU5URVIpKSB7XG4gICAgICByZXR1cm4gUExBQ0VNRU5UX1RPUENFTlRFUjtcbiAgICB9XG4gICAgaWYgKHBhcmVudERyb3Bkb3duLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0RST1BET1dOX0NFTlRFUikpIHtcbiAgICAgIHJldHVybiBQTEFDRU1FTlRfQk9UVE9NQ0VOVEVSO1xuICAgIH1cblxuICAgIC8vIFdlIG5lZWQgdG8gdHJpbSB0aGUgdmFsdWUgYmVjYXVzZSBjdXN0b20gcHJvcGVydGllcyBjYW4gYWxzbyBpbmNsdWRlIHNwYWNlc1xuICAgIGNvbnN0IGlzRW5kID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLl9tZW51KS5nZXRQcm9wZXJ0eVZhbHVlKCctLWJzLXBvc2l0aW9uJykudHJpbSgpID09PSAnZW5kJztcbiAgICBpZiAocGFyZW50RHJvcGRvd24uY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRFJPUFVQKSkge1xuICAgICAgcmV0dXJuIGlzRW5kID8gUExBQ0VNRU5UX1RPUEVORCA6IFBMQUNFTUVOVF9UT1A7XG4gICAgfVxuICAgIHJldHVybiBpc0VuZCA/IFBMQUNFTUVOVF9CT1RUT01FTkQgOiBQTEFDRU1FTlRfQk9UVE9NO1xuICB9XG4gIF9kZXRlY3ROYXZiYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQuY2xvc2VzdChTRUxFQ1RPUl9OQVZCQVIpICE9PSBudWxsO1xuICB9XG4gIF9nZXRPZmZzZXQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgb2Zmc2V0XG4gICAgfSA9IHRoaXMuX2NvbmZpZztcbiAgICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBvZmZzZXQuc3BsaXQoJywnKS5tYXAodmFsdWUgPT4gTnVtYmVyLnBhcnNlSW50KHZhbHVlLCAxMCkpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHBvcHBlckRhdGEgPT4gb2Zmc2V0KHBvcHBlckRhdGEsIHRoaXMuX2VsZW1lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG4gIF9nZXRQb3BwZXJDb25maWcoKSB7XG4gICAgY29uc3QgZGVmYXVsdEJzUG9wcGVyQ29uZmlnID0ge1xuICAgICAgcGxhY2VtZW50OiB0aGlzLl9nZXRQbGFjZW1lbnQoKSxcbiAgICAgIG1vZGlmaWVyczogW3tcbiAgICAgICAgbmFtZTogJ3ByZXZlbnRPdmVyZmxvdycsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBib3VuZGFyeTogdGhpcy5fY29uZmlnLmJvdW5kYXJ5XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAgbmFtZTogJ29mZnNldCcsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBvZmZzZXQ6IHRoaXMuX2dldE9mZnNldCgpXG4gICAgICAgIH1cbiAgICAgIH1dXG4gICAgfTtcblxuICAgIC8vIERpc2FibGUgUG9wcGVyIGlmIHdlIGhhdmUgYSBzdGF0aWMgZGlzcGxheSBvciBEcm9wZG93biBpcyBpbiBOYXZiYXJcbiAgICBpZiAodGhpcy5faW5OYXZiYXIgfHwgdGhpcy5fY29uZmlnLmRpc3BsYXkgPT09ICdzdGF0aWMnKSB7XG4gICAgICBNYW5pcHVsYXRvci5zZXREYXRhQXR0cmlidXRlKHRoaXMuX21lbnUsICdwb3BwZXInLCAnc3RhdGljJyk7IC8vIFRPRE86IHY2IHJlbW92ZVxuICAgICAgZGVmYXVsdEJzUG9wcGVyQ29uZmlnLm1vZGlmaWVycyA9IFt7XG4gICAgICAgIG5hbWU6ICdhcHBseVN0eWxlcycsXG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICB9XTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRlZmF1bHRCc1BvcHBlckNvbmZpZyxcbiAgICAgIC4uLmV4ZWN1dGUodGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZywgW2RlZmF1bHRCc1BvcHBlckNvbmZpZ10pXG4gICAgfTtcbiAgfVxuICBfc2VsZWN0TWVudUl0ZW0oe1xuICAgIGtleSxcbiAgICB0YXJnZXRcbiAgfSkge1xuICAgIGNvbnN0IGl0ZW1zID0gU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9WSVNJQkxFX0lURU1TLCB0aGlzLl9tZW51KS5maWx0ZXIoZWxlbWVudCA9PiBpc1Zpc2libGUoZWxlbWVudCkpO1xuICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gaWYgdGFyZ2V0IGlzbid0IGluY2x1ZGVkIGluIGl0ZW1zIChlLmcuIHdoZW4gZXhwYW5kaW5nIHRoZSBkcm9wZG93bilcbiAgICAvLyBhbGxvdyBjeWNsaW5nIHRvIGdldCB0aGUgbGFzdCBpdGVtIGluIGNhc2Uga2V5IGVxdWFscyBBUlJPV19VUF9LRVlcbiAgICBnZXROZXh0QWN0aXZlRWxlbWVudChpdGVtcywgdGFyZ2V0LCBrZXkgPT09IEFSUk9XX0RPV05fS0VZJDEsICFpdGVtcy5pbmNsdWRlcyh0YXJnZXQpKS5mb2N1cygpO1xuICB9XG5cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCBkYXRhID0gRHJvcGRvd24uZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCBjb25maWcpO1xuICAgICAgaWYgKHR5cGVvZiBjb25maWcgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApO1xuICAgICAgfVxuICAgICAgZGF0YVtjb25maWddKCk7XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGNsZWFyTWVudXMoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuYnV0dG9uID09PSBSSUdIVF9NT1VTRV9CVVRUT04gfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJyAmJiBldmVudC5rZXkgIT09IFRBQl9LRVkkMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvcGVuVG9nZ2xlcyA9IFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfREFUQV9UT0dHTEVfU0hPV04pO1xuICAgIGZvciAoY29uc3QgdG9nZ2xlIG9mIG9wZW5Ub2dnbGVzKSB7XG4gICAgICBjb25zdCBjb250ZXh0ID0gRHJvcGRvd24uZ2V0SW5zdGFuY2UodG9nZ2xlKTtcbiAgICAgIGlmICghY29udGV4dCB8fCBjb250ZXh0Ll9jb25maWcuYXV0b0Nsb3NlID09PSBmYWxzZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbXBvc2VkUGF0aCA9IGV2ZW50LmNvbXBvc2VkUGF0aCgpO1xuICAgICAgY29uc3QgaXNNZW51VGFyZ2V0ID0gY29tcG9zZWRQYXRoLmluY2x1ZGVzKGNvbnRleHQuX21lbnUpO1xuICAgICAgaWYgKGNvbXBvc2VkUGF0aC5pbmNsdWRlcyhjb250ZXh0Ll9lbGVtZW50KSB8fCBjb250ZXh0Ll9jb25maWcuYXV0b0Nsb3NlID09PSAnaW5zaWRlJyAmJiAhaXNNZW51VGFyZ2V0IHx8IGNvbnRleHQuX2NvbmZpZy5hdXRvQ2xvc2UgPT09ICdvdXRzaWRlJyAmJiBpc01lbnVUYXJnZXQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFRhYiBuYXZpZ2F0aW9uIHRocm91Z2ggdGhlIGRyb3Bkb3duIG1lbnUgb3IgZXZlbnRzIGZyb20gY29udGFpbmVkIGlucHV0cyBzaG91bGRuJ3QgY2xvc2UgdGhlIG1lbnVcbiAgICAgIGlmIChjb250ZXh0Ll9tZW51LmNvbnRhaW5zKGV2ZW50LnRhcmdldCkgJiYgKGV2ZW50LnR5cGUgPT09ICdrZXl1cCcgJiYgZXZlbnQua2V5ID09PSBUQUJfS0VZJDEgfHwgL2lucHV0fHNlbGVjdHxvcHRpb258dGV4dGFyZWF8Zm9ybS9pLnRlc3QoZXZlbnQudGFyZ2V0LnRhZ05hbWUpKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlbGF0ZWRUYXJnZXQgPSB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IGNvbnRleHQuX2VsZW1lbnRcbiAgICAgIH07XG4gICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2NsaWNrJykge1xuICAgICAgICByZWxhdGVkVGFyZ2V0LmNsaWNrRXZlbnQgPSBldmVudDtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuX2NvbXBsZXRlSGlkZShyZWxhdGVkVGFyZ2V0KTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGRhdGFBcGlLZXlkb3duSGFuZGxlcihldmVudCkge1xuICAgIC8vIElmIG5vdCBhbiBVUCB8IERPV04gfCBFU0NBUEUga2V5ID0+IG5vdCBhIGRyb3Bkb3duIGNvbW1hbmRcbiAgICAvLyBJZiBpbnB1dC90ZXh0YXJlYSAmJiBpZiBrZXkgaXMgb3RoZXIgdGhhbiBFU0NBUEUgPT4gbm90IGEgZHJvcGRvd24gY29tbWFuZFxuXG4gICAgY29uc3QgaXNJbnB1dCA9IC9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QoZXZlbnQudGFyZ2V0LnRhZ05hbWUpO1xuICAgIGNvbnN0IGlzRXNjYXBlRXZlbnQgPSBldmVudC5rZXkgPT09IEVTQ0FQRV9LRVkkMjtcbiAgICBjb25zdCBpc1VwT3JEb3duRXZlbnQgPSBbQVJST1dfVVBfS0VZJDEsIEFSUk9XX0RPV05fS0VZJDFdLmluY2x1ZGVzKGV2ZW50LmtleSk7XG4gICAgaWYgKCFpc1VwT3JEb3duRXZlbnQgJiYgIWlzRXNjYXBlRXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzSW5wdXQgJiYgIWlzRXNjYXBlRXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgIC8vIFRPRE86IHY2IHJldmVydCAjMzcwMTEgJiBjaGFuZ2UgbWFya3VwIGh0dHBzOi8vZ2V0Ym9vdHN0cmFwLmNvbS9kb2NzLzUuMy9mb3Jtcy9pbnB1dC1ncm91cC9cbiAgICBjb25zdCBnZXRUb2dnbGVCdXR0b24gPSB0aGlzLm1hdGNoZXMoU0VMRUNUT1JfREFUQV9UT0dHTEUkMykgPyB0aGlzIDogU2VsZWN0b3JFbmdpbmUucHJldih0aGlzLCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQzKVswXSB8fCBTZWxlY3RvckVuZ2luZS5uZXh0KHRoaXMsIFNFTEVDVE9SX0RBVEFfVE9HR0xFJDMpWzBdIHx8IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfREFUQV9UT0dHTEUkMywgZXZlbnQuZGVsZWdhdGVUYXJnZXQucGFyZW50Tm9kZSk7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBEcm9wZG93bi5nZXRPckNyZWF0ZUluc3RhbmNlKGdldFRvZ2dsZUJ1dHRvbik7XG4gICAgaWYgKGlzVXBPckRvd25FdmVudCkge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBpbnN0YW5jZS5zaG93KCk7XG4gICAgICBpbnN0YW5jZS5fc2VsZWN0TWVudUl0ZW0oZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaW5zdGFuY2UuX2lzU2hvd24oKSkge1xuICAgICAgLy8gZWxzZSBpcyBlc2NhcGUgYW5kIHdlIGNoZWNrIGlmIGl0IGlzIHNob3duXG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGluc3RhbmNlLmhpZGUoKTtcbiAgICAgIGdldFRvZ2dsZUJ1dHRvbi5mb2N1cygpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIERhdGEgQVBJIGltcGxlbWVudGF0aW9uXG4gKi9cblxuRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9LRVlET1dOX0RBVEFfQVBJLCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQzLCBEcm9wZG93bi5kYXRhQXBpS2V5ZG93bkhhbmRsZXIpO1xuRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9LRVlET1dOX0RBVEFfQVBJLCBTRUxFQ1RPUl9NRU5VLCBEcm9wZG93bi5kYXRhQXBpS2V5ZG93bkhhbmRsZXIpO1xuRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9DTElDS19EQVRBX0FQSSQzLCBEcm9wZG93bi5jbGVhck1lbnVzKTtcbkV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfS0VZVVBfREFUQV9BUEksIERyb3Bkb3duLmNsZWFyTWVudXMpO1xuRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9DTElDS19EQVRBX0FQSSQzLCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQzLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgRHJvcGRvd24uZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzKS50b2dnbGUoKTtcbn0pO1xuXG4vKipcbiAqIGpRdWVyeVxuICovXG5cbmRlZmluZUpRdWVyeVBsdWdpbihEcm9wZG93bik7XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCB1dGlsL2JhY2tkcm9wLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuLyoqXG4gKiBDb25zdGFudHNcbiAqL1xuXG5jb25zdCBOQU1FJDkgPSAnYmFja2Ryb3AnO1xuY29uc3QgQ0xBU1NfTkFNRV9GQURFJDQgPSAnZmFkZSc7XG5jb25zdCBDTEFTU19OQU1FX1NIT1ckNSA9ICdzaG93JztcbmNvbnN0IEVWRU5UX01PVVNFRE9XTiA9IGBtb3VzZWRvd24uYnMuJHtOQU1FJDl9YDtcbmNvbnN0IERlZmF1bHQkOCA9IHtcbiAgY2xhc3NOYW1lOiAnbW9kYWwtYmFja2Ryb3AnLFxuICBjbGlja0NhbGxiYWNrOiBudWxsLFxuICBpc0FuaW1hdGVkOiBmYWxzZSxcbiAgaXNWaXNpYmxlOiB0cnVlLFxuICAvLyBpZiBmYWxzZSwgd2UgdXNlIHRoZSBiYWNrZHJvcCBoZWxwZXIgd2l0aG91dCBhZGRpbmcgYW55IGVsZW1lbnQgdG8gdGhlIGRvbVxuICByb290RWxlbWVudDogJ2JvZHknIC8vIGdpdmUgdGhlIGNob2ljZSB0byBwbGFjZSBiYWNrZHJvcCB1bmRlciBkaWZmZXJlbnQgZWxlbWVudHNcbn07XG5cbmNvbnN0IERlZmF1bHRUeXBlJDggPSB7XG4gIGNsYXNzTmFtZTogJ3N0cmluZycsXG4gIGNsaWNrQ2FsbGJhY2s6ICcoZnVuY3Rpb258bnVsbCknLFxuICBpc0FuaW1hdGVkOiAnYm9vbGVhbicsXG4gIGlzVmlzaWJsZTogJ2Jvb2xlYW4nLFxuICByb290RWxlbWVudDogJyhlbGVtZW50fHN0cmluZyknXG59O1xuXG4vKipcbiAqIENsYXNzIGRlZmluaXRpb25cbiAqL1xuXG5jbGFzcyBCYWNrZHJvcCBleHRlbmRzIENvbmZpZyB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZyk7XG4gICAgdGhpcy5faXNBcHBlbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICB9XG5cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIERlZmF1bHQkODtcbiAgfVxuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgIHJldHVybiBEZWZhdWx0VHlwZSQ4O1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gTkFNRSQ5O1xuICB9XG5cbiAgLy8gUHVibGljXG4gIHNob3coY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuX2NvbmZpZy5pc1Zpc2libGUpIHtcbiAgICAgIGV4ZWN1dGUoY2FsbGJhY2spO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9hcHBlbmQoKTtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fZ2V0RWxlbWVudCgpO1xuICAgIGlmICh0aGlzLl9jb25maWcuaXNBbmltYXRlZCkge1xuICAgICAgcmVmbG93KGVsZW1lbnQpO1xuICAgIH1cbiAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XJDUpO1xuICAgIHRoaXMuX2VtdWxhdGVBbmltYXRpb24oKCkgPT4ge1xuICAgICAgZXhlY3V0ZShjYWxsYmFjayk7XG4gICAgfSk7XG4gIH1cbiAgaGlkZShjYWxsYmFjaykge1xuICAgIGlmICghdGhpcy5fY29uZmlnLmlzVmlzaWJsZSkge1xuICAgICAgZXhlY3V0ZShjYWxsYmFjayk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2dldEVsZW1lbnQoKS5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVyQ1KTtcbiAgICB0aGlzLl9lbXVsYXRlQW5pbWF0aW9uKCgpID0+IHtcbiAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgZXhlY3V0ZShjYWxsYmFjayk7XG4gICAgfSk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBpZiAoIXRoaXMuX2lzQXBwZW5kZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgRXZlbnRIYW5kbGVyLm9mZih0aGlzLl9lbGVtZW50LCBFVkVOVF9NT1VTRURPV04pO1xuICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlKCk7XG4gICAgdGhpcy5faXNBcHBlbmRlZCA9IGZhbHNlO1xuICB9XG5cbiAgLy8gUHJpdmF0ZVxuICBfZ2V0RWxlbWVudCgpIHtcbiAgICBpZiAoIXRoaXMuX2VsZW1lbnQpIHtcbiAgICAgIGNvbnN0IGJhY2tkcm9wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBiYWNrZHJvcC5jbGFzc05hbWUgPSB0aGlzLl9jb25maWcuY2xhc3NOYW1lO1xuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5pc0FuaW1hdGVkKSB7XG4gICAgICAgIGJhY2tkcm9wLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9GQURFJDQpO1xuICAgICAgfVxuICAgICAgdGhpcy5fZWxlbWVudCA9IGJhY2tkcm9wO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudDtcbiAgfVxuICBfY29uZmlnQWZ0ZXJNZXJnZShjb25maWcpIHtcbiAgICAvLyB1c2UgZ2V0RWxlbWVudCgpIHdpdGggdGhlIGRlZmF1bHQgXCJib2R5XCIgdG8gZ2V0IGEgZnJlc2ggRWxlbWVudCBvbiBlYWNoIGluc3RhbnRpYXRpb25cbiAgICBjb25maWcucm9vdEVsZW1lbnQgPSBnZXRFbGVtZW50KGNvbmZpZy5yb290RWxlbWVudCk7XG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfVxuICBfYXBwZW5kKCkge1xuICAgIGlmICh0aGlzLl9pc0FwcGVuZGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9nZXRFbGVtZW50KCk7XG4gICAgdGhpcy5fY29uZmlnLnJvb3RFbGVtZW50LmFwcGVuZChlbGVtZW50KTtcbiAgICBFdmVudEhhbmRsZXIub24oZWxlbWVudCwgRVZFTlRfTU9VU0VET1dOLCAoKSA9PiB7XG4gICAgICBleGVjdXRlKHRoaXMuX2NvbmZpZy5jbGlja0NhbGxiYWNrKTtcbiAgICB9KTtcbiAgICB0aGlzLl9pc0FwcGVuZGVkID0gdHJ1ZTtcbiAgfVxuICBfZW11bGF0ZUFuaW1hdGlvbihjYWxsYmFjaykge1xuICAgIGV4ZWN1dGVBZnRlclRyYW5zaXRpb24oY2FsbGJhY2ssIHRoaXMuX2dldEVsZW1lbnQoKSwgdGhpcy5fY29uZmlnLmlzQW5pbWF0ZWQpO1xuICB9XG59XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCB1dGlsL2ZvY3VzdHJhcC5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbi8qKlxuICogQ29uc3RhbnRzXG4gKi9cblxuY29uc3QgTkFNRSQ4ID0gJ2ZvY3VzdHJhcCc7XG5jb25zdCBEQVRBX0tFWSQ1ID0gJ2JzLmZvY3VzdHJhcCc7XG5jb25zdCBFVkVOVF9LRVkkNSA9IGAuJHtEQVRBX0tFWSQ1fWA7XG5jb25zdCBFVkVOVF9GT0NVU0lOJDIgPSBgZm9jdXNpbiR7RVZFTlRfS0VZJDV9YDtcbmNvbnN0IEVWRU5UX0tFWURPV05fVEFCID0gYGtleWRvd24udGFiJHtFVkVOVF9LRVkkNX1gO1xuY29uc3QgVEFCX0tFWSA9ICdUYWInO1xuY29uc3QgVEFCX05BVl9GT1JXQVJEID0gJ2ZvcndhcmQnO1xuY29uc3QgVEFCX05BVl9CQUNLV0FSRCA9ICdiYWNrd2FyZCc7XG5jb25zdCBEZWZhdWx0JDcgPSB7XG4gIGF1dG9mb2N1czogdHJ1ZSxcbiAgdHJhcEVsZW1lbnQ6IG51bGwgLy8gVGhlIGVsZW1lbnQgdG8gdHJhcCBmb2N1cyBpbnNpZGUgb2Zcbn07XG5cbmNvbnN0IERlZmF1bHRUeXBlJDcgPSB7XG4gIGF1dG9mb2N1czogJ2Jvb2xlYW4nLFxuICB0cmFwRWxlbWVudDogJ2VsZW1lbnQnXG59O1xuXG4vKipcbiAqIENsYXNzIGRlZmluaXRpb25cbiAqL1xuXG5jbGFzcyBGb2N1c1RyYXAgZXh0ZW5kcyBDb25maWcge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpO1xuICAgIHRoaXMuX2lzQWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5fbGFzdFRhYk5hdkRpcmVjdGlvbiA9IG51bGw7XG4gIH1cblxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gRGVmYXVsdCQ3O1xuICB9XG4gIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgcmV0dXJuIERlZmF1bHRUeXBlJDc7XG4gIH1cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBOQU1FJDg7XG4gIH1cblxuICAvLyBQdWJsaWNcbiAgYWN0aXZhdGUoKSB7XG4gICAgaWYgKHRoaXMuX2lzQWN0aXZlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9jb25maWcuYXV0b2ZvY3VzKSB7XG4gICAgICB0aGlzLl9jb25maWcudHJhcEVsZW1lbnQuZm9jdXMoKTtcbiAgICB9XG4gICAgRXZlbnRIYW5kbGVyLm9mZihkb2N1bWVudCwgRVZFTlRfS0VZJDUpOyAvLyBndWFyZCBhZ2FpbnN0IGluZmluaXRlIGZvY3VzIGxvb3BcbiAgICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0ZPQ1VTSU4kMiwgZXZlbnQgPT4gdGhpcy5faGFuZGxlRm9jdXNpbihldmVudCkpO1xuICAgIEV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfS0VZRE9XTl9UQUIsIGV2ZW50ID0+IHRoaXMuX2hhbmRsZUtleWRvd24oZXZlbnQpKTtcbiAgICB0aGlzLl9pc0FjdGl2ZSA9IHRydWU7XG4gIH1cbiAgZGVhY3RpdmF0ZSgpIHtcbiAgICBpZiAoIXRoaXMuX2lzQWN0aXZlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2lzQWN0aXZlID0gZmFsc2U7XG4gICAgRXZlbnRIYW5kbGVyLm9mZihkb2N1bWVudCwgRVZFTlRfS0VZJDUpO1xuICB9XG5cbiAgLy8gUHJpdmF0ZVxuICBfaGFuZGxlRm9jdXNpbihldmVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHRyYXBFbGVtZW50XG4gICAgfSA9IHRoaXMuX2NvbmZpZztcbiAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSBkb2N1bWVudCB8fCBldmVudC50YXJnZXQgPT09IHRyYXBFbGVtZW50IHx8IHRyYXBFbGVtZW50LmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZWxlbWVudHMgPSBTZWxlY3RvckVuZ2luZS5mb2N1c2FibGVDaGlsZHJlbih0cmFwRWxlbWVudCk7XG4gICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdHJhcEVsZW1lbnQuZm9jdXMoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2xhc3RUYWJOYXZEaXJlY3Rpb24gPT09IFRBQl9OQVZfQkFDS1dBUkQpIHtcbiAgICAgIGVsZW1lbnRzW2VsZW1lbnRzLmxlbmd0aCAtIDFdLmZvY3VzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnRzWzBdLmZvY3VzKCk7XG4gICAgfVxuICB9XG4gIF9oYW5kbGVLZXlkb3duKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmtleSAhPT0gVEFCX0tFWSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9sYXN0VGFiTmF2RGlyZWN0aW9uID0gZXZlbnQuc2hpZnRLZXkgPyBUQUJfTkFWX0JBQ0tXQVJEIDogVEFCX05BVl9GT1JXQVJEO1xuICB9XG59XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCB1dGlsL3Njcm9sbEJhci5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbi8qKlxuICogQ29uc3RhbnRzXG4gKi9cblxuY29uc3QgU0VMRUNUT1JfRklYRURfQ09OVEVOVCA9ICcuZml4ZWQtdG9wLCAuZml4ZWQtYm90dG9tLCAuaXMtZml4ZWQsIC5zdGlja3ktdG9wJztcbmNvbnN0IFNFTEVDVE9SX1NUSUNLWV9DT05URU5UID0gJy5zdGlja3ktdG9wJztcbmNvbnN0IFBST1BFUlRZX1BBRERJTkcgPSAncGFkZGluZy1yaWdodCc7XG5jb25zdCBQUk9QRVJUWV9NQVJHSU4gPSAnbWFyZ2luLXJpZ2h0JztcblxuLyoqXG4gKiBDbGFzcyBkZWZpbml0aW9uXG4gKi9cblxuY2xhc3MgU2Nyb2xsQmFySGVscGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IGRvY3VtZW50LmJvZHk7XG4gIH1cblxuICAvLyBQdWJsaWNcbiAgZ2V0V2lkdGgoKSB7XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvdy9pbm5lcldpZHRoI3VzYWdlX25vdGVzXG4gICAgY29uc3QgZG9jdW1lbnRXaWR0aCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICByZXR1cm4gTWF0aC5hYnMod2luZG93LmlubmVyV2lkdGggLSBkb2N1bWVudFdpZHRoKTtcbiAgfVxuICBoaWRlKCkge1xuICAgIGNvbnN0IHdpZHRoID0gdGhpcy5nZXRXaWR0aCgpO1xuICAgIHRoaXMuX2Rpc2FibGVPdmVyRmxvdygpO1xuICAgIC8vIGdpdmUgcGFkZGluZyB0byBlbGVtZW50IHRvIGJhbGFuY2UgdGhlIGhpZGRlbiBzY3JvbGxiYXIgd2lkdGhcbiAgICB0aGlzLl9zZXRFbGVtZW50QXR0cmlidXRlcyh0aGlzLl9lbGVtZW50LCBQUk9QRVJUWV9QQURESU5HLCBjYWxjdWxhdGVkVmFsdWUgPT4gY2FsY3VsYXRlZFZhbHVlICsgd2lkdGgpO1xuICAgIC8vIHRyaWNrOiBXZSBhZGp1c3QgcG9zaXRpdmUgcGFkZGluZ1JpZ2h0IGFuZCBuZWdhdGl2ZSBtYXJnaW5SaWdodCB0byBzdGlja3ktdG9wIGVsZW1lbnRzIHRvIGtlZXAgc2hvd2luZyBmdWxsd2lkdGhcbiAgICB0aGlzLl9zZXRFbGVtZW50QXR0cmlidXRlcyhTRUxFQ1RPUl9GSVhFRF9DT05URU5ULCBQUk9QRVJUWV9QQURESU5HLCBjYWxjdWxhdGVkVmFsdWUgPT4gY2FsY3VsYXRlZFZhbHVlICsgd2lkdGgpO1xuICAgIHRoaXMuX3NldEVsZW1lbnRBdHRyaWJ1dGVzKFNFTEVDVE9SX1NUSUNLWV9DT05URU5ULCBQUk9QRVJUWV9NQVJHSU4sIGNhbGN1bGF0ZWRWYWx1ZSA9PiBjYWxjdWxhdGVkVmFsdWUgLSB3aWR0aCk7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5fcmVzZXRFbGVtZW50QXR0cmlidXRlcyh0aGlzLl9lbGVtZW50LCAnb3ZlcmZsb3cnKTtcbiAgICB0aGlzLl9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQsIFBST1BFUlRZX1BBRERJTkcpO1xuICAgIHRoaXMuX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXMoU0VMRUNUT1JfRklYRURfQ09OVEVOVCwgUFJPUEVSVFlfUEFERElORyk7XG4gICAgdGhpcy5fcmVzZXRFbGVtZW50QXR0cmlidXRlcyhTRUxFQ1RPUl9TVElDS1lfQ09OVEVOVCwgUFJPUEVSVFlfTUFSR0lOKTtcbiAgfVxuICBpc092ZXJmbG93aW5nKCkge1xuICAgIHJldHVybiB0aGlzLmdldFdpZHRoKCkgPiAwO1xuICB9XG5cbiAgLy8gUHJpdmF0ZVxuICBfZGlzYWJsZU92ZXJGbG93KCkge1xuICAgIHRoaXMuX3NhdmVJbml0aWFsQXR0cmlidXRlKHRoaXMuX2VsZW1lbnQsICdvdmVyZmxvdycpO1xuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgfVxuICBfc2V0RWxlbWVudEF0dHJpYnV0ZXMoc2VsZWN0b3IsIHN0eWxlUHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgc2Nyb2xsYmFyV2lkdGggPSB0aGlzLmdldFdpZHRoKCk7XG4gICAgY29uc3QgbWFuaXB1bGF0aW9uQ2FsbEJhY2sgPSBlbGVtZW50ID0+IHtcbiAgICAgIGlmIChlbGVtZW50ICE9PSB0aGlzLl9lbGVtZW50ICYmIHdpbmRvdy5pbm5lcldpZHRoID4gZWxlbWVudC5jbGllbnRXaWR0aCArIHNjcm9sbGJhcldpZHRoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NhdmVJbml0aWFsQXR0cmlidXRlKGVsZW1lbnQsIHN0eWxlUHJvcGVydHkpO1xuICAgICAgY29uc3QgY2FsY3VsYXRlZFZhbHVlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZShzdHlsZVByb3BlcnR5KTtcbiAgICAgIGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoc3R5bGVQcm9wZXJ0eSwgYCR7Y2FsbGJhY2soTnVtYmVyLnBhcnNlRmxvYXQoY2FsY3VsYXRlZFZhbHVlKSl9cHhgKTtcbiAgICB9O1xuICAgIHRoaXMuX2FwcGx5TWFuaXB1bGF0aW9uQ2FsbGJhY2soc2VsZWN0b3IsIG1hbmlwdWxhdGlvbkNhbGxCYWNrKTtcbiAgfVxuICBfc2F2ZUluaXRpYWxBdHRyaWJ1dGUoZWxlbWVudCwgc3R5bGVQcm9wZXJ0eSkge1xuICAgIGNvbnN0IGFjdHVhbFZhbHVlID0gZWxlbWVudC5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHN0eWxlUHJvcGVydHkpO1xuICAgIGlmIChhY3R1YWxWYWx1ZSkge1xuICAgICAgTWFuaXB1bGF0b3Iuc2V0RGF0YUF0dHJpYnV0ZShlbGVtZW50LCBzdHlsZVByb3BlcnR5LCBhY3R1YWxWYWx1ZSk7XG4gICAgfVxuICB9XG4gIF9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzKHNlbGVjdG9yLCBzdHlsZVByb3BlcnR5KSB7XG4gICAgY29uc3QgbWFuaXB1bGF0aW9uQ2FsbEJhY2sgPSBlbGVtZW50ID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gTWFuaXB1bGF0b3IuZ2V0RGF0YUF0dHJpYnV0ZShlbGVtZW50LCBzdHlsZVByb3BlcnR5KTtcbiAgICAgIC8vIFdlIG9ubHkgd2FudCB0byByZW1vdmUgdGhlIHByb3BlcnR5IGlmIHRoZSB2YWx1ZSBpcyBgbnVsbGA7IHRoZSB2YWx1ZSBjYW4gYWxzbyBiZSB6ZXJvXG4gICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5yZW1vdmVQcm9wZXJ0eShzdHlsZVByb3BlcnR5KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgTWFuaXB1bGF0b3IucmVtb3ZlRGF0YUF0dHJpYnV0ZShlbGVtZW50LCBzdHlsZVByb3BlcnR5KTtcbiAgICAgIGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoc3R5bGVQcm9wZXJ0eSwgdmFsdWUpO1xuICAgIH07XG4gICAgdGhpcy5fYXBwbHlNYW5pcHVsYXRpb25DYWxsYmFjayhzZWxlY3RvciwgbWFuaXB1bGF0aW9uQ2FsbEJhY2spO1xuICB9XG4gIF9hcHBseU1hbmlwdWxhdGlvbkNhbGxiYWNrKHNlbGVjdG9yLCBjYWxsQmFjaykge1xuICAgIGlmIChpc0VsZW1lbnQoc2VsZWN0b3IpKSB7XG4gICAgICBjYWxsQmFjayhzZWxlY3Rvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3Qgc2VsIG9mIFNlbGVjdG9yRW5naW5lLmZpbmQoc2VsZWN0b3IsIHRoaXMuX2VsZW1lbnQpKSB7XG4gICAgICBjYWxsQmFjayhzZWwpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgbW9kYWwuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG4vKipcbiAqIENvbnN0YW50c1xuICovXG5cbmNvbnN0IE5BTUUkNyA9ICdtb2RhbCc7XG5jb25zdCBEQVRBX0tFWSQ0ID0gJ2JzLm1vZGFsJztcbmNvbnN0IEVWRU5UX0tFWSQ0ID0gYC4ke0RBVEFfS0VZJDR9YDtcbmNvbnN0IERBVEFfQVBJX0tFWSQyID0gJy5kYXRhLWFwaSc7XG5jb25zdCBFU0NBUEVfS0VZJDEgPSAnRXNjYXBlJztcbmNvbnN0IEVWRU5UX0hJREUkNCA9IGBoaWRlJHtFVkVOVF9LRVkkNH1gO1xuY29uc3QgRVZFTlRfSElERV9QUkVWRU5URUQkMSA9IGBoaWRlUHJldmVudGVkJHtFVkVOVF9LRVkkNH1gO1xuY29uc3QgRVZFTlRfSElEREVOJDQgPSBgaGlkZGVuJHtFVkVOVF9LRVkkNH1gO1xuY29uc3QgRVZFTlRfU0hPVyQ0ID0gYHNob3cke0VWRU5UX0tFWSQ0fWA7XG5jb25zdCBFVkVOVF9TSE9XTiQ0ID0gYHNob3duJHtFVkVOVF9LRVkkNH1gO1xuY29uc3QgRVZFTlRfUkVTSVpFJDEgPSBgcmVzaXplJHtFVkVOVF9LRVkkNH1gO1xuY29uc3QgRVZFTlRfQ0xJQ0tfRElTTUlTUyA9IGBjbGljay5kaXNtaXNzJHtFVkVOVF9LRVkkNH1gO1xuY29uc3QgRVZFTlRfTU9VU0VET1dOX0RJU01JU1MgPSBgbW91c2Vkb3duLmRpc21pc3Mke0VWRU5UX0tFWSQ0fWA7XG5jb25zdCBFVkVOVF9LRVlET1dOX0RJU01JU1MkMSA9IGBrZXlkb3duLmRpc21pc3Mke0VWRU5UX0tFWSQ0fWA7XG5jb25zdCBFVkVOVF9DTElDS19EQVRBX0FQSSQyID0gYGNsaWNrJHtFVkVOVF9LRVkkNH0ke0RBVEFfQVBJX0tFWSQyfWA7XG5jb25zdCBDTEFTU19OQU1FX09QRU4gPSAnbW9kYWwtb3Blbic7XG5jb25zdCBDTEFTU19OQU1FX0ZBREUkMyA9ICdmYWRlJztcbmNvbnN0IENMQVNTX05BTUVfU0hPVyQ0ID0gJ3Nob3cnO1xuY29uc3QgQ0xBU1NfTkFNRV9TVEFUSUMgPSAnbW9kYWwtc3RhdGljJztcbmNvbnN0IE9QRU5fU0VMRUNUT1IkMSA9ICcubW9kYWwuc2hvdyc7XG5jb25zdCBTRUxFQ1RPUl9ESUFMT0cgPSAnLm1vZGFsLWRpYWxvZyc7XG5jb25zdCBTRUxFQ1RPUl9NT0RBTF9CT0RZID0gJy5tb2RhbC1ib2R5JztcbmNvbnN0IFNFTEVDVE9SX0RBVEFfVE9HR0xFJDIgPSAnW2RhdGEtYnMtdG9nZ2xlPVwibW9kYWxcIl0nO1xuY29uc3QgRGVmYXVsdCQ2ID0ge1xuICBiYWNrZHJvcDogdHJ1ZSxcbiAgZm9jdXM6IHRydWUsXG4gIGtleWJvYXJkOiB0cnVlXG59O1xuY29uc3QgRGVmYXVsdFR5cGUkNiA9IHtcbiAgYmFja2Ryb3A6ICcoYm9vbGVhbnxzdHJpbmcpJyxcbiAgZm9jdXM6ICdib29sZWFuJyxcbiAga2V5Ym9hcmQ6ICdib29sZWFuJ1xufTtcblxuLyoqXG4gKiBDbGFzcyBkZWZpbml0aW9uXG4gKi9cblxuY2xhc3MgTW9kYWwgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgc3VwZXIoZWxlbWVudCwgY29uZmlnKTtcbiAgICB0aGlzLl9kaWFsb2cgPSBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX0RJQUxPRywgdGhpcy5fZWxlbWVudCk7XG4gICAgdGhpcy5fYmFja2Ryb3AgPSB0aGlzLl9pbml0aWFsaXplQmFja0Ryb3AoKTtcbiAgICB0aGlzLl9mb2N1c3RyYXAgPSB0aGlzLl9pbml0aWFsaXplRm9jdXNUcmFwKCk7XG4gICAgdGhpcy5faXNTaG93biA9IGZhbHNlO1xuICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3Njcm9sbEJhciA9IG5ldyBTY3JvbGxCYXJIZWxwZXIoKTtcbiAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpO1xuICB9XG5cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIERlZmF1bHQkNjtcbiAgfVxuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgIHJldHVybiBEZWZhdWx0VHlwZSQ2O1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gTkFNRSQ3O1xuICB9XG5cbiAgLy8gUHVibGljXG4gIHRvZ2dsZShyZWxhdGVkVGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzU2hvd24gPyB0aGlzLmhpZGUoKSA6IHRoaXMuc2hvdyhyZWxhdGVkVGFyZ2V0KTtcbiAgfVxuICBzaG93KHJlbGF0ZWRUYXJnZXQpIHtcbiAgICBpZiAodGhpcy5faXNTaG93biB8fCB0aGlzLl9pc1RyYW5zaXRpb25pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2hvd0V2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPVyQ0LCB7XG4gICAgICByZWxhdGVkVGFyZ2V0XG4gICAgfSk7XG4gICAgaWYgKHNob3dFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2lzU2hvd24gPSB0cnVlO1xuICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IHRydWU7XG4gICAgdGhpcy5fc2Nyb2xsQmFyLmhpZGUoKTtcbiAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9PUEVOKTtcbiAgICB0aGlzLl9hZGp1c3REaWFsb2coKTtcbiAgICB0aGlzLl9iYWNrZHJvcC5zaG93KCgpID0+IHRoaXMuX3Nob3dFbGVtZW50KHJlbGF0ZWRUYXJnZXQpKTtcbiAgfVxuICBoaWRlKCkge1xuICAgIGlmICghdGhpcy5faXNTaG93biB8fCB0aGlzLl9pc1RyYW5zaXRpb25pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaGlkZUV2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElERSQ0KTtcbiAgICBpZiAoaGlkZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5faXNTaG93biA9IGZhbHNlO1xuICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IHRydWU7XG4gICAgdGhpcy5fZm9jdXN0cmFwLmRlYWN0aXZhdGUoKTtcbiAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XJDQpO1xuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soKCkgPT4gdGhpcy5faGlkZU1vZGFsKCksIHRoaXMuX2VsZW1lbnQsIHRoaXMuX2lzQW5pbWF0ZWQoKSk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBFdmVudEhhbmRsZXIub2ZmKHdpbmRvdywgRVZFTlRfS0VZJDQpO1xuICAgIEV2ZW50SGFuZGxlci5vZmYodGhpcy5fZGlhbG9nLCBFVkVOVF9LRVkkNCk7XG4gICAgdGhpcy5fYmFja2Ryb3AuZGlzcG9zZSgpO1xuICAgIHRoaXMuX2ZvY3VzdHJhcC5kZWFjdGl2YXRlKCk7XG4gICAgc3VwZXIuZGlzcG9zZSgpO1xuICB9XG4gIGhhbmRsZVVwZGF0ZSgpIHtcbiAgICB0aGlzLl9hZGp1c3REaWFsb2coKTtcbiAgfVxuXG4gIC8vIFByaXZhdGVcbiAgX2luaXRpYWxpemVCYWNrRHJvcCgpIHtcbiAgICByZXR1cm4gbmV3IEJhY2tkcm9wKHtcbiAgICAgIGlzVmlzaWJsZTogQm9vbGVhbih0aGlzLl9jb25maWcuYmFja2Ryb3ApLFxuICAgICAgLy8gJ3N0YXRpYycgb3B0aW9uIHdpbGwgYmUgdHJhbnNsYXRlZCB0byB0cnVlLCBhbmQgYm9vbGVhbnMgd2lsbCBrZWVwIHRoZWlyIHZhbHVlLFxuICAgICAgaXNBbmltYXRlZDogdGhpcy5faXNBbmltYXRlZCgpXG4gICAgfSk7XG4gIH1cbiAgX2luaXRpYWxpemVGb2N1c1RyYXAoKSB7XG4gICAgcmV0dXJuIG5ldyBGb2N1c1RyYXAoe1xuICAgICAgdHJhcEVsZW1lbnQ6IHRoaXMuX2VsZW1lbnRcbiAgICB9KTtcbiAgfVxuICBfc2hvd0VsZW1lbnQocmVsYXRlZFRhcmdldCkge1xuICAgIC8vIHRyeSB0byBhcHBlbmQgZHluYW1pYyBtb2RhbFxuICAgIGlmICghZG9jdW1lbnQuYm9keS5jb250YWlucyh0aGlzLl9lbGVtZW50KSkge1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmQodGhpcy5fZWxlbWVudCk7XG4gICAgfVxuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJyk7XG4gICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbW9kYWwnLCB0cnVlKTtcbiAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgncm9sZScsICdkaWFsb2cnKTtcbiAgICB0aGlzLl9lbGVtZW50LnNjcm9sbFRvcCA9IDA7XG4gICAgY29uc3QgbW9kYWxCb2R5ID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9NT0RBTF9CT0RZLCB0aGlzLl9kaWFsb2cpO1xuICAgIGlmIChtb2RhbEJvZHkpIHtcbiAgICAgIG1vZGFsQm9keS5zY3JvbGxUb3AgPSAwO1xuICAgIH1cbiAgICByZWZsb3codGhpcy5fZWxlbWVudCk7XG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVyQ0KTtcbiAgICBjb25zdCB0cmFuc2l0aW9uQ29tcGxldGUgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5fY29uZmlnLmZvY3VzKSB7XG4gICAgICAgIHRoaXMuX2ZvY3VzdHJhcC5hY3RpdmF0ZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gZmFsc2U7XG4gICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XTiQ0LCB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXRcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayh0cmFuc2l0aW9uQ29tcGxldGUsIHRoaXMuX2RpYWxvZywgdGhpcy5faXNBbmltYXRlZCgpKTtcbiAgfVxuICBfYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0tFWURPV05fRElTTUlTUyQxLCBldmVudCA9PiB7XG4gICAgICBpZiAoZXZlbnQua2V5ICE9PSBFU0NBUEVfS0VZJDEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5rZXlib2FyZCkge1xuICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fdHJpZ2dlckJhY2tkcm9wVHJhbnNpdGlvbigpO1xuICAgIH0pO1xuICAgIEV2ZW50SGFuZGxlci5vbih3aW5kb3csIEVWRU5UX1JFU0laRSQxLCAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5faXNTaG93biAmJiAhdGhpcy5faXNUcmFuc2l0aW9uaW5nKSB7XG4gICAgICAgIHRoaXMuX2FkanVzdERpYWxvZygpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9NT1VTRURPV05fRElTTUlTUywgZXZlbnQgPT4ge1xuICAgICAgLy8gYSBiYWQgdHJpY2sgdG8gc2VncmVnYXRlIGNsaWNrcyB0aGF0IG1heSBzdGFydCBpbnNpZGUgZGlhbG9nIGJ1dCBlbmQgb3V0c2lkZSwgYW5kIGF2b2lkIGxpc3RlbiB0byBzY3JvbGxiYXIgY2xpY2tzXG4gICAgICBFdmVudEhhbmRsZXIub25lKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0NMSUNLX0RJU01JU1MsIGV2ZW50MiA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9lbGVtZW50ICE9PSBldmVudC50YXJnZXQgfHwgdGhpcy5fZWxlbWVudCAhPT0gZXZlbnQyLnRhcmdldCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fY29uZmlnLmJhY2tkcm9wID09PSAnc3RhdGljJykge1xuICAgICAgICAgIHRoaXMuX3RyaWdnZXJCYWNrZHJvcFRyYW5zaXRpb24oKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2NvbmZpZy5iYWNrZHJvcCkge1xuICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBfaGlkZU1vZGFsKCkge1xuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCB0cnVlKTtcbiAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1tb2RhbCcpO1xuICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdyb2xlJyk7XG4gICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fYmFja2Ryb3AuaGlkZSgoKSA9PiB7XG4gICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9PUEVOKTtcbiAgICAgIHRoaXMuX3Jlc2V0QWRqdXN0bWVudHMoKTtcbiAgICAgIHRoaXMuX3Njcm9sbEJhci5yZXNldCgpO1xuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElEREVOJDQpO1xuICAgIH0pO1xuICB9XG4gIF9pc0FuaW1hdGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0ZBREUkMyk7XG4gIH1cbiAgX3RyaWdnZXJCYWNrZHJvcFRyYW5zaXRpb24oKSB7XG4gICAgY29uc3QgaGlkZUV2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElERV9QUkVWRU5URUQkMSk7XG4gICAgaWYgKGhpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGlzTW9kYWxPdmVyZmxvd2luZyA9IHRoaXMuX2VsZW1lbnQuc2Nyb2xsSGVpZ2h0ID4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtcbiAgICBjb25zdCBpbml0aWFsT3ZlcmZsb3dZID0gdGhpcy5fZWxlbWVudC5zdHlsZS5vdmVyZmxvd1k7XG4gICAgLy8gcmV0dXJuIGlmIHRoZSBmb2xsb3dpbmcgYmFja2dyb3VuZCB0cmFuc2l0aW9uIGhhc24ndCB5ZXQgY29tcGxldGVkXG4gICAgaWYgKGluaXRpYWxPdmVyZmxvd1kgPT09ICdoaWRkZW4nIHx8IHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfU1RBVElDKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWlzTW9kYWxPdmVyZmxvd2luZykge1xuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS5vdmVyZmxvd1kgPSAnaGlkZGVuJztcbiAgICB9XG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU1RBVElDKTtcbiAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NUQVRJQyk7XG4gICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS5vdmVyZmxvd1kgPSBpbml0aWFsT3ZlcmZsb3dZO1xuICAgICAgfSwgdGhpcy5fZGlhbG9nKTtcbiAgICB9LCB0aGlzLl9kaWFsb2cpO1xuICAgIHRoaXMuX2VsZW1lbnQuZm9jdXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgZm9sbG93aW5nIG1ldGhvZHMgYXJlIHVzZWQgdG8gaGFuZGxlIG92ZXJmbG93aW5nIG1vZGFsc1xuICAgKi9cblxuICBfYWRqdXN0RGlhbG9nKCkge1xuICAgIGNvbnN0IGlzTW9kYWxPdmVyZmxvd2luZyA9IHRoaXMuX2VsZW1lbnQuc2Nyb2xsSGVpZ2h0ID4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtcbiAgICBjb25zdCBzY3JvbGxiYXJXaWR0aCA9IHRoaXMuX3Njcm9sbEJhci5nZXRXaWR0aCgpO1xuICAgIGNvbnN0IGlzQm9keU92ZXJmbG93aW5nID0gc2Nyb2xsYmFyV2lkdGggPiAwO1xuICAgIGlmIChpc0JvZHlPdmVyZmxvd2luZyAmJiAhaXNNb2RhbE92ZXJmbG93aW5nKSB7XG4gICAgICBjb25zdCBwcm9wZXJ0eSA9IGlzUlRMKCkgPyAncGFkZGluZ0xlZnQnIDogJ3BhZGRpbmdSaWdodCc7XG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlW3Byb3BlcnR5XSA9IGAke3Njcm9sbGJhcldpZHRofXB4YDtcbiAgICB9XG4gICAgaWYgKCFpc0JvZHlPdmVyZmxvd2luZyAmJiBpc01vZGFsT3ZlcmZsb3dpbmcpIHtcbiAgICAgIGNvbnN0IHByb3BlcnR5ID0gaXNSVEwoKSA/ICdwYWRkaW5nUmlnaHQnIDogJ3BhZGRpbmdMZWZ0JztcbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbcHJvcGVydHldID0gYCR7c2Nyb2xsYmFyV2lkdGh9cHhgO1xuICAgIH1cbiAgfVxuICBfcmVzZXRBZGp1c3RtZW50cygpIHtcbiAgICB0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdMZWZ0ID0gJyc7XG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZS5wYWRkaW5nUmlnaHQgPSAnJztcbiAgfVxuXG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZywgcmVsYXRlZFRhcmdldCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgZGF0YSA9IE1vZGFsLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgY29uZmlnKTtcbiAgICAgIGlmICh0eXBlb2YgY29uZmlnICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKTtcbiAgICAgIH1cbiAgICAgIGRhdGFbY29uZmlnXShyZWxhdGVkVGFyZ2V0KTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIERhdGEgQVBJIGltcGxlbWVudGF0aW9uXG4gKi9cblxuRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9DTElDS19EQVRBX0FQSSQyLCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQyLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgY29uc3QgdGFyZ2V0ID0gU2VsZWN0b3JFbmdpbmUuZ2V0RWxlbWVudEZyb21TZWxlY3Rvcih0aGlzKTtcbiAgaWYgKFsnQScsICdBUkVBJ10uaW5jbHVkZXModGhpcy50YWdOYW1lKSkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgRXZlbnRIYW5kbGVyLm9uZSh0YXJnZXQsIEVWRU5UX1NIT1ckNCwgc2hvd0V2ZW50ID0+IHtcbiAgICBpZiAoc2hvd0V2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIC8vIG9ubHkgcmVnaXN0ZXIgZm9jdXMgcmVzdG9yZXIgaWYgbW9kYWwgd2lsbCBhY3R1YWxseSBnZXQgc2hvd25cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgRXZlbnRIYW5kbGVyLm9uZSh0YXJnZXQsIEVWRU5UX0hJRERFTiQ0LCAoKSA9PiB7XG4gICAgICBpZiAoaXNWaXNpYmxlKHRoaXMpKSB7XG4gICAgICAgIHRoaXMuZm9jdXMoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gYXZvaWQgY29uZmxpY3Qgd2hlbiBjbGlja2luZyBtb2RhbCB0b2dnbGVyIHdoaWxlIGFub3RoZXIgb25lIGlzIG9wZW5cbiAgY29uc3QgYWxyZWFkeU9wZW4gPSBTZWxlY3RvckVuZ2luZS5maW5kT25lKE9QRU5fU0VMRUNUT1IkMSk7XG4gIGlmIChhbHJlYWR5T3Blbikge1xuICAgIE1vZGFsLmdldEluc3RhbmNlKGFscmVhZHlPcGVuKS5oaWRlKCk7XG4gIH1cbiAgY29uc3QgZGF0YSA9IE1vZGFsLmdldE9yQ3JlYXRlSW5zdGFuY2UodGFyZ2V0KTtcbiAgZGF0YS50b2dnbGUodGhpcyk7XG59KTtcbmVuYWJsZURpc21pc3NUcmlnZ2VyKE1vZGFsKTtcblxuLyoqXG4gKiBqUXVlcnlcbiAqL1xuXG5kZWZpbmVKUXVlcnlQbHVnaW4oTW9kYWwpO1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgb2ZmY2FudmFzLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuLyoqXG4gKiBDb25zdGFudHNcbiAqL1xuXG5jb25zdCBOQU1FJDYgPSAnb2ZmY2FudmFzJztcbmNvbnN0IERBVEFfS0VZJDMgPSAnYnMub2ZmY2FudmFzJztcbmNvbnN0IEVWRU5UX0tFWSQzID0gYC4ke0RBVEFfS0VZJDN9YDtcbmNvbnN0IERBVEFfQVBJX0tFWSQxID0gJy5kYXRhLWFwaSc7XG5jb25zdCBFVkVOVF9MT0FEX0RBVEFfQVBJJDIgPSBgbG9hZCR7RVZFTlRfS0VZJDN9JHtEQVRBX0FQSV9LRVkkMX1gO1xuY29uc3QgRVNDQVBFX0tFWSA9ICdFc2NhcGUnO1xuY29uc3QgQ0xBU1NfTkFNRV9TSE9XJDMgPSAnc2hvdyc7XG5jb25zdCBDTEFTU19OQU1FX1NIT1dJTkckMSA9ICdzaG93aW5nJztcbmNvbnN0IENMQVNTX05BTUVfSElESU5HID0gJ2hpZGluZyc7XG5jb25zdCBDTEFTU19OQU1FX0JBQ0tEUk9QID0gJ29mZmNhbnZhcy1iYWNrZHJvcCc7XG5jb25zdCBPUEVOX1NFTEVDVE9SID0gJy5vZmZjYW52YXMuc2hvdyc7XG5jb25zdCBFVkVOVF9TSE9XJDMgPSBgc2hvdyR7RVZFTlRfS0VZJDN9YDtcbmNvbnN0IEVWRU5UX1NIT1dOJDMgPSBgc2hvd24ke0VWRU5UX0tFWSQzfWA7XG5jb25zdCBFVkVOVF9ISURFJDMgPSBgaGlkZSR7RVZFTlRfS0VZJDN9YDtcbmNvbnN0IEVWRU5UX0hJREVfUFJFVkVOVEVEID0gYGhpZGVQcmV2ZW50ZWQke0VWRU5UX0tFWSQzfWA7XG5jb25zdCBFVkVOVF9ISURERU4kMyA9IGBoaWRkZW4ke0VWRU5UX0tFWSQzfWA7XG5jb25zdCBFVkVOVF9SRVNJWkUgPSBgcmVzaXplJHtFVkVOVF9LRVkkM31gO1xuY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkMSA9IGBjbGljayR7RVZFTlRfS0VZJDN9JHtEQVRBX0FQSV9LRVkkMX1gO1xuY29uc3QgRVZFTlRfS0VZRE9XTl9ESVNNSVNTID0gYGtleWRvd24uZGlzbWlzcyR7RVZFTlRfS0VZJDN9YDtcbmNvbnN0IFNFTEVDVE9SX0RBVEFfVE9HR0xFJDEgPSAnW2RhdGEtYnMtdG9nZ2xlPVwib2ZmY2FudmFzXCJdJztcbmNvbnN0IERlZmF1bHQkNSA9IHtcbiAgYmFja2Ryb3A6IHRydWUsXG4gIGtleWJvYXJkOiB0cnVlLFxuICBzY3JvbGw6IGZhbHNlXG59O1xuY29uc3QgRGVmYXVsdFR5cGUkNSA9IHtcbiAgYmFja2Ryb3A6ICcoYm9vbGVhbnxzdHJpbmcpJyxcbiAga2V5Ym9hcmQ6ICdib29sZWFuJyxcbiAgc2Nyb2xsOiAnYm9vbGVhbidcbn07XG5cbi8qKlxuICogQ2xhc3MgZGVmaW5pdGlvblxuICovXG5cbmNsYXNzIE9mZmNhbnZhcyBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcbiAgICBzdXBlcihlbGVtZW50LCBjb25maWcpO1xuICAgIHRoaXMuX2lzU2hvd24gPSBmYWxzZTtcbiAgICB0aGlzLl9iYWNrZHJvcCA9IHRoaXMuX2luaXRpYWxpemVCYWNrRHJvcCgpO1xuICAgIHRoaXMuX2ZvY3VzdHJhcCA9IHRoaXMuX2luaXRpYWxpemVGb2N1c1RyYXAoKTtcbiAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpO1xuICB9XG5cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIERlZmF1bHQkNTtcbiAgfVxuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgIHJldHVybiBEZWZhdWx0VHlwZSQ1O1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gTkFNRSQ2O1xuICB9XG5cbiAgLy8gUHVibGljXG4gIHRvZ2dsZShyZWxhdGVkVGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzU2hvd24gPyB0aGlzLmhpZGUoKSA6IHRoaXMuc2hvdyhyZWxhdGVkVGFyZ2V0KTtcbiAgfVxuICBzaG93KHJlbGF0ZWRUYXJnZXQpIHtcbiAgICBpZiAodGhpcy5faXNTaG93bikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzaG93RXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XJDMsIHtcbiAgICAgIHJlbGF0ZWRUYXJnZXRcbiAgICB9KTtcbiAgICBpZiAoc2hvd0V2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5faXNTaG93biA9IHRydWU7XG4gICAgdGhpcy5fYmFja2Ryb3Auc2hvdygpO1xuICAgIGlmICghdGhpcy5fY29uZmlnLnNjcm9sbCkge1xuICAgICAgbmV3IFNjcm9sbEJhckhlbHBlcigpLmhpZGUoKTtcbiAgICB9XG4gICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbW9kYWwnLCB0cnVlKTtcbiAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgncm9sZScsICdkaWFsb2cnKTtcbiAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XSU5HJDEpO1xuICAgIGNvbnN0IGNvbXBsZXRlQ2FsbEJhY2sgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX2NvbmZpZy5zY3JvbGwgfHwgdGhpcy5fY29uZmlnLmJhY2tkcm9wKSB7XG4gICAgICAgIHRoaXMuX2ZvY3VzdHJhcC5hY3RpdmF0ZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVyQzKTtcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1dJTkckMSk7XG4gICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XTiQzLCB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXRcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZUNhbGxCYWNrLCB0aGlzLl9lbGVtZW50LCB0cnVlKTtcbiAgfVxuICBoaWRlKCkge1xuICAgIGlmICghdGhpcy5faXNTaG93bikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBoaWRlRXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURFJDMpO1xuICAgIGlmIChoaWRlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9mb2N1c3RyYXAuZGVhY3RpdmF0ZSgpO1xuICAgIHRoaXMuX2VsZW1lbnQuYmx1cigpO1xuICAgIHRoaXMuX2lzU2hvd24gPSBmYWxzZTtcbiAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9ISURJTkcpO1xuICAgIHRoaXMuX2JhY2tkcm9wLmhpZGUoKTtcbiAgICBjb25zdCBjb21wbGV0ZUNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVyQzLCBDTEFTU19OQU1FX0hJRElORyk7XG4gICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1tb2RhbCcpO1xuICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3JvbGUnKTtcbiAgICAgIGlmICghdGhpcy5fY29uZmlnLnNjcm9sbCkge1xuICAgICAgICBuZXcgU2Nyb2xsQmFySGVscGVyKCkucmVzZXQoKTtcbiAgICAgIH1cbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJRERFTiQzKTtcbiAgICB9O1xuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGVDYWxsYmFjaywgdGhpcy5fZWxlbWVudCwgdHJ1ZSk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9iYWNrZHJvcC5kaXNwb3NlKCk7XG4gICAgdGhpcy5fZm9jdXN0cmFwLmRlYWN0aXZhdGUoKTtcbiAgICBzdXBlci5kaXNwb3NlKCk7XG4gIH1cblxuICAvLyBQcml2YXRlXG4gIF9pbml0aWFsaXplQmFja0Ryb3AoKSB7XG4gICAgY29uc3QgY2xpY2tDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLl9jb25maWcuYmFja2Ryb3AgPT09ICdzdGF0aWMnKSB7XG4gICAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJREVfUFJFVkVOVEVEKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfTtcblxuICAgIC8vICdzdGF0aWMnIG9wdGlvbiB3aWxsIGJlIHRyYW5zbGF0ZWQgdG8gdHJ1ZSwgYW5kIGJvb2xlYW5zIHdpbGwga2VlcCB0aGVpciB2YWx1ZVxuICAgIGNvbnN0IGlzVmlzaWJsZSA9IEJvb2xlYW4odGhpcy5fY29uZmlnLmJhY2tkcm9wKTtcbiAgICByZXR1cm4gbmV3IEJhY2tkcm9wKHtcbiAgICAgIGNsYXNzTmFtZTogQ0xBU1NfTkFNRV9CQUNLRFJPUCxcbiAgICAgIGlzVmlzaWJsZSxcbiAgICAgIGlzQW5pbWF0ZWQ6IHRydWUsXG4gICAgICByb290RWxlbWVudDogdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlLFxuICAgICAgY2xpY2tDYWxsYmFjazogaXNWaXNpYmxlID8gY2xpY2tDYWxsYmFjayA6IG51bGxcbiAgICB9KTtcbiAgfVxuICBfaW5pdGlhbGl6ZUZvY3VzVHJhcCgpIHtcbiAgICByZXR1cm4gbmV3IEZvY3VzVHJhcCh7XG4gICAgICB0cmFwRWxlbWVudDogdGhpcy5fZWxlbWVudFxuICAgIH0pO1xuICB9XG4gIF9hZGRFdmVudExpc3RlbmVycygpIHtcbiAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfS0VZRE9XTl9ESVNNSVNTLCBldmVudCA9PiB7XG4gICAgICBpZiAoZXZlbnQua2V5ICE9PSBFU0NBUEVfS0VZKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9jb25maWcua2V5Ym9hcmQpIHtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJREVfUFJFVkVOVEVEKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgZGF0YSA9IE9mZmNhbnZhcy5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIGNvbmZpZyk7XG4gICAgICBpZiAodHlwZW9mIGNvbmZpZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGFbY29uZmlnXSA9PT0gdW5kZWZpbmVkIHx8IGNvbmZpZy5zdGFydHNXaXRoKCdfJykgfHwgY29uZmlnID09PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYCk7XG4gICAgICB9XG4gICAgICBkYXRhW2NvbmZpZ10odGhpcyk7XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBEYXRhIEFQSSBpbXBsZW1lbnRhdGlvblxuICovXG5cbkV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkMSwgU0VMRUNUT1JfREFUQV9UT0dHTEUkMSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gIGNvbnN0IHRhcmdldCA9IFNlbGVjdG9yRW5naW5lLmdldEVsZW1lbnRGcm9tU2VsZWN0b3IodGhpcyk7XG4gIGlmIChbJ0EnLCAnQVJFQSddLmluY2x1ZGVzKHRoaXMudGFnTmFtZSkpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG4gIGlmIChpc0Rpc2FibGVkKHRoaXMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIEV2ZW50SGFuZGxlci5vbmUodGFyZ2V0LCBFVkVOVF9ISURERU4kMywgKCkgPT4ge1xuICAgIC8vIGZvY3VzIG9uIHRyaWdnZXIgd2hlbiBpdCBpcyBjbG9zZWRcbiAgICBpZiAoaXNWaXNpYmxlKHRoaXMpKSB7XG4gICAgICB0aGlzLmZvY3VzKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBhdm9pZCBjb25mbGljdCB3aGVuIGNsaWNraW5nIGEgdG9nZ2xlciBvZiBhbiBvZmZjYW52YXMsIHdoaWxlIGFub3RoZXIgaXMgb3BlblxuICBjb25zdCBhbHJlYWR5T3BlbiA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoT1BFTl9TRUxFQ1RPUik7XG4gIGlmIChhbHJlYWR5T3BlbiAmJiBhbHJlYWR5T3BlbiAhPT0gdGFyZ2V0KSB7XG4gICAgT2ZmY2FudmFzLmdldEluc3RhbmNlKGFscmVhZHlPcGVuKS5oaWRlKCk7XG4gIH1cbiAgY29uc3QgZGF0YSA9IE9mZmNhbnZhcy5nZXRPckNyZWF0ZUluc3RhbmNlKHRhcmdldCk7XG4gIGRhdGEudG9nZ2xlKHRoaXMpO1xufSk7XG5FdmVudEhhbmRsZXIub24od2luZG93LCBFVkVOVF9MT0FEX0RBVEFfQVBJJDIsICgpID0+IHtcbiAgZm9yIChjb25zdCBzZWxlY3RvciBvZiBTZWxlY3RvckVuZ2luZS5maW5kKE9QRU5fU0VMRUNUT1IpKSB7XG4gICAgT2ZmY2FudmFzLmdldE9yQ3JlYXRlSW5zdGFuY2Uoc2VsZWN0b3IpLnNob3coKTtcbiAgfVxufSk7XG5FdmVudEhhbmRsZXIub24od2luZG93LCBFVkVOVF9SRVNJWkUsICgpID0+IHtcbiAgZm9yIChjb25zdCBlbGVtZW50IG9mIFNlbGVjdG9yRW5naW5lLmZpbmQoJ1thcmlhLW1vZGFsXVtjbGFzcyo9c2hvd11bY2xhc3MqPW9mZmNhbnZhcy1dJykpIHtcbiAgICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbiAhPT0gJ2ZpeGVkJykge1xuICAgICAgT2ZmY2FudmFzLmdldE9yQ3JlYXRlSW5zdGFuY2UoZWxlbWVudCkuaGlkZSgpO1xuICAgIH1cbiAgfVxufSk7XG5lbmFibGVEaXNtaXNzVHJpZ2dlcihPZmZjYW52YXMpO1xuXG4vKipcbiAqIGpRdWVyeVxuICovXG5cbmRlZmluZUpRdWVyeVBsdWdpbihPZmZjYW52YXMpO1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgdXRpbC9zYW5pdGl6ZXIuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jb25zdCB1cmlBdHRyaWJ1dGVzID0gbmV3IFNldChbJ2JhY2tncm91bmQnLCAnY2l0ZScsICdocmVmJywgJ2l0ZW10eXBlJywgJ2xvbmdkZXNjJywgJ3Bvc3RlcicsICdzcmMnLCAneGxpbms6aHJlZiddKTtcblxuLyoqXG4gKiBBIHBhdHRlcm4gdGhhdCByZWNvZ25pemVzIGEgY29tbW9ubHkgdXNlZnVsIHN1YnNldCBvZiBVUkxzIHRoYXQgYXJlIHNhZmUuXG4gKlxuICogU2hvdXQtb3V0IHRvIEFuZ3VsYXIgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9ibG9iLzEyLjIueC9wYWNrYWdlcy9jb3JlL3NyYy9zYW5pdGl6YXRpb24vdXJsX3Nhbml0aXplci50c1xuICovXG5jb25zdCBTQUZFX1VSTF9QQVRURVJOID0gL14oPzooPzpodHRwcz98bWFpbHRvfGZ0cHx0ZWx8ZmlsZXxzbXMpOnxbXiMmLzo/XSooPzpbIy8/XXwkKSkvaTtcblxuLyoqXG4gKiBBIHBhdHRlcm4gdGhhdCBtYXRjaGVzIHNhZmUgZGF0YSBVUkxzLiBPbmx5IG1hdGNoZXMgaW1hZ2UsIHZpZGVvIGFuZCBhdWRpbyB0eXBlcy5cbiAqXG4gKiBTaG91dC1vdXQgdG8gQW5ndWxhciBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2Jsb2IvMTIuMi54L3BhY2thZ2VzL2NvcmUvc3JjL3Nhbml0aXphdGlvbi91cmxfc2FuaXRpemVyLnRzXG4gKi9cbmNvbnN0IERBVEFfVVJMX1BBVFRFUk4gPSAvXmRhdGE6KD86aW1hZ2VcXC8oPzpibXB8Z2lmfGpwZWd8anBnfHBuZ3x0aWZmfHdlYnApfHZpZGVvXFwvKD86bXBlZ3xtcDR8b2dnfHdlYm0pfGF1ZGlvXFwvKD86bXAzfG9nYXxvZ2d8b3B1cykpO2Jhc2U2NCxbXFxkKy9hLXpdKz0qJC9pO1xuY29uc3QgYWxsb3dlZEF0dHJpYnV0ZSA9IChhdHRyaWJ1dGUsIGFsbG93ZWRBdHRyaWJ1dGVMaXN0KSA9PiB7XG4gIGNvbnN0IGF0dHJpYnV0ZU5hbWUgPSBhdHRyaWJ1dGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgaWYgKGFsbG93ZWRBdHRyaWJ1dGVMaXN0LmluY2x1ZGVzKGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgaWYgKHVyaUF0dHJpYnV0ZXMuaGFzKGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICByZXR1cm4gQm9vbGVhbihTQUZFX1VSTF9QQVRURVJOLnRlc3QoYXR0cmlidXRlLm5vZGVWYWx1ZSkgfHwgREFUQV9VUkxfUEFUVEVSTi50ZXN0KGF0dHJpYnV0ZS5ub2RlVmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBDaGVjayBpZiBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB2YWxpZGF0ZXMgdGhlIGF0dHJpYnV0ZS5cbiAgcmV0dXJuIGFsbG93ZWRBdHRyaWJ1dGVMaXN0LmZpbHRlcihhdHRyaWJ1dGVSZWdleCA9PiBhdHRyaWJ1dGVSZWdleCBpbnN0YW5jZW9mIFJlZ0V4cCkuc29tZShyZWdleCA9PiByZWdleC50ZXN0KGF0dHJpYnV0ZU5hbWUpKTtcbn07XG5cbi8vIGpzLWRvY3Mtc3RhcnQgYWxsb3ctbGlzdFxuY29uc3QgQVJJQV9BVFRSSUJVVEVfUEFUVEVSTiA9IC9eYXJpYS1bXFx3LV0qJC9pO1xuY29uc3QgRGVmYXVsdEFsbG93bGlzdCA9IHtcbiAgLy8gR2xvYmFsIGF0dHJpYnV0ZXMgYWxsb3dlZCBvbiBhbnkgc3VwcGxpZWQgZWxlbWVudCBiZWxvdy5cbiAgJyonOiBbJ2NsYXNzJywgJ2RpcicsICdpZCcsICdsYW5nJywgJ3JvbGUnLCBBUklBX0FUVFJJQlVURV9QQVRURVJOXSxcbiAgYTogWyd0YXJnZXQnLCAnaHJlZicsICd0aXRsZScsICdyZWwnXSxcbiAgYXJlYTogW10sXG4gIGI6IFtdLFxuICBicjogW10sXG4gIGNvbDogW10sXG4gIGNvZGU6IFtdLFxuICBkaXY6IFtdLFxuICBlbTogW10sXG4gIGhyOiBbXSxcbiAgaDE6IFtdLFxuICBoMjogW10sXG4gIGgzOiBbXSxcbiAgaDQ6IFtdLFxuICBoNTogW10sXG4gIGg2OiBbXSxcbiAgaTogW10sXG4gIGltZzogWydzcmMnLCAnc3Jjc2V0JywgJ2FsdCcsICd0aXRsZScsICd3aWR0aCcsICdoZWlnaHQnXSxcbiAgbGk6IFtdLFxuICBvbDogW10sXG4gIHA6IFtdLFxuICBwcmU6IFtdLFxuICBzOiBbXSxcbiAgc21hbGw6IFtdLFxuICBzcGFuOiBbXSxcbiAgc3ViOiBbXSxcbiAgc3VwOiBbXSxcbiAgc3Ryb25nOiBbXSxcbiAgdTogW10sXG4gIHVsOiBbXVxufTtcbi8vIGpzLWRvY3MtZW5kIGFsbG93LWxpc3RcblxuZnVuY3Rpb24gc2FuaXRpemVIdG1sKHVuc2FmZUh0bWwsIGFsbG93TGlzdCwgc2FuaXRpemVGdW5jdGlvbikge1xuICBpZiAoIXVuc2FmZUh0bWwubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHVuc2FmZUh0bWw7XG4gIH1cbiAgaWYgKHNhbml0aXplRnVuY3Rpb24gJiYgdHlwZW9mIHNhbml0aXplRnVuY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gc2FuaXRpemVGdW5jdGlvbih1bnNhZmVIdG1sKTtcbiAgfVxuICBjb25zdCBkb21QYXJzZXIgPSBuZXcgd2luZG93LkRPTVBhcnNlcigpO1xuICBjb25zdCBjcmVhdGVkRG9jdW1lbnQgPSBkb21QYXJzZXIucGFyc2VGcm9tU3RyaW5nKHVuc2FmZUh0bWwsICd0ZXh0L2h0bWwnKTtcbiAgY29uc3QgZWxlbWVudHMgPSBbXS5jb25jYXQoLi4uY3JlYXRlZERvY3VtZW50LmJvZHkucXVlcnlTZWxlY3RvckFsbCgnKicpKTtcbiAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgY29uc3QgZWxlbWVudE5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKCFPYmplY3Qua2V5cyhhbGxvd0xpc3QpLmluY2x1ZGVzKGVsZW1lbnROYW1lKSkge1xuICAgICAgZWxlbWVudC5yZW1vdmUoKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBhdHRyaWJ1dGVMaXN0ID0gW10uY29uY2F0KC4uLmVsZW1lbnQuYXR0cmlidXRlcyk7XG4gICAgY29uc3QgYWxsb3dlZEF0dHJpYnV0ZXMgPSBbXS5jb25jYXQoYWxsb3dMaXN0WycqJ10gfHwgW10sIGFsbG93TGlzdFtlbGVtZW50TmFtZV0gfHwgW10pO1xuICAgIGZvciAoY29uc3QgYXR0cmlidXRlIG9mIGF0dHJpYnV0ZUxpc3QpIHtcbiAgICAgIGlmICghYWxsb3dlZEF0dHJpYnV0ZShhdHRyaWJ1dGUsIGFsbG93ZWRBdHRyaWJ1dGVzKSkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUubm9kZU5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY3JlYXRlZERvY3VtZW50LmJvZHkuaW5uZXJIVE1MO1xufVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgdXRpbC90ZW1wbGF0ZS1mYWN0b3J5LmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuLyoqXG4gKiBDb25zdGFudHNcbiAqL1xuXG5jb25zdCBOQU1FJDUgPSAnVGVtcGxhdGVGYWN0b3J5JztcbmNvbnN0IERlZmF1bHQkNCA9IHtcbiAgYWxsb3dMaXN0OiBEZWZhdWx0QWxsb3dsaXN0LFxuICBjb250ZW50OiB7fSxcbiAgLy8geyBzZWxlY3RvciA6IHRleHQgLCAgc2VsZWN0b3IyIDogdGV4dDIgLCB9XG4gIGV4dHJhQ2xhc3M6ICcnLFxuICBodG1sOiBmYWxzZSxcbiAgc2FuaXRpemU6IHRydWUsXG4gIHNhbml0aXplRm46IG51bGwsXG4gIHRlbXBsYXRlOiAnPGRpdj48L2Rpdj4nXG59O1xuY29uc3QgRGVmYXVsdFR5cGUkNCA9IHtcbiAgYWxsb3dMaXN0OiAnb2JqZWN0JyxcbiAgY29udGVudDogJ29iamVjdCcsXG4gIGV4dHJhQ2xhc3M6ICcoc3RyaW5nfGZ1bmN0aW9uKScsXG4gIGh0bWw6ICdib29sZWFuJyxcbiAgc2FuaXRpemU6ICdib29sZWFuJyxcbiAgc2FuaXRpemVGbjogJyhudWxsfGZ1bmN0aW9uKScsXG4gIHRlbXBsYXRlOiAnc3RyaW5nJ1xufTtcbmNvbnN0IERlZmF1bHRDb250ZW50VHlwZSA9IHtcbiAgZW50cnk6ICcoc3RyaW5nfGVsZW1lbnR8ZnVuY3Rpb258bnVsbCknLFxuICBzZWxlY3RvcjogJyhzdHJpbmd8ZWxlbWVudCknXG59O1xuXG4vKipcbiAqIENsYXNzIGRlZmluaXRpb25cbiAqL1xuXG5jbGFzcyBUZW1wbGF0ZUZhY3RvcnkgZXh0ZW5kcyBDb25maWcge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpO1xuICB9XG5cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIERlZmF1bHQkNDtcbiAgfVxuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgIHJldHVybiBEZWZhdWx0VHlwZSQ0O1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gTkFNRSQ1O1xuICB9XG5cbiAgLy8gUHVibGljXG4gIGdldENvbnRlbnQoKSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5fY29uZmlnLmNvbnRlbnQpLm1hcChjb25maWcgPT4gdGhpcy5fcmVzb2x2ZVBvc3NpYmxlRnVuY3Rpb24oY29uZmlnKSkuZmlsdGVyKEJvb2xlYW4pO1xuICB9XG4gIGhhc0NvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q29udGVudCgpLmxlbmd0aCA+IDA7XG4gIH1cbiAgY2hhbmdlQ29udGVudChjb250ZW50KSB7XG4gICAgdGhpcy5fY2hlY2tDb250ZW50KGNvbnRlbnQpO1xuICAgIHRoaXMuX2NvbmZpZy5jb250ZW50ID0ge1xuICAgICAgLi4udGhpcy5fY29uZmlnLmNvbnRlbnQsXG4gICAgICAuLi5jb250ZW50XG4gICAgfTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB0b0h0bWwoKSB7XG4gICAgY29uc3QgdGVtcGxhdGVXcmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGVtcGxhdGVXcmFwcGVyLmlubmVySFRNTCA9IHRoaXMuX21heWJlU2FuaXRpemUodGhpcy5fY29uZmlnLnRlbXBsYXRlKTtcbiAgICBmb3IgKGNvbnN0IFtzZWxlY3RvciwgdGV4dF0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5fY29uZmlnLmNvbnRlbnQpKSB7XG4gICAgICB0aGlzLl9zZXRDb250ZW50KHRlbXBsYXRlV3JhcHBlciwgdGV4dCwgc2VsZWN0b3IpO1xuICAgIH1cbiAgICBjb25zdCB0ZW1wbGF0ZSA9IHRlbXBsYXRlV3JhcHBlci5jaGlsZHJlblswXTtcbiAgICBjb25zdCBleHRyYUNsYXNzID0gdGhpcy5fcmVzb2x2ZVBvc3NpYmxlRnVuY3Rpb24odGhpcy5fY29uZmlnLmV4dHJhQ2xhc3MpO1xuICAgIGlmIChleHRyYUNsYXNzKSB7XG4gICAgICB0ZW1wbGF0ZS5jbGFzc0xpc3QuYWRkKC4uLmV4dHJhQ2xhc3Muc3BsaXQoJyAnKSk7XG4gICAgfVxuICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgfVxuXG4gIC8vIFByaXZhdGVcbiAgX3R5cGVDaGVja0NvbmZpZyhjb25maWcpIHtcbiAgICBzdXBlci5fdHlwZUNoZWNrQ29uZmlnKGNvbmZpZyk7XG4gICAgdGhpcy5fY2hlY2tDb250ZW50KGNvbmZpZy5jb250ZW50KTtcbiAgfVxuICBfY2hlY2tDb250ZW50KGFyZykge1xuICAgIGZvciAoY29uc3QgW3NlbGVjdG9yLCBjb250ZW50XSBvZiBPYmplY3QuZW50cmllcyhhcmcpKSB7XG4gICAgICBzdXBlci5fdHlwZUNoZWNrQ29uZmlnKHtcbiAgICAgICAgc2VsZWN0b3IsXG4gICAgICAgIGVudHJ5OiBjb250ZW50XG4gICAgICB9LCBEZWZhdWx0Q29udGVudFR5cGUpO1xuICAgIH1cbiAgfVxuICBfc2V0Q29udGVudCh0ZW1wbGF0ZSwgY29udGVudCwgc2VsZWN0b3IpIHtcbiAgICBjb25zdCB0ZW1wbGF0ZUVsZW1lbnQgPSBTZWxlY3RvckVuZ2luZS5maW5kT25lKHNlbGVjdG9yLCB0ZW1wbGF0ZSk7XG4gICAgaWYgKCF0ZW1wbGF0ZUVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29udGVudCA9IHRoaXMuX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKGNvbnRlbnQpO1xuICAgIGlmICghY29udGVudCkge1xuICAgICAgdGVtcGxhdGVFbGVtZW50LnJlbW92ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNFbGVtZW50KGNvbnRlbnQpKSB7XG4gICAgICB0aGlzLl9wdXRFbGVtZW50SW5UZW1wbGF0ZShnZXRFbGVtZW50KGNvbnRlbnQpLCB0ZW1wbGF0ZUVsZW1lbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fY29uZmlnLmh0bWwpIHtcbiAgICAgIHRlbXBsYXRlRWxlbWVudC5pbm5lckhUTUwgPSB0aGlzLl9tYXliZVNhbml0aXplKGNvbnRlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0ZW1wbGF0ZUVsZW1lbnQudGV4dENvbnRlbnQgPSBjb250ZW50O1xuICB9XG4gIF9tYXliZVNhbml0aXplKGFyZykge1xuICAgIHJldHVybiB0aGlzLl9jb25maWcuc2FuaXRpemUgPyBzYW5pdGl6ZUh0bWwoYXJnLCB0aGlzLl9jb25maWcuYWxsb3dMaXN0LCB0aGlzLl9jb25maWcuc2FuaXRpemVGbikgOiBhcmc7XG4gIH1cbiAgX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBleGVjdXRlKGFyZywgW3RoaXNdKTtcbiAgfVxuICBfcHV0RWxlbWVudEluVGVtcGxhdGUoZWxlbWVudCwgdGVtcGxhdGVFbGVtZW50KSB7XG4gICAgaWYgKHRoaXMuX2NvbmZpZy5odG1sKSB7XG4gICAgICB0ZW1wbGF0ZUVsZW1lbnQuaW5uZXJIVE1MID0gJyc7XG4gICAgICB0ZW1wbGF0ZUVsZW1lbnQuYXBwZW5kKGVsZW1lbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0ZW1wbGF0ZUVsZW1lbnQudGV4dENvbnRlbnQgPSBlbGVtZW50LnRleHRDb250ZW50O1xuICB9XG59XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCB0b29sdGlwLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuLyoqXG4gKiBDb25zdGFudHNcbiAqL1xuXG5jb25zdCBOQU1FJDQgPSAndG9vbHRpcCc7XG5jb25zdCBESVNBTExPV0VEX0FUVFJJQlVURVMgPSBuZXcgU2V0KFsnc2FuaXRpemUnLCAnYWxsb3dMaXN0JywgJ3Nhbml0aXplRm4nXSk7XG5jb25zdCBDTEFTU19OQU1FX0ZBREUkMiA9ICdmYWRlJztcbmNvbnN0IENMQVNTX05BTUVfTU9EQUwgPSAnbW9kYWwnO1xuY29uc3QgQ0xBU1NfTkFNRV9TSE9XJDIgPSAnc2hvdyc7XG5jb25zdCBTRUxFQ1RPUl9UT09MVElQX0lOTkVSID0gJy50b29sdGlwLWlubmVyJztcbmNvbnN0IFNFTEVDVE9SX01PREFMID0gYC4ke0NMQVNTX05BTUVfTU9EQUx9YDtcbmNvbnN0IEVWRU5UX01PREFMX0hJREUgPSAnaGlkZS5icy5tb2RhbCc7XG5jb25zdCBUUklHR0VSX0hPVkVSID0gJ2hvdmVyJztcbmNvbnN0IFRSSUdHRVJfRk9DVVMgPSAnZm9jdXMnO1xuY29uc3QgVFJJR0dFUl9DTElDSyA9ICdjbGljayc7XG5jb25zdCBUUklHR0VSX01BTlVBTCA9ICdtYW51YWwnO1xuY29uc3QgRVZFTlRfSElERSQyID0gJ2hpZGUnO1xuY29uc3QgRVZFTlRfSElEREVOJDIgPSAnaGlkZGVuJztcbmNvbnN0IEVWRU5UX1NIT1ckMiA9ICdzaG93JztcbmNvbnN0IEVWRU5UX1NIT1dOJDIgPSAnc2hvd24nO1xuY29uc3QgRVZFTlRfSU5TRVJURUQgPSAnaW5zZXJ0ZWQnO1xuY29uc3QgRVZFTlRfQ0xJQ0skMSA9ICdjbGljayc7XG5jb25zdCBFVkVOVF9GT0NVU0lOJDEgPSAnZm9jdXNpbic7XG5jb25zdCBFVkVOVF9GT0NVU09VVCQxID0gJ2ZvY3Vzb3V0JztcbmNvbnN0IEVWRU5UX01PVVNFRU5URVIgPSAnbW91c2VlbnRlcic7XG5jb25zdCBFVkVOVF9NT1VTRUxFQVZFID0gJ21vdXNlbGVhdmUnO1xuY29uc3QgQXR0YWNobWVudE1hcCA9IHtcbiAgQVVUTzogJ2F1dG8nLFxuICBUT1A6ICd0b3AnLFxuICBSSUdIVDogaXNSVEwoKSA/ICdsZWZ0JyA6ICdyaWdodCcsXG4gIEJPVFRPTTogJ2JvdHRvbScsXG4gIExFRlQ6IGlzUlRMKCkgPyAncmlnaHQnIDogJ2xlZnQnXG59O1xuY29uc3QgRGVmYXVsdCQzID0ge1xuICBhbGxvd0xpc3Q6IERlZmF1bHRBbGxvd2xpc3QsXG4gIGFuaW1hdGlvbjogdHJ1ZSxcbiAgYm91bmRhcnk6ICdjbGlwcGluZ1BhcmVudHMnLFxuICBjb250YWluZXI6IGZhbHNlLFxuICBjdXN0b21DbGFzczogJycsXG4gIGRlbGF5OiAwLFxuICBmYWxsYmFja1BsYWNlbWVudHM6IFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J10sXG4gIGh0bWw6IGZhbHNlLFxuICBvZmZzZXQ6IFswLCA2XSxcbiAgcGxhY2VtZW50OiAndG9wJyxcbiAgcG9wcGVyQ29uZmlnOiBudWxsLFxuICBzYW5pdGl6ZTogdHJ1ZSxcbiAgc2FuaXRpemVGbjogbnVsbCxcbiAgc2VsZWN0b3I6IGZhbHNlLFxuICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XCJ0b29sdGlwXCIgcm9sZT1cInRvb2x0aXBcIj4nICsgJzxkaXYgY2xhc3M9XCJ0b29sdGlwLWFycm93XCI+PC9kaXY+JyArICc8ZGl2IGNsYXNzPVwidG9vbHRpcC1pbm5lclwiPjwvZGl2PicgKyAnPC9kaXY+JyxcbiAgdGl0bGU6ICcnLFxuICB0cmlnZ2VyOiAnaG92ZXIgZm9jdXMnXG59O1xuY29uc3QgRGVmYXVsdFR5cGUkMyA9IHtcbiAgYWxsb3dMaXN0OiAnb2JqZWN0JyxcbiAgYW5pbWF0aW9uOiAnYm9vbGVhbicsXG4gIGJvdW5kYXJ5OiAnKHN0cmluZ3xlbGVtZW50KScsXG4gIGNvbnRhaW5lcjogJyhzdHJpbmd8ZWxlbWVudHxib29sZWFuKScsXG4gIGN1c3RvbUNsYXNzOiAnKHN0cmluZ3xmdW5jdGlvbiknLFxuICBkZWxheTogJyhudW1iZXJ8b2JqZWN0KScsXG4gIGZhbGxiYWNrUGxhY2VtZW50czogJ2FycmF5JyxcbiAgaHRtbDogJ2Jvb2xlYW4nLFxuICBvZmZzZXQ6ICcoYXJyYXl8c3RyaW5nfGZ1bmN0aW9uKScsXG4gIHBsYWNlbWVudDogJyhzdHJpbmd8ZnVuY3Rpb24pJyxcbiAgcG9wcGVyQ29uZmlnOiAnKG51bGx8b2JqZWN0fGZ1bmN0aW9uKScsXG4gIHNhbml0aXplOiAnYm9vbGVhbicsXG4gIHNhbml0aXplRm46ICcobnVsbHxmdW5jdGlvbiknLFxuICBzZWxlY3RvcjogJyhzdHJpbmd8Ym9vbGVhbiknLFxuICB0ZW1wbGF0ZTogJ3N0cmluZycsXG4gIHRpdGxlOiAnKHN0cmluZ3xlbGVtZW50fGZ1bmN0aW9uKScsXG4gIHRyaWdnZXI6ICdzdHJpbmcnXG59O1xuXG4vKipcbiAqIENsYXNzIGRlZmluaXRpb25cbiAqL1xuXG5jbGFzcyBUb29sdGlwIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZykge1xuICAgIGlmICh0eXBlb2YgUG9wcGVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9vdHN0cmFwXFwncyB0b29sdGlwcyByZXF1aXJlIFBvcHBlciAoaHR0cHM6Ly9wb3BwZXIuanMub3JnKScpO1xuICAgIH1cbiAgICBzdXBlcihlbGVtZW50LCBjb25maWcpO1xuXG4gICAgLy8gUHJpdmF0ZVxuICAgIHRoaXMuX2lzRW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5fdGltZW91dCA9IDA7XG4gICAgdGhpcy5faXNIb3ZlcmVkID0gbnVsbDtcbiAgICB0aGlzLl9hY3RpdmVUcmlnZ2VyID0ge307XG4gICAgdGhpcy5fcG9wcGVyID0gbnVsbDtcbiAgICB0aGlzLl90ZW1wbGF0ZUZhY3RvcnkgPSBudWxsO1xuICAgIHRoaXMuX25ld0NvbnRlbnQgPSBudWxsO1xuXG4gICAgLy8gUHJvdGVjdGVkXG4gICAgdGhpcy50aXAgPSBudWxsO1xuICAgIHRoaXMuX3NldExpc3RlbmVycygpO1xuICAgIGlmICghdGhpcy5fY29uZmlnLnNlbGVjdG9yKSB7XG4gICAgICB0aGlzLl9maXhUaXRsZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBEZWZhdWx0JDM7XG4gIH1cbiAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICByZXR1cm4gRGVmYXVsdFR5cGUkMztcbiAgfVxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIE5BTUUkNDtcbiAgfVxuXG4gIC8vIFB1YmxpY1xuICBlbmFibGUoKSB7XG4gICAgdGhpcy5faXNFbmFibGVkID0gdHJ1ZTtcbiAgfVxuICBkaXNhYmxlKCkge1xuICAgIHRoaXMuX2lzRW5hYmxlZCA9IGZhbHNlO1xuICB9XG4gIHRvZ2dsZUVuYWJsZWQoKSB7XG4gICAgdGhpcy5faXNFbmFibGVkID0gIXRoaXMuX2lzRW5hYmxlZDtcbiAgfVxuICB0b2dnbGUoKSB7XG4gICAgaWYgKCF0aGlzLl9pc0VuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fYWN0aXZlVHJpZ2dlci5jbGljayA9ICF0aGlzLl9hY3RpdmVUcmlnZ2VyLmNsaWNrO1xuICAgIGlmICh0aGlzLl9pc1Nob3duKCkpIHtcbiAgICAgIHRoaXMuX2xlYXZlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2VudGVyKCk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XG4gICAgRXZlbnRIYW5kbGVyLm9mZih0aGlzLl9lbGVtZW50LmNsb3Nlc3QoU0VMRUNUT1JfTU9EQUwpLCBFVkVOVF9NT0RBTF9ISURFLCB0aGlzLl9oaWRlTW9kYWxIYW5kbGVyKTtcbiAgICBpZiAodGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYnMtb3JpZ2luYWwtdGl0bGUnKSkge1xuICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgdGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYnMtb3JpZ2luYWwtdGl0bGUnKSk7XG4gICAgfVxuICAgIHRoaXMuX2Rpc3Bvc2VQb3BwZXIoKTtcbiAgICBzdXBlci5kaXNwb3NlKCk7XG4gIH1cbiAgc2hvdygpIHtcbiAgICBpZiAodGhpcy5fZWxlbWVudC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHVzZSBzaG93IG9uIHZpc2libGUgZWxlbWVudHMnKTtcbiAgICB9XG4gICAgaWYgKCEodGhpcy5faXNXaXRoQ29udGVudCgpICYmIHRoaXMuX2lzRW5hYmxlZCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2hvd0V2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfU0hPVyQyKSk7XG4gICAgY29uc3Qgc2hhZG93Um9vdCA9IGZpbmRTaGFkb3dSb290KHRoaXMuX2VsZW1lbnQpO1xuICAgIGNvbnN0IGlzSW5UaGVEb20gPSAoc2hhZG93Um9vdCB8fCB0aGlzLl9lbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5jb250YWlucyh0aGlzLl9lbGVtZW50KTtcbiAgICBpZiAoc2hvd0V2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgfHwgIWlzSW5UaGVEb20pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiB2NiByZW1vdmUgdGhpcyBvciBtYWtlIGl0IG9wdGlvbmFsXG4gICAgdGhpcy5fZGlzcG9zZVBvcHBlcigpO1xuICAgIGNvbnN0IHRpcCA9IHRoaXMuX2dldFRpcEVsZW1lbnQoKTtcbiAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1kZXNjcmliZWRieScsIHRpcC5nZXRBdHRyaWJ1dGUoJ2lkJykpO1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRhaW5lclxuICAgIH0gPSB0aGlzLl9jb25maWc7XG4gICAgaWYgKCF0aGlzLl9lbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKHRoaXMudGlwKSkge1xuICAgICAgY29udGFpbmVyLmFwcGVuZCh0aXApO1xuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfSU5TRVJURUQpKTtcbiAgICB9XG4gICAgdGhpcy5fcG9wcGVyID0gdGhpcy5fY3JlYXRlUG9wcGVyKHRpcCk7XG4gICAgdGlwLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XJDIpO1xuXG4gICAgLy8gSWYgdGhpcyBpcyBhIHRvdWNoLWVuYWJsZWQgZGV2aWNlIHdlIGFkZCBleHRyYVxuICAgIC8vIGVtcHR5IG1vdXNlb3ZlciBsaXN0ZW5lcnMgdG8gdGhlIGJvZHkncyBpbW1lZGlhdGUgY2hpbGRyZW47XG4gICAgLy8gb25seSBuZWVkZWQgYmVjYXVzZSBvZiBicm9rZW4gZXZlbnQgZGVsZWdhdGlvbiBvbiBpT1NcbiAgICAvLyBodHRwczovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTQvMDIvbW91c2VfZXZlbnRfYnViLmh0bWxcbiAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgW10uY29uY2F0KC4uLmRvY3VtZW50LmJvZHkuY2hpbGRyZW4pKSB7XG4gICAgICAgIEV2ZW50SGFuZGxlci5vbihlbGVtZW50LCAnbW91c2VvdmVyJywgbm9vcCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfU0hPV04kMikpO1xuICAgICAgaWYgKHRoaXMuX2lzSG92ZXJlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5fbGVhdmUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2lzSG92ZXJlZCA9IGZhbHNlO1xuICAgIH07XG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZSwgdGhpcy50aXAsIHRoaXMuX2lzQW5pbWF0ZWQoKSk7XG4gIH1cbiAgaGlkZSgpIHtcbiAgICBpZiAoIXRoaXMuX2lzU2hvd24oKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBoaWRlRXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLmV2ZW50TmFtZShFVkVOVF9ISURFJDIpKTtcbiAgICBpZiAoaGlkZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGlwID0gdGhpcy5fZ2V0VGlwRWxlbWVudCgpO1xuICAgIHRpcC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVyQyKTtcblxuICAgIC8vIElmIHRoaXMgaXMgYSB0b3VjaC1lbmFibGVkIGRldmljZSB3ZSByZW1vdmUgdGhlIGV4dHJhXG4gICAgLy8gZW1wdHkgbW91c2VvdmVyIGxpc3RlbmVycyB3ZSBhZGRlZCBmb3IgaU9TIHN1cHBvcnRcbiAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgW10uY29uY2F0KC4uLmRvY3VtZW50LmJvZHkuY2hpbGRyZW4pKSB7XG4gICAgICAgIEV2ZW50SGFuZGxlci5vZmYoZWxlbWVudCwgJ21vdXNlb3ZlcicsIG5vb3ApO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9hY3RpdmVUcmlnZ2VyW1RSSUdHRVJfQ0xJQ0tdID0gZmFsc2U7XG4gICAgdGhpcy5fYWN0aXZlVHJpZ2dlcltUUklHR0VSX0ZPQ1VTXSA9IGZhbHNlO1xuICAgIHRoaXMuX2FjdGl2ZVRyaWdnZXJbVFJJR0dFUl9IT1ZFUl0gPSBmYWxzZTtcbiAgICB0aGlzLl9pc0hvdmVyZWQgPSBudWxsOyAvLyBpdCBpcyBhIHRyaWNrIHRvIHN1cHBvcnQgbWFudWFsIHRyaWdnZXJpbmdcblxuICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX2lzV2l0aEFjdGl2ZVRyaWdnZXIoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuX2lzSG92ZXJlZCkge1xuICAgICAgICB0aGlzLl9kaXNwb3NlUG9wcGVyKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1kZXNjcmliZWRieScpO1xuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfSElEREVOJDIpKTtcbiAgICB9O1xuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGUsIHRoaXMudGlwLCB0aGlzLl9pc0FuaW1hdGVkKCkpO1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICBpZiAodGhpcy5fcG9wcGVyKSB7XG4gICAgICB0aGlzLl9wb3BwZXIudXBkYXRlKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gUHJvdGVjdGVkXG4gIF9pc1dpdGhDb250ZW50KCkge1xuICAgIHJldHVybiBCb29sZWFuKHRoaXMuX2dldFRpdGxlKCkpO1xuICB9XG4gIF9nZXRUaXBFbGVtZW50KCkge1xuICAgIGlmICghdGhpcy50aXApIHtcbiAgICAgIHRoaXMudGlwID0gdGhpcy5fY3JlYXRlVGlwRWxlbWVudCh0aGlzLl9uZXdDb250ZW50IHx8IHRoaXMuX2dldENvbnRlbnRGb3JUZW1wbGF0ZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGlwO1xuICB9XG4gIF9jcmVhdGVUaXBFbGVtZW50KGNvbnRlbnQpIHtcbiAgICBjb25zdCB0aXAgPSB0aGlzLl9nZXRUZW1wbGF0ZUZhY3RvcnkoY29udGVudCkudG9IdG1sKCk7XG5cbiAgICAvLyBUT0RPOiByZW1vdmUgdGhpcyBjaGVjayBpbiB2NlxuICAgIGlmICghdGlwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdGlwLmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9GQURFJDIsIENMQVNTX05BTUVfU0hPVyQyKTtcbiAgICAvLyBUT0RPOiB2NiB0aGUgZm9sbG93aW5nIGNhbiBiZSBhY2hpZXZlZCB3aXRoIENTUyBvbmx5XG4gICAgdGlwLmNsYXNzTGlzdC5hZGQoYGJzLSR7dGhpcy5jb25zdHJ1Y3Rvci5OQU1FfS1hdXRvYCk7XG4gICAgY29uc3QgdGlwSWQgPSBnZXRVSUQodGhpcy5jb25zdHJ1Y3Rvci5OQU1FKS50b1N0cmluZygpO1xuICAgIHRpcC5zZXRBdHRyaWJ1dGUoJ2lkJywgdGlwSWQpO1xuICAgIGlmICh0aGlzLl9pc0FuaW1hdGVkKCkpIHtcbiAgICAgIHRpcC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfRkFERSQyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRpcDtcbiAgfVxuICBzZXRDb250ZW50KGNvbnRlbnQpIHtcbiAgICB0aGlzLl9uZXdDb250ZW50ID0gY29udGVudDtcbiAgICBpZiAodGhpcy5faXNTaG93bigpKSB7XG4gICAgICB0aGlzLl9kaXNwb3NlUG9wcGVyKCk7XG4gICAgICB0aGlzLnNob3coKTtcbiAgICB9XG4gIH1cbiAgX2dldFRlbXBsYXRlRmFjdG9yeShjb250ZW50KSB7XG4gICAgaWYgKHRoaXMuX3RlbXBsYXRlRmFjdG9yeSkge1xuICAgICAgdGhpcy5fdGVtcGxhdGVGYWN0b3J5LmNoYW5nZUNvbnRlbnQoY29udGVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3RlbXBsYXRlRmFjdG9yeSA9IG5ldyBUZW1wbGF0ZUZhY3Rvcnkoe1xuICAgICAgICAuLi50aGlzLl9jb25maWcsXG4gICAgICAgIC8vIHRoZSBgY29udGVudGAgdmFyIGhhcyB0byBiZSBhZnRlciBgdGhpcy5fY29uZmlnYFxuICAgICAgICAvLyB0byBvdmVycmlkZSBjb25maWcuY29udGVudCBpbiBjYXNlIG9mIHBvcG92ZXJcbiAgICAgICAgY29udGVudCxcbiAgICAgICAgZXh0cmFDbGFzczogdGhpcy5fcmVzb2x2ZVBvc3NpYmxlRnVuY3Rpb24odGhpcy5fY29uZmlnLmN1c3RvbUNsYXNzKVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl90ZW1wbGF0ZUZhY3Rvcnk7XG4gIH1cbiAgX2dldENvbnRlbnRGb3JUZW1wbGF0ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgW1NFTEVDVE9SX1RPT0xUSVBfSU5ORVJdOiB0aGlzLl9nZXRUaXRsZSgpXG4gICAgfTtcbiAgfVxuICBfZ2V0VGl0bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKHRoaXMuX2NvbmZpZy50aXRsZSkgfHwgdGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYnMtb3JpZ2luYWwtdGl0bGUnKTtcbiAgfVxuXG4gIC8vIFByaXZhdGVcbiAgX2luaXRpYWxpemVPbkRlbGVnYXRlZFRhcmdldChldmVudCkge1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLmdldE9yQ3JlYXRlSW5zdGFuY2UoZXZlbnQuZGVsZWdhdGVUYXJnZXQsIHRoaXMuX2dldERlbGVnYXRlQ29uZmlnKCkpO1xuICB9XG4gIF9pc0FuaW1hdGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWcuYW5pbWF0aW9uIHx8IHRoaXMudGlwICYmIHRoaXMudGlwLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0ZBREUkMik7XG4gIH1cbiAgX2lzU2hvd24oKSB7XG4gICAgcmV0dXJuIHRoaXMudGlwICYmIHRoaXMudGlwLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX1NIT1ckMik7XG4gIH1cbiAgX2NyZWF0ZVBvcHBlcih0aXApIHtcbiAgICBjb25zdCBwbGFjZW1lbnQgPSBleGVjdXRlKHRoaXMuX2NvbmZpZy5wbGFjZW1lbnQsIFt0aGlzLCB0aXAsIHRoaXMuX2VsZW1lbnRdKTtcbiAgICBjb25zdCBhdHRhY2htZW50ID0gQXR0YWNobWVudE1hcFtwbGFjZW1lbnQudG9VcHBlckNhc2UoKV07XG4gICAgcmV0dXJuIFBvcHBlci5jcmVhdGVQb3BwZXIodGhpcy5fZWxlbWVudCwgdGlwLCB0aGlzLl9nZXRQb3BwZXJDb25maWcoYXR0YWNobWVudCkpO1xuICB9XG4gIF9nZXRPZmZzZXQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgb2Zmc2V0XG4gICAgfSA9IHRoaXMuX2NvbmZpZztcbiAgICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBvZmZzZXQuc3BsaXQoJywnKS5tYXAodmFsdWUgPT4gTnVtYmVyLnBhcnNlSW50KHZhbHVlLCAxMCkpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHBvcHBlckRhdGEgPT4gb2Zmc2V0KHBvcHBlckRhdGEsIHRoaXMuX2VsZW1lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG4gIF9yZXNvbHZlUG9zc2libGVGdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZXhlY3V0ZShhcmcsIFt0aGlzLl9lbGVtZW50XSk7XG4gIH1cbiAgX2dldFBvcHBlckNvbmZpZyhhdHRhY2htZW50KSB7XG4gICAgY29uc3QgZGVmYXVsdEJzUG9wcGVyQ29uZmlnID0ge1xuICAgICAgcGxhY2VtZW50OiBhdHRhY2htZW50LFxuICAgICAgbW9kaWZpZXJzOiBbe1xuICAgICAgICBuYW1lOiAnZmxpcCcsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBmYWxsYmFja1BsYWNlbWVudHM6IHRoaXMuX2NvbmZpZy5mYWxsYmFja1BsYWNlbWVudHNcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBuYW1lOiAnb2Zmc2V0JyxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIG9mZnNldDogdGhpcy5fZ2V0T2Zmc2V0KClcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBuYW1lOiAncHJldmVudE92ZXJmbG93JyxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIGJvdW5kYXJ5OiB0aGlzLl9jb25maWcuYm91bmRhcnlcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBuYW1lOiAnYXJyb3cnLFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgZWxlbWVudDogYC4ke3RoaXMuY29uc3RydWN0b3IuTkFNRX0tYXJyb3dgXG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAgbmFtZTogJ3ByZVNldFBsYWNlbWVudCcsXG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIHBoYXNlOiAnYmVmb3JlTWFpbicsXG4gICAgICAgIGZuOiBkYXRhID0+IHtcbiAgICAgICAgICAvLyBQcmUtc2V0IFBvcHBlcidzIHBsYWNlbWVudCBhdHRyaWJ1dGUgaW4gb3JkZXIgdG8gcmVhZCB0aGUgYXJyb3cgc2l6ZXMgcHJvcGVybHkuXG4gICAgICAgICAgLy8gT3RoZXJ3aXNlLCBQb3BwZXIgbWl4ZXMgdXAgdGhlIHdpZHRoIGFuZCBoZWlnaHQgZGltZW5zaW9ucyBzaW5jZSB0aGUgaW5pdGlhbCBhcnJvdyBzdHlsZSBpcyBmb3IgdG9wIHBsYWNlbWVudFxuICAgICAgICAgIHRoaXMuX2dldFRpcEVsZW1lbnQoKS5zZXRBdHRyaWJ1dGUoJ2RhdGEtcG9wcGVyLXBsYWNlbWVudCcsIGRhdGEuc3RhdGUucGxhY2VtZW50KTtcbiAgICAgICAgfVxuICAgICAgfV1cbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAuLi5kZWZhdWx0QnNQb3BwZXJDb25maWcsXG4gICAgICAuLi5leGVjdXRlKHRoaXMuX2NvbmZpZy5wb3BwZXJDb25maWcsIFtkZWZhdWx0QnNQb3BwZXJDb25maWddKVxuICAgIH07XG4gIH1cbiAgX3NldExpc3RlbmVycygpIHtcbiAgICBjb25zdCB0cmlnZ2VycyA9IHRoaXMuX2NvbmZpZy50cmlnZ2VyLnNwbGl0KCcgJyk7XG4gICAgZm9yIChjb25zdCB0cmlnZ2VyIG9mIHRyaWdnZXJzKSB7XG4gICAgICBpZiAodHJpZ2dlciA9PT0gJ2NsaWNrJykge1xuICAgICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfQ0xJQ0skMSksIHRoaXMuX2NvbmZpZy5zZWxlY3RvciwgZXZlbnQgPT4ge1xuICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLl9pbml0aWFsaXplT25EZWxlZ2F0ZWRUYXJnZXQoZXZlbnQpO1xuICAgICAgICAgIGNvbnRleHQudG9nZ2xlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICh0cmlnZ2VyICE9PSBUUklHR0VSX01BTlVBTCkge1xuICAgICAgICBjb25zdCBldmVudEluID0gdHJpZ2dlciA9PT0gVFJJR0dFUl9IT1ZFUiA/IHRoaXMuY29uc3RydWN0b3IuZXZlbnROYW1lKEVWRU5UX01PVVNFRU5URVIpIDogdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfRk9DVVNJTiQxKTtcbiAgICAgICAgY29uc3QgZXZlbnRPdXQgPSB0cmlnZ2VyID09PSBUUklHR0VSX0hPVkVSID8gdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfTU9VU0VMRUFWRSkgOiB0aGlzLmNvbnN0cnVjdG9yLmV2ZW50TmFtZShFVkVOVF9GT0NVU09VVCQxKTtcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIGV2ZW50SW4sIHRoaXMuX2NvbmZpZy5zZWxlY3RvciwgZXZlbnQgPT4ge1xuICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLl9pbml0aWFsaXplT25EZWxlZ2F0ZWRUYXJnZXQoZXZlbnQpO1xuICAgICAgICAgIGNvbnRleHQuX2FjdGl2ZVRyaWdnZXJbZXZlbnQudHlwZSA9PT0gJ2ZvY3VzaW4nID8gVFJJR0dFUl9GT0NVUyA6IFRSSUdHRVJfSE9WRVJdID0gdHJ1ZTtcbiAgICAgICAgICBjb250ZXh0Ll9lbnRlcigpO1xuICAgICAgICB9KTtcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIGV2ZW50T3V0LCB0aGlzLl9jb25maWcuc2VsZWN0b3IsIGV2ZW50ID0+IHtcbiAgICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5faW5pdGlhbGl6ZU9uRGVsZWdhdGVkVGFyZ2V0KGV2ZW50KTtcbiAgICAgICAgICBjb250ZXh0Ll9hY3RpdmVUcmlnZ2VyW2V2ZW50LnR5cGUgPT09ICdmb2N1c291dCcgPyBUUklHR0VSX0ZPQ1VTIDogVFJJR0dFUl9IT1ZFUl0gPSBjb250ZXh0Ll9lbGVtZW50LmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQpO1xuICAgICAgICAgIGNvbnRleHQuX2xlYXZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9oaWRlTW9kYWxIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX2VsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudC5jbG9zZXN0KFNFTEVDVE9SX01PREFMKSwgRVZFTlRfTU9EQUxfSElERSwgdGhpcy5faGlkZU1vZGFsSGFuZGxlcik7XG4gIH1cbiAgX2ZpeFRpdGxlKCkge1xuICAgIGNvbnN0IHRpdGxlID0gdGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3RpdGxlJyk7XG4gICAgaWYgKCF0aXRsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJykgJiYgIXRoaXMuX2VsZW1lbnQudGV4dENvbnRlbnQudHJpbSgpKSB7XG4gICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIHRpdGxlKTtcbiAgICB9XG4gICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtYnMtb3JpZ2luYWwtdGl0bGUnLCB0aXRsZSk7IC8vIERPIE5PVCBVU0UgSVQuIElzIG9ubHkgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3RpdGxlJyk7XG4gIH1cbiAgX2VudGVyKCkge1xuICAgIGlmICh0aGlzLl9pc1Nob3duKCkgfHwgdGhpcy5faXNIb3ZlcmVkKSB7XG4gICAgICB0aGlzLl9pc0hvdmVyZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9pc0hvdmVyZWQgPSB0cnVlO1xuICAgIHRoaXMuX3NldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX2lzSG92ZXJlZCkge1xuICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLl9jb25maWcuZGVsYXkuc2hvdyk7XG4gIH1cbiAgX2xlYXZlKCkge1xuICAgIGlmICh0aGlzLl9pc1dpdGhBY3RpdmVUcmlnZ2VyKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5faXNIb3ZlcmVkID0gZmFsc2U7XG4gICAgdGhpcy5fc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX2lzSG92ZXJlZCkge1xuICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLl9jb25maWcuZGVsYXkuaGlkZSk7XG4gIH1cbiAgX3NldFRpbWVvdXQoaGFuZGxlciwgdGltZW91dCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcbiAgICB0aGlzLl90aW1lb3V0ID0gc2V0VGltZW91dChoYW5kbGVyLCB0aW1lb3V0KTtcbiAgfVxuICBfaXNXaXRoQWN0aXZlVHJpZ2dlcigpIHtcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLl9hY3RpdmVUcmlnZ2VyKS5pbmNsdWRlcyh0cnVlKTtcbiAgfVxuICBfZ2V0Q29uZmlnKGNvbmZpZykge1xuICAgIGNvbnN0IGRhdGFBdHRyaWJ1dGVzID0gTWFuaXB1bGF0b3IuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgZm9yIChjb25zdCBkYXRhQXR0cmlidXRlIG9mIE9iamVjdC5rZXlzKGRhdGFBdHRyaWJ1dGVzKSkge1xuICAgICAgaWYgKERJU0FMTE9XRURfQVRUUklCVVRFUy5oYXMoZGF0YUF0dHJpYnV0ZSkpIHtcbiAgICAgICAgZGVsZXRlIGRhdGFBdHRyaWJ1dGVzW2RhdGFBdHRyaWJ1dGVdO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25maWcgPSB7XG4gICAgICAuLi5kYXRhQXR0cmlidXRlcyxcbiAgICAgIC4uLih0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyAmJiBjb25maWcgPyBjb25maWcgOiB7fSlcbiAgICB9O1xuICAgIGNvbmZpZyA9IHRoaXMuX21lcmdlQ29uZmlnT2JqKGNvbmZpZyk7XG4gICAgY29uZmlnID0gdGhpcy5fY29uZmlnQWZ0ZXJNZXJnZShjb25maWcpO1xuICAgIHRoaXMuX3R5cGVDaGVja0NvbmZpZyhjb25maWcpO1xuICAgIHJldHVybiBjb25maWc7XG4gIH1cbiAgX2NvbmZpZ0FmdGVyTWVyZ2UoY29uZmlnKSB7XG4gICAgY29uZmlnLmNvbnRhaW5lciA9IGNvbmZpZy5jb250YWluZXIgPT09IGZhbHNlID8gZG9jdW1lbnQuYm9keSA6IGdldEVsZW1lbnQoY29uZmlnLmNvbnRhaW5lcik7XG4gICAgaWYgKHR5cGVvZiBjb25maWcuZGVsYXkgPT09ICdudW1iZXInKSB7XG4gICAgICBjb25maWcuZGVsYXkgPSB7XG4gICAgICAgIHNob3c6IGNvbmZpZy5kZWxheSxcbiAgICAgICAgaGlkZTogY29uZmlnLmRlbGF5XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbmZpZy50aXRsZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGNvbmZpZy50aXRsZSA9IGNvbmZpZy50aXRsZS50b1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbmZpZy5jb250ZW50ID09PSAnbnVtYmVyJykge1xuICAgICAgY29uZmlnLmNvbnRlbnQgPSBjb25maWcuY29udGVudC50b1N0cmluZygpO1xuICAgIH1cbiAgICByZXR1cm4gY29uZmlnO1xuICB9XG4gIF9nZXREZWxlZ2F0ZUNvbmZpZygpIHtcbiAgICBjb25zdCBjb25maWcgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLl9jb25maWcpKSB7XG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0W2tleV0gIT09IHZhbHVlKSB7XG4gICAgICAgIGNvbmZpZ1trZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbmZpZy5zZWxlY3RvciA9IGZhbHNlO1xuICAgIGNvbmZpZy50cmlnZ2VyID0gJ21hbnVhbCc7XG5cbiAgICAvLyBJbiB0aGUgZnV0dXJlIGNhbiBiZSByZXBsYWNlZCB3aXRoOlxuICAgIC8vIGNvbnN0IGtleXNXaXRoRGlmZmVyZW50VmFsdWVzID0gT2JqZWN0LmVudHJpZXModGhpcy5fY29uZmlnKS5maWx0ZXIoZW50cnkgPT4gdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0W2VudHJ5WzBdXSAhPT0gdGhpcy5fY29uZmlnW2VudHJ5WzBdXSlcbiAgICAvLyBgT2JqZWN0LmZyb21FbnRyaWVzKGtleXNXaXRoRGlmZmVyZW50VmFsdWVzKWBcbiAgICByZXR1cm4gY29uZmlnO1xuICB9XG4gIF9kaXNwb3NlUG9wcGVyKCkge1xuICAgIGlmICh0aGlzLl9wb3BwZXIpIHtcbiAgICAgIHRoaXMuX3BvcHBlci5kZXN0cm95KCk7XG4gICAgICB0aGlzLl9wb3BwZXIgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy50aXApIHtcbiAgICAgIHRoaXMudGlwLnJlbW92ZSgpO1xuICAgICAgdGhpcy50aXAgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgZGF0YSA9IFRvb2x0aXAuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCBjb25maWcpO1xuICAgICAgaWYgKHR5cGVvZiBjb25maWcgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApO1xuICAgICAgfVxuICAgICAgZGF0YVtjb25maWddKCk7XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBqUXVlcnlcbiAqL1xuXG5kZWZpbmVKUXVlcnlQbHVnaW4oVG9vbHRpcCk7XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCBwb3BvdmVyLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuLyoqXG4gKiBDb25zdGFudHNcbiAqL1xuXG5jb25zdCBOQU1FJDMgPSAncG9wb3Zlcic7XG5jb25zdCBTRUxFQ1RPUl9USVRMRSA9ICcucG9wb3Zlci1oZWFkZXInO1xuY29uc3QgU0VMRUNUT1JfQ09OVEVOVCA9ICcucG9wb3Zlci1ib2R5JztcbmNvbnN0IERlZmF1bHQkMiA9IHtcbiAgLi4uVG9vbHRpcC5EZWZhdWx0LFxuICBjb250ZW50OiAnJyxcbiAgb2Zmc2V0OiBbMCwgOF0sXG4gIHBsYWNlbWVudDogJ3JpZ2h0JyxcbiAgdGVtcGxhdGU6ICc8ZGl2IGNsYXNzPVwicG9wb3ZlclwiIHJvbGU9XCJ0b29sdGlwXCI+JyArICc8ZGl2IGNsYXNzPVwicG9wb3Zlci1hcnJvd1wiPjwvZGl2PicgKyAnPGgzIGNsYXNzPVwicG9wb3Zlci1oZWFkZXJcIj48L2gzPicgKyAnPGRpdiBjbGFzcz1cInBvcG92ZXItYm9keVwiPjwvZGl2PicgKyAnPC9kaXY+JyxcbiAgdHJpZ2dlcjogJ2NsaWNrJ1xufTtcbmNvbnN0IERlZmF1bHRUeXBlJDIgPSB7XG4gIC4uLlRvb2x0aXAuRGVmYXVsdFR5cGUsXG4gIGNvbnRlbnQ6ICcobnVsbHxzdHJpbmd8ZWxlbWVudHxmdW5jdGlvbiknXG59O1xuXG4vKipcbiAqIENsYXNzIGRlZmluaXRpb25cbiAqL1xuXG5jbGFzcyBQb3BvdmVyIGV4dGVuZHMgVG9vbHRpcCB7XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBEZWZhdWx0JDI7XG4gIH1cbiAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICByZXR1cm4gRGVmYXVsdFR5cGUkMjtcbiAgfVxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIE5BTUUkMztcbiAgfVxuXG4gIC8vIE92ZXJyaWRlc1xuICBfaXNXaXRoQ29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0VGl0bGUoKSB8fCB0aGlzLl9nZXRDb250ZW50KCk7XG4gIH1cblxuICAvLyBQcml2YXRlXG4gIF9nZXRDb250ZW50Rm9yVGVtcGxhdGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFtTRUxFQ1RPUl9USVRMRV06IHRoaXMuX2dldFRpdGxlKCksXG4gICAgICBbU0VMRUNUT1JfQ09OVEVOVF06IHRoaXMuX2dldENvbnRlbnQoKVxuICAgIH07XG4gIH1cbiAgX2dldENvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKHRoaXMuX2NvbmZpZy5jb250ZW50KTtcbiAgfVxuXG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgZGF0YSA9IFBvcG92ZXIuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCBjb25maWcpO1xuICAgICAgaWYgKHR5cGVvZiBjb25maWcgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApO1xuICAgICAgfVxuICAgICAgZGF0YVtjb25maWddKCk7XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBqUXVlcnlcbiAqL1xuXG5kZWZpbmVKUXVlcnlQbHVnaW4oUG9wb3Zlcik7XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCBzY3JvbGxzcHkuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG4vKipcbiAqIENvbnN0YW50c1xuICovXG5cbmNvbnN0IE5BTUUkMiA9ICdzY3JvbGxzcHknO1xuY29uc3QgREFUQV9LRVkkMiA9ICdicy5zY3JvbGxzcHknO1xuY29uc3QgRVZFTlRfS0VZJDIgPSBgLiR7REFUQV9LRVkkMn1gO1xuY29uc3QgREFUQV9BUElfS0VZID0gJy5kYXRhLWFwaSc7XG5jb25zdCBFVkVOVF9BQ1RJVkFURSA9IGBhY3RpdmF0ZSR7RVZFTlRfS0VZJDJ9YDtcbmNvbnN0IEVWRU5UX0NMSUNLID0gYGNsaWNrJHtFVkVOVF9LRVkkMn1gO1xuY29uc3QgRVZFTlRfTE9BRF9EQVRBX0FQSSQxID0gYGxvYWQke0VWRU5UX0tFWSQyfSR7REFUQV9BUElfS0VZfWA7XG5jb25zdCBDTEFTU19OQU1FX0RST1BET1dOX0lURU0gPSAnZHJvcGRvd24taXRlbSc7XG5jb25zdCBDTEFTU19OQU1FX0FDVElWRSQxID0gJ2FjdGl2ZSc7XG5jb25zdCBTRUxFQ1RPUl9EQVRBX1NQWSA9ICdbZGF0YS1icy1zcHk9XCJzY3JvbGxcIl0nO1xuY29uc3QgU0VMRUNUT1JfVEFSR0VUX0xJTktTID0gJ1tocmVmXSc7XG5jb25zdCBTRUxFQ1RPUl9OQVZfTElTVF9HUk9VUCA9ICcubmF2LCAubGlzdC1ncm91cCc7XG5jb25zdCBTRUxFQ1RPUl9OQVZfTElOS1MgPSAnLm5hdi1saW5rJztcbmNvbnN0IFNFTEVDVE9SX05BVl9JVEVNUyA9ICcubmF2LWl0ZW0nO1xuY29uc3QgU0VMRUNUT1JfTElTVF9JVEVNUyA9ICcubGlzdC1ncm91cC1pdGVtJztcbmNvbnN0IFNFTEVDVE9SX0xJTktfSVRFTVMgPSBgJHtTRUxFQ1RPUl9OQVZfTElOS1N9LCAke1NFTEVDVE9SX05BVl9JVEVNU30gPiAke1NFTEVDVE9SX05BVl9MSU5LU30sICR7U0VMRUNUT1JfTElTVF9JVEVNU31gO1xuY29uc3QgU0VMRUNUT1JfRFJPUERPV04gPSAnLmRyb3Bkb3duJztcbmNvbnN0IFNFTEVDVE9SX0RST1BET1dOX1RPR0dMRSQxID0gJy5kcm9wZG93bi10b2dnbGUnO1xuY29uc3QgRGVmYXVsdCQxID0ge1xuICBvZmZzZXQ6IG51bGwsXG4gIC8vIFRPRE86IHY2IEBkZXByZWNhdGVkLCBrZWVwIGl0IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSByZWFzb25zXG4gIHJvb3RNYXJnaW46ICcwcHggMHB4IC0yNSUnLFxuICBzbW9vdGhTY3JvbGw6IGZhbHNlLFxuICB0YXJnZXQ6IG51bGwsXG4gIHRocmVzaG9sZDogWzAuMSwgMC41LCAxXVxufTtcbmNvbnN0IERlZmF1bHRUeXBlJDEgPSB7XG4gIG9mZnNldDogJyhudW1iZXJ8bnVsbCknLFxuICAvLyBUT0RPIHY2IEBkZXByZWNhdGVkLCBrZWVwIGl0IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSByZWFzb25zXG4gIHJvb3RNYXJnaW46ICdzdHJpbmcnLFxuICBzbW9vdGhTY3JvbGw6ICdib29sZWFuJyxcbiAgdGFyZ2V0OiAnZWxlbWVudCcsXG4gIHRocmVzaG9sZDogJ2FycmF5J1xufTtcblxuLyoqXG4gKiBDbGFzcyBkZWZpbml0aW9uXG4gKi9cblxuY2xhc3MgU2Nyb2xsU3B5IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZykge1xuICAgIHN1cGVyKGVsZW1lbnQsIGNvbmZpZyk7XG5cbiAgICAvLyB0aGlzLl9lbGVtZW50IGlzIHRoZSBvYnNlcnZhYmxlc0NvbnRhaW5lciBhbmQgY29uZmlnLnRhcmdldCB0aGUgbWVudSBsaW5rcyB3cmFwcGVyXG4gICAgdGhpcy5fdGFyZ2V0TGlua3MgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5fb2JzZXJ2YWJsZVNlY3Rpb25zID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuX3Jvb3RFbGVtZW50ID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLl9lbGVtZW50KS5vdmVyZmxvd1kgPT09ICd2aXNpYmxlJyA/IG51bGwgOiB0aGlzLl9lbGVtZW50O1xuICAgIHRoaXMuX2FjdGl2ZVRhcmdldCA9IG51bGw7XG4gICAgdGhpcy5fb2JzZXJ2ZXIgPSBudWxsO1xuICAgIHRoaXMuX3ByZXZpb3VzU2Nyb2xsRGF0YSA9IHtcbiAgICAgIHZpc2libGVFbnRyeVRvcDogMCxcbiAgICAgIHBhcmVudFNjcm9sbFRvcDogMFxuICAgIH07XG4gICAgdGhpcy5yZWZyZXNoKCk7IC8vIGluaXRpYWxpemVcbiAgfVxuXG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBEZWZhdWx0JDE7XG4gIH1cbiAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICByZXR1cm4gRGVmYXVsdFR5cGUkMTtcbiAgfVxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIE5BTUUkMjtcbiAgfVxuXG4gIC8vIFB1YmxpY1xuICByZWZyZXNoKCkge1xuICAgIHRoaXMuX2luaXRpYWxpemVUYXJnZXRzQW5kT2JzZXJ2YWJsZXMoKTtcbiAgICB0aGlzLl9tYXliZUVuYWJsZVNtb290aFNjcm9sbCgpO1xuICAgIGlmICh0aGlzLl9vYnNlcnZlcikge1xuICAgICAgdGhpcy5fb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9vYnNlcnZlciA9IHRoaXMuX2dldE5ld09ic2VydmVyKCk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgc2VjdGlvbiBvZiB0aGlzLl9vYnNlcnZhYmxlU2VjdGlvbnMudmFsdWVzKCkpIHtcbiAgICAgIHRoaXMuX29ic2VydmVyLm9ic2VydmUoc2VjdGlvbik7XG4gICAgfVxuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgfVxuXG4gIC8vIFByaXZhdGVcbiAgX2NvbmZpZ0FmdGVyTWVyZ2UoY29uZmlnKSB7XG4gICAgLy8gVE9ETzogb24gdjYgdGFyZ2V0IHNob3VsZCBiZSBnaXZlbiBleHBsaWNpdGx5ICYgcmVtb3ZlIHRoZSB7dGFyZ2V0OiAnc3MtdGFyZ2V0J30gY2FzZVxuICAgIGNvbmZpZy50YXJnZXQgPSBnZXRFbGVtZW50KGNvbmZpZy50YXJnZXQpIHx8IGRvY3VtZW50LmJvZHk7XG5cbiAgICAvLyBUT0RPOiB2NiBPbmx5IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSByZWFzb25zLiBVc2Ugcm9vdE1hcmdpbiBvbmx5XG4gICAgY29uZmlnLnJvb3RNYXJnaW4gPSBjb25maWcub2Zmc2V0ID8gYCR7Y29uZmlnLm9mZnNldH1weCAwcHggLTMwJWAgOiBjb25maWcucm9vdE1hcmdpbjtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy50aHJlc2hvbGQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25maWcudGhyZXNob2xkID0gY29uZmlnLnRocmVzaG9sZC5zcGxpdCgnLCcpLm1hcCh2YWx1ZSA9PiBOdW1iZXIucGFyc2VGbG9hdCh2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gY29uZmlnO1xuICB9XG4gIF9tYXliZUVuYWJsZVNtb290aFNjcm9sbCgpIHtcbiAgICBpZiAoIXRoaXMuX2NvbmZpZy5zbW9vdGhTY3JvbGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyB1bnJlZ2lzdGVyIGFueSBwcmV2aW91cyBsaXN0ZW5lcnNcbiAgICBFdmVudEhhbmRsZXIub2ZmKHRoaXMuX2NvbmZpZy50YXJnZXQsIEVWRU5UX0NMSUNLKTtcbiAgICBFdmVudEhhbmRsZXIub24odGhpcy5fY29uZmlnLnRhcmdldCwgRVZFTlRfQ0xJQ0ssIFNFTEVDVE9SX1RBUkdFVF9MSU5LUywgZXZlbnQgPT4ge1xuICAgICAgY29uc3Qgb2JzZXJ2YWJsZVNlY3Rpb24gPSB0aGlzLl9vYnNlcnZhYmxlU2VjdGlvbnMuZ2V0KGV2ZW50LnRhcmdldC5oYXNoKTtcbiAgICAgIGlmIChvYnNlcnZhYmxlU2VjdGlvbikge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBjb25zdCByb290ID0gdGhpcy5fcm9vdEVsZW1lbnQgfHwgd2luZG93O1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBvYnNlcnZhYmxlU2VjdGlvbi5vZmZzZXRUb3AgLSB0aGlzLl9lbGVtZW50Lm9mZnNldFRvcDtcbiAgICAgICAgaWYgKHJvb3Quc2Nyb2xsVG8pIHtcbiAgICAgICAgICByb290LnNjcm9sbFRvKHtcbiAgICAgICAgICAgIHRvcDogaGVpZ2h0LFxuICAgICAgICAgICAgYmVoYXZpb3I6ICdzbW9vdGgnXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hyb21lIDYwIGRvZXNuJ3Qgc3VwcG9ydCBgc2Nyb2xsVG9gXG4gICAgICAgIHJvb3Quc2Nyb2xsVG9wID0gaGVpZ2h0O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIF9nZXROZXdPYnNlcnZlcigpIHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgcm9vdDogdGhpcy5fcm9vdEVsZW1lbnQsXG4gICAgICB0aHJlc2hvbGQ6IHRoaXMuX2NvbmZpZy50aHJlc2hvbGQsXG4gICAgICByb290TWFyZ2luOiB0aGlzLl9jb25maWcucm9vdE1hcmdpblxuICAgIH07XG4gICAgcmV0dXJuIG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihlbnRyaWVzID0+IHRoaXMuX29ic2VydmVyQ2FsbGJhY2soZW50cmllcyksIG9wdGlvbnMpO1xuICB9XG5cbiAgLy8gVGhlIGxvZ2ljIG9mIHNlbGVjdGlvblxuICBfb2JzZXJ2ZXJDYWxsYmFjayhlbnRyaWVzKSB7XG4gICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IGVudHJ5ID0+IHRoaXMuX3RhcmdldExpbmtzLmdldChgIyR7ZW50cnkudGFyZ2V0LmlkfWApO1xuICAgIGNvbnN0IGFjdGl2YXRlID0gZW50cnkgPT4ge1xuICAgICAgdGhpcy5fcHJldmlvdXNTY3JvbGxEYXRhLnZpc2libGVFbnRyeVRvcCA9IGVudHJ5LnRhcmdldC5vZmZzZXRUb3A7XG4gICAgICB0aGlzLl9wcm9jZXNzKHRhcmdldEVsZW1lbnQoZW50cnkpKTtcbiAgICB9O1xuICAgIGNvbnN0IHBhcmVudFNjcm9sbFRvcCA9ICh0aGlzLl9yb290RWxlbWVudCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpLnNjcm9sbFRvcDtcbiAgICBjb25zdCB1c2VyU2Nyb2xsc0Rvd24gPSBwYXJlbnRTY3JvbGxUb3AgPj0gdGhpcy5fcHJldmlvdXNTY3JvbGxEYXRhLnBhcmVudFNjcm9sbFRvcDtcbiAgICB0aGlzLl9wcmV2aW91c1Njcm9sbERhdGEucGFyZW50U2Nyb2xsVG9wID0gcGFyZW50U2Nyb2xsVG9wO1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgaWYgKCFlbnRyeS5pc0ludGVyc2VjdGluZykge1xuICAgICAgICB0aGlzLl9hY3RpdmVUYXJnZXQgPSBudWxsO1xuICAgICAgICB0aGlzLl9jbGVhckFjdGl2ZUNsYXNzKHRhcmdldEVsZW1lbnQoZW50cnkpKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBlbnRyeUlzTG93ZXJUaGFuUHJldmlvdXMgPSBlbnRyeS50YXJnZXQub2Zmc2V0VG9wID49IHRoaXMuX3ByZXZpb3VzU2Nyb2xsRGF0YS52aXNpYmxlRW50cnlUb3A7XG4gICAgICAvLyBpZiB3ZSBhcmUgc2Nyb2xsaW5nIGRvd24sIHBpY2sgdGhlIGJpZ2dlciBvZmZzZXRUb3BcbiAgICAgIGlmICh1c2VyU2Nyb2xsc0Rvd24gJiYgZW50cnlJc0xvd2VyVGhhblByZXZpb3VzKSB7XG4gICAgICAgIGFjdGl2YXRlKGVudHJ5KTtcbiAgICAgICAgLy8gaWYgcGFyZW50IGlzbid0IHNjcm9sbGVkLCBsZXQncyBrZWVwIHRoZSBmaXJzdCB2aXNpYmxlIGl0ZW0sIGJyZWFraW5nIHRoZSBpdGVyYXRpb25cbiAgICAgICAgaWYgKCFwYXJlbnRTY3JvbGxUb3ApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHdlIGFyZSBzY3JvbGxpbmcgdXAsIHBpY2sgdGhlIHNtYWxsZXN0IG9mZnNldFRvcFxuICAgICAgaWYgKCF1c2VyU2Nyb2xsc0Rvd24gJiYgIWVudHJ5SXNMb3dlclRoYW5QcmV2aW91cykge1xuICAgICAgICBhY3RpdmF0ZShlbnRyeSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9pbml0aWFsaXplVGFyZ2V0c0FuZE9ic2VydmFibGVzKCkge1xuICAgIHRoaXMuX3RhcmdldExpbmtzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuX29ic2VydmFibGVTZWN0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCB0YXJnZXRMaW5rcyA9IFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfVEFSR0VUX0xJTktTLCB0aGlzLl9jb25maWcudGFyZ2V0KTtcbiAgICBmb3IgKGNvbnN0IGFuY2hvciBvZiB0YXJnZXRMaW5rcykge1xuICAgICAgLy8gZW5zdXJlIHRoYXQgdGhlIGFuY2hvciBoYXMgYW4gaWQgYW5kIGlzIG5vdCBkaXNhYmxlZFxuICAgICAgaWYgKCFhbmNob3IuaGFzaCB8fCBpc0Rpc2FibGVkKGFuY2hvcikpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBvYnNlcnZhYmxlU2VjdGlvbiA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoYW5jaG9yLmhhc2gsIHRoaXMuX2VsZW1lbnQpO1xuXG4gICAgICAvLyBlbnN1cmUgdGhhdCB0aGUgb2JzZXJ2YWJsZVNlY3Rpb24gZXhpc3RzICYgaXMgdmlzaWJsZVxuICAgICAgaWYgKGlzVmlzaWJsZShvYnNlcnZhYmxlU2VjdGlvbikpIHtcbiAgICAgICAgdGhpcy5fdGFyZ2V0TGlua3Muc2V0KGFuY2hvci5oYXNoLCBhbmNob3IpO1xuICAgICAgICB0aGlzLl9vYnNlcnZhYmxlU2VjdGlvbnMuc2V0KGFuY2hvci5oYXNoLCBvYnNlcnZhYmxlU2VjdGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9wcm9jZXNzKHRhcmdldCkge1xuICAgIGlmICh0aGlzLl9hY3RpdmVUYXJnZXQgPT09IHRhcmdldCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9jbGVhckFjdGl2ZUNsYXNzKHRoaXMuX2NvbmZpZy50YXJnZXQpO1xuICAgIHRoaXMuX2FjdGl2ZVRhcmdldCA9IHRhcmdldDtcbiAgICB0YXJnZXQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0FDVElWRSQxKTtcbiAgICB0aGlzLl9hY3RpdmF0ZVBhcmVudHModGFyZ2V0KTtcbiAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9BQ1RJVkFURSwge1xuICAgICAgcmVsYXRlZFRhcmdldDogdGFyZ2V0XG4gICAgfSk7XG4gIH1cbiAgX2FjdGl2YXRlUGFyZW50cyh0YXJnZXQpIHtcbiAgICAvLyBBY3RpdmF0ZSBkcm9wZG93biBwYXJlbnRzXG4gICAgaWYgKHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9EUk9QRE9XTl9JVEVNKSkge1xuICAgICAgU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9EUk9QRE9XTl9UT0dHTEUkMSwgdGFyZ2V0LmNsb3Nlc3QoU0VMRUNUT1JfRFJPUERPV04pKS5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQUNUSVZFJDEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGxpc3RHcm91cCBvZiBTZWxlY3RvckVuZ2luZS5wYXJlbnRzKHRhcmdldCwgU0VMRUNUT1JfTkFWX0xJU1RfR1JPVVApKSB7XG4gICAgICAvLyBTZXQgdHJpZ2dlcmVkIGxpbmtzIHBhcmVudHMgYXMgYWN0aXZlXG4gICAgICAvLyBXaXRoIGJvdGggPHVsPiBhbmQgPG5hdj4gbWFya3VwIGEgcGFyZW50IGlzIHRoZSBwcmV2aW91cyBzaWJsaW5nIG9mIGFueSBuYXYgYW5jZXN0b3JcbiAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBTZWxlY3RvckVuZ2luZS5wcmV2KGxpc3RHcm91cCwgU0VMRUNUT1JfTElOS19JVEVNUykpIHtcbiAgICAgICAgaXRlbS5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQUNUSVZFJDEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBfY2xlYXJBY3RpdmVDbGFzcyhwYXJlbnQpIHtcbiAgICBwYXJlbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0FDVElWRSQxKTtcbiAgICBjb25zdCBhY3RpdmVOb2RlcyA9IFNlbGVjdG9yRW5naW5lLmZpbmQoYCR7U0VMRUNUT1JfVEFSR0VUX0xJTktTfS4ke0NMQVNTX05BTUVfQUNUSVZFJDF9YCwgcGFyZW50KTtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgYWN0aXZlTm9kZXMpIHtcbiAgICAgIG5vZGUuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0FDVElWRSQxKTtcbiAgICB9XG4gIH1cblxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBTY3JvbGxTcHkuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCBjb25maWcpO1xuICAgICAgaWYgKHR5cGVvZiBjb25maWcgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhW2NvbmZpZ10gPT09IHVuZGVmaW5lZCB8fCBjb25maWcuc3RhcnRzV2l0aCgnXycpIHx8IGNvbmZpZyA9PT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApO1xuICAgICAgfVxuICAgICAgZGF0YVtjb25maWddKCk7XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBEYXRhIEFQSSBpbXBsZW1lbnRhdGlvblxuICovXG5cbkV2ZW50SGFuZGxlci5vbih3aW5kb3csIEVWRU5UX0xPQURfREFUQV9BUEkkMSwgKCkgPT4ge1xuICBmb3IgKGNvbnN0IHNweSBvZiBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0RBVEFfU1BZKSkge1xuICAgIFNjcm9sbFNweS5nZXRPckNyZWF0ZUluc3RhbmNlKHNweSk7XG4gIH1cbn0pO1xuXG4vKipcbiAqIGpRdWVyeVxuICovXG5cbmRlZmluZUpRdWVyeVBsdWdpbihTY3JvbGxTcHkpO1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgdGFiLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuLyoqXG4gKiBDb25zdGFudHNcbiAqL1xuXG5jb25zdCBOQU1FJDEgPSAndGFiJztcbmNvbnN0IERBVEFfS0VZJDEgPSAnYnMudGFiJztcbmNvbnN0IEVWRU5UX0tFWSQxID0gYC4ke0RBVEFfS0VZJDF9YDtcbmNvbnN0IEVWRU5UX0hJREUkMSA9IGBoaWRlJHtFVkVOVF9LRVkkMX1gO1xuY29uc3QgRVZFTlRfSElEREVOJDEgPSBgaGlkZGVuJHtFVkVOVF9LRVkkMX1gO1xuY29uc3QgRVZFTlRfU0hPVyQxID0gYHNob3cke0VWRU5UX0tFWSQxfWA7XG5jb25zdCBFVkVOVF9TSE9XTiQxID0gYHNob3duJHtFVkVOVF9LRVkkMX1gO1xuY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkgPSBgY2xpY2ske0VWRU5UX0tFWSQxfWA7XG5jb25zdCBFVkVOVF9LRVlET1dOID0gYGtleWRvd24ke0VWRU5UX0tFWSQxfWA7XG5jb25zdCBFVkVOVF9MT0FEX0RBVEFfQVBJID0gYGxvYWQke0VWRU5UX0tFWSQxfWA7XG5jb25zdCBBUlJPV19MRUZUX0tFWSA9ICdBcnJvd0xlZnQnO1xuY29uc3QgQVJST1dfUklHSFRfS0VZID0gJ0Fycm93UmlnaHQnO1xuY29uc3QgQVJST1dfVVBfS0VZID0gJ0Fycm93VXAnO1xuY29uc3QgQVJST1dfRE9XTl9LRVkgPSAnQXJyb3dEb3duJztcbmNvbnN0IENMQVNTX05BTUVfQUNUSVZFID0gJ2FjdGl2ZSc7XG5jb25zdCBDTEFTU19OQU1FX0ZBREUkMSA9ICdmYWRlJztcbmNvbnN0IENMQVNTX05BTUVfU0hPVyQxID0gJ3Nob3cnO1xuY29uc3QgQ0xBU1NfRFJPUERPV04gPSAnZHJvcGRvd24nO1xuY29uc3QgU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFID0gJy5kcm9wZG93bi10b2dnbGUnO1xuY29uc3QgU0VMRUNUT1JfRFJPUERPV05fTUVOVSA9ICcuZHJvcGRvd24tbWVudSc7XG5jb25zdCBOT1RfU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFID0gJzpub3QoLmRyb3Bkb3duLXRvZ2dsZSknO1xuY29uc3QgU0VMRUNUT1JfVEFCX1BBTkVMID0gJy5saXN0LWdyb3VwLCAubmF2LCBbcm9sZT1cInRhYmxpc3RcIl0nO1xuY29uc3QgU0VMRUNUT1JfT1VURVIgPSAnLm5hdi1pdGVtLCAubGlzdC1ncm91cC1pdGVtJztcbmNvbnN0IFNFTEVDVE9SX0lOTkVSID0gYC5uYXYtbGluayR7Tk9UX1NFTEVDVE9SX0RST1BET1dOX1RPR0dMRX0sIC5saXN0LWdyb3VwLWl0ZW0ke05PVF9TRUxFQ1RPUl9EUk9QRE9XTl9UT0dHTEV9LCBbcm9sZT1cInRhYlwiXSR7Tk9UX1NFTEVDVE9SX0RST1BET1dOX1RPR0dMRX1gO1xuY29uc3QgU0VMRUNUT1JfREFUQV9UT0dHTEUgPSAnW2RhdGEtYnMtdG9nZ2xlPVwidGFiXCJdLCBbZGF0YS1icy10b2dnbGU9XCJwaWxsXCJdLCBbZGF0YS1icy10b2dnbGU9XCJsaXN0XCJdJzsgLy8gVE9ETzogY291bGQgb25seSBiZSBgdGFiYCBpbiB2NlxuY29uc3QgU0VMRUNUT1JfSU5ORVJfRUxFTSA9IGAke1NFTEVDVE9SX0lOTkVSfSwgJHtTRUxFQ1RPUl9EQVRBX1RPR0dMRX1gO1xuY29uc3QgU0VMRUNUT1JfREFUQV9UT0dHTEVfQUNUSVZFID0gYC4ke0NMQVNTX05BTUVfQUNUSVZFfVtkYXRhLWJzLXRvZ2dsZT1cInRhYlwiXSwgLiR7Q0xBU1NfTkFNRV9BQ1RJVkV9W2RhdGEtYnMtdG9nZ2xlPVwicGlsbFwiXSwgLiR7Q0xBU1NfTkFNRV9BQ1RJVkV9W2RhdGEtYnMtdG9nZ2xlPVwibGlzdFwiXWA7XG5cbi8qKlxuICogQ2xhc3MgZGVmaW5pdGlvblxuICovXG5cbmNsYXNzIFRhYiBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50KSB7XG4gICAgc3VwZXIoZWxlbWVudCk7XG4gICAgdGhpcy5fcGFyZW50ID0gdGhpcy5fZWxlbWVudC5jbG9zZXN0KFNFTEVDVE9SX1RBQl9QQU5FTCk7XG4gICAgaWYgKCF0aGlzLl9wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICAgIC8vIFRPRE86IHNob3VsZCB0aHJvdyBleGNlcHRpb24gaW4gdjZcbiAgICAgIC8vIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7ZWxlbWVudC5vdXRlckhUTUx9IGhhcyBub3QgYSB2YWxpZCBwYXJlbnQgJHtTRUxFQ1RPUl9JTk5FUl9FTEVNfWApXG4gICAgfVxuXG4gICAgLy8gU2V0IHVwIGluaXRpYWwgYXJpYSBhdHRyaWJ1dGVzXG4gICAgdGhpcy5fc2V0SW5pdGlhbEF0dHJpYnV0ZXModGhpcy5fcGFyZW50LCB0aGlzLl9nZXRDaGlsZHJlbigpKTtcbiAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfS0VZRE9XTiwgZXZlbnQgPT4gdGhpcy5fa2V5ZG93bihldmVudCkpO1xuICB9XG5cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIE5BTUUkMTtcbiAgfVxuXG4gIC8vIFB1YmxpY1xuICBzaG93KCkge1xuICAgIC8vIFNob3dzIHRoaXMgZWxlbSBhbmQgZGVhY3RpdmF0ZSB0aGUgYWN0aXZlIHNpYmxpbmcgaWYgZXhpc3RzXG4gICAgY29uc3QgaW5uZXJFbGVtID0gdGhpcy5fZWxlbWVudDtcbiAgICBpZiAodGhpcy5fZWxlbUlzQWN0aXZlKGlubmVyRWxlbSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTZWFyY2ggZm9yIGFjdGl2ZSB0YWIgb24gc2FtZSBwYXJlbnQgdG8gZGVhY3RpdmF0ZSBpdFxuICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2dldEFjdGl2ZUVsZW0oKTtcbiAgICBjb25zdCBoaWRlRXZlbnQgPSBhY3RpdmUgPyBFdmVudEhhbmRsZXIudHJpZ2dlcihhY3RpdmUsIEVWRU5UX0hJREUkMSwge1xuICAgICAgcmVsYXRlZFRhcmdldDogaW5uZXJFbGVtXG4gICAgfSkgOiBudWxsO1xuICAgIGNvbnN0IHNob3dFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKGlubmVyRWxlbSwgRVZFTlRfU0hPVyQxLCB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiBhY3RpdmVcbiAgICB9KTtcbiAgICBpZiAoc2hvd0V2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgfHwgaGlkZUV2ZW50ICYmIGhpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2RlYWN0aXZhdGUoYWN0aXZlLCBpbm5lckVsZW0pO1xuICAgIHRoaXMuX2FjdGl2YXRlKGlubmVyRWxlbSwgYWN0aXZlKTtcbiAgfVxuXG4gIC8vIFByaXZhdGVcbiAgX2FjdGl2YXRlKGVsZW1lbnQsIHJlbGF0ZWRFbGVtKSB7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0FDVElWRSk7XG4gICAgdGhpcy5fYWN0aXZhdGUoU2VsZWN0b3JFbmdpbmUuZ2V0RWxlbWVudEZyb21TZWxlY3RvcihlbGVtZW50KSk7IC8vIFNlYXJjaCBhbmQgYWN0aXZhdGUvc2hvdyB0aGUgcHJvcGVyIHNlY3Rpb25cblxuICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgaWYgKGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdyb2xlJykgIT09ICd0YWInKSB7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1ckMSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCd0YWJpbmRleCcpO1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtc2VsZWN0ZWQnLCB0cnVlKTtcbiAgICAgIHRoaXMuX3RvZ2dsZURyb3BEb3duKGVsZW1lbnQsIHRydWUpO1xuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIoZWxlbWVudCwgRVZFTlRfU0hPV04kMSwge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiByZWxhdGVkRWxlbVxuICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGNvbXBsZXRlLCBlbGVtZW50LCBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0ZBREUkMSkpO1xuICB9XG4gIF9kZWFjdGl2YXRlKGVsZW1lbnQsIHJlbGF0ZWRFbGVtKSB7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0FDVElWRSk7XG4gICAgZWxlbWVudC5ibHVyKCk7XG4gICAgdGhpcy5fZGVhY3RpdmF0ZShTZWxlY3RvckVuZ2luZS5nZXRFbGVtZW50RnJvbVNlbGVjdG9yKGVsZW1lbnQpKTsgLy8gU2VhcmNoIGFuZCBkZWFjdGl2YXRlIHRoZSBzaG93biBzZWN0aW9uIHRvb1xuXG4gICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICBpZiAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3JvbGUnKSAhPT0gJ3RhYicpIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVyQxKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtc2VsZWN0ZWQnLCBmYWxzZSk7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcbiAgICAgIHRoaXMuX3RvZ2dsZURyb3BEb3duKGVsZW1lbnQsIGZhbHNlKTtcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKGVsZW1lbnQsIEVWRU5UX0hJRERFTiQxLCB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHJlbGF0ZWRFbGVtXG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGUsIGVsZW1lbnQsIGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRkFERSQxKSk7XG4gIH1cbiAgX2tleWRvd24oZXZlbnQpIHtcbiAgICBpZiAoIVtBUlJPV19MRUZUX0tFWSwgQVJST1dfUklHSFRfS0VZLCBBUlJPV19VUF9LRVksIEFSUk9XX0RPV05fS0VZXS5pbmNsdWRlcyhldmVudC5rZXkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOyAvLyBzdG9wUHJvcGFnYXRpb24vcHJldmVudERlZmF1bHQgYm90aCBhZGRlZCB0byBzdXBwb3J0IHVwL2Rvd24ga2V5cyB3aXRob3V0IHNjcm9sbGluZyB0aGUgcGFnZVxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3QgaXNOZXh0ID0gW0FSUk9XX1JJR0hUX0tFWSwgQVJST1dfRE9XTl9LRVldLmluY2x1ZGVzKGV2ZW50LmtleSk7XG4gICAgY29uc3QgbmV4dEFjdGl2ZUVsZW1lbnQgPSBnZXROZXh0QWN0aXZlRWxlbWVudCh0aGlzLl9nZXRDaGlsZHJlbigpLmZpbHRlcihlbGVtZW50ID0+ICFpc0Rpc2FibGVkKGVsZW1lbnQpKSwgZXZlbnQudGFyZ2V0LCBpc05leHQsIHRydWUpO1xuICAgIGlmIChuZXh0QWN0aXZlRWxlbWVudCkge1xuICAgICAgbmV4dEFjdGl2ZUVsZW1lbnQuZm9jdXMoe1xuICAgICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIFRhYi5nZXRPckNyZWF0ZUluc3RhbmNlKG5leHRBY3RpdmVFbGVtZW50KS5zaG93KCk7XG4gICAgfVxuICB9XG4gIF9nZXRDaGlsZHJlbigpIHtcbiAgICAvLyBjb2xsZWN0aW9uIG9mIGlubmVyIGVsZW1lbnRzXG4gICAgcmV0dXJuIFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfSU5ORVJfRUxFTSwgdGhpcy5fcGFyZW50KTtcbiAgfVxuICBfZ2V0QWN0aXZlRWxlbSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0Q2hpbGRyZW4oKS5maW5kKGNoaWxkID0+IHRoaXMuX2VsZW1Jc0FjdGl2ZShjaGlsZCkpIHx8IG51bGw7XG4gIH1cbiAgX3NldEluaXRpYWxBdHRyaWJ1dGVzKHBhcmVudCwgY2hpbGRyZW4pIHtcbiAgICB0aGlzLl9zZXRBdHRyaWJ1dGVJZk5vdEV4aXN0cyhwYXJlbnQsICdyb2xlJywgJ3RhYmxpc3QnKTtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuKSB7XG4gICAgICB0aGlzLl9zZXRJbml0aWFsQXR0cmlidXRlc09uQ2hpbGQoY2hpbGQpO1xuICAgIH1cbiAgfVxuICBfc2V0SW5pdGlhbEF0dHJpYnV0ZXNPbkNoaWxkKGNoaWxkKSB7XG4gICAgY2hpbGQgPSB0aGlzLl9nZXRJbm5lckVsZW1lbnQoY2hpbGQpO1xuICAgIGNvbnN0IGlzQWN0aXZlID0gdGhpcy5fZWxlbUlzQWN0aXZlKGNoaWxkKTtcbiAgICBjb25zdCBvdXRlckVsZW0gPSB0aGlzLl9nZXRPdXRlckVsZW1lbnQoY2hpbGQpO1xuICAgIGNoaWxkLnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsIGlzQWN0aXZlKTtcbiAgICBpZiAob3V0ZXJFbGVtICE9PSBjaGlsZCkge1xuICAgICAgdGhpcy5fc2V0QXR0cmlidXRlSWZOb3RFeGlzdHMob3V0ZXJFbGVtLCAncm9sZScsICdwcmVzZW50YXRpb24nKTtcbiAgICB9XG4gICAgaWYgKCFpc0FjdGl2ZSkge1xuICAgICAgY2hpbGQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICctMScpO1xuICAgIH1cbiAgICB0aGlzLl9zZXRBdHRyaWJ1dGVJZk5vdEV4aXN0cyhjaGlsZCwgJ3JvbGUnLCAndGFiJyk7XG5cbiAgICAvLyBzZXQgYXR0cmlidXRlcyB0byB0aGUgcmVsYXRlZCBwYW5lbCB0b29cbiAgICB0aGlzLl9zZXRJbml0aWFsQXR0cmlidXRlc09uVGFyZ2V0UGFuZWwoY2hpbGQpO1xuICB9XG4gIF9zZXRJbml0aWFsQXR0cmlidXRlc09uVGFyZ2V0UGFuZWwoY2hpbGQpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBTZWxlY3RvckVuZ2luZS5nZXRFbGVtZW50RnJvbVNlbGVjdG9yKGNoaWxkKTtcbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9zZXRBdHRyaWJ1dGVJZk5vdEV4aXN0cyh0YXJnZXQsICdyb2xlJywgJ3RhYnBhbmVsJyk7XG4gICAgaWYgKGNoaWxkLmlkKSB7XG4gICAgICB0aGlzLl9zZXRBdHRyaWJ1dGVJZk5vdEV4aXN0cyh0YXJnZXQsICdhcmlhLWxhYmVsbGVkYnknLCBgJHtjaGlsZC5pZH1gKTtcbiAgICB9XG4gIH1cbiAgX3RvZ2dsZURyb3BEb3duKGVsZW1lbnQsIG9wZW4pIHtcbiAgICBjb25zdCBvdXRlckVsZW0gPSB0aGlzLl9nZXRPdXRlckVsZW1lbnQoZWxlbWVudCk7XG4gICAgaWYgKCFvdXRlckVsZW0uY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX0RST1BET1dOKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0b2dnbGUgPSAoc2VsZWN0b3IsIGNsYXNzTmFtZSkgPT4ge1xuICAgICAgY29uc3QgZWxlbWVudCA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoc2VsZWN0b3IsIG91dGVyRWxlbSk7XG4gICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoY2xhc3NOYW1lLCBvcGVuKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRvZ2dsZShTRUxFQ1RPUl9EUk9QRE9XTl9UT0dHTEUsIENMQVNTX05BTUVfQUNUSVZFKTtcbiAgICB0b2dnbGUoU0VMRUNUT1JfRFJPUERPV05fTUVOVSwgQ0xBU1NfTkFNRV9TSE9XJDEpO1xuICAgIG91dGVyRWxlbS5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCBvcGVuKTtcbiAgfVxuICBfc2V0QXR0cmlidXRlSWZOb3RFeGlzdHMoZWxlbWVudCwgYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgIGlmICghZWxlbWVudC5oYXNBdHRyaWJ1dGUoYXR0cmlidXRlKSkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlLCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIF9lbGVtSXNBY3RpdmUoZWxlbSkge1xuICAgIHJldHVybiBlbGVtLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0FDVElWRSk7XG4gIH1cblxuICAvLyBUcnkgdG8gZ2V0IHRoZSBpbm5lciBlbGVtZW50ICh1c3VhbGx5IHRoZSAubmF2LWxpbmspXG4gIF9nZXRJbm5lckVsZW1lbnQoZWxlbSkge1xuICAgIHJldHVybiBlbGVtLm1hdGNoZXMoU0VMRUNUT1JfSU5ORVJfRUxFTSkgPyBlbGVtIDogU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9JTk5FUl9FTEVNLCBlbGVtKTtcbiAgfVxuXG4gIC8vIFRyeSB0byBnZXQgdGhlIG91dGVyIGVsZW1lbnQgKHVzdWFsbHkgdGhlIC5uYXYtaXRlbSlcbiAgX2dldE91dGVyRWxlbWVudChlbGVtKSB7XG4gICAgcmV0dXJuIGVsZW0uY2xvc2VzdChTRUxFQ1RPUl9PVVRFUikgfHwgZWxlbTtcbiAgfVxuXG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgZGF0YSA9IFRhYi5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMpO1xuICAgICAgaWYgKHR5cGVvZiBjb25maWcgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhW2NvbmZpZ10gPT09IHVuZGVmaW5lZCB8fCBjb25maWcuc3RhcnRzV2l0aCgnXycpIHx8IGNvbmZpZyA9PT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApO1xuICAgICAgfVxuICAgICAgZGF0YVtjb25maWddKCk7XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBEYXRhIEFQSSBpbXBsZW1lbnRhdGlvblxuICovXG5cbkV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfQ0xJQ0tfREFUQV9BUEksIFNFTEVDVE9SX0RBVEFfVE9HR0xFLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgaWYgKFsnQScsICdBUkVBJ10uaW5jbHVkZXModGhpcy50YWdOYW1lKSkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgaWYgKGlzRGlzYWJsZWQodGhpcykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgVGFiLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcykuc2hvdygpO1xufSk7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBvbiBmb2N1c1xuICovXG5FdmVudEhhbmRsZXIub24od2luZG93LCBFVkVOVF9MT0FEX0RBVEFfQVBJLCAoKSA9PiB7XG4gIGZvciAoY29uc3QgZWxlbWVudCBvZiBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0RBVEFfVE9HR0xFX0FDVElWRSkpIHtcbiAgICBUYWIuZ2V0T3JDcmVhdGVJbnN0YW5jZShlbGVtZW50KTtcbiAgfVxufSk7XG4vKipcbiAqIGpRdWVyeVxuICovXG5cbmRlZmluZUpRdWVyeVBsdWdpbihUYWIpO1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgdG9hc3QuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG4vKipcbiAqIENvbnN0YW50c1xuICovXG5cbmNvbnN0IE5BTUUgPSAndG9hc3QnO1xuY29uc3QgREFUQV9LRVkgPSAnYnMudG9hc3QnO1xuY29uc3QgRVZFTlRfS0VZID0gYC4ke0RBVEFfS0VZfWA7XG5jb25zdCBFVkVOVF9NT1VTRU9WRVIgPSBgbW91c2VvdmVyJHtFVkVOVF9LRVl9YDtcbmNvbnN0IEVWRU5UX01PVVNFT1VUID0gYG1vdXNlb3V0JHtFVkVOVF9LRVl9YDtcbmNvbnN0IEVWRU5UX0ZPQ1VTSU4gPSBgZm9jdXNpbiR7RVZFTlRfS0VZfWA7XG5jb25zdCBFVkVOVF9GT0NVU09VVCA9IGBmb2N1c291dCR7RVZFTlRfS0VZfWA7XG5jb25zdCBFVkVOVF9ISURFID0gYGhpZGUke0VWRU5UX0tFWX1gO1xuY29uc3QgRVZFTlRfSElEREVOID0gYGhpZGRlbiR7RVZFTlRfS0VZfWA7XG5jb25zdCBFVkVOVF9TSE9XID0gYHNob3cke0VWRU5UX0tFWX1gO1xuY29uc3QgRVZFTlRfU0hPV04gPSBgc2hvd24ke0VWRU5UX0tFWX1gO1xuY29uc3QgQ0xBU1NfTkFNRV9GQURFID0gJ2ZhZGUnO1xuY29uc3QgQ0xBU1NfTkFNRV9ISURFID0gJ2hpZGUnOyAvLyBAZGVwcmVjYXRlZCAtIGtlcHQgaGVyZSBvbmx5IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuY29uc3QgQ0xBU1NfTkFNRV9TSE9XID0gJ3Nob3cnO1xuY29uc3QgQ0xBU1NfTkFNRV9TSE9XSU5HID0gJ3Nob3dpbmcnO1xuY29uc3QgRGVmYXVsdFR5cGUgPSB7XG4gIGFuaW1hdGlvbjogJ2Jvb2xlYW4nLFxuICBhdXRvaGlkZTogJ2Jvb2xlYW4nLFxuICBkZWxheTogJ251bWJlcidcbn07XG5jb25zdCBEZWZhdWx0ID0ge1xuICBhbmltYXRpb246IHRydWUsXG4gIGF1dG9oaWRlOiB0cnVlLFxuICBkZWxheTogNTAwMFxufTtcblxuLyoqXG4gKiBDbGFzcyBkZWZpbml0aW9uXG4gKi9cblxuY2xhc3MgVG9hc3QgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgc3VwZXIoZWxlbWVudCwgY29uZmlnKTtcbiAgICB0aGlzLl90aW1lb3V0ID0gbnVsbDtcbiAgICB0aGlzLl9oYXNNb3VzZUludGVyYWN0aW9uID0gZmFsc2U7XG4gICAgdGhpcy5faGFzS2V5Ym9hcmRJbnRlcmFjdGlvbiA9IGZhbHNlO1xuICAgIHRoaXMuX3NldExpc3RlbmVycygpO1xuICB9XG5cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIERlZmF1bHQ7XG4gIH1cbiAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICByZXR1cm4gRGVmYXVsdFR5cGU7XG4gIH1cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBOQU1FO1xuICB9XG5cbiAgLy8gUHVibGljXG4gIHNob3coKSB7XG4gICAgY29uc3Qgc2hvd0V2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPVyk7XG4gICAgaWYgKHNob3dFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2NsZWFyVGltZW91dCgpO1xuICAgIGlmICh0aGlzLl9jb25maWcuYW5pbWF0aW9uKSB7XG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9GQURFKTtcbiAgICB9XG4gICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XSU5HKTtcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1dOKTtcbiAgICAgIHRoaXMuX21heWJlU2NoZWR1bGVIaWRlKCk7XG4gICAgfTtcbiAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9ISURFKTsgLy8gQGRlcHJlY2F0ZWRcbiAgICByZWZsb3codGhpcy5fZWxlbWVudCk7XG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVywgQ0xBU1NfTkFNRV9TSE9XSU5HKTtcbiAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGNvbXBsZXRlLCB0aGlzLl9lbGVtZW50LCB0aGlzLl9jb25maWcuYW5pbWF0aW9uKTtcbiAgfVxuICBoaWRlKCkge1xuICAgIGlmICghdGhpcy5pc1Nob3duKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaGlkZUV2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElERSk7XG4gICAgaWYgKGhpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfSElERSk7IC8vIEBkZXByZWNhdGVkXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XSU5HLCBDTEFTU19OQU1FX1NIT1cpO1xuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElEREVOKTtcbiAgICB9O1xuICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1dJTkcpO1xuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGUsIHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NvbmZpZy5hbmltYXRpb24pO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fY2xlYXJUaW1lb3V0KCk7XG4gICAgaWYgKHRoaXMuaXNTaG93bigpKSB7XG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XKTtcbiAgICB9XG4gICAgc3VwZXIuZGlzcG9zZSgpO1xuICB9XG4gIGlzU2hvd24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfU0hPVyk7XG4gIH1cblxuICAvLyBQcml2YXRlXG5cbiAgX21heWJlU2NoZWR1bGVIaWRlKCkge1xuICAgIGlmICghdGhpcy5fY29uZmlnLmF1dG9oaWRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9oYXNNb3VzZUludGVyYWN0aW9uIHx8IHRoaXMuX2hhc0tleWJvYXJkSW50ZXJhY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfSwgdGhpcy5fY29uZmlnLmRlbGF5KTtcbiAgfVxuICBfb25JbnRlcmFjdGlvbihldmVudCwgaXNJbnRlcmFjdGluZykge1xuICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgY2FzZSAnbW91c2VvdmVyJzpcbiAgICAgIGNhc2UgJ21vdXNlb3V0JzpcbiAgICAgICAge1xuICAgICAgICAgIHRoaXMuX2hhc01vdXNlSW50ZXJhY3Rpb24gPSBpc0ludGVyYWN0aW5nO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdmb2N1c2luJzpcbiAgICAgIGNhc2UgJ2ZvY3Vzb3V0JzpcbiAgICAgICAge1xuICAgICAgICAgIHRoaXMuX2hhc0tleWJvYXJkSW50ZXJhY3Rpb24gPSBpc0ludGVyYWN0aW5nO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpc0ludGVyYWN0aW5nKSB7XG4gICAgICB0aGlzLl9jbGVhclRpbWVvdXQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbmV4dEVsZW1lbnQgPSBldmVudC5yZWxhdGVkVGFyZ2V0O1xuICAgIGlmICh0aGlzLl9lbGVtZW50ID09PSBuZXh0RWxlbWVudCB8fCB0aGlzLl9lbGVtZW50LmNvbnRhaW5zKG5leHRFbGVtZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9tYXliZVNjaGVkdWxlSGlkZSgpO1xuICB9XG4gIF9zZXRMaXN0ZW5lcnMoKSB7XG4gICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX01PVVNFT1ZFUiwgZXZlbnQgPT4gdGhpcy5fb25JbnRlcmFjdGlvbihldmVudCwgdHJ1ZSkpO1xuICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9NT1VTRU9VVCwgZXZlbnQgPT4gdGhpcy5fb25JbnRlcmFjdGlvbihldmVudCwgZmFsc2UpKTtcbiAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfRk9DVVNJTiwgZXZlbnQgPT4gdGhpcy5fb25JbnRlcmFjdGlvbihldmVudCwgdHJ1ZSkpO1xuICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9GT0NVU09VVCwgZXZlbnQgPT4gdGhpcy5fb25JbnRlcmFjdGlvbihldmVudCwgZmFsc2UpKTtcbiAgfVxuICBfY2xlYXJUaW1lb3V0KCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcbiAgICB0aGlzLl90aW1lb3V0ID0gbnVsbDtcbiAgfVxuXG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgZGF0YSA9IFRvYXN0LmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgY29uZmlnKTtcbiAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApO1xuICAgICAgICB9XG4gICAgICAgIGRhdGFbY29uZmlnXSh0aGlzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIERhdGEgQVBJIGltcGxlbWVudGF0aW9uXG4gKi9cblxuZW5hYmxlRGlzbWlzc1RyaWdnZXIoVG9hc3QpO1xuXG4vKipcbiAqIGpRdWVyeVxuICovXG5cbmRlZmluZUpRdWVyeVBsdWdpbihUb2FzdCk7XG5cbmV4cG9ydCB7IEFsZXJ0LCBCdXR0b24sIENhcm91c2VsLCBDb2xsYXBzZSwgRHJvcGRvd24sIE1vZGFsLCBPZmZjYW52YXMsIFBvcG92ZXIsIFNjcm9sbFNweSwgVGFiLCBUb2FzdCwgVG9vbHRpcCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ym9vdHN0cmFwLmVzbS5qcy5tYXBcbiIsIi8qIVxuICogXG4gKiBsaXRlcGlja2VyLnVtZC5qc1xuICogTGl0ZXBpY2tlciB2Mi4wLjEyIChodHRwczovL2dpdGh1Yi5jb20vd2FraXJpbi9MaXRlcGlja2VyKVxuICogUGFja2FnZTogbGl0ZXBpY2tlciAoaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbGl0ZXBpY2tlcilcbiAqIExpY2Vuc2U6IE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3dha2lyaW4vTGl0ZXBpY2tlci9ibG9iL21hc3Rlci9MSUNFTkNFLm1kKVxuICogQ29weXJpZ2h0IDIwMTktMjAyMSBSaW5hdCBHLlxuICogICAgIFxuICogSGFzaDogNTA0ZWVmOWMwOGNiNDI1NDM2NjBcbiAqIFxuICovXG4hZnVuY3Rpb24odCxlKXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz1lKCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShcIkxpdGVwaWNrZXJcIixbXSxlKTpcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9leHBvcnRzLkxpdGVwaWNrZXI9ZSgpOnQuTGl0ZXBpY2tlcj1lKCl9KHdpbmRvdywoZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCl7dmFyIGU9e307ZnVuY3Rpb24gaShuKXtpZihlW25dKXJldHVybiBlW25dLmV4cG9ydHM7dmFyIG89ZVtuXT17aTpuLGw6ITEsZXhwb3J0czp7fX07cmV0dXJuIHRbbl0uY2FsbChvLmV4cG9ydHMsbyxvLmV4cG9ydHMsaSksby5sPSEwLG8uZXhwb3J0c31yZXR1cm4gaS5tPXQsaS5jPWUsaS5kPWZ1bmN0aW9uKHQsZSxuKXtpLm8odCxlKXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsZSx7ZW51bWVyYWJsZTohMCxnZXQ6bn0pfSxpLnI9ZnVuY3Rpb24odCl7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLnRvU3RyaW5nVGFnJiZPYmplY3QuZGVmaW5lUHJvcGVydHkodCxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOlwiTW9kdWxlXCJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX0saS50PWZ1bmN0aW9uKHQsZSl7aWYoMSZlJiYodD1pKHQpKSw4JmUpcmV0dXJuIHQ7aWYoNCZlJiZcIm9iamVjdFwiPT10eXBlb2YgdCYmdCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O3ZhciBuPU9iamVjdC5jcmVhdGUobnVsbCk7aWYoaS5yKG4pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOiEwLHZhbHVlOnR9KSwyJmUmJlwic3RyaW5nXCIhPXR5cGVvZiB0KWZvcih2YXIgbyBpbiB0KWkuZChuLG8sZnVuY3Rpb24oZSl7cmV0dXJuIHRbZV19LmJpbmQobnVsbCxvKSk7cmV0dXJuIG59LGkubj1mdW5jdGlvbih0KXt2YXIgZT10JiZ0Ll9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gdC5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiB0fTtyZXR1cm4gaS5kKGUsXCJhXCIsZSksZX0saS5vPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LGUpfSxpLnA9XCJcIixpKGkucz00KX0oW2Z1bmN0aW9uKHQsZSxpKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSxpLG4pe3ZvaWQgMD09PWUmJihlPW51bGwpLHZvaWQgMD09PWkmJihpPW51bGwpLHZvaWQgMD09PW4mJihuPVwiZW4tVVNcIiksdGhpcy5kYXRlSW5zdGFuY2U9XCJvYmplY3RcIj09dHlwZW9mIGkmJm51bGwhPT1pP2kucGFyc2UoZSBpbnN0YW5jZW9mIHQ/ZS5jbG9uZSgpLnRvSlNEYXRlKCk6ZSk6XCJzdHJpbmdcIj09dHlwZW9mIGk/dC5wYXJzZURhdGVUaW1lKGUsaSxuKTplP3QucGFyc2VEYXRlVGltZShlKTp0LnBhcnNlRGF0ZVRpbWUobmV3IERhdGUpLHRoaXMubGFuZz1ufXJldHVybiB0LnBhcnNlRGF0ZVRpbWU9ZnVuY3Rpb24oZSxpLG4pe2lmKHZvaWQgMD09PWkmJihpPVwiWVlZWS1NTS1ERFwiKSx2b2lkIDA9PT1uJiYobj1cImVuLVVTXCIpLCFlKXJldHVybiBuZXcgRGF0ZShOYU4pO2lmKGUgaW5zdGFuY2VvZiBEYXRlKXJldHVybiBuZXcgRGF0ZShlKTtpZihlIGluc3RhbmNlb2YgdClyZXR1cm4gZS5jbG9uZSgpLnRvSlNEYXRlKCk7aWYoL14tP1xcZHsxMCx9JC8udGVzdChlKSlyZXR1cm4gdC5nZXREYXRlWmVyb1RpbWUobmV3IERhdGUoTnVtYmVyKGUpKSk7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpe2Zvcih2YXIgbz1bXSxzPW51bGw7bnVsbCE9KHM9dC5yZWdleC5leGVjKGkpKTspXCJcXFxcXCIhPT1zWzFdJiZvLnB1c2gocyk7aWYoby5sZW5ndGgpe3ZhciByPXt5ZWFyOm51bGwsbW9udGg6bnVsbCxzaG9ydE1vbnRoOm51bGwsbG9uZ01vbnRoOm51bGwsZGF5Om51bGwsdmFsdWU6XCJcIn07b1swXS5pbmRleD4wJiYoci52YWx1ZSs9XCIuKj9cIik7Zm9yKHZhciBhPTAsbD1PYmplY3QuZW50cmllcyhvKTthPGwubGVuZ3RoO2ErKyl7dmFyIGM9bFthXSxoPWNbMF0scD1jWzFdLGQ9TnVtYmVyKGgpLHU9dC5mb3JtYXRQYXR0ZXJucyhwWzBdLG4pLG09dS5ncm91cCxmPXUucGF0dGVybjtyW21dPWQrMSxyLnZhbHVlKz1mLHIudmFsdWUrPVwiLio/XCJ9dmFyIGc9bmV3IFJlZ0V4cChcIl5cIityLnZhbHVlK1wiJFwiKTtpZihnLnRlc3QoZSkpe3ZhciB2PWcuZXhlYyhlKSx5PU51bWJlcih2W3IueWVhcl0pLGI9bnVsbDtyLm1vbnRoP2I9TnVtYmVyKHZbci5tb250aF0pLTE6ci5zaG9ydE1vbnRoP2I9dC5zaG9ydE1vbnRocyhuKS5pbmRleE9mKHZbci5zaG9ydE1vbnRoXSk6ci5sb25nTW9udGgmJihiPXQubG9uZ01vbnRocyhuKS5pbmRleE9mKHZbci5sb25nTW9udGhdKSk7dmFyIGs9TnVtYmVyKHZbci5kYXldKXx8MTtyZXR1cm4gbmV3IERhdGUoeSxiLGssMCwwLDAsMCl9fX1yZXR1cm4gdC5nZXREYXRlWmVyb1RpbWUobmV3IERhdGUoZSkpfSx0LmNvbnZlcnRBcnJheT1mdW5jdGlvbihlLGkpe3JldHVybiBlLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBBcnJheT9lLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyB0KGUsaSl9KSk6bmV3IHQoZSxpKX0pKX0sdC5nZXREYXRlWmVyb1RpbWU9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSx0LmdldE1vbnRoKCksdC5nZXREYXRlKCksMCwwLDAsMCl9LHQuc2hvcnRNb250aHM9ZnVuY3Rpb24oZSl7cmV0dXJuIHQuTU9OVEhfSlMubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gbmV3IERhdGUoMjAxOSx0KS50b0xvY2FsZVN0cmluZyhlLHttb250aDpcInNob3J0XCJ9KX0pKX0sdC5sb25nTW9udGhzPWZ1bmN0aW9uKGUpe3JldHVybiB0Lk1PTlRIX0pTLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBEYXRlKDIwMTksdCkudG9Mb2NhbGVTdHJpbmcoZSx7bW9udGg6XCJsb25nXCJ9KX0pKX0sdC5mb3JtYXRQYXR0ZXJucz1mdW5jdGlvbihlLGkpe3N3aXRjaChlKXtjYXNlXCJZWVwiOmNhc2VcIllZWVlcIjpyZXR1cm57Z3JvdXA6XCJ5ZWFyXCIscGF0dGVybjpcIihcXFxcZHtcIitlLmxlbmd0aCtcIn0pXCJ9O2Nhc2VcIk1cIjpyZXR1cm57Z3JvdXA6XCJtb250aFwiLHBhdHRlcm46XCIoXFxcXGR7MSwyfSlcIn07Y2FzZVwiTU1cIjpyZXR1cm57Z3JvdXA6XCJtb250aFwiLHBhdHRlcm46XCIoXFxcXGR7Mn0pXCJ9O2Nhc2VcIk1NTVwiOnJldHVybntncm91cDpcInNob3J0TW9udGhcIixwYXR0ZXJuOlwiKFwiK3Quc2hvcnRNb250aHMoaSkuam9pbihcInxcIikrXCIpXCJ9O2Nhc2VcIk1NTU1cIjpyZXR1cm57Z3JvdXA6XCJsb25nTW9udGhcIixwYXR0ZXJuOlwiKFwiK3QubG9uZ01vbnRocyhpKS5qb2luKFwifFwiKStcIilcIn07Y2FzZVwiRFwiOnJldHVybntncm91cDpcImRheVwiLHBhdHRlcm46XCIoXFxcXGR7MSwyfSlcIn07Y2FzZVwiRERcIjpyZXR1cm57Z3JvdXA6XCJkYXlcIixwYXR0ZXJuOlwiKFxcXFxkezJ9KVwifX19LHQucHJvdG90eXBlLnRvSlNEYXRlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGF0ZUluc3RhbmNlfSx0LnByb3RvdHlwZS50b0xvY2FsZVN0cmluZz1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmRhdGVJbnN0YW5jZS50b0xvY2FsZVN0cmluZyh0LGUpfSx0LnByb3RvdHlwZS50b0RhdGVTdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kYXRlSW5zdGFuY2UudG9EYXRlU3RyaW5nKCl9LHQucHJvdG90eXBlLmdldFNlY29uZHM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kYXRlSW5zdGFuY2UuZ2V0U2Vjb25kcygpfSx0LnByb3RvdHlwZS5nZXREYXk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kYXRlSW5zdGFuY2UuZ2V0RGF5KCl9LHQucHJvdG90eXBlLmdldFRpbWU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kYXRlSW5zdGFuY2UuZ2V0VGltZSgpfSx0LnByb3RvdHlwZS5nZXREYXRlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGF0ZUluc3RhbmNlLmdldERhdGUoKX0sdC5wcm90b3R5cGUuZ2V0TW9udGg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kYXRlSW5zdGFuY2UuZ2V0TW9udGgoKX0sdC5wcm90b3R5cGUuZ2V0RnVsbFllYXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kYXRlSW5zdGFuY2UuZ2V0RnVsbFllYXIoKX0sdC5wcm90b3R5cGUuc2V0TW9udGg9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZGF0ZUluc3RhbmNlLnNldE1vbnRoKHQpfSx0LnByb3RvdHlwZS5zZXRIb3Vycz1mdW5jdGlvbih0LGUsaSxuKXt2b2lkIDA9PT10JiYodD0wKSx2b2lkIDA9PT1lJiYoZT0wKSx2b2lkIDA9PT1pJiYoaT0wKSx2b2lkIDA9PT1uJiYobj0wKSx0aGlzLmRhdGVJbnN0YW5jZS5zZXRIb3Vycyh0LGUsaSxuKX0sdC5wcm90b3R5cGUuc2V0U2Vjb25kcz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5kYXRlSW5zdGFuY2Uuc2V0U2Vjb25kcyh0KX0sdC5wcm90b3R5cGUuc2V0RGF0ZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5kYXRlSW5zdGFuY2Uuc2V0RGF0ZSh0KX0sdC5wcm90b3R5cGUuc2V0RnVsbFllYXI9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZGF0ZUluc3RhbmNlLnNldEZ1bGxZZWFyKHQpfSx0LnByb3RvdHlwZS5nZXRXZWVrPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBEYXRlKHRoaXMudGltZXN0YW1wKCkpLGk9KHRoaXMuZ2V0RGF5KCkrKDctdCkpJTc7ZS5zZXREYXRlKGUuZ2V0RGF0ZSgpLWkpO3ZhciBuPWUuZ2V0VGltZSgpO3JldHVybiBlLnNldE1vbnRoKDAsMSksZS5nZXREYXkoKSE9PXQmJmUuc2V0TW9udGgoMCwxKyg0LWUuZ2V0RGF5KCkrNyklNyksMStNYXRoLmNlaWwoKG4tZS5nZXRUaW1lKCkpLzYwNDhlNSl9LHQucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyB0KHRoaXMudG9KU0RhdGUoKSl9LHQucHJvdG90eXBlLmlzQmV0d2Vlbj1mdW5jdGlvbih0LGUsaSl7c3dpdGNoKHZvaWQgMD09PWkmJihpPVwiKClcIiksaSl7ZGVmYXVsdDpjYXNlXCIoKVwiOnJldHVybiB0aGlzLnRpbWVzdGFtcCgpPnQuZ2V0VGltZSgpJiZ0aGlzLnRpbWVzdGFtcCgpPGUuZ2V0VGltZSgpO2Nhc2VcIlspXCI6cmV0dXJuIHRoaXMudGltZXN0YW1wKCk+PXQuZ2V0VGltZSgpJiZ0aGlzLnRpbWVzdGFtcCgpPGUuZ2V0VGltZSgpO2Nhc2VcIihdXCI6cmV0dXJuIHRoaXMudGltZXN0YW1wKCk+dC5nZXRUaW1lKCkmJnRoaXMudGltZXN0YW1wKCk8PWUuZ2V0VGltZSgpO2Nhc2VcIltdXCI6cmV0dXJuIHRoaXMudGltZXN0YW1wKCk+PXQuZ2V0VGltZSgpJiZ0aGlzLnRpbWVzdGFtcCgpPD1lLmdldFRpbWUoKX19LHQucHJvdG90eXBlLmlzQmVmb3JlPWZ1bmN0aW9uKHQsZSl7c3dpdGNoKHZvaWQgMD09PWUmJihlPVwic2Vjb25kc1wiKSxlKXtjYXNlXCJzZWNvbmRcIjpjYXNlXCJzZWNvbmRzXCI6cmV0dXJuIHQuZ2V0VGltZSgpPnRoaXMuZ2V0VGltZSgpO2Nhc2VcImRheVwiOmNhc2VcImRheXNcIjpyZXR1cm4gbmV3IERhdGUodC5nZXRGdWxsWWVhcigpLHQuZ2V0TW9udGgoKSx0LmdldERhdGUoKSkuZ2V0VGltZSgpPm5ldyBEYXRlKHRoaXMuZ2V0RnVsbFllYXIoKSx0aGlzLmdldE1vbnRoKCksdGhpcy5nZXREYXRlKCkpLmdldFRpbWUoKTtjYXNlXCJtb250aFwiOmNhc2VcIm1vbnRoc1wiOnJldHVybiBuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksdC5nZXRNb250aCgpLDEpLmdldFRpbWUoKT5uZXcgRGF0ZSh0aGlzLmdldEZ1bGxZZWFyKCksdGhpcy5nZXRNb250aCgpLDEpLmdldFRpbWUoKTtjYXNlXCJ5ZWFyXCI6Y2FzZVwieWVhcnNcIjpyZXR1cm4gdC5nZXRGdWxsWWVhcigpPnRoaXMuZ2V0RnVsbFllYXIoKX10aHJvdyBuZXcgRXJyb3IoXCJpc0JlZm9yZTogSW52YWxpZCB1bml0IVwiKX0sdC5wcm90b3R5cGUuaXNTYW1lT3JCZWZvcmU9ZnVuY3Rpb24odCxlKXtzd2l0Y2godm9pZCAwPT09ZSYmKGU9XCJzZWNvbmRzXCIpLGUpe2Nhc2VcInNlY29uZFwiOmNhc2VcInNlY29uZHNcIjpyZXR1cm4gdC5nZXRUaW1lKCk+PXRoaXMuZ2V0VGltZSgpO2Nhc2VcImRheVwiOmNhc2VcImRheXNcIjpyZXR1cm4gbmV3IERhdGUodC5nZXRGdWxsWWVhcigpLHQuZ2V0TW9udGgoKSx0LmdldERhdGUoKSkuZ2V0VGltZSgpPj1uZXcgRGF0ZSh0aGlzLmdldEZ1bGxZZWFyKCksdGhpcy5nZXRNb250aCgpLHRoaXMuZ2V0RGF0ZSgpKS5nZXRUaW1lKCk7Y2FzZVwibW9udGhcIjpjYXNlXCJtb250aHNcIjpyZXR1cm4gbmV3IERhdGUodC5nZXRGdWxsWWVhcigpLHQuZ2V0TW9udGgoKSwxKS5nZXRUaW1lKCk+PW5ldyBEYXRlKHRoaXMuZ2V0RnVsbFllYXIoKSx0aGlzLmdldE1vbnRoKCksMSkuZ2V0VGltZSgpfXRocm93IG5ldyBFcnJvcihcImlzU2FtZU9yQmVmb3JlOiBJbnZhbGlkIHVuaXQhXCIpfSx0LnByb3RvdHlwZS5pc0FmdGVyPWZ1bmN0aW9uKHQsZSl7c3dpdGNoKHZvaWQgMD09PWUmJihlPVwic2Vjb25kc1wiKSxlKXtjYXNlXCJzZWNvbmRcIjpjYXNlXCJzZWNvbmRzXCI6cmV0dXJuIHRoaXMuZ2V0VGltZSgpPnQuZ2V0VGltZSgpO2Nhc2VcImRheVwiOmNhc2VcImRheXNcIjpyZXR1cm4gbmV3IERhdGUodGhpcy5nZXRGdWxsWWVhcigpLHRoaXMuZ2V0TW9udGgoKSx0aGlzLmdldERhdGUoKSkuZ2V0VGltZSgpPm5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSx0LmdldE1vbnRoKCksdC5nZXREYXRlKCkpLmdldFRpbWUoKTtjYXNlXCJtb250aFwiOmNhc2VcIm1vbnRoc1wiOnJldHVybiBuZXcgRGF0ZSh0aGlzLmdldEZ1bGxZZWFyKCksdGhpcy5nZXRNb250aCgpLDEpLmdldFRpbWUoKT5uZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksdC5nZXRNb250aCgpLDEpLmdldFRpbWUoKTtjYXNlXCJ5ZWFyXCI6Y2FzZVwieWVhcnNcIjpyZXR1cm4gdGhpcy5nZXRGdWxsWWVhcigpPnQuZ2V0RnVsbFllYXIoKX10aHJvdyBuZXcgRXJyb3IoXCJpc0FmdGVyOiBJbnZhbGlkIHVuaXQhXCIpfSx0LnByb3RvdHlwZS5pc1NhbWVPckFmdGVyPWZ1bmN0aW9uKHQsZSl7c3dpdGNoKHZvaWQgMD09PWUmJihlPVwic2Vjb25kc1wiKSxlKXtjYXNlXCJzZWNvbmRcIjpjYXNlXCJzZWNvbmRzXCI6cmV0dXJuIHRoaXMuZ2V0VGltZSgpPj10LmdldFRpbWUoKTtjYXNlXCJkYXlcIjpjYXNlXCJkYXlzXCI6cmV0dXJuIG5ldyBEYXRlKHRoaXMuZ2V0RnVsbFllYXIoKSx0aGlzLmdldE1vbnRoKCksdGhpcy5nZXREYXRlKCkpLmdldFRpbWUoKT49bmV3IERhdGUodC5nZXRGdWxsWWVhcigpLHQuZ2V0TW9udGgoKSx0LmdldERhdGUoKSkuZ2V0VGltZSgpO2Nhc2VcIm1vbnRoXCI6Y2FzZVwibW9udGhzXCI6cmV0dXJuIG5ldyBEYXRlKHRoaXMuZ2V0RnVsbFllYXIoKSx0aGlzLmdldE1vbnRoKCksMSkuZ2V0VGltZSgpPj1uZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksdC5nZXRNb250aCgpLDEpLmdldFRpbWUoKX10aHJvdyBuZXcgRXJyb3IoXCJpc1NhbWVPckFmdGVyOiBJbnZhbGlkIHVuaXQhXCIpfSx0LnByb3RvdHlwZS5pc1NhbWU9ZnVuY3Rpb24odCxlKXtzd2l0Y2godm9pZCAwPT09ZSYmKGU9XCJzZWNvbmRzXCIpLGUpe2Nhc2VcInNlY29uZFwiOmNhc2VcInNlY29uZHNcIjpyZXR1cm4gdGhpcy5nZXRUaW1lKCk9PT10LmdldFRpbWUoKTtjYXNlXCJkYXlcIjpjYXNlXCJkYXlzXCI6cmV0dXJuIG5ldyBEYXRlKHRoaXMuZ2V0RnVsbFllYXIoKSx0aGlzLmdldE1vbnRoKCksdGhpcy5nZXREYXRlKCkpLmdldFRpbWUoKT09PW5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSx0LmdldE1vbnRoKCksdC5nZXREYXRlKCkpLmdldFRpbWUoKTtjYXNlXCJtb250aFwiOmNhc2VcIm1vbnRoc1wiOnJldHVybiBuZXcgRGF0ZSh0aGlzLmdldEZ1bGxZZWFyKCksdGhpcy5nZXRNb250aCgpLDEpLmdldFRpbWUoKT09PW5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSx0LmdldE1vbnRoKCksMSkuZ2V0VGltZSgpfXRocm93IG5ldyBFcnJvcihcImlzU2FtZTogSW52YWxpZCB1bml0IVwiKX0sdC5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKHQsZSl7c3dpdGNoKHZvaWQgMD09PWUmJihlPVwic2Vjb25kc1wiKSxlKXtjYXNlXCJzZWNvbmRcIjpjYXNlXCJzZWNvbmRzXCI6dGhpcy5zZXRTZWNvbmRzKHRoaXMuZ2V0U2Vjb25kcygpK3QpO2JyZWFrO2Nhc2VcImRheVwiOmNhc2VcImRheXNcIjp0aGlzLnNldERhdGUodGhpcy5nZXREYXRlKCkrdCk7YnJlYWs7Y2FzZVwibW9udGhcIjpjYXNlXCJtb250aHNcIjp0aGlzLnNldE1vbnRoKHRoaXMuZ2V0TW9udGgoKSt0KX1yZXR1cm4gdGhpc30sdC5wcm90b3R5cGUuc3VidHJhY3Q9ZnVuY3Rpb24odCxlKXtzd2l0Y2godm9pZCAwPT09ZSYmKGU9XCJzZWNvbmRzXCIpLGUpe2Nhc2VcInNlY29uZFwiOmNhc2VcInNlY29uZHNcIjp0aGlzLnNldFNlY29uZHModGhpcy5nZXRTZWNvbmRzKCktdCk7YnJlYWs7Y2FzZVwiZGF5XCI6Y2FzZVwiZGF5c1wiOnRoaXMuc2V0RGF0ZSh0aGlzLmdldERhdGUoKS10KTticmVhaztjYXNlXCJtb250aFwiOmNhc2VcIm1vbnRoc1wiOnRoaXMuc2V0TW9udGgodGhpcy5nZXRNb250aCgpLXQpfXJldHVybiB0aGlzfSx0LnByb3RvdHlwZS5kaWZmPWZ1bmN0aW9uKHQsZSl7dm9pZCAwPT09ZSYmKGU9XCJzZWNvbmRzXCIpO3N3aXRjaChlKXtkZWZhdWx0OmNhc2VcInNlY29uZFwiOmNhc2VcInNlY29uZHNcIjpyZXR1cm4gdGhpcy5nZXRUaW1lKCktdC5nZXRUaW1lKCk7Y2FzZVwiZGF5XCI6Y2FzZVwiZGF5c1wiOnJldHVybiBNYXRoLnJvdW5kKCh0aGlzLnRpbWVzdGFtcCgpLXQuZ2V0VGltZSgpKS84NjRlNSk7Y2FzZVwibW9udGhcIjpjYXNlXCJtb250aHNcIjp9fSx0LnByb3RvdHlwZS5mb3JtYXQ9ZnVuY3Rpb24oZSxpKXtpZih2b2lkIDA9PT1pJiYoaT1cImVuLVVTXCIpLFwib2JqZWN0XCI9PXR5cGVvZiBlKXJldHVybiBlLm91dHB1dCh0aGlzLmNsb25lKCkudG9KU0RhdGUoKSk7Zm9yKHZhciBuPVwiXCIsbz1bXSxzPW51bGw7bnVsbCE9KHM9dC5yZWdleC5leGVjKGUpKTspXCJcXFxcXCIhPT1zWzFdJiZvLnB1c2gocyk7aWYoby5sZW5ndGgpe29bMF0uaW5kZXg+MCYmKG4rPWUuc3Vic3RyaW5nKDAsb1swXS5pbmRleCkpO2Zvcih2YXIgcj0wLGE9T2JqZWN0LmVudHJpZXMobyk7cjxhLmxlbmd0aDtyKyspe3ZhciBsPWFbcl0sYz1sWzBdLGg9bFsxXSxwPU51bWJlcihjKTtuKz10aGlzLmZvcm1hdFRva2VucyhoWzBdLGkpLG9bcCsxXSYmKG4rPWUuc3Vic3RyaW5nKGguaW5kZXgraFswXS5sZW5ndGgsb1twKzFdLmluZGV4KSkscD09PW8ubGVuZ3RoLTEmJihuKz1lLnN1YnN0cmluZyhoLmluZGV4K2hbMF0ubGVuZ3RoKSl9fXJldHVybiBuLnJlcGxhY2UoL1xcXFwvZyxcIlwiKX0sdC5wcm90b3R5cGUudGltZXN0YW1wPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBEYXRlKHRoaXMuZ2V0RnVsbFllYXIoKSx0aGlzLmdldE1vbnRoKCksdGhpcy5nZXREYXRlKCksMCwwLDAsMCkuZ2V0VGltZSgpfSx0LnByb3RvdHlwZS5mb3JtYXRUb2tlbnM9ZnVuY3Rpb24oZSxpKXtzd2l0Y2goZSl7Y2FzZVwiWVlcIjpyZXR1cm4gU3RyaW5nKHRoaXMuZ2V0RnVsbFllYXIoKSkuc2xpY2UoLTIpO2Nhc2VcIllZWVlcIjpyZXR1cm4gU3RyaW5nKHRoaXMuZ2V0RnVsbFllYXIoKSk7Y2FzZVwiTVwiOnJldHVybiBTdHJpbmcodGhpcy5nZXRNb250aCgpKzEpO2Nhc2VcIk1NXCI6cmV0dXJuKFwiMFwiKyh0aGlzLmdldE1vbnRoKCkrMSkpLnNsaWNlKC0yKTtjYXNlXCJNTU1cIjpyZXR1cm4gdC5zaG9ydE1vbnRocyhpKVt0aGlzLmdldE1vbnRoKCldO2Nhc2VcIk1NTU1cIjpyZXR1cm4gdC5sb25nTW9udGhzKGkpW3RoaXMuZ2V0TW9udGgoKV07Y2FzZVwiRFwiOnJldHVybiBTdHJpbmcodGhpcy5nZXREYXRlKCkpO2Nhc2VcIkREXCI6cmV0dXJuKFwiMFwiK3RoaXMuZ2V0RGF0ZSgpKS5zbGljZSgtMik7ZGVmYXVsdDpyZXR1cm5cIlwifX0sdC5yZWdleD0vKFxcXFwpPyhZezIsNH18TXsxLDR9fER7MSwyfXxkezEsNH0pL2csdC5NT05USF9KUz1bMCwxLDIsMyw0LDUsNiw3LDgsOSwxMCwxMV0sdH0oKTtlLkRhdGVUaW1lPW59LGZ1bmN0aW9uKHQsZSxpKXtcInVzZSBzdHJpY3RcIjt2YXIgbixvPXRoaXMmJnRoaXMuX19leHRlbmRzfHwobj1mdW5jdGlvbih0LGUpe3JldHVybihuPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbih0LGUpe3QuX19wcm90b19fPWV9fHxmdW5jdGlvbih0LGUpe2Zvcih2YXIgaSBpbiBlKWUuaGFzT3duUHJvcGVydHkoaSkmJih0W2ldPWVbaV0pfSkodCxlKX0sZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBpKCl7dGhpcy5jb25zdHJ1Y3Rvcj10fW4odCxlKSx0LnByb3RvdHlwZT1udWxsPT09ZT9PYmplY3QuY3JlYXRlKGUpOihpLnByb3RvdHlwZT1lLnByb3RvdHlwZSxuZXcgaSl9KSxzPXRoaXMmJnRoaXMuX19zcHJlYWRBcnJheXN8fGZ1bmN0aW9uKCl7Zm9yKHZhciB0PTAsZT0wLGk9YXJndW1lbnRzLmxlbmd0aDtlPGk7ZSsrKXQrPWFyZ3VtZW50c1tlXS5sZW5ndGg7dmFyIG49QXJyYXkodCksbz0wO2ZvcihlPTA7ZTxpO2UrKylmb3IodmFyIHM9YXJndW1lbnRzW2VdLHI9MCxhPXMubGVuZ3RoO3I8YTtyKyssbysrKW5bb109c1tyXTtyZXR1cm4gbn07T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHI9aSg1KSxhPWkoMCksbD1pKDMpLGM9aSgyKSxoPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSl7dmFyIGk9dC5jYWxsKHRoaXMsZSl8fHRoaXM7cmV0dXJuIGkucHJldmVudENsaWNrPSExLGkuYmluZEV2ZW50cygpLGl9cmV0dXJuIG8oZSx0KSxlLnByb3RvdHlwZS5zY3JvbGxUb0RhdGU9ZnVuY3Rpb24odCl7aWYodGhpcy5vcHRpb25zLnNjcm9sbFRvRGF0ZSl7dmFyIGU9dGhpcy5vcHRpb25zLnN0YXJ0RGF0ZSBpbnN0YW5jZW9mIGEuRGF0ZVRpbWU/dGhpcy5vcHRpb25zLnN0YXJ0RGF0ZS5jbG9uZSgpOm51bGwsaT10aGlzLm9wdGlvbnMuZW5kRGF0ZSBpbnN0YW5jZW9mIGEuRGF0ZVRpbWU/dGhpcy5vcHRpb25zLmVuZERhdGUuY2xvbmUoKTpudWxsOyF0aGlzLm9wdGlvbnMuc3RhcnREYXRlfHx0JiZ0IT09dGhpcy5vcHRpb25zLmVsZW1lbnQ/dCYmdGhpcy5vcHRpb25zLmVuZERhdGUmJnQ9PT10aGlzLm9wdGlvbnMuZWxlbWVudEVuZCYmKGkuc2V0RGF0ZSgxKSx0aGlzLm9wdGlvbnMubnVtYmVyT2ZNb250aHM+MSYmaS5pc0FmdGVyKGUpJiZpLnNldE1vbnRoKGkuZ2V0TW9udGgoKS0odGhpcy5vcHRpb25zLm51bWJlck9mTW9udGhzLTEpKSx0aGlzLmNhbGVuZGFyc1swXT1pLmNsb25lKCkpOihlLnNldERhdGUoMSksdGhpcy5jYWxlbmRhcnNbMF09ZS5jbG9uZSgpKX19LGUucHJvdG90eXBlLmJpbmRFdmVudHM9ZnVuY3Rpb24oKXtkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIix0aGlzLm9uQ2xpY2suYmluZCh0aGlzKSwhMCksdGhpcy51aT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLHRoaXMudWkuY2xhc3NOYW1lPWwubGl0ZXBpY2tlcix0aGlzLnVpLnN0eWxlLmRpc3BsYXk9XCJub25lXCIsdGhpcy51aS5hZGRFdmVudExpc3RlbmVyKFwibW91c2VlbnRlclwiLHRoaXMub25Nb3VzZUVudGVyLmJpbmQodGhpcyksITApLHRoaXMudWkuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIix0aGlzLm9uTW91c2VMZWF2ZS5iaW5kKHRoaXMpLCExKSx0aGlzLm9wdGlvbnMuYXV0b1JlZnJlc2g/KHRoaXMub3B0aW9ucy5lbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQmJnRoaXMub3B0aW9ucy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLHRoaXMub25JbnB1dC5iaW5kKHRoaXMpLCEwKSx0aGlzLm9wdGlvbnMuZWxlbWVudEVuZCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50JiZ0aGlzLm9wdGlvbnMuZWxlbWVudEVuZC5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIix0aGlzLm9uSW5wdXQuYmluZCh0aGlzKSwhMCkpOih0aGlzLm9wdGlvbnMuZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50JiZ0aGlzLm9wdGlvbnMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsdGhpcy5vbklucHV0LmJpbmQodGhpcyksITApLHRoaXMub3B0aW9ucy5lbGVtZW50RW5kIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQmJnRoaXMub3B0aW9ucy5lbGVtZW50RW5kLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIix0aGlzLm9uSW5wdXQuYmluZCh0aGlzKSwhMCkpLHRoaXMub3B0aW9ucy5wYXJlbnRFbD90aGlzLm9wdGlvbnMucGFyZW50RWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudD90aGlzLm9wdGlvbnMucGFyZW50RWwuYXBwZW5kQ2hpbGQodGhpcy51aSk6ZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0aGlzLm9wdGlvbnMucGFyZW50RWwpLmFwcGVuZENoaWxkKHRoaXMudWkpOnRoaXMub3B0aW9ucy5pbmxpbmVNb2RlP3RoaXMub3B0aW9ucy5lbGVtZW50IGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudD90aGlzLm9wdGlvbnMuZWxlbWVudC5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHRoaXMudWkpOnRoaXMub3B0aW9ucy5lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMudWkpOmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy51aSksdGhpcy51cGRhdGVJbnB1dCgpLHRoaXMuaW5pdCgpLFwiZnVuY3Rpb25cIj09dHlwZW9mIHRoaXMub3B0aW9ucy5zZXR1cCYmdGhpcy5vcHRpb25zLnNldHVwLmNhbGwodGhpcyx0aGlzKSx0aGlzLnJlbmRlcigpLHRoaXMub3B0aW9ucy5pbmxpbmVNb2RlJiZ0aGlzLnNob3coKX0sZS5wcm90b3R5cGUudXBkYXRlSW5wdXQ9ZnVuY3Rpb24oKXtpZih0aGlzLm9wdGlvbnMuZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQpe3ZhciB0PXRoaXMub3B0aW9ucy5zdGFydERhdGUsZT10aGlzLm9wdGlvbnMuZW5kRGF0ZTtpZih0aGlzLm9wdGlvbnMuc2luZ2xlTW9kZSYmdCl0aGlzLm9wdGlvbnMuZWxlbWVudC52YWx1ZT10LmZvcm1hdCh0aGlzLm9wdGlvbnMuZm9ybWF0LHRoaXMub3B0aW9ucy5sYW5nKTtlbHNlIGlmKCF0aGlzLm9wdGlvbnMuc2luZ2xlTW9kZSYmdCYmZSl7dmFyIGk9dC5mb3JtYXQodGhpcy5vcHRpb25zLmZvcm1hdCx0aGlzLm9wdGlvbnMubGFuZyksbj1lLmZvcm1hdCh0aGlzLm9wdGlvbnMuZm9ybWF0LHRoaXMub3B0aW9ucy5sYW5nKTt0aGlzLm9wdGlvbnMuZWxlbWVudEVuZCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQ/KHRoaXMub3B0aW9ucy5lbGVtZW50LnZhbHVlPWksdGhpcy5vcHRpb25zLmVsZW1lbnRFbmQudmFsdWU9bik6dGhpcy5vcHRpb25zLmVsZW1lbnQudmFsdWU9XCJcIitpK3RoaXMub3B0aW9ucy5kZWxpbWl0ZXIrbn10fHxlfHwodGhpcy5vcHRpb25zLmVsZW1lbnQudmFsdWU9XCJcIix0aGlzLm9wdGlvbnMuZWxlbWVudEVuZCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQmJih0aGlzLm9wdGlvbnMuZWxlbWVudEVuZC52YWx1ZT1cIlwiKSl9fSxlLnByb3RvdHlwZS5pc1NhbWVQaWNrZXI9ZnVuY3Rpb24odCl7cmV0dXJuIHQuY2xvc2VzdChcIi5cIitsLmxpdGVwaWNrZXIpPT09dGhpcy51aX0sZS5wcm90b3R5cGUuc2hvdWxkU2hvd249ZnVuY3Rpb24odCl7cmV0dXJuIXQuZGlzYWJsZWQmJih0PT09dGhpcy5vcHRpb25zLmVsZW1lbnR8fHRoaXMub3B0aW9ucy5lbGVtZW50RW5kJiZ0PT09dGhpcy5vcHRpb25zLmVsZW1lbnRFbmQpfSxlLnByb3RvdHlwZS5zaG91bGRSZXNldERhdGVQaWNrZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vcHRpb25zLnNpbmdsZU1vZGV8fDI9PT10aGlzLmRhdGVQaWNrZWQubGVuZ3RofSxlLnByb3RvdHlwZS5zaG91bGRTd2FwRGF0ZVBpY2tlZD1mdW5jdGlvbigpe3JldHVybiAyPT09dGhpcy5kYXRlUGlja2VkLmxlbmd0aCYmdGhpcy5kYXRlUGlja2VkWzBdLmdldFRpbWUoKT50aGlzLmRhdGVQaWNrZWRbMV0uZ2V0VGltZSgpfSxlLnByb3RvdHlwZS5zaG91bGRDaGVja0xvY2tEYXlzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub3B0aW9ucy5kaXNhbGxvd0xvY2tEYXlzSW5SYW5nZSYmMj09PXRoaXMuZGF0ZVBpY2tlZC5sZW5ndGh9LGUucHJvdG90eXBlLm9uQ2xpY2s9ZnVuY3Rpb24odCl7dmFyIGU9dC50YXJnZXQ7aWYodC50YXJnZXQuc2hhZG93Um9vdCYmKGU9dC5jb21wb3NlZFBhdGgoKVswXSksZSYmdGhpcy51aSlpZih0aGlzLnNob3VsZFNob3duKGUpKXRoaXMuc2hvdyhlKTtlbHNlIGlmKGUuY2xvc2VzdChcIi5cIitsLmxpdGVwaWNrZXIpfHwhdGhpcy5pc1Nob3duaW5nKCkpe2lmKHRoaXMuaXNTYW1lUGlja2VyKGUpKWlmKHRoaXMuZW1pdChcImJlZm9yZTpjbGlja1wiLGUpLHRoaXMucHJldmVudENsaWNrKXRoaXMucHJldmVudENsaWNrPSExO2Vsc2V7aWYoZS5jbGFzc0xpc3QuY29udGFpbnMobC5kYXlJdGVtKSl7aWYodC5wcmV2ZW50RGVmYXVsdCgpLGUuY2xhc3NMaXN0LmNvbnRhaW5zKGwuaXNMb2NrZWQpKXJldHVybjtpZih0aGlzLnNob3VsZFJlc2V0RGF0ZVBpY2tlZCgpJiYodGhpcy5kYXRlUGlja2VkLmxlbmd0aD0wKSx0aGlzLmRhdGVQaWNrZWRbdGhpcy5kYXRlUGlja2VkLmxlbmd0aF09bmV3IGEuRGF0ZVRpbWUoZS5kYXRhc2V0LnRpbWUpLHRoaXMuc2hvdWxkU3dhcERhdGVQaWNrZWQoKSl7dmFyIGk9dGhpcy5kYXRlUGlja2VkWzFdLmNsb25lKCk7dGhpcy5kYXRlUGlja2VkWzFdPXRoaXMuZGF0ZVBpY2tlZFswXS5jbG9uZSgpLHRoaXMuZGF0ZVBpY2tlZFswXT1pLmNsb25lKCl9aWYodGhpcy5zaG91bGRDaGVja0xvY2tEYXlzKCkpYy5yYW5nZUlzTG9ja2VkKHRoaXMuZGF0ZVBpY2tlZCx0aGlzLm9wdGlvbnMpJiYodGhpcy5lbWl0KFwiZXJyb3I6cmFuZ2VcIix0aGlzLmRhdGVQaWNrZWQpLHRoaXMuZGF0ZVBpY2tlZC5sZW5ndGg9MCk7cmV0dXJuIHRoaXMucmVuZGVyKCksdGhpcy5lbWl0LmFwcGx5KHRoaXMscyhbXCJwcmVzZWxlY3RcIl0scyh0aGlzLmRhdGVQaWNrZWQpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQuY2xvbmUoKX0pKSkpLHZvaWQodGhpcy5vcHRpb25zLmF1dG9BcHBseSYmKHRoaXMub3B0aW9ucy5zaW5nbGVNb2RlJiZ0aGlzLmRhdGVQaWNrZWQubGVuZ3RoPyh0aGlzLnNldERhdGUodGhpcy5kYXRlUGlja2VkWzBdKSx0aGlzLmhpZGUoKSk6dGhpcy5vcHRpb25zLnNpbmdsZU1vZGV8fDIhPT10aGlzLmRhdGVQaWNrZWQubGVuZ3RofHwodGhpcy5zZXREYXRlUmFuZ2UodGhpcy5kYXRlUGlja2VkWzBdLHRoaXMuZGF0ZVBpY2tlZFsxXSksdGhpcy5oaWRlKCkpKSl9aWYoZS5jbGFzc0xpc3QuY29udGFpbnMobC5idXR0b25QcmV2aW91c01vbnRoKSl7dC5wcmV2ZW50RGVmYXVsdCgpO3ZhciBuPTAsbz10aGlzLm9wdGlvbnMuc3dpdGNoaW5nTW9udGhzfHx0aGlzLm9wdGlvbnMubnVtYmVyT2ZNb250aHM7aWYodGhpcy5vcHRpb25zLnNwbGl0Vmlldyl7dmFyIHI9ZS5jbG9zZXN0KFwiLlwiK2wubW9udGhJdGVtKTtuPWMuZmluZE5lc3RlZE1vbnRoSXRlbShyKSxvPTF9cmV0dXJuIHRoaXMuY2FsZW5kYXJzW25dLnNldE1vbnRoKHRoaXMuY2FsZW5kYXJzW25dLmdldE1vbnRoKCktbyksdGhpcy5nb3RvRGF0ZSh0aGlzLmNhbGVuZGFyc1tuXSxuKSx2b2lkIHRoaXMuZW1pdChcImNoYW5nZTptb250aFwiLHRoaXMuY2FsZW5kYXJzW25dLG4pfWlmKGUuY2xhc3NMaXN0LmNvbnRhaW5zKGwuYnV0dG9uTmV4dE1vbnRoKSl7dC5wcmV2ZW50RGVmYXVsdCgpO249MCxvPXRoaXMub3B0aW9ucy5zd2l0Y2hpbmdNb250aHN8fHRoaXMub3B0aW9ucy5udW1iZXJPZk1vbnRocztpZih0aGlzLm9wdGlvbnMuc3BsaXRWaWV3KXtyPWUuY2xvc2VzdChcIi5cIitsLm1vbnRoSXRlbSk7bj1jLmZpbmROZXN0ZWRNb250aEl0ZW0ociksbz0xfXJldHVybiB0aGlzLmNhbGVuZGFyc1tuXS5zZXRNb250aCh0aGlzLmNhbGVuZGFyc1tuXS5nZXRNb250aCgpK28pLHRoaXMuZ290b0RhdGUodGhpcy5jYWxlbmRhcnNbbl0sbiksdm9pZCB0aGlzLmVtaXQoXCJjaGFuZ2U6bW9udGhcIix0aGlzLmNhbGVuZGFyc1tuXSxuKX1lLmNsYXNzTGlzdC5jb250YWlucyhsLmJ1dHRvbkNhbmNlbCkmJih0LnByZXZlbnREZWZhdWx0KCksdGhpcy5oaWRlKCksdGhpcy5lbWl0KFwiYnV0dG9uOmNhbmNlbFwiKSksZS5jbGFzc0xpc3QuY29udGFpbnMobC5idXR0b25BcHBseSkmJih0LnByZXZlbnREZWZhdWx0KCksdGhpcy5vcHRpb25zLnNpbmdsZU1vZGUmJnRoaXMuZGF0ZVBpY2tlZC5sZW5ndGg/dGhpcy5zZXREYXRlKHRoaXMuZGF0ZVBpY2tlZFswXSk6dGhpcy5vcHRpb25zLnNpbmdsZU1vZGV8fDIhPT10aGlzLmRhdGVQaWNrZWQubGVuZ3RofHx0aGlzLnNldERhdGVSYW5nZSh0aGlzLmRhdGVQaWNrZWRbMF0sdGhpcy5kYXRlUGlja2VkWzFdKSx0aGlzLmhpZGUoKSx0aGlzLmVtaXQoXCJidXR0b246YXBwbHlcIix0aGlzLm9wdGlvbnMuc3RhcnREYXRlLHRoaXMub3B0aW9ucy5lbmREYXRlKSl9fWVsc2UgdGhpcy5oaWRlKCl9LGUucHJvdG90eXBlLnNob3dUb29sdGlwPWZ1bmN0aW9uKHQsZSl7dmFyIGk9dGhpcy51aS5xdWVyeVNlbGVjdG9yKFwiLlwiK2wuY29udGFpbmVyVG9vbHRpcCk7aS5zdHlsZS52aXNpYmlsaXR5PVwidmlzaWJsZVwiLGkuaW5uZXJIVE1MPWU7dmFyIG49dGhpcy51aS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxvPWkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkscz10LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLHI9cy50b3AsYT1zLmxlZnQ7aWYodGhpcy5vcHRpb25zLmlubGluZU1vZGUmJnRoaXMub3B0aW9ucy5wYXJlbnRFbCl7dmFyIGM9dGhpcy51aS5wYXJlbnROb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3ItPWMudG9wLGEtPWMubGVmdH1lbHNlIHItPW4udG9wLGEtPW4ubGVmdDtyLT1vLmhlaWdodCxhLT1vLndpZHRoLzIsYSs9cy53aWR0aC8yLGkuc3R5bGUudG9wPXIrXCJweFwiLGkuc3R5bGUubGVmdD1hK1wicHhcIix0aGlzLmVtaXQoXCJ0b29sdGlwXCIsaSx0KX0sZS5wcm90b3R5cGUuaGlkZVRvb2x0aXA9ZnVuY3Rpb24oKXt0aGlzLnVpLnF1ZXJ5U2VsZWN0b3IoXCIuXCIrbC5jb250YWluZXJUb29sdGlwKS5zdHlsZS52aXNpYmlsaXR5PVwiaGlkZGVuXCJ9LGUucHJvdG90eXBlLnNob3VsZEFsbG93TW91c2VFbnRlcj1mdW5jdGlvbih0KXtyZXR1cm4hdGhpcy5vcHRpb25zLnNpbmdsZU1vZGUmJiF0LmNsYXNzTGlzdC5jb250YWlucyhsLmlzTG9ja2VkKX0sZS5wcm90b3R5cGUuc2hvdWxkQWxsb3dSZXBpY2s9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vcHRpb25zLmVsZW1lbnRFbmQmJnRoaXMub3B0aW9ucy5hbGxvd1JlcGljayYmdGhpcy5vcHRpb25zLnN0YXJ0RGF0ZSYmdGhpcy5vcHRpb25zLmVuZERhdGV9LGUucHJvdG90eXBlLmlzRGF5SXRlbT1mdW5jdGlvbih0KXtyZXR1cm4gdC5jbGFzc0xpc3QuY29udGFpbnMobC5kYXlJdGVtKX0sZS5wcm90b3R5cGUub25Nb3VzZUVudGVyPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMsaT10LnRhcmdldDtpZih0aGlzLmlzRGF5SXRlbShpKSYmdGhpcy5zaG91bGRBbGxvd01vdXNlRW50ZXIoaSkpe2lmKHRoaXMuc2hvdWxkQWxsb3dSZXBpY2soKSYmKHRoaXMudHJpZ2dlckVsZW1lbnQ9PT10aGlzLm9wdGlvbnMuZWxlbWVudD90aGlzLmRhdGVQaWNrZWRbMF09dGhpcy5vcHRpb25zLmVuZERhdGUuY2xvbmUoKTp0aGlzLnRyaWdnZXJFbGVtZW50PT09dGhpcy5vcHRpb25zLmVsZW1lbnRFbmQmJih0aGlzLmRhdGVQaWNrZWRbMF09dGhpcy5vcHRpb25zLnN0YXJ0RGF0ZS5jbG9uZSgpKSksMSE9PXRoaXMuZGF0ZVBpY2tlZC5sZW5ndGgpcmV0dXJuO3ZhciBuPXRoaXMudWkucXVlcnlTZWxlY3RvcihcIi5cIitsLmRheUl0ZW0rJ1tkYXRhLXRpbWU9XCInK3RoaXMuZGF0ZVBpY2tlZFswXS5nZXRUaW1lKCkrJ1wiXScpLG89dGhpcy5kYXRlUGlja2VkWzBdLmNsb25lKCkscz1uZXcgYS5EYXRlVGltZShpLmRhdGFzZXQudGltZSkscj0hMTtpZihvLmdldFRpbWUoKT5zLmdldFRpbWUoKSl7dmFyIGM9by5jbG9uZSgpO289cy5jbG9uZSgpLHM9Yy5jbG9uZSgpLHI9ITB9aWYoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy51aS5xdWVyeVNlbGVjdG9yQWxsKFwiLlwiK2wuZGF5SXRlbSkpLmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciBpPW5ldyBhLkRhdGVUaW1lKHQuZGF0YXNldC50aW1lKSxuPWUucmVuZGVyRGF5KGkpO2kuaXNCZXR3ZWVuKG8scykmJm4uY2xhc3NMaXN0LmFkZChsLmlzSW5SYW5nZSksdC5jbGFzc05hbWU9bi5jbGFzc05hbWV9KSksaS5jbGFzc0xpc3QuYWRkKGwuaXNFbmREYXRlKSxyPyhuJiZuLmNsYXNzTGlzdC5hZGQobC5pc0ZsaXBwZWQpLGkuY2xhc3NMaXN0LmFkZChsLmlzRmxpcHBlZCkpOihuJiZuLmNsYXNzTGlzdC5yZW1vdmUobC5pc0ZsaXBwZWQpLGkuY2xhc3NMaXN0LnJlbW92ZShsLmlzRmxpcHBlZCkpLHRoaXMub3B0aW9ucy5zaG93VG9vbHRpcCl7dmFyIGg9cy5kaWZmKG8sXCJkYXlcIikrMTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiB0aGlzLm9wdGlvbnMudG9vbHRpcE51bWJlciYmKGg9dGhpcy5vcHRpb25zLnRvb2x0aXBOdW1iZXIuY2FsbCh0aGlzLGgpKSxoPjApe3ZhciBwPXRoaXMucGx1cmFsU2VsZWN0b3IoaCksZD1oK1wiIFwiKyh0aGlzLm9wdGlvbnMudG9vbHRpcFRleHRbcF0/dGhpcy5vcHRpb25zLnRvb2x0aXBUZXh0W3BdOlwiW1wiK3ArXCJdXCIpO3RoaXMuc2hvd1Rvb2x0aXAoaSxkKTt2YXIgdT13aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCxtPS8oaXBob25lfGlwYWQpL2kudGVzdCh1KSxmPS9PUyAxKFswLTJdKS9pLnRlc3QodSk7bSYmZiYmaS5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcImNsaWNrXCIpKX1lbHNlIHRoaXMuaGlkZVRvb2x0aXAoKX19fSxlLnByb3RvdHlwZS5vbk1vdXNlTGVhdmU9ZnVuY3Rpb24odCl7dC50YXJnZXQ7dGhpcy5vcHRpb25zLmFsbG93UmVwaWNrJiYoIXRoaXMub3B0aW9ucy5hbGxvd1JlcGlja3x8dGhpcy5vcHRpb25zLnN0YXJ0RGF0ZXx8dGhpcy5vcHRpb25zLmVuZERhdGUpJiYodGhpcy5kYXRlUGlja2VkLmxlbmd0aD0wLHRoaXMucmVuZGVyKCkpfSxlLnByb3RvdHlwZS5vbklucHV0PWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMucGFyc2VJbnB1dCgpLGk9ZVswXSxuPWVbMV0sbz10aGlzLm9wdGlvbnMuZm9ybWF0O2lmKHRoaXMub3B0aW9ucy5lbGVtZW50RW5kP2kgaW5zdGFuY2VvZiBhLkRhdGVUaW1lJiZuIGluc3RhbmNlb2YgYS5EYXRlVGltZSYmaS5mb3JtYXQobyk9PT10aGlzLm9wdGlvbnMuZWxlbWVudC52YWx1ZSYmbi5mb3JtYXQobyk9PT10aGlzLm9wdGlvbnMuZWxlbWVudEVuZC52YWx1ZTp0aGlzLm9wdGlvbnMuc2luZ2xlTW9kZT9pIGluc3RhbmNlb2YgYS5EYXRlVGltZSYmaS5mb3JtYXQobyk9PT10aGlzLm9wdGlvbnMuZWxlbWVudC52YWx1ZTppIGluc3RhbmNlb2YgYS5EYXRlVGltZSYmbiBpbnN0YW5jZW9mIGEuRGF0ZVRpbWUmJlwiXCIraS5mb3JtYXQobykrdGhpcy5vcHRpb25zLmRlbGltaXRlcituLmZvcm1hdChvKT09PXRoaXMub3B0aW9ucy5lbGVtZW50LnZhbHVlKXtpZihuJiZpLmdldFRpbWUoKT5uLmdldFRpbWUoKSl7dmFyIHM9aS5jbG9uZSgpO2k9bi5jbG9uZSgpLG49cy5jbG9uZSgpfXRoaXMub3B0aW9ucy5zdGFydERhdGU9bmV3IGEuRGF0ZVRpbWUoaSx0aGlzLm9wdGlvbnMuZm9ybWF0LHRoaXMub3B0aW9ucy5sYW5nKSxuJiYodGhpcy5vcHRpb25zLmVuZERhdGU9bmV3IGEuRGF0ZVRpbWUobix0aGlzLm9wdGlvbnMuZm9ybWF0LHRoaXMub3B0aW9ucy5sYW5nKSksdGhpcy51cGRhdGVJbnB1dCgpLHRoaXMucmVuZGVyKCk7dmFyIHI9aS5jbG9uZSgpLGw9MDsodGhpcy5vcHRpb25zLmVsZW1lbnRFbmQ/aS5mb3JtYXQobyk9PT10LnRhcmdldC52YWx1ZTp0LnRhcmdldC52YWx1ZS5zdGFydHNXaXRoKGkuZm9ybWF0KG8pKSl8fChyPW4uY2xvbmUoKSxsPXRoaXMub3B0aW9ucy5udW1iZXJPZk1vbnRocy0xKSx0aGlzLmVtaXQoXCJzZWxlY3RlZFwiLHRoaXMuZ2V0U3RhcnREYXRlKCksdGhpcy5nZXRFbmREYXRlKCkpLHRoaXMuZ290b0RhdGUocixsKX19LGV9KHIuQ2FsZW5kYXIpO2UuTGl0ZXBpY2tlcj1ofSxmdW5jdGlvbih0LGUsaSl7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5maW5kTmVzdGVkTW9udGhJdGVtPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10LnBhcmVudE5vZGUuY2hpbGROb2RlcyxpPTA7aTxlLmxlbmd0aDtpKz0xKXtpZihlLml0ZW0oaSk9PT10KXJldHVybiBpfXJldHVybiAwfSxlLmRhdGVJc0xvY2tlZD1mdW5jdGlvbih0LGUsaSl7dmFyIG49ITE7cmV0dXJuIGUubG9ja0RheXMubGVuZ3RoJiYobj1lLmxvY2tEYXlzLmZpbHRlcigoZnVuY3Rpb24oaSl7cmV0dXJuIGkgaW5zdGFuY2VvZiBBcnJheT90LmlzQmV0d2VlbihpWzBdLGlbMV0sZS5sb2NrRGF5c0luY2x1c2l2aXR5KTppLmlzU2FtZSh0LFwiZGF5XCIpfSkpLmxlbmd0aCksbnx8XCJmdW5jdGlvblwiIT10eXBlb2YgZS5sb2NrRGF5c0ZpbHRlcnx8KG49ZS5sb2NrRGF5c0ZpbHRlci5jYWxsKHRoaXMsdC5jbG9uZSgpLG51bGwsaSkpLG59LGUucmFuZ2VJc0xvY2tlZD1mdW5jdGlvbih0LGUpe3ZhciBpPSExO3JldHVybiBlLmxvY2tEYXlzLmxlbmd0aCYmKGk9ZS5sb2NrRGF5cy5maWx0ZXIoKGZ1bmN0aW9uKGkpe2lmKGkgaW5zdGFuY2VvZiBBcnJheSl7dmFyIG49dFswXS50b0RhdGVTdHJpbmcoKT09PWlbMF0udG9EYXRlU3RyaW5nKCkmJnRbMV0udG9EYXRlU3RyaW5nKCk9PT1pWzFdLnRvRGF0ZVN0cmluZygpO3JldHVybiBpWzBdLmlzQmV0d2Vlbih0WzBdLHRbMV0sZS5sb2NrRGF5c0luY2x1c2l2aXR5KXx8aVsxXS5pc0JldHdlZW4odFswXSx0WzFdLGUubG9ja0RheXNJbmNsdXNpdml0eSl8fG59cmV0dXJuIGkuaXNCZXR3ZWVuKHRbMF0sdFsxXSxlLmxvY2tEYXlzSW5jbHVzaXZpdHkpfSkpLmxlbmd0aCksaXx8XCJmdW5jdGlvblwiIT10eXBlb2YgZS5sb2NrRGF5c0ZpbHRlcnx8KGk9ZS5sb2NrRGF5c0ZpbHRlci5jYWxsKHRoaXMsdFswXS5jbG9uZSgpLHRbMV0uY2xvbmUoKSx0KSksaX19LGZ1bmN0aW9uKHQsZSxpKXt2YXIgbj1pKDgpO1wic3RyaW5nXCI9PXR5cGVvZiBuJiYobj1bW3QuaSxuLFwiXCJdXSk7dmFyIG89e2luc2VydDpmdW5jdGlvbih0KXt2YXIgZT1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiaGVhZFwiKSxpPXdpbmRvdy5fbGFzdEVsZW1lbnRJbnNlcnRlZEJ5U3R5bGVMb2FkZXI7d2luZG93LmRpc2FibGVMaXRlcGlja2VyU3R5bGVzfHwoaT9pLm5leHRTaWJsaW5nP2UuaW5zZXJ0QmVmb3JlKHQsaS5uZXh0U2libGluZyk6ZS5hcHBlbmRDaGlsZCh0KTplLmluc2VydEJlZm9yZSh0LGUuZmlyc3RDaGlsZCksd2luZG93Ll9sYXN0RWxlbWVudEluc2VydGVkQnlTdHlsZUxvYWRlcj10KX0sc2luZ2xldG9uOiExfTtpKDEwKShuLG8pO24ubG9jYWxzJiYodC5leHBvcnRzPW4ubG9jYWxzKX0sZnVuY3Rpb24odCxlLGkpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBuPWkoMSk7ZS5MaXRlcGlja2VyPW4uTGl0ZXBpY2tlcixpKDExKSx3aW5kb3cuTGl0ZXBpY2tlcj1uLkxpdGVwaWNrZXIsZS5kZWZhdWx0PW4uTGl0ZXBpY2tlcn0sZnVuY3Rpb24odCxlLGkpe1widXNlIHN0cmljdFwiO3ZhciBuLG89dGhpcyYmdGhpcy5fX2V4dGVuZHN8fChuPWZ1bmN0aW9uKHQsZSl7cmV0dXJuKG49T2JqZWN0LnNldFByb3RvdHlwZU9mfHx7X19wcm90b19fOltdfWluc3RhbmNlb2YgQXJyYXkmJmZ1bmN0aW9uKHQsZSl7dC5fX3Byb3RvX189ZX18fGZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBpIGluIGUpZS5oYXNPd25Qcm9wZXJ0eShpKSYmKHRbaV09ZVtpXSl9KSh0LGUpfSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIGkoKXt0aGlzLmNvbnN0cnVjdG9yPXR9bih0LGUpLHQucHJvdG90eXBlPW51bGw9PT1lP09iamVjdC5jcmVhdGUoZSk6KGkucHJvdG90eXBlPWUucHJvdG90eXBlLG5ldyBpKX0pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBzPWkoNikscj1pKDApLGE9aSgzKSxsPWkoMiksYz1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUpe3JldHVybiB0LmNhbGwodGhpcyxlKXx8dGhpc31yZXR1cm4gbyhlLHQpLGUucHJvdG90eXBlLnJlbmRlcj1mdW5jdGlvbigpe3ZhciB0PXRoaXM7dGhpcy5lbWl0KFwiYmVmb3JlOnJlbmRlclwiLHRoaXMudWkpO3ZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7ZS5jbGFzc05hbWU9YS5jb250YWluZXJNYWluO3ZhciBpPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7aS5jbGFzc05hbWU9YS5jb250YWluZXJNb250aHMsYVtcImNvbHVtbnNcIit0aGlzLm9wdGlvbnMubnVtYmVyT2ZDb2x1bW5zXSYmKGkuY2xhc3NMaXN0LnJlbW92ZShhLmNvbHVtbnMyLGEuY29sdW1uczMsYS5jb2x1bW5zNCksaS5jbGFzc0xpc3QuYWRkKGFbXCJjb2x1bW5zXCIrdGhpcy5vcHRpb25zLm51bWJlck9mQ29sdW1uc10pKSx0aGlzLm9wdGlvbnMuc3BsaXRWaWV3JiZpLmNsYXNzTGlzdC5hZGQoYS5zcGxpdFZpZXcpLHRoaXMub3B0aW9ucy5zaG93V2Vla051bWJlcnMmJmkuY2xhc3NMaXN0LmFkZChhLnNob3dXZWVrTnVtYmVycyk7Zm9yKHZhciBuPXRoaXMuY2FsZW5kYXJzWzBdLmNsb25lKCksbz1uLmdldE1vbnRoKCkscz1uLmdldE1vbnRoKCkrdGhpcy5vcHRpb25zLm51bWJlck9mTW9udGhzLHI9MCxsPW87bDxzO2wrPTEpe3ZhciBjPW4uY2xvbmUoKTtjLnNldERhdGUoMSksYy5zZXRIb3VycygwLDAsMCwwKSx0aGlzLm9wdGlvbnMuc3BsaXRWaWV3P2M9dGhpcy5jYWxlbmRhcnNbcl0uY2xvbmUoKTpjLnNldE1vbnRoKGwpLGkuYXBwZW5kQ2hpbGQodGhpcy5yZW5kZXJNb250aChjLHIpKSxyKz0xfWlmKHRoaXMudWkuaW5uZXJIVE1MPVwiXCIsZS5hcHBlbmRDaGlsZChpKSx0aGlzLm9wdGlvbnMucmVzZXRCdXR0b24pe3ZhciBoPXZvaWQgMDtcImZ1bmN0aW9uXCI9PXR5cGVvZiB0aGlzLm9wdGlvbnMucmVzZXRCdXR0b24/aD10aGlzLm9wdGlvbnMucmVzZXRCdXR0b24uY2FsbCh0aGlzKTooKGg9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKSkudHlwZT1cImJ1dHRvblwiLGguY2xhc3NOYW1lPWEucmVzZXRCdXR0b24saC5pbm5lckhUTUw9dGhpcy5vcHRpb25zLmJ1dHRvblRleHQucmVzZXQpLGguYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsKGZ1bmN0aW9uKGUpe2UucHJldmVudERlZmF1bHQoKSx0LmNsZWFyU2VsZWN0aW9uKCl9KSksZS5xdWVyeVNlbGVjdG9yKFwiLlwiK2EubW9udGhJdGVtK1wiOmxhc3QtY2hpbGRcIikucXVlcnlTZWxlY3RvcihcIi5cIithLm1vbnRoSXRlbUhlYWRlcikuYXBwZW5kQ2hpbGQoaCl9dGhpcy51aS5hcHBlbmRDaGlsZChlKSx0aGlzLm9wdGlvbnMuYXV0b0FwcGx5JiYhdGhpcy5vcHRpb25zLmZvb3RlckhUTUx8fHRoaXMudWkuYXBwZW5kQ2hpbGQodGhpcy5yZW5kZXJGb290ZXIoKSksdGhpcy5vcHRpb25zLnNob3dUb29sdGlwJiZ0aGlzLnVpLmFwcGVuZENoaWxkKHRoaXMucmVuZGVyVG9vbHRpcCgpKSx0aGlzLnVpLmRhdGFzZXQucGx1Z2lucz0odGhpcy5vcHRpb25zLnBsdWdpbnN8fFtdKS5qb2luKFwifFwiKSx0aGlzLmVtaXQoXCJyZW5kZXJcIix0aGlzLnVpKX0sZS5wcm90b3R5cGUucmVuZGVyTW9udGg9ZnVuY3Rpb24odCxlKXt2YXIgaT10aGlzLG49dC5jbG9uZSgpLG89MzItbmV3IERhdGUobi5nZXRGdWxsWWVhcigpLG4uZ2V0TW9udGgoKSwzMikuZ2V0RGF0ZSgpLHM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtzLmNsYXNzTmFtZT1hLm1vbnRoSXRlbTt2YXIgYz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO2MuY2xhc3NOYW1lPWEubW9udGhJdGVtSGVhZGVyO3ZhciBoPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7aWYodGhpcy5vcHRpb25zLmRyb3Bkb3ducy5tb250aHMpe3ZhciBwPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzZWxlY3RcIik7cC5jbGFzc05hbWU9YS5tb250aEl0ZW1OYW1lO2Zvcih2YXIgZD0wO2Q8MTI7ZCs9MSl7dmFyIHU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKSxtPW5ldyByLkRhdGVUaW1lKG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSxkLDIsMCwwLDApKSxmPW5ldyByLkRhdGVUaW1lKG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSxkLDEsMCwwLDApKTt1LnZhbHVlPVN0cmluZyhkKSx1LnRleHQ9bS50b0xvY2FsZVN0cmluZyh0aGlzLm9wdGlvbnMubGFuZyx7bW9udGg6XCJsb25nXCJ9KSx1LmRpc2FibGVkPXRoaXMub3B0aW9ucy5taW5EYXRlJiZmLmlzQmVmb3JlKG5ldyByLkRhdGVUaW1lKHRoaXMub3B0aW9ucy5taW5EYXRlKSxcIm1vbnRoXCIpfHx0aGlzLm9wdGlvbnMubWF4RGF0ZSYmZi5pc0FmdGVyKG5ldyByLkRhdGVUaW1lKHRoaXMub3B0aW9ucy5tYXhEYXRlKSxcIm1vbnRoXCIpLHUuc2VsZWN0ZWQ9Zi5nZXRNb250aCgpPT09dC5nZXRNb250aCgpLHAuYXBwZW5kQ2hpbGQodSl9cC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsKGZ1bmN0aW9uKHQpe3ZhciBlPXQudGFyZ2V0LG49MDtpZihpLm9wdGlvbnMuc3BsaXRWaWV3KXt2YXIgbz1lLmNsb3Nlc3QoXCIuXCIrYS5tb250aEl0ZW0pO249bC5maW5kTmVzdGVkTW9udGhJdGVtKG8pfWkuY2FsZW5kYXJzW25dLnNldE1vbnRoKE51bWJlcihlLnZhbHVlKSksaS5yZW5kZXIoKSxpLmVtaXQoXCJjaGFuZ2U6bW9udGhcIixpLmNhbGVuZGFyc1tuXSxuLHQpfSkpLGguYXBwZW5kQ2hpbGQocCl9ZWxzZXsobT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3Ryb25nXCIpKS5jbGFzc05hbWU9YS5tb250aEl0ZW1OYW1lLG0uaW5uZXJIVE1MPXQudG9Mb2NhbGVTdHJpbmcodGhpcy5vcHRpb25zLmxhbmcse21vbnRoOlwibG9uZ1wifSksaC5hcHBlbmRDaGlsZChtKX1pZih0aGlzLm9wdGlvbnMuZHJvcGRvd25zLnllYXJzKXt2YXIgZz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIpO2cuY2xhc3NOYW1lPWEubW9udGhJdGVtWWVhcjt2YXIgdj10aGlzLm9wdGlvbnMuZHJvcGRvd25zLm1pblllYXIseT10aGlzLm9wdGlvbnMuZHJvcGRvd25zLm1heFllYXI/dGhpcy5vcHRpb25zLmRyb3Bkb3ducy5tYXhZZWFyOihuZXcgRGF0ZSkuZ2V0RnVsbFllYXIoKTtpZih0LmdldEZ1bGxZZWFyKCk+eSkodT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpKS52YWx1ZT1TdHJpbmcodC5nZXRGdWxsWWVhcigpKSx1LnRleHQ9U3RyaW5nKHQuZ2V0RnVsbFllYXIoKSksdS5zZWxlY3RlZD0hMCx1LmRpc2FibGVkPSEwLGcuYXBwZW5kQ2hpbGQodSk7Zm9yKGQ9eTtkPj12O2QtPTEpe3ZhciB1PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIiksYj1uZXcgci5EYXRlVGltZShuZXcgRGF0ZShkLDAsMSwwLDAsMCkpO3UudmFsdWU9U3RyaW5nKGQpLHUudGV4dD1TdHJpbmcoZCksdS5kaXNhYmxlZD10aGlzLm9wdGlvbnMubWluRGF0ZSYmYi5pc0JlZm9yZShuZXcgci5EYXRlVGltZSh0aGlzLm9wdGlvbnMubWluRGF0ZSksXCJ5ZWFyXCIpfHx0aGlzLm9wdGlvbnMubWF4RGF0ZSYmYi5pc0FmdGVyKG5ldyByLkRhdGVUaW1lKHRoaXMub3B0aW9ucy5tYXhEYXRlKSxcInllYXJcIiksdS5zZWxlY3RlZD10LmdldEZ1bGxZZWFyKCk9PT1kLGcuYXBwZW5kQ2hpbGQodSl9aWYodC5nZXRGdWxsWWVhcigpPHYpKHU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKSkudmFsdWU9U3RyaW5nKHQuZ2V0RnVsbFllYXIoKSksdS50ZXh0PVN0cmluZyh0LmdldEZ1bGxZZWFyKCkpLHUuc2VsZWN0ZWQ9ITAsdS5kaXNhYmxlZD0hMCxnLmFwcGVuZENoaWxkKHUpO2lmKFwiYXNjXCI9PT10aGlzLm9wdGlvbnMuZHJvcGRvd25zLnllYXJzKXt2YXIgaz1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChnLmNoaWxkTm9kZXMpLnJldmVyc2UoKTtnLmlubmVySFRNTD1cIlwiLGsuZm9yRWFjaCgoZnVuY3Rpb24odCl7dC5pbm5lckhUTUw9dC52YWx1ZSxnLmFwcGVuZENoaWxkKHQpfSkpfWcuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLChmdW5jdGlvbih0KXt2YXIgZT10LnRhcmdldCxuPTA7aWYoaS5vcHRpb25zLnNwbGl0Vmlldyl7dmFyIG89ZS5jbG9zZXN0KFwiLlwiK2EubW9udGhJdGVtKTtuPWwuZmluZE5lc3RlZE1vbnRoSXRlbShvKX1pLmNhbGVuZGFyc1tuXS5zZXRGdWxsWWVhcihOdW1iZXIoZS52YWx1ZSkpLGkucmVuZGVyKCksaS5lbWl0KFwiY2hhbmdlOnllYXJcIixpLmNhbGVuZGFyc1tuXSxuLHQpfSkpLGguYXBwZW5kQ2hpbGQoZyl9ZWxzZXt2YXIgdz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTt3LmNsYXNzTmFtZT1hLm1vbnRoSXRlbVllYXIsdy5pbm5lckhUTUw9U3RyaW5nKHQuZ2V0RnVsbFllYXIoKSksaC5hcHBlbmRDaGlsZCh3KX12YXIgRD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO0QudHlwZT1cImJ1dHRvblwiLEQuY2xhc3NOYW1lPWEuYnV0dG9uUHJldmlvdXNNb250aCxELmlubmVySFRNTD10aGlzLm9wdGlvbnMuYnV0dG9uVGV4dC5wcmV2aW91c01vbnRoO3ZhciB4PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7eC50eXBlPVwiYnV0dG9uXCIseC5jbGFzc05hbWU9YS5idXR0b25OZXh0TW9udGgseC5pbm5lckhUTUw9dGhpcy5vcHRpb25zLmJ1dHRvblRleHQubmV4dE1vbnRoLGMuYXBwZW5kQ2hpbGQoRCksYy5hcHBlbmRDaGlsZChoKSxjLmFwcGVuZENoaWxkKHgpLHRoaXMub3B0aW9ucy5taW5EYXRlJiZuLmlzU2FtZU9yQmVmb3JlKG5ldyByLkRhdGVUaW1lKHRoaXMub3B0aW9ucy5taW5EYXRlKSxcIm1vbnRoXCIpJiZzLmNsYXNzTGlzdC5hZGQoYS5ub1ByZXZpb3VzTW9udGgpLHRoaXMub3B0aW9ucy5tYXhEYXRlJiZuLmlzU2FtZU9yQWZ0ZXIobmV3IHIuRGF0ZVRpbWUodGhpcy5vcHRpb25zLm1heERhdGUpLFwibW9udGhcIikmJnMuY2xhc3NMaXN0LmFkZChhLm5vTmV4dE1vbnRoKTt2YXIgTT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO00uY2xhc3NOYW1lPWEubW9udGhJdGVtV2Vla2RheXNSb3csdGhpcy5vcHRpb25zLnNob3dXZWVrTnVtYmVycyYmKE0uaW5uZXJIVE1MPVwiPGRpdj5XPC9kaXY+XCIpO2Zvcih2YXIgXz0xO188PTc7Xys9MSl7dmFyIFQ9Myt0aGlzLm9wdGlvbnMuZmlyc3REYXkrXyxMPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7TC5pbm5lckhUTUw9dGhpcy53ZWVrZGF5TmFtZShUKSxMLnRpdGxlPXRoaXMud2Vla2RheU5hbWUoVCxcImxvbmdcIiksTS5hcHBlbmRDaGlsZChMKX12YXIgRT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO0UuY2xhc3NOYW1lPWEuY29udGFpbmVyRGF5czt2YXIgUz10aGlzLmNhbGNTa2lwRGF5cyhuKTt0aGlzLm9wdGlvbnMuc2hvd1dlZWtOdW1iZXJzJiZTJiZFLmFwcGVuZENoaWxkKHRoaXMucmVuZGVyV2Vla051bWJlcihuKSk7Zm9yKHZhciBJPTA7STxTO0krPTEpe3ZhciBQPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7RS5hcHBlbmRDaGlsZChQKX1mb3IoST0xO0k8PW87SSs9MSluLnNldERhdGUoSSksdGhpcy5vcHRpb25zLnNob3dXZWVrTnVtYmVycyYmbi5nZXREYXkoKT09PXRoaXMub3B0aW9ucy5maXJzdERheSYmRS5hcHBlbmRDaGlsZCh0aGlzLnJlbmRlcldlZWtOdW1iZXIobikpLEUuYXBwZW5kQ2hpbGQodGhpcy5yZW5kZXJEYXkobikpO3JldHVybiBzLmFwcGVuZENoaWxkKGMpLHMuYXBwZW5kQ2hpbGQoTSkscy5hcHBlbmRDaGlsZChFKSx0aGlzLmVtaXQoXCJyZW5kZXI6bW9udGhcIixzLHQpLHN9LGUucHJvdG90eXBlLnJlbmRlckRheT1mdW5jdGlvbih0KXt0LnNldEhvdXJzKCk7dmFyIGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtpZihlLmNsYXNzTmFtZT1hLmRheUl0ZW0sZS5pbm5lckhUTUw9U3RyaW5nKHQuZ2V0RGF0ZSgpKSxlLmRhdGFzZXQudGltZT1TdHJpbmcodC5nZXRUaW1lKCkpLHQudG9EYXRlU3RyaW5nKCk9PT0obmV3IERhdGUpLnRvRGF0ZVN0cmluZygpJiZlLmNsYXNzTGlzdC5hZGQoYS5pc1RvZGF5KSx0aGlzLmRhdGVQaWNrZWQubGVuZ3RoKXRoaXMuZGF0ZVBpY2tlZFswXS50b0RhdGVTdHJpbmcoKT09PXQudG9EYXRlU3RyaW5nKCkmJihlLmNsYXNzTGlzdC5hZGQoYS5pc1N0YXJ0RGF0ZSksdGhpcy5vcHRpb25zLnNpbmdsZU1vZGUmJmUuY2xhc3NMaXN0LmFkZChhLmlzRW5kRGF0ZSkpLDI9PT10aGlzLmRhdGVQaWNrZWQubGVuZ3RoJiZ0aGlzLmRhdGVQaWNrZWRbMV0udG9EYXRlU3RyaW5nKCk9PT10LnRvRGF0ZVN0cmluZygpJiZlLmNsYXNzTGlzdC5hZGQoYS5pc0VuZERhdGUpLDI9PT10aGlzLmRhdGVQaWNrZWQubGVuZ3RoJiZ0LmlzQmV0d2Vlbih0aGlzLmRhdGVQaWNrZWRbMF0sdGhpcy5kYXRlUGlja2VkWzFdKSYmZS5jbGFzc0xpc3QuYWRkKGEuaXNJblJhbmdlKTtlbHNlIGlmKHRoaXMub3B0aW9ucy5zdGFydERhdGUpe3ZhciBpPXRoaXMub3B0aW9ucy5zdGFydERhdGUsbj10aGlzLm9wdGlvbnMuZW5kRGF0ZTtpLnRvRGF0ZVN0cmluZygpPT09dC50b0RhdGVTdHJpbmcoKSYmKGUuY2xhc3NMaXN0LmFkZChhLmlzU3RhcnREYXRlKSx0aGlzLm9wdGlvbnMuc2luZ2xlTW9kZSYmZS5jbGFzc0xpc3QuYWRkKGEuaXNFbmREYXRlKSksbiYmbi50b0RhdGVTdHJpbmcoKT09PXQudG9EYXRlU3RyaW5nKCkmJmUuY2xhc3NMaXN0LmFkZChhLmlzRW5kRGF0ZSksaSYmbiYmdC5pc0JldHdlZW4oaSxuKSYmZS5jbGFzc0xpc3QuYWRkKGEuaXNJblJhbmdlKX1pZih0aGlzLm9wdGlvbnMubWluRGF0ZSYmdC5pc0JlZm9yZShuZXcgci5EYXRlVGltZSh0aGlzLm9wdGlvbnMubWluRGF0ZSkpJiZlLmNsYXNzTGlzdC5hZGQoYS5pc0xvY2tlZCksdGhpcy5vcHRpb25zLm1heERhdGUmJnQuaXNBZnRlcihuZXcgci5EYXRlVGltZSh0aGlzLm9wdGlvbnMubWF4RGF0ZSkpJiZlLmNsYXNzTGlzdC5hZGQoYS5pc0xvY2tlZCksdGhpcy5vcHRpb25zLm1pbkRheXM+MSYmMT09PXRoaXMuZGF0ZVBpY2tlZC5sZW5ndGgpe3ZhciBvPXRoaXMub3B0aW9ucy5taW5EYXlzLTEscz10aGlzLmRhdGVQaWNrZWRbMF0uY2xvbmUoKS5zdWJ0cmFjdChvLFwiZGF5XCIpLGM9dGhpcy5kYXRlUGlja2VkWzBdLmNsb25lKCkuYWRkKG8sXCJkYXlcIik7dC5pc0JldHdlZW4ocyx0aGlzLmRhdGVQaWNrZWRbMF0sXCIoXVwiKSYmZS5jbGFzc0xpc3QuYWRkKGEuaXNMb2NrZWQpLHQuaXNCZXR3ZWVuKHRoaXMuZGF0ZVBpY2tlZFswXSxjLFwiWylcIikmJmUuY2xhc3NMaXN0LmFkZChhLmlzTG9ja2VkKX1pZih0aGlzLm9wdGlvbnMubWF4RGF5cyYmMT09PXRoaXMuZGF0ZVBpY2tlZC5sZW5ndGgpe3ZhciBoPXRoaXMub3B0aW9ucy5tYXhEYXlzO3M9dGhpcy5kYXRlUGlja2VkWzBdLmNsb25lKCkuc3VidHJhY3QoaCxcImRheVwiKSxjPXRoaXMuZGF0ZVBpY2tlZFswXS5jbG9uZSgpLmFkZChoLFwiZGF5XCIpO3QuaXNTYW1lT3JCZWZvcmUocykmJmUuY2xhc3NMaXN0LmFkZChhLmlzTG9ja2VkKSx0LmlzU2FtZU9yQWZ0ZXIoYykmJmUuY2xhc3NMaXN0LmFkZChhLmlzTG9ja2VkKX0odGhpcy5vcHRpb25zLnNlbGVjdEZvcndhcmQmJjE9PT10aGlzLmRhdGVQaWNrZWQubGVuZ3RoJiZ0LmlzQmVmb3JlKHRoaXMuZGF0ZVBpY2tlZFswXSkmJmUuY2xhc3NMaXN0LmFkZChhLmlzTG9ja2VkKSx0aGlzLm9wdGlvbnMuc2VsZWN0QmFja3dhcmQmJjE9PT10aGlzLmRhdGVQaWNrZWQubGVuZ3RoJiZ0LmlzQWZ0ZXIodGhpcy5kYXRlUGlja2VkWzBdKSYmZS5jbGFzc0xpc3QuYWRkKGEuaXNMb2NrZWQpLGwuZGF0ZUlzTG9ja2VkKHQsdGhpcy5vcHRpb25zLHRoaXMuZGF0ZVBpY2tlZCkmJmUuY2xhc3NMaXN0LmFkZChhLmlzTG9ja2VkKSx0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0ZWREYXlzLmxlbmd0aCkmJih0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0ZWREYXlzLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBBcnJheT90LmlzQmV0d2VlbihlWzBdLGVbMV0sXCJbXVwiKTplLmlzU2FtZSh0LFwiZGF5XCIpfSkpLmxlbmd0aCYmZS5jbGFzc0xpc3QuYWRkKGEuaXNIaWdobGlnaHRlZCkpO3JldHVybiBlLnRhYkluZGV4PWUuY2xhc3NMaXN0LmNvbnRhaW5zKFwiaXMtbG9ja2VkXCIpPy0xOjAsdGhpcy5lbWl0KFwicmVuZGVyOmRheVwiLGUsdCksZX0sZS5wcm90b3R5cGUucmVuZGVyRm9vdGVyPWZ1bmN0aW9uKCl7dmFyIHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtpZih0LmNsYXNzTmFtZT1hLmNvbnRhaW5lckZvb3Rlcix0aGlzLm9wdGlvbnMuZm9vdGVySFRNTD90LmlubmVySFRNTD10aGlzLm9wdGlvbnMuZm9vdGVySFRNTDp0LmlubmVySFRNTD0nXFxuICAgICAgPHNwYW4gY2xhc3M9XCInK2EucHJldmlld0RhdGVSYW5nZSsnXCI+PC9zcGFuPlxcbiAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiJythLmJ1dHRvbkNhbmNlbCsnXCI+Jyt0aGlzLm9wdGlvbnMuYnV0dG9uVGV4dC5jYW5jZWwrJzwvYnV0dG9uPlxcbiAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiJythLmJ1dHRvbkFwcGx5KydcIj4nK3RoaXMub3B0aW9ucy5idXR0b25UZXh0LmFwcGx5K1wiPC9idXR0b24+XFxuICAgICAgXCIsdGhpcy5vcHRpb25zLnNpbmdsZU1vZGUpe2lmKDE9PT10aGlzLmRhdGVQaWNrZWQubGVuZ3RoKXt2YXIgZT10aGlzLmRhdGVQaWNrZWRbMF0uZm9ybWF0KHRoaXMub3B0aW9ucy5mb3JtYXQsdGhpcy5vcHRpb25zLmxhbmcpO3QucXVlcnlTZWxlY3RvcihcIi5cIithLnByZXZpZXdEYXRlUmFuZ2UpLmlubmVySFRNTD1lfX1lbHNlIGlmKDE9PT10aGlzLmRhdGVQaWNrZWQubGVuZ3RoJiZ0LnF1ZXJ5U2VsZWN0b3IoXCIuXCIrYS5idXR0b25BcHBseSkuc2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIixcIlwiKSwyPT09dGhpcy5kYXRlUGlja2VkLmxlbmd0aCl7ZT10aGlzLmRhdGVQaWNrZWRbMF0uZm9ybWF0KHRoaXMub3B0aW9ucy5mb3JtYXQsdGhpcy5vcHRpb25zLmxhbmcpO3ZhciBpPXRoaXMuZGF0ZVBpY2tlZFsxXS5mb3JtYXQodGhpcy5vcHRpb25zLmZvcm1hdCx0aGlzLm9wdGlvbnMubGFuZyk7dC5xdWVyeVNlbGVjdG9yKFwiLlwiK2EucHJldmlld0RhdGVSYW5nZSkuaW5uZXJIVE1MPVwiXCIrZSt0aGlzLm9wdGlvbnMuZGVsaW1pdGVyK2l9cmV0dXJuIHRoaXMuZW1pdChcInJlbmRlcjpmb290ZXJcIix0KSx0fSxlLnByb3RvdHlwZS5yZW5kZXJXZWVrTnVtYmVyPWZ1bmN0aW9uKHQpe3ZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksaT10LmdldFdlZWsodGhpcy5vcHRpb25zLmZpcnN0RGF5KTtyZXR1cm4gZS5jbGFzc05hbWU9YS53ZWVrTnVtYmVyLGUuaW5uZXJIVE1MPTUzPT09aSYmMD09PXQuZ2V0TW9udGgoKT9cIjUzIC8gMVwiOmksZX0sZS5wcm90b3R5cGUucmVuZGVyVG9vbHRpcD1mdW5jdGlvbigpe3ZhciB0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7cmV0dXJuIHQuY2xhc3NOYW1lPWEuY29udGFpbmVyVG9vbHRpcCx0fSxlLnByb3RvdHlwZS53ZWVrZGF5TmFtZT1mdW5jdGlvbih0LGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT1cInNob3J0XCIpLG5ldyBEYXRlKDE5NzAsMCx0LDEyLDAsMCwwKS50b0xvY2FsZVN0cmluZyh0aGlzLm9wdGlvbnMubGFuZyx7d2Vla2RheTplfSl9LGUucHJvdG90eXBlLmNhbGNTa2lwRGF5cz1mdW5jdGlvbih0KXt2YXIgZT10LmdldERheSgpLXRoaXMub3B0aW9ucy5maXJzdERheTtyZXR1cm4gZTwwJiYoZSs9NyksZX0sZX0ocy5MUENvcmUpO2UuQ2FsZW5kYXI9Y30sZnVuY3Rpb24odCxlLGkpe1widXNlIHN0cmljdFwiO3ZhciBuLG89dGhpcyYmdGhpcy5fX2V4dGVuZHN8fChuPWZ1bmN0aW9uKHQsZSl7cmV0dXJuKG49T2JqZWN0LnNldFByb3RvdHlwZU9mfHx7X19wcm90b19fOltdfWluc3RhbmNlb2YgQXJyYXkmJmZ1bmN0aW9uKHQsZSl7dC5fX3Byb3RvX189ZX18fGZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBpIGluIGUpZS5oYXNPd25Qcm9wZXJ0eShpKSYmKHRbaV09ZVtpXSl9KSh0LGUpfSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIGkoKXt0aGlzLmNvbnN0cnVjdG9yPXR9bih0LGUpLHQucHJvdG90eXBlPW51bGw9PT1lP09iamVjdC5jcmVhdGUoZSk6KGkucHJvdG90eXBlPWUucHJvdG90eXBlLG5ldyBpKX0pLHM9dGhpcyYmdGhpcy5fX2Fzc2lnbnx8ZnVuY3Rpb24oKXtyZXR1cm4ocz1PYmplY3QuYXNzaWdufHxmdW5jdGlvbih0KXtmb3IodmFyIGUsaT0xLG49YXJndW1lbnRzLmxlbmd0aDtpPG47aSsrKWZvcih2YXIgbyBpbiBlPWFyZ3VtZW50c1tpXSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxvKSYmKHRbb109ZVtvXSk7cmV0dXJuIHR9KS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciByPWkoNyksYT1pKDApLGw9aSgxKSxjPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSl7dmFyIGk9dC5jYWxsKHRoaXMpfHx0aGlzO2kuZGF0ZVBpY2tlZD1bXSxpLmNhbGVuZGFycz1bXSxpLm9wdGlvbnM9e2VsZW1lbnQ6bnVsbCxlbGVtZW50RW5kOm51bGwscGFyZW50RWw6bnVsbCxmaXJzdERheToxLGZvcm1hdDpcIllZWVktTU0tRERcIixsYW5nOlwiZW4tVVNcIixkZWxpbWl0ZXI6XCIgLSBcIixudW1iZXJPZk1vbnRoczoxLG51bWJlck9mQ29sdW1uczoxLHN0YXJ0RGF0ZTpudWxsLGVuZERhdGU6bnVsbCx6SW5kZXg6OTk5OSxwb3NpdGlvbjpcImF1dG9cIixzZWxlY3RGb3J3YXJkOiExLHNlbGVjdEJhY2t3YXJkOiExLHNwbGl0VmlldzohMSxpbmxpbmVNb2RlOiExLHNpbmdsZU1vZGU6ITAsYXV0b0FwcGx5OiEwLGFsbG93UmVwaWNrOiExLHNob3dXZWVrTnVtYmVyczohMSxzaG93VG9vbHRpcDohMCxzY3JvbGxUb0RhdGU6ITAsbW9iaWxlRnJpZW5kbHk6ITAscmVzZXRCdXR0b246ITEsYXV0b1JlZnJlc2g6ITEsbG9ja0RheXNGb3JtYXQ6XCJZWVlZLU1NLUREXCIsbG9ja0RheXM6W10sZGlzYWxsb3dMb2NrRGF5c0luUmFuZ2U6ITEsbG9ja0RheXNJbmNsdXNpdml0eTpcIltdXCIsaGlnaGxpZ2h0ZWREYXlzRm9ybWF0OlwiWVlZWS1NTS1ERFwiLGhpZ2hsaWdodGVkRGF5czpbXSxkcm9wZG93bnM6e21pblllYXI6MTk5MCxtYXhZZWFyOm51bGwsbW9udGhzOiExLHllYXJzOiExfSxidXR0b25UZXh0OnthcHBseTpcIkFwcGx5XCIsY2FuY2VsOlwiQ2FuY2VsXCIscHJldmlvdXNNb250aDonPHN2ZyB3aWR0aD1cIjExXCIgaGVpZ2h0PVwiMTZcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+PHBhdGggZD1cIk03LjkxOSAwbDIuNzQ4IDIuNjY3TDUuMzMzIDhsNS4zMzQgNS4zMzNMNy45MTkgMTYgMCA4elwiIGZpbGwtcnVsZT1cIm5vbnplcm9cIi8+PC9zdmc+JyxuZXh0TW9udGg6Jzxzdmcgd2lkdGg9XCIxMVwiIGhlaWdodD1cIjE2XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxwYXRoIGQ9XCJNMi43NDggMTZMMCAxMy4zMzMgNS4zMzMgOCAwIDIuNjY3IDIuNzQ4IDBsNy45MTkgOHpcIiBmaWxsLXJ1bGU9XCJub256ZXJvXCIvPjwvc3ZnPicscmVzZXQ6JzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHdpZHRoPVwiMjRcIj5cXG4gICAgICAgIDxwYXRoIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIi8+XFxuICAgICAgICA8cGF0aCBkPVwiTTEzIDNjLTQuOTcgMC05IDQuMDMtOSA5SDFsMy44OSAzLjg5LjA3LjE0TDkgMTJINmMwLTMuODcgMy4xMy03IDctN3M3IDMuMTMgNyA3LTMuMTMgNy03IDdjLTEuOTMgMC0zLjY4LS43OS00Ljk0LTIuMDZsLTEuNDIgMS40MkM4LjI3IDE5Ljk5IDEwLjUxIDIxIDEzIDIxYzQuOTcgMCA5LTQuMDMgOS05cy00LjAzLTktOS05em0tMSA1djVsNC4yOCAyLjU0LjcyLTEuMjEtMy41LTIuMDhWOEgxMnpcIi8+XFxuICAgICAgPC9zdmc+J30sdG9vbHRpcFRleHQ6e29uZTpcImRheVwiLG90aGVyOlwiZGF5c1wifX0saS5vcHRpb25zPXMocyh7fSxpLm9wdGlvbnMpLGUuZWxlbWVudC5kYXRhc2V0KSxPYmplY3Qua2V5cyhpLm9wdGlvbnMpLmZvckVhY2goKGZ1bmN0aW9uKHQpe1widHJ1ZVwiIT09aS5vcHRpb25zW3RdJiZcImZhbHNlXCIhPT1pLm9wdGlvbnNbdF18fChpLm9wdGlvbnNbdF09XCJ0cnVlXCI9PT1pLm9wdGlvbnNbdF0pfSkpO3ZhciBuPXMocyh7fSxpLm9wdGlvbnMuZHJvcGRvd25zKSxlLmRyb3Bkb3ducyksbz1zKHMoe30saS5vcHRpb25zLmJ1dHRvblRleHQpLGUuYnV0dG9uVGV4dCkscj1zKHMoe30saS5vcHRpb25zLnRvb2x0aXBUZXh0KSxlLnRvb2x0aXBUZXh0KTtpLm9wdGlvbnM9cyhzKHt9LGkub3B0aW9ucyksZSksaS5vcHRpb25zLmRyb3Bkb3ducz1zKHt9LG4pLGkub3B0aW9ucy5idXR0b25UZXh0PXMoe30sbyksaS5vcHRpb25zLnRvb2x0aXBUZXh0PXMoe30sciksaS5vcHRpb25zLmVsZW1lbnRFbmR8fChpLm9wdGlvbnMuYWxsb3dSZXBpY2s9ITEpLGkub3B0aW9ucy5sb2NrRGF5cy5sZW5ndGgmJihpLm9wdGlvbnMubG9ja0RheXM9YS5EYXRlVGltZS5jb252ZXJ0QXJyYXkoaS5vcHRpb25zLmxvY2tEYXlzLGkub3B0aW9ucy5sb2NrRGF5c0Zvcm1hdCkpLGkub3B0aW9ucy5oaWdobGlnaHRlZERheXMubGVuZ3RoJiYoaS5vcHRpb25zLmhpZ2hsaWdodGVkRGF5cz1hLkRhdGVUaW1lLmNvbnZlcnRBcnJheShpLm9wdGlvbnMuaGlnaGxpZ2h0ZWREYXlzLGkub3B0aW9ucy5oaWdobGlnaHRlZERheXNGb3JtYXQpKTt2YXIgbD1pLnBhcnNlSW5wdXQoKSxjPWxbMF0saD1sWzFdO2kub3B0aW9ucy5zdGFydERhdGUmJihpLm9wdGlvbnMuc2luZ2xlTW9kZXx8aS5vcHRpb25zLmVuZERhdGUpJiYoYz1uZXcgYS5EYXRlVGltZShpLm9wdGlvbnMuc3RhcnREYXRlLGkub3B0aW9ucy5mb3JtYXQsaS5vcHRpb25zLmxhbmcpKSxjJiZpLm9wdGlvbnMuZW5kRGF0ZSYmKGg9bmV3IGEuRGF0ZVRpbWUoaS5vcHRpb25zLmVuZERhdGUsaS5vcHRpb25zLmZvcm1hdCxpLm9wdGlvbnMubGFuZykpLGMgaW5zdGFuY2VvZiBhLkRhdGVUaW1lJiYhaXNOYU4oYy5nZXRUaW1lKCkpJiYoaS5vcHRpb25zLnN0YXJ0RGF0ZT1jKSxpLm9wdGlvbnMuc3RhcnREYXRlJiZoIGluc3RhbmNlb2YgYS5EYXRlVGltZSYmIWlzTmFOKGguZ2V0VGltZSgpKSYmKGkub3B0aW9ucy5lbmREYXRlPWgpLCFpLm9wdGlvbnMuc2luZ2xlTW9kZXx8aS5vcHRpb25zLnN0YXJ0RGF0ZSBpbnN0YW5jZW9mIGEuRGF0ZVRpbWV8fChpLm9wdGlvbnMuc3RhcnREYXRlPW51bGwpLGkub3B0aW9ucy5zaW5nbGVNb2RlfHxpLm9wdGlvbnMuc3RhcnREYXRlIGluc3RhbmNlb2YgYS5EYXRlVGltZSYmaS5vcHRpb25zLmVuZERhdGUgaW5zdGFuY2VvZiBhLkRhdGVUaW1lfHwoaS5vcHRpb25zLnN0YXJ0RGF0ZT1udWxsLGkub3B0aW9ucy5lbmREYXRlPW51bGwpO2Zvcih2YXIgcD0wO3A8aS5vcHRpb25zLm51bWJlck9mTW9udGhzO3ArPTEpe3ZhciBkPWkub3B0aW9ucy5zdGFydERhdGUgaW5zdGFuY2VvZiBhLkRhdGVUaW1lP2kub3B0aW9ucy5zdGFydERhdGUuY2xvbmUoKTpuZXcgYS5EYXRlVGltZTtpZighaS5vcHRpb25zLnN0YXJ0RGF0ZSYmKDA9PT1wfHxpLm9wdGlvbnMuc3BsaXRWaWV3KSl7dmFyIHU9aS5vcHRpb25zLm1heERhdGU/bmV3IGEuRGF0ZVRpbWUoaS5vcHRpb25zLm1heERhdGUpOm51bGwsbT1pLm9wdGlvbnMubWluRGF0ZT9uZXcgYS5EYXRlVGltZShpLm9wdGlvbnMubWluRGF0ZSk6bnVsbCxmPWkub3B0aW9ucy5udW1iZXJPZk1vbnRocy0xO20mJnUmJmQuaXNBZnRlcih1KT8oZD1tLmNsb25lKCkpLnNldERhdGUoMSk6IW0mJnUmJmQuaXNBZnRlcih1KSYmKChkPXUuY2xvbmUoKSkuc2V0RGF0ZSgxKSxkLnNldE1vbnRoKGQuZ2V0TW9udGgoKS1mKSl9ZC5zZXREYXRlKDEpLGQuc2V0TW9udGgoZC5nZXRNb250aCgpK3ApLGkuY2FsZW5kYXJzW3BdPWR9aWYoaS5vcHRpb25zLnNob3dUb29sdGlwKWlmKGkub3B0aW9ucy50b29sdGlwUGx1cmFsU2VsZWN0b3IpaS5wbHVyYWxTZWxlY3Rvcj1pLm9wdGlvbnMudG9vbHRpcFBsdXJhbFNlbGVjdG9yO2Vsc2UgdHJ5e3ZhciBnPW5ldyBJbnRsLlBsdXJhbFJ1bGVzKGkub3B0aW9ucy5sYW5nKTtpLnBsdXJhbFNlbGVjdG9yPWcuc2VsZWN0LmJpbmQoZyl9Y2F0Y2godCl7aS5wbHVyYWxTZWxlY3Rvcj1mdW5jdGlvbih0KXtyZXR1cm4gMD09PU1hdGguYWJzKHQpP1wib25lXCI6XCJvdGhlclwifX1yZXR1cm4gaX1yZXR1cm4gbyhlLHQpLGUuYWRkPWZ1bmN0aW9uKHQsZSl7bC5MaXRlcGlja2VyLnByb3RvdHlwZVt0XT1lfSxlLnByb3RvdHlwZS5EYXRlVGltZT1mdW5jdGlvbih0LGUpe3JldHVybiB0P25ldyBhLkRhdGVUaW1lKHQsZSk6bmV3IGEuRGF0ZVRpbWV9LGUucHJvdG90eXBlLmluaXQ9ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3RoaXMub3B0aW9ucy5wbHVnaW5zJiZ0aGlzLm9wdGlvbnMucGx1Z2lucy5sZW5ndGgmJnRoaXMub3B0aW9ucy5wbHVnaW5zLmZvckVhY2goKGZ1bmN0aW9uKGUpe2wuTGl0ZXBpY2tlci5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoZSk/bC5MaXRlcGlja2VyLnByb3RvdHlwZVtlXS5pbml0LmNhbGwodCx0KTpjb25zb2xlLndhcm4oXCJMaXRlcGlja2VyOiBwbHVnaW4gwqtcIitlK1wiwrsgbm90IGZvdW5kLlwiKX0pKX0sZS5wcm90b3R5cGUucGFyc2VJbnB1dD1mdW5jdGlvbigpe3ZhciB0PXRoaXMub3B0aW9ucy5kZWxpbWl0ZXIsZT1uZXcgUmVnRXhwKFwiXCIrdCksaT10aGlzLm9wdGlvbnMuZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQ/dGhpcy5vcHRpb25zLmVsZW1lbnQudmFsdWUuc3BsaXQodCk6W107aWYodGhpcy5vcHRpb25zLmVsZW1lbnRFbmQpe2lmKHRoaXMub3B0aW9ucy5lbGVtZW50IGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCYmdGhpcy5vcHRpb25zLmVsZW1lbnQudmFsdWUubGVuZ3RoJiZ0aGlzLm9wdGlvbnMuZWxlbWVudEVuZCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQmJnRoaXMub3B0aW9ucy5lbGVtZW50RW5kLnZhbHVlLmxlbmd0aClyZXR1cm5bbmV3IGEuRGF0ZVRpbWUodGhpcy5vcHRpb25zLmVsZW1lbnQudmFsdWUsdGhpcy5vcHRpb25zLmZvcm1hdCksbmV3IGEuRGF0ZVRpbWUodGhpcy5vcHRpb25zLmVsZW1lbnRFbmQudmFsdWUsdGhpcy5vcHRpb25zLmZvcm1hdCldfWVsc2UgaWYodGhpcy5vcHRpb25zLnNpbmdsZU1vZGUpe2lmKHRoaXMub3B0aW9ucy5lbGVtZW50IGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCYmdGhpcy5vcHRpb25zLmVsZW1lbnQudmFsdWUubGVuZ3RoKXJldHVybltuZXcgYS5EYXRlVGltZSh0aGlzLm9wdGlvbnMuZWxlbWVudC52YWx1ZSx0aGlzLm9wdGlvbnMuZm9ybWF0KV19ZWxzZSBpZih0aGlzLm9wdGlvbnMuZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQmJmUudGVzdCh0aGlzLm9wdGlvbnMuZWxlbWVudC52YWx1ZSkmJmkubGVuZ3RoJiZpLmxlbmd0aCUyPT0wKXt2YXIgbj1pLnNsaWNlKDAsaS5sZW5ndGgvMikuam9pbih0KSxvPWkuc2xpY2UoaS5sZW5ndGgvMikuam9pbih0KTtyZXR1cm5bbmV3IGEuRGF0ZVRpbWUobix0aGlzLm9wdGlvbnMuZm9ybWF0KSxuZXcgYS5EYXRlVGltZShvLHRoaXMub3B0aW9ucy5mb3JtYXQpXX1yZXR1cm5bXX0sZS5wcm90b3R5cGUuaXNTaG93bmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVpJiZcIm5vbmVcIiE9PXRoaXMudWkuc3R5bGUuZGlzcGxheX0sZS5wcm90b3R5cGUuZmluZFBvc2l0aW9uPWZ1bmN0aW9uKHQpe3ZhciBlPXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksaT10aGlzLnVpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLG49dGhpcy5vcHRpb25zLnBvc2l0aW9uLnNwbGl0KFwiIFwiKSxvPXdpbmRvdy5zY3JvbGxYfHx3aW5kb3cucGFnZVhPZmZzZXQscz13aW5kb3cuc2Nyb2xsWXx8d2luZG93LnBhZ2VZT2Zmc2V0LHI9MCxhPTA7aWYoXCJhdXRvXCIhPT1uWzBdJiYvdG9wfGJvdHRvbS8udGVzdChuWzBdKSlyPWVbblswXV0rcyxcInRvcFwiPT09blswXSYmKHItPWkuaGVpZ2h0KTtlbHNle3I9ZS5ib3R0b20rczt2YXIgbD1lLmJvdHRvbStpLmhlaWdodD53aW5kb3cuaW5uZXJIZWlnaHQsYz1lLnRvcCtzLWkuaGVpZ2h0Pj1pLmhlaWdodDtsJiZjJiYocj1lLnRvcCtzLWkuaGVpZ2h0KX1pZigvbGVmdHxyaWdodC8udGVzdChuWzBdKXx8blsxXSYmXCJhdXRvXCIhPT1uWzFdJiYvbGVmdHxyaWdodC8udGVzdChuWzFdKSlhPS9sZWZ0fHJpZ2h0Ly50ZXN0KG5bMF0pP2VbblswXV0rbzplW25bMV1dK28sXCJyaWdodFwiIT09blswXSYmXCJyaWdodFwiIT09blsxXXx8KGEtPWkud2lkdGgpO2Vsc2V7YT1lLmxlZnQrbztsPWUubGVmdCtpLndpZHRoPndpbmRvdy5pbm5lcldpZHRoO3ZhciBoPWUucmlnaHQrby1pLndpZHRoPj0wO2wmJmgmJihhPWUucmlnaHQrby1pLndpZHRoKX1yZXR1cm57bGVmdDphLHRvcDpyfX0sZX0oci5FdmVudEVtaXR0ZXIpO2UuTFBDb3JlPWN9LGZ1bmN0aW9uKHQsZSxpKXtcInVzZSBzdHJpY3RcIjt2YXIgbixvPVwib2JqZWN0XCI9PXR5cGVvZiBSZWZsZWN0P1JlZmxlY3Q6bnVsbCxzPW8mJlwiZnVuY3Rpb25cIj09dHlwZW9mIG8uYXBwbHk/by5hcHBseTpmdW5jdGlvbih0LGUsaSl7cmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHQsZSxpKX07bj1vJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBvLm93bktleXM/by5vd25LZXlzOk9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM/ZnVuY3Rpb24odCl7cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHQpLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHQpKX06ZnVuY3Rpb24odCl7cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHQpfTt2YXIgcj1OdW1iZXIuaXNOYU58fGZ1bmN0aW9uKHQpe3JldHVybiB0IT10fTtmdW5jdGlvbiBhKCl7YS5pbml0LmNhbGwodGhpcyl9dC5leHBvcnRzPWEsYS5FdmVudEVtaXR0ZXI9YSxhLnByb3RvdHlwZS5fZXZlbnRzPXZvaWQgMCxhLnByb3RvdHlwZS5fZXZlbnRzQ291bnQ9MCxhLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzPXZvaWQgMDt2YXIgbD0xMDtmdW5jdGlvbiBjKHQpe3JldHVybiB2b2lkIDA9PT10Ll9tYXhMaXN0ZW5lcnM/YS5kZWZhdWx0TWF4TGlzdGVuZXJzOnQuX21heExpc3RlbmVyc31mdW5jdGlvbiBoKHQsZSxpLG4pe3ZhciBvLHMscixhO2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGkpdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyt0eXBlb2YgaSk7aWYodm9pZCAwPT09KHM9dC5fZXZlbnRzKT8ocz10Ll9ldmVudHM9T2JqZWN0LmNyZWF0ZShudWxsKSx0Ll9ldmVudHNDb3VudD0wKToodm9pZCAwIT09cy5uZXdMaXN0ZW5lciYmKHQuZW1pdChcIm5ld0xpc3RlbmVyXCIsZSxpLmxpc3RlbmVyP2kubGlzdGVuZXI6aSkscz10Ll9ldmVudHMpLHI9c1tlXSksdm9pZCAwPT09cilyPXNbZV09aSwrK3QuX2V2ZW50c0NvdW50O2Vsc2UgaWYoXCJmdW5jdGlvblwiPT10eXBlb2Ygcj9yPXNbZV09bj9baSxyXTpbcixpXTpuP3IudW5zaGlmdChpKTpyLnB1c2goaSksKG89Yyh0KSk+MCYmci5sZW5ndGg+byYmIXIud2FybmVkKXtyLndhcm5lZD0hMDt2YXIgbD1uZXcgRXJyb3IoXCJQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuIFwiK3IubGVuZ3RoK1wiIFwiK1N0cmluZyhlKStcIiBsaXN0ZW5lcnMgYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0XCIpO2wubmFtZT1cIk1heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZ1wiLGwuZW1pdHRlcj10LGwudHlwZT1lLGwuY291bnQ9ci5sZW5ndGgsYT1sLGNvbnNvbGUmJmNvbnNvbGUud2FybiYmY29uc29sZS53YXJuKGEpfXJldHVybiB0fWZ1bmN0aW9uIHAoKXtmb3IodmFyIHQ9W10sZT0wO2U8YXJndW1lbnRzLmxlbmd0aDtlKyspdC5wdXNoKGFyZ3VtZW50c1tlXSk7dGhpcy5maXJlZHx8KHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSx0aGlzLndyYXBGbiksdGhpcy5maXJlZD0hMCxzKHRoaXMubGlzdGVuZXIsdGhpcy50YXJnZXQsdCkpfWZ1bmN0aW9uIGQodCxlLGkpe3ZhciBuPXtmaXJlZDohMSx3cmFwRm46dm9pZCAwLHRhcmdldDp0LHR5cGU6ZSxsaXN0ZW5lcjppfSxvPXAuYmluZChuKTtyZXR1cm4gby5saXN0ZW5lcj1pLG4ud3JhcEZuPW8sb31mdW5jdGlvbiB1KHQsZSxpKXt2YXIgbj10Ll9ldmVudHM7aWYodm9pZCAwPT09bilyZXR1cm5bXTt2YXIgbz1uW2VdO3JldHVybiB2b2lkIDA9PT1vP1tdOlwiZnVuY3Rpb25cIj09dHlwZW9mIG8/aT9bby5saXN0ZW5lcnx8b106W29dOmk/ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBBcnJheSh0Lmxlbmd0aCksaT0wO2k8ZS5sZW5ndGg7KytpKWVbaV09dFtpXS5saXN0ZW5lcnx8dFtpXTtyZXR1cm4gZX0obyk6ZihvLG8ubGVuZ3RoKX1mdW5jdGlvbiBtKHQpe3ZhciBlPXRoaXMuX2V2ZW50cztpZih2b2lkIDAhPT1lKXt2YXIgaT1lW3RdO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGkpcmV0dXJuIDE7aWYodm9pZCAwIT09aSlyZXR1cm4gaS5sZW5ndGh9cmV0dXJuIDB9ZnVuY3Rpb24gZih0LGUpe2Zvcih2YXIgaT1uZXcgQXJyYXkoZSksbj0wO248ZTsrK24paVtuXT10W25dO3JldHVybiBpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLFwiZGVmYXVsdE1heExpc3RlbmVyc1wiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBsfSxzZXQ6ZnVuY3Rpb24odCl7aWYoXCJudW1iZXJcIiE9dHlwZW9mIHR8fHQ8MHx8cih0KSl0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiZGVmYXVsdE1heExpc3RlbmVyc1wiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcrdCtcIi5cIik7bD10fX0pLGEuaW5pdD1mdW5jdGlvbigpe3ZvaWQgMCE9PXRoaXMuX2V2ZW50cyYmdGhpcy5fZXZlbnRzIT09T2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHN8fCh0aGlzLl9ldmVudHM9T2JqZWN0LmNyZWF0ZShudWxsKSx0aGlzLl9ldmVudHNDb3VudD0wKSx0aGlzLl9tYXhMaXN0ZW5lcnM9dGhpcy5fbWF4TGlzdGVuZXJzfHx2b2lkIDB9LGEucHJvdG90eXBlLnNldE1heExpc3RlbmVycz1mdW5jdGlvbih0KXtpZihcIm51bWJlclwiIT10eXBlb2YgdHx8dDwwfHxyKHQpKXRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyt0K1wiLlwiKTtyZXR1cm4gdGhpcy5fbWF4TGlzdGVuZXJzPXQsdGhpc30sYS5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzPWZ1bmN0aW9uKCl7cmV0dXJuIGModGhpcyl9LGEucHJvdG90eXBlLmVtaXQ9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLGk9MTtpPGFyZ3VtZW50cy5sZW5ndGg7aSsrKWUucHVzaChhcmd1bWVudHNbaV0pO3ZhciBuPVwiZXJyb3JcIj09PXQsbz10aGlzLl9ldmVudHM7aWYodm9pZCAwIT09byluPW4mJnZvaWQgMD09PW8uZXJyb3I7ZWxzZSBpZighbilyZXR1cm4hMTtpZihuKXt2YXIgcjtpZihlLmxlbmd0aD4wJiYocj1lWzBdKSxyIGluc3RhbmNlb2YgRXJyb3IpdGhyb3cgcjt2YXIgYT1uZXcgRXJyb3IoXCJVbmhhbmRsZWQgZXJyb3IuXCIrKHI/XCIgKFwiK3IubWVzc2FnZStcIilcIjpcIlwiKSk7dGhyb3cgYS5jb250ZXh0PXIsYX12YXIgbD1vW3RdO2lmKHZvaWQgMD09PWwpcmV0dXJuITE7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgbClzKGwsdGhpcyxlKTtlbHNle3ZhciBjPWwubGVuZ3RoLGg9ZihsLGMpO2ZvcihpPTA7aTxjOysraSlzKGhbaV0sdGhpcyxlKX1yZXR1cm4hMH0sYS5wcm90b3R5cGUuYWRkTGlzdGVuZXI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gaCh0aGlzLHQsZSwhMSl9LGEucHJvdG90eXBlLm9uPWEucHJvdG90eXBlLmFkZExpc3RlbmVyLGEucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lcj1mdW5jdGlvbih0LGUpe3JldHVybiBoKHRoaXMsdCxlLCEwKX0sYS5wcm90b3R5cGUub25jZT1mdW5jdGlvbih0LGUpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUpdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyt0eXBlb2YgZSk7cmV0dXJuIHRoaXMub24odCxkKHRoaXMsdCxlKSksdGhpc30sYS5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lcj1mdW5jdGlvbih0LGUpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUpdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyt0eXBlb2YgZSk7cmV0dXJuIHRoaXMucHJlcGVuZExpc3RlbmVyKHQsZCh0aGlzLHQsZSkpLHRoaXN9LGEucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyPWZ1bmN0aW9uKHQsZSl7dmFyIGksbixvLHMscjtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlKXRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcrdHlwZW9mIGUpO2lmKHZvaWQgMD09PShuPXRoaXMuX2V2ZW50cykpcmV0dXJuIHRoaXM7aWYodm9pZCAwPT09KGk9blt0XSkpcmV0dXJuIHRoaXM7aWYoaT09PWV8fGkubGlzdGVuZXI9PT1lKTA9PS0tdGhpcy5fZXZlbnRzQ291bnQ/dGhpcy5fZXZlbnRzPU9iamVjdC5jcmVhdGUobnVsbCk6KGRlbGV0ZSBuW3RdLG4ucmVtb3ZlTGlzdGVuZXImJnRoaXMuZW1pdChcInJlbW92ZUxpc3RlbmVyXCIsdCxpLmxpc3RlbmVyfHxlKSk7ZWxzZSBpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBpKXtmb3Iobz0tMSxzPWkubGVuZ3RoLTE7cz49MDtzLS0paWYoaVtzXT09PWV8fGlbc10ubGlzdGVuZXI9PT1lKXtyPWlbc10ubGlzdGVuZXIsbz1zO2JyZWFrfWlmKG88MClyZXR1cm4gdGhpczswPT09bz9pLnNoaWZ0KCk6ZnVuY3Rpb24odCxlKXtmb3IoO2UrMTx0Lmxlbmd0aDtlKyspdFtlXT10W2UrMV07dC5wb3AoKX0oaSxvKSwxPT09aS5sZW5ndGgmJihuW3RdPWlbMF0pLHZvaWQgMCE9PW4ucmVtb3ZlTGlzdGVuZXImJnRoaXMuZW1pdChcInJlbW92ZUxpc3RlbmVyXCIsdCxyfHxlKX1yZXR1cm4gdGhpc30sYS5wcm90b3R5cGUub2ZmPWEucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyLGEucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycz1mdW5jdGlvbih0KXt2YXIgZSxpLG47aWYodm9pZCAwPT09KGk9dGhpcy5fZXZlbnRzKSlyZXR1cm4gdGhpcztpZih2b2lkIDA9PT1pLnJlbW92ZUxpc3RlbmVyKXJldHVybiAwPT09YXJndW1lbnRzLmxlbmd0aD8odGhpcy5fZXZlbnRzPU9iamVjdC5jcmVhdGUobnVsbCksdGhpcy5fZXZlbnRzQ291bnQ9MCk6dm9pZCAwIT09aVt0XSYmKDA9PS0tdGhpcy5fZXZlbnRzQ291bnQ/dGhpcy5fZXZlbnRzPU9iamVjdC5jcmVhdGUobnVsbCk6ZGVsZXRlIGlbdF0pLHRoaXM7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBvLHM9T2JqZWN0LmtleXMoaSk7Zm9yKG49MDtuPHMubGVuZ3RoOysrbilcInJlbW92ZUxpc3RlbmVyXCIhPT0obz1zW25dKSYmdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMobyk7cmV0dXJuIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKFwicmVtb3ZlTGlzdGVuZXJcIiksdGhpcy5fZXZlbnRzPU9iamVjdC5jcmVhdGUobnVsbCksdGhpcy5fZXZlbnRzQ291bnQ9MCx0aGlzfWlmKFwiZnVuY3Rpb25cIj09dHlwZW9mKGU9aVt0XSkpdGhpcy5yZW1vdmVMaXN0ZW5lcih0LGUpO2Vsc2UgaWYodm9pZCAwIT09ZSlmb3Iobj1lLmxlbmd0aC0xO24+PTA7bi0tKXRoaXMucmVtb3ZlTGlzdGVuZXIodCxlW25dKTtyZXR1cm4gdGhpc30sYS5wcm90b3R5cGUubGlzdGVuZXJzPWZ1bmN0aW9uKHQpe3JldHVybiB1KHRoaXMsdCwhMCl9LGEucHJvdG90eXBlLnJhd0xpc3RlbmVycz1mdW5jdGlvbih0KXtyZXR1cm4gdSh0aGlzLHQsITEpfSxhLmxpc3RlbmVyQ291bnQ9ZnVuY3Rpb24odCxlKXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiB0Lmxpc3RlbmVyQ291bnQ/dC5saXN0ZW5lckNvdW50KGUpOm0uY2FsbCh0LGUpfSxhLnByb3RvdHlwZS5saXN0ZW5lckNvdW50PW0sYS5wcm90b3R5cGUuZXZlbnROYW1lcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9ldmVudHNDb3VudD4wP24odGhpcy5fZXZlbnRzKTpbXX19LGZ1bmN0aW9uKHQsZSxpKXsoZT1pKDkpKCExKSkucHVzaChbdC5pLCc6cm9vdHstLWxpdGVwaWNrZXItY29udGFpbmVyLW1vbnRocy1jb2xvci1iZzogI2ZmZjstLWxpdGVwaWNrZXItY29udGFpbmVyLW1vbnRocy1ib3gtc2hhZG93LWNvbG9yOiAjZGRkOy0tbGl0ZXBpY2tlci1mb290ZXItY29sb3ItYmc6ICNmYWZhZmE7LS1saXRlcGlja2VyLWZvb3Rlci1ib3gtc2hhZG93LWNvbG9yOiAjZGRkOy0tbGl0ZXBpY2tlci10b29sdGlwLWNvbG9yLWJnOiAjZmZmOy0tbGl0ZXBpY2tlci1tb250aC1oZWFkZXItY29sb3I6ICMzMzM7LS1saXRlcGlja2VyLWJ1dHRvbi1wcmV2LW1vbnRoLWNvbG9yOiAjOWU5ZTllOy0tbGl0ZXBpY2tlci1idXR0b24tbmV4dC1tb250aC1jb2xvcjogIzllOWU5ZTstLWxpdGVwaWNrZXItYnV0dG9uLXByZXYtbW9udGgtY29sb3ItaG92ZXI6ICMyMTk2ZjM7LS1saXRlcGlja2VyLWJ1dHRvbi1uZXh0LW1vbnRoLWNvbG9yLWhvdmVyOiAjMjE5NmYzOy0tbGl0ZXBpY2tlci1tb250aC13aWR0aDogY2FsYyh2YXIoLS1saXRlcGlja2VyLWRheS13aWR0aCkgKiA3KTstLWxpdGVwaWNrZXItbW9udGgtd2Vla2RheS1jb2xvcjogIzllOWU5ZTstLWxpdGVwaWNrZXItbW9udGgtd2Vlay1udW1iZXItY29sb3I6ICM5ZTllOWU7LS1saXRlcGlja2VyLWRheS13aWR0aDogMzhweDstLWxpdGVwaWNrZXItZGF5LWNvbG9yOiAjMzMzOy0tbGl0ZXBpY2tlci1kYXktY29sb3ItaG92ZXI6ICMyMTk2ZjM7LS1saXRlcGlja2VyLWlzLXRvZGF5LWNvbG9yOiAjZjQ0MzM2Oy0tbGl0ZXBpY2tlci1pcy1pbi1yYW5nZS1jb2xvcjogI2JiZGVmYjstLWxpdGVwaWNrZXItaXMtbG9ja2VkLWNvbG9yOiAjOWU5ZTllOy0tbGl0ZXBpY2tlci1pcy1zdGFydC1jb2xvcjogI2ZmZjstLWxpdGVwaWNrZXItaXMtc3RhcnQtY29sb3ItYmc6ICMyMTk2ZjM7LS1saXRlcGlja2VyLWlzLWVuZC1jb2xvcjogI2ZmZjstLWxpdGVwaWNrZXItaXMtZW5kLWNvbG9yLWJnOiAjMjE5NmYzOy0tbGl0ZXBpY2tlci1idXR0b24tY2FuY2VsLWNvbG9yOiAjZmZmOy0tbGl0ZXBpY2tlci1idXR0b24tY2FuY2VsLWNvbG9yLWJnOiAjOWU5ZTllOy0tbGl0ZXBpY2tlci1idXR0b24tYXBwbHktY29sb3I6ICNmZmY7LS1saXRlcGlja2VyLWJ1dHRvbi1hcHBseS1jb2xvci1iZzogIzIxOTZmMzstLWxpdGVwaWNrZXItYnV0dG9uLXJlc2V0LWNvbG9yOiAjOTA5MDkwOy0tbGl0ZXBpY2tlci1idXR0b24tcmVzZXQtY29sb3ItaG92ZXI6ICMyMTk2ZjM7LS1saXRlcGlja2VyLWhpZ2hsaWdodGVkLWRheS1jb2xvcjogIzMzMzstLWxpdGVwaWNrZXItaGlnaGxpZ2h0ZWQtZGF5LWNvbG9yLWJnOiAjZmZlYjNifS5zaG93LXdlZWstbnVtYmVyc3stLWxpdGVwaWNrZXItbW9udGgtd2lkdGg6IGNhbGModmFyKC0tbGl0ZXBpY2tlci1kYXktd2lkdGgpICogOCl9LmxpdGVwaWNrZXJ7Zm9udC1mYW1pbHk6LWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCBcIlNlZ29lIFVJXCIsIFJvYm90bywgXCJIZWx2ZXRpY2EgTmV1ZVwiLCBBcmlhbCwgc2Fucy1zZXJpZjtmb250LXNpemU6MC44ZW07ZGlzcGxheTpub25lfS5saXRlcGlja2VyIGJ1dHRvbntib3JkZXI6bm9uZTtiYWNrZ3JvdW5kOm5vbmV9LmxpdGVwaWNrZXIgLmNvbnRhaW5lcl9fbWFpbntkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4fS5saXRlcGlja2VyIC5jb250YWluZXJfX21vbnRoc3tkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4Oy1tcy1mbGV4LXdyYXA6d3JhcDtmbGV4LXdyYXA6d3JhcDtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWxpdGVwaWNrZXItY29udGFpbmVyLW1vbnRocy1jb2xvci1iZyk7Ym9yZGVyLXJhZGl1czo1cHg7LXdlYmtpdC1ib3gtc2hhZG93OjAgMCA1cHggdmFyKC0tbGl0ZXBpY2tlci1jb250YWluZXItbW9udGhzLWJveC1zaGFkb3ctY29sb3IpO2JveC1zaGFkb3c6MCAwIDVweCB2YXIoLS1saXRlcGlja2VyLWNvbnRhaW5lci1tb250aHMtYm94LXNoYWRvdy1jb2xvcik7d2lkdGg6Y2FsYyh2YXIoLS1saXRlcGlja2VyLW1vbnRoLXdpZHRoKSArIDEwcHgpOy13ZWJraXQtYm94LXNpemluZzpjb250ZW50LWJveDtib3gtc2l6aW5nOmNvbnRlbnQtYm94fS5saXRlcGlja2VyIC5jb250YWluZXJfX21vbnRocy5jb2x1bW5zLTJ7d2lkdGg6Y2FsYygodmFyKC0tbGl0ZXBpY2tlci1tb250aC13aWR0aCkgKiAyKSArIDIwcHgpfS5saXRlcGlja2VyIC5jb250YWluZXJfX21vbnRocy5jb2x1bW5zLTN7d2lkdGg6Y2FsYygodmFyKC0tbGl0ZXBpY2tlci1tb250aC13aWR0aCkgKiAzKSArIDMwcHgpfS5saXRlcGlja2VyIC5jb250YWluZXJfX21vbnRocy5jb2x1bW5zLTR7d2lkdGg6Y2FsYygodmFyKC0tbGl0ZXBpY2tlci1tb250aC13aWR0aCkgKiA0KSArIDQwcHgpfS5saXRlcGlja2VyIC5jb250YWluZXJfX21vbnRocy5zcGxpdC12aWV3IC5tb250aC1pdGVtLWhlYWRlciAuYnV0dG9uLXByZXZpb3VzLW1vbnRoLC5saXRlcGlja2VyIC5jb250YWluZXJfX21vbnRocy5zcGxpdC12aWV3IC5tb250aC1pdGVtLWhlYWRlciAuYnV0dG9uLW5leHQtbW9udGh7dmlzaWJpbGl0eTp2aXNpYmxlfS5saXRlcGlja2VyIC5jb250YWluZXJfX21vbnRocyAubW9udGgtaXRlbXtwYWRkaW5nOjVweDt3aWR0aDp2YXIoLS1saXRlcGlja2VyLW1vbnRoLXdpZHRoKTstd2Via2l0LWJveC1zaXppbmc6Y29udGVudC1ib3g7Ym94LXNpemluZzpjb250ZW50LWJveH0ubGl0ZXBpY2tlciAuY29udGFpbmVyX19tb250aHMgLm1vbnRoLWl0ZW0taGVhZGVye2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7LXdlYmtpdC1ib3gtcGFjazpqdXN0aWZ5Oy1tcy1mbGV4LXBhY2s6anVzdGlmeTtqdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYmV0d2Vlbjtmb250LXdlaWdodDo1MDA7cGFkZGluZzoxMHB4IDVweDt0ZXh0LWFsaWduOmNlbnRlcjstd2Via2l0LWJveC1hbGlnbjpjZW50ZXI7LW1zLWZsZXgtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjtjb2xvcjp2YXIoLS1saXRlcGlja2VyLW1vbnRoLWhlYWRlci1jb2xvcil9LmxpdGVwaWNrZXIgLmNvbnRhaW5lcl9fbW9udGhzIC5tb250aC1pdGVtLWhlYWRlciBkaXZ7LXdlYmtpdC1ib3gtZmxleDoxOy1tcy1mbGV4OjE7ZmxleDoxfS5saXRlcGlja2VyIC5jb250YWluZXJfX21vbnRocyAubW9udGgtaXRlbS1oZWFkZXIgZGl2Pi5tb250aC1pdGVtLW5hbWV7bWFyZ2luLXJpZ2h0OjVweH0ubGl0ZXBpY2tlciAuY29udGFpbmVyX19tb250aHMgLm1vbnRoLWl0ZW0taGVhZGVyIGRpdj4ubW9udGgtaXRlbS15ZWFye3BhZGRpbmc6MH0ubGl0ZXBpY2tlciAuY29udGFpbmVyX19tb250aHMgLm1vbnRoLWl0ZW0taGVhZGVyIC5yZXNldC1idXR0b257Y29sb3I6dmFyKC0tbGl0ZXBpY2tlci1idXR0b24tcmVzZXQtY29sb3IpfS5saXRlcGlja2VyIC5jb250YWluZXJfX21vbnRocyAubW9udGgtaXRlbS1oZWFkZXIgLnJlc2V0LWJ1dHRvbj5zdmd7ZmlsbDp2YXIoLS1saXRlcGlja2VyLWJ1dHRvbi1yZXNldC1jb2xvcil9LmxpdGVwaWNrZXIgLmNvbnRhaW5lcl9fbW9udGhzIC5tb250aC1pdGVtLWhlYWRlciAucmVzZXQtYnV0dG9uICp7cG9pbnRlci1ldmVudHM6bm9uZX0ubGl0ZXBpY2tlciAuY29udGFpbmVyX19tb250aHMgLm1vbnRoLWl0ZW0taGVhZGVyIC5yZXNldC1idXR0b246aG92ZXJ7Y29sb3I6dmFyKC0tbGl0ZXBpY2tlci1idXR0b24tcmVzZXQtY29sb3ItaG92ZXIpfS5saXRlcGlja2VyIC5jb250YWluZXJfX21vbnRocyAubW9udGgtaXRlbS1oZWFkZXIgLnJlc2V0LWJ1dHRvbjpob3Zlcj5zdmd7ZmlsbDp2YXIoLS1saXRlcGlja2VyLWJ1dHRvbi1yZXNldC1jb2xvci1ob3Zlcil9LmxpdGVwaWNrZXIgLmNvbnRhaW5lcl9fbW9udGhzIC5tb250aC1pdGVtLWhlYWRlciAuYnV0dG9uLXByZXZpb3VzLW1vbnRoLC5saXRlcGlja2VyIC5jb250YWluZXJfX21vbnRocyAubW9udGgtaXRlbS1oZWFkZXIgLmJ1dHRvbi1uZXh0LW1vbnRoe3Zpc2liaWxpdHk6aGlkZGVuO3RleHQtZGVjb3JhdGlvbjpub25lO3BhZGRpbmc6M3B4IDVweDtib3JkZXItcmFkaXVzOjNweDstd2Via2l0LXRyYW5zaXRpb246Y29sb3IgMC4zcywgYm9yZGVyIDAuM3M7dHJhbnNpdGlvbjpjb2xvciAwLjNzLCBib3JkZXIgMC4zcztjdXJzb3I6ZGVmYXVsdH0ubGl0ZXBpY2tlciAuY29udGFpbmVyX19tb250aHMgLm1vbnRoLWl0ZW0taGVhZGVyIC5idXR0b24tcHJldmlvdXMtbW9udGggKiwubGl0ZXBpY2tlciAuY29udGFpbmVyX19tb250aHMgLm1vbnRoLWl0ZW0taGVhZGVyIC5idXR0b24tbmV4dC1tb250aCAqe3BvaW50ZXItZXZlbnRzOm5vbmV9LmxpdGVwaWNrZXIgLmNvbnRhaW5lcl9fbW9udGhzIC5tb250aC1pdGVtLWhlYWRlciAuYnV0dG9uLXByZXZpb3VzLW1vbnRoe2NvbG9yOnZhcigtLWxpdGVwaWNrZXItYnV0dG9uLXByZXYtbW9udGgtY29sb3IpfS5saXRlcGlja2VyIC5jb250YWluZXJfX21vbnRocyAubW9udGgtaXRlbS1oZWFkZXIgLmJ1dHRvbi1wcmV2aW91cy1tb250aD5zdmcsLmxpdGVwaWNrZXIgLmNvbnRhaW5lcl9fbW9udGhzIC5tb250aC1pdGVtLWhlYWRlciAuYnV0dG9uLXByZXZpb3VzLW1vbnRoPmltZ3tmaWxsOnZhcigtLWxpdGVwaWNrZXItYnV0dG9uLXByZXYtbW9udGgtY29sb3IpfS5saXRlcGlja2VyIC5jb250YWluZXJfX21vbnRocyAubW9udGgtaXRlbS1oZWFkZXIgLmJ1dHRvbi1wcmV2aW91cy1tb250aDpob3Zlcntjb2xvcjp2YXIoLS1saXRlcGlja2VyLWJ1dHRvbi1wcmV2LW1vbnRoLWNvbG9yLWhvdmVyKX0ubGl0ZXBpY2tlciAuY29udGFpbmVyX19tb250aHMgLm1vbnRoLWl0ZW0taGVhZGVyIC5idXR0b24tcHJldmlvdXMtbW9udGg6aG92ZXI+c3Zne2ZpbGw6dmFyKC0tbGl0ZXBpY2tlci1idXR0b24tcHJldi1tb250aC1jb2xvci1ob3Zlcil9LmxpdGVwaWNrZXIgLmNvbnRhaW5lcl9fbW9udGhzIC5tb250aC1pdGVtLWhlYWRlciAuYnV0dG9uLW5leHQtbW9udGh7Y29sb3I6dmFyKC0tbGl0ZXBpY2tlci1idXR0b24tbmV4dC1tb250aC1jb2xvcil9LmxpdGVwaWNrZXIgLmNvbnRhaW5lcl9fbW9udGhzIC5tb250aC1pdGVtLWhlYWRlciAuYnV0dG9uLW5leHQtbW9udGg+c3ZnLC5saXRlcGlja2VyIC5jb250YWluZXJfX21vbnRocyAubW9udGgtaXRlbS1oZWFkZXIgLmJ1dHRvbi1uZXh0LW1vbnRoPmltZ3tmaWxsOnZhcigtLWxpdGVwaWNrZXItYnV0dG9uLW5leHQtbW9udGgtY29sb3IpfS5saXRlcGlja2VyIC5jb250YWluZXJfX21vbnRocyAubW9udGgtaXRlbS1oZWFkZXIgLmJ1dHRvbi1uZXh0LW1vbnRoOmhvdmVye2NvbG9yOnZhcigtLWxpdGVwaWNrZXItYnV0dG9uLW5leHQtbW9udGgtY29sb3ItaG92ZXIpfS5saXRlcGlja2VyIC5jb250YWluZXJfX21vbnRocyAubW9udGgtaXRlbS1oZWFkZXIgLmJ1dHRvbi1uZXh0LW1vbnRoOmhvdmVyPnN2Z3tmaWxsOnZhcigtLWxpdGVwaWNrZXItYnV0dG9uLW5leHQtbW9udGgtY29sb3ItaG92ZXIpfS5saXRlcGlja2VyIC5jb250YWluZXJfX21vbnRocyAubW9udGgtaXRlbS13ZWVrZGF5cy1yb3d7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LXNlbGY6Y2VudGVyOy13ZWJraXQtYm94LXBhY2s6c3RhcnQ7LW1zLWZsZXgtcGFjazpzdGFydDtqdXN0aWZ5LWNvbnRlbnQ6ZmxleC1zdGFydDtjb2xvcjp2YXIoLS1saXRlcGlja2VyLW1vbnRoLXdlZWtkYXktY29sb3IpfS5saXRlcGlja2VyIC5jb250YWluZXJfX21vbnRocyAubW9udGgtaXRlbS13ZWVrZGF5cy1yb3c+ZGl2e3BhZGRpbmc6NXB4IDA7Zm9udC1zaXplOjg1JTstd2Via2l0LWJveC1mbGV4OjE7LW1zLWZsZXg6MTtmbGV4OjE7d2lkdGg6dmFyKC0tbGl0ZXBpY2tlci1kYXktd2lkdGgpO3RleHQtYWxpZ246Y2VudGVyfS5saXRlcGlja2VyIC5jb250YWluZXJfX21vbnRocyAubW9udGgtaXRlbTpmaXJzdC1jaGlsZCAuYnV0dG9uLXByZXZpb3VzLW1vbnRoe3Zpc2liaWxpdHk6dmlzaWJsZX0ubGl0ZXBpY2tlciAuY29udGFpbmVyX19tb250aHMgLm1vbnRoLWl0ZW06bGFzdC1jaGlsZCAuYnV0dG9uLW5leHQtbW9udGh7dmlzaWJpbGl0eTp2aXNpYmxlfS5saXRlcGlja2VyIC5jb250YWluZXJfX21vbnRocyAubW9udGgtaXRlbS5uby1wcmV2aW91cy1tb250aCAuYnV0dG9uLXByZXZpb3VzLW1vbnRoe3Zpc2liaWxpdHk6aGlkZGVufS5saXRlcGlja2VyIC5jb250YWluZXJfX21vbnRocyAubW9udGgtaXRlbS5uby1uZXh0LW1vbnRoIC5idXR0b24tbmV4dC1tb250aHt2aXNpYmlsaXR5OmhpZGRlbn0ubGl0ZXBpY2tlciAuY29udGFpbmVyX19kYXlze2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7LW1zLWZsZXgtd3JhcDp3cmFwO2ZsZXgtd3JhcDp3cmFwO2p1c3RpZnktc2VsZjpjZW50ZXI7LXdlYmtpdC1ib3gtcGFjazpzdGFydDstbXMtZmxleC1wYWNrOnN0YXJ0O2p1c3RpZnktY29udGVudDpmbGV4LXN0YXJ0O3RleHQtYWxpZ246Y2VudGVyOy13ZWJraXQtYm94LXNpemluZzpjb250ZW50LWJveDtib3gtc2l6aW5nOmNvbnRlbnQtYm94fS5saXRlcGlja2VyIC5jb250YWluZXJfX2RheXM+ZGl2LC5saXRlcGlja2VyIC5jb250YWluZXJfX2RheXM+YXtwYWRkaW5nOjVweCAwO3dpZHRoOnZhcigtLWxpdGVwaWNrZXItZGF5LXdpZHRoKX0ubGl0ZXBpY2tlciAuY29udGFpbmVyX19kYXlzIC5kYXktaXRlbXtjb2xvcjp2YXIoLS1saXRlcGlja2VyLWRheS1jb2xvcik7dGV4dC1hbGlnbjpjZW50ZXI7dGV4dC1kZWNvcmF0aW9uOm5vbmU7Ym9yZGVyLXJhZGl1czozcHg7LXdlYmtpdC10cmFuc2l0aW9uOmNvbG9yIDAuM3MsIGJvcmRlciAwLjNzO3RyYW5zaXRpb246Y29sb3IgMC4zcywgYm9yZGVyIDAuM3M7Y3Vyc29yOmRlZmF1bHR9LmxpdGVwaWNrZXIgLmNvbnRhaW5lcl9fZGF5cyAuZGF5LWl0ZW06aG92ZXJ7Y29sb3I6dmFyKC0tbGl0ZXBpY2tlci1kYXktY29sb3ItaG92ZXIpOy13ZWJraXQtYm94LXNoYWRvdzppbnNldCAwIDAgMCAxcHggdmFyKC0tbGl0ZXBpY2tlci1kYXktY29sb3ItaG92ZXIpO2JveC1zaGFkb3c6aW5zZXQgMCAwIDAgMXB4IHZhcigtLWxpdGVwaWNrZXItZGF5LWNvbG9yLWhvdmVyKX0ubGl0ZXBpY2tlciAuY29udGFpbmVyX19kYXlzIC5kYXktaXRlbS5pcy10b2RheXtjb2xvcjp2YXIoLS1saXRlcGlja2VyLWlzLXRvZGF5LWNvbG9yKX0ubGl0ZXBpY2tlciAuY29udGFpbmVyX19kYXlzIC5kYXktaXRlbS5pcy1sb2NrZWR7Y29sb3I6dmFyKC0tbGl0ZXBpY2tlci1pcy1sb2NrZWQtY29sb3IpfS5saXRlcGlja2VyIC5jb250YWluZXJfX2RheXMgLmRheS1pdGVtLmlzLWxvY2tlZDpob3Zlcntjb2xvcjp2YXIoLS1saXRlcGlja2VyLWlzLWxvY2tlZC1jb2xvcik7LXdlYmtpdC1ib3gtc2hhZG93Om5vbmU7Ym94LXNoYWRvdzpub25lO2N1cnNvcjpkZWZhdWx0fS5saXRlcGlja2VyIC5jb250YWluZXJfX2RheXMgLmRheS1pdGVtLmlzLWluLXJhbmdle2JhY2tncm91bmQtY29sb3I6dmFyKC0tbGl0ZXBpY2tlci1pcy1pbi1yYW5nZS1jb2xvcik7Ym9yZGVyLXJhZGl1czowfS5saXRlcGlja2VyIC5jb250YWluZXJfX2RheXMgLmRheS1pdGVtLmlzLXN0YXJ0LWRhdGV7Y29sb3I6dmFyKC0tbGl0ZXBpY2tlci1pcy1zdGFydC1jb2xvcik7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1saXRlcGlja2VyLWlzLXN0YXJ0LWNvbG9yLWJnKTtib3JkZXItdG9wLWxlZnQtcmFkaXVzOjVweDtib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOjVweDtib3JkZXItdG9wLXJpZ2h0LXJhZGl1czowO2JvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOjB9LmxpdGVwaWNrZXIgLmNvbnRhaW5lcl9fZGF5cyAuZGF5LWl0ZW0uaXMtc3RhcnQtZGF0ZS5pcy1mbGlwcGVke2JvcmRlci10b3AtbGVmdC1yYWRpdXM6MDtib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOjA7Ym9yZGVyLXRvcC1yaWdodC1yYWRpdXM6NXB4O2JvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOjVweH0ubGl0ZXBpY2tlciAuY29udGFpbmVyX19kYXlzIC5kYXktaXRlbS5pcy1lbmQtZGF0ZXtjb2xvcjp2YXIoLS1saXRlcGlja2VyLWlzLWVuZC1jb2xvcik7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1saXRlcGlja2VyLWlzLWVuZC1jb2xvci1iZyk7Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1czowO2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6MDtib3JkZXItdG9wLXJpZ2h0LXJhZGl1czo1cHg7Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6NXB4fS5saXRlcGlja2VyIC5jb250YWluZXJfX2RheXMgLmRheS1pdGVtLmlzLWVuZC1kYXRlLmlzLWZsaXBwZWR7Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1czo1cHg7Ym9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czo1cHg7Ym9yZGVyLXRvcC1yaWdodC1yYWRpdXM6MDtib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czowfS5saXRlcGlja2VyIC5jb250YWluZXJfX2RheXMgLmRheS1pdGVtLmlzLXN0YXJ0LWRhdGUuaXMtZW5kLWRhdGV7Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1czo1cHg7Ym9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czo1cHg7Ym9yZGVyLXRvcC1yaWdodC1yYWRpdXM6NXB4O2JvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOjVweH0ubGl0ZXBpY2tlciAuY29udGFpbmVyX19kYXlzIC5kYXktaXRlbS5pcy1oaWdobGlnaHRlZHtjb2xvcjp2YXIoLS1saXRlcGlja2VyLWhpZ2hsaWdodGVkLWRheS1jb2xvcik7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1saXRlcGlja2VyLWhpZ2hsaWdodGVkLWRheS1jb2xvci1iZyl9LmxpdGVwaWNrZXIgLmNvbnRhaW5lcl9fZGF5cyAud2Vlay1udW1iZXJ7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDstd2Via2l0LWJveC1hbGlnbjpjZW50ZXI7LW1zLWZsZXgtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjstd2Via2l0LWJveC1wYWNrOmNlbnRlcjstbXMtZmxleC1wYWNrOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO2NvbG9yOnZhcigtLWxpdGVwaWNrZXItbW9udGgtd2Vlay1udW1iZXItY29sb3IpO2ZvbnQtc2l6ZTo4NSV9LmxpdGVwaWNrZXIgLmNvbnRhaW5lcl9fZm9vdGVye3RleHQtYWxpZ246cmlnaHQ7cGFkZGluZzoxMHB4IDVweDttYXJnaW46MCA1cHg7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1saXRlcGlja2VyLWZvb3Rlci1jb2xvci1iZyk7LXdlYmtpdC1ib3gtc2hhZG93Omluc2V0IDBweCAzcHggM3B4IDBweCB2YXIoLS1saXRlcGlja2VyLWZvb3Rlci1ib3gtc2hhZG93LWNvbG9yKTtib3gtc2hhZG93Omluc2V0IDBweCAzcHggM3B4IDBweCB2YXIoLS1saXRlcGlja2VyLWZvb3Rlci1ib3gtc2hhZG93LWNvbG9yKTtib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOjVweDtib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czo1cHh9LmxpdGVwaWNrZXIgLmNvbnRhaW5lcl9fZm9vdGVyIC5wcmV2aWV3LWRhdGUtcmFuZ2V7bWFyZ2luLXJpZ2h0OjEwcHg7Zm9udC1zaXplOjkwJX0ubGl0ZXBpY2tlciAuY29udGFpbmVyX19mb290ZXIgLmJ1dHRvbi1jYW5jZWx7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1saXRlcGlja2VyLWJ1dHRvbi1jYW5jZWwtY29sb3ItYmcpO2NvbG9yOnZhcigtLWxpdGVwaWNrZXItYnV0dG9uLWNhbmNlbC1jb2xvcik7Ym9yZGVyOjA7cGFkZGluZzozcHggN3B4IDRweDtib3JkZXItcmFkaXVzOjNweH0ubGl0ZXBpY2tlciAuY29udGFpbmVyX19mb290ZXIgLmJ1dHRvbi1jYW5jZWwgKntwb2ludGVyLWV2ZW50czpub25lfS5saXRlcGlja2VyIC5jb250YWluZXJfX2Zvb3RlciAuYnV0dG9uLWFwcGx5e2JhY2tncm91bmQtY29sb3I6dmFyKC0tbGl0ZXBpY2tlci1idXR0b24tYXBwbHktY29sb3ItYmcpO2NvbG9yOnZhcigtLWxpdGVwaWNrZXItYnV0dG9uLWFwcGx5LWNvbG9yKTtib3JkZXI6MDtwYWRkaW5nOjNweCA3cHggNHB4O2JvcmRlci1yYWRpdXM6M3B4O21hcmdpbi1sZWZ0OjEwcHg7bWFyZ2luLXJpZ2h0OjEwcHh9LmxpdGVwaWNrZXIgLmNvbnRhaW5lcl9fZm9vdGVyIC5idXR0b24tYXBwbHk6ZGlzYWJsZWR7b3BhY2l0eTowLjd9LmxpdGVwaWNrZXIgLmNvbnRhaW5lcl9fZm9vdGVyIC5idXR0b24tYXBwbHkgKntwb2ludGVyLWV2ZW50czpub25lfS5saXRlcGlja2VyIC5jb250YWluZXJfX3Rvb2x0aXB7cG9zaXRpb246YWJzb2x1dGU7bWFyZ2luLXRvcDotNHB4O3BhZGRpbmc6NHB4IDhweDtib3JkZXItcmFkaXVzOjRweDtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWxpdGVwaWNrZXItdG9vbHRpcC1jb2xvci1iZyk7LXdlYmtpdC1ib3gtc2hhZG93OjAgMXB4IDNweCByZ2JhKDAsMCwwLDAuMjUpO2JveC1zaGFkb3c6MCAxcHggM3B4IHJnYmEoMCwwLDAsMC4yNSk7d2hpdGUtc3BhY2U6bm93cmFwO2ZvbnQtc2l6ZToxMXB4O3BvaW50ZXItZXZlbnRzOm5vbmU7dmlzaWJpbGl0eTpoaWRkZW59LmxpdGVwaWNrZXIgLmNvbnRhaW5lcl9fdG9vbHRpcDpiZWZvcmV7cG9zaXRpb246YWJzb2x1dGU7Ym90dG9tOi01cHg7bGVmdDpjYWxjKDUwJSAtIDVweCk7Ym9yZGVyLXRvcDo1cHggc29saWQgcmdiYSgwLDAsMCwwLjEyKTtib3JkZXItcmlnaHQ6NXB4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1sZWZ0OjVweCBzb2xpZCB0cmFuc3BhcmVudDtjb250ZW50OlwiXCJ9LmxpdGVwaWNrZXIgLmNvbnRhaW5lcl9fdG9vbHRpcDphZnRlcntwb3NpdGlvbjphYnNvbHV0ZTtib3R0b206LTRweDtsZWZ0OmNhbGMoNTAlIC0gNHB4KTtib3JkZXItdG9wOjRweCBzb2xpZCB2YXIoLS1saXRlcGlja2VyLXRvb2x0aXAtY29sb3ItYmcpO2JvcmRlci1yaWdodDo0cHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLWxlZnQ6NHB4IHNvbGlkIHRyYW5zcGFyZW50O2NvbnRlbnQ6XCJcIn1cXG4nLFwiXCJdKSxlLmxvY2Fscz17c2hvd1dlZWtOdW1iZXJzOlwic2hvdy13ZWVrLW51bWJlcnNcIixsaXRlcGlja2VyOlwibGl0ZXBpY2tlclwiLGNvbnRhaW5lck1haW46XCJjb250YWluZXJfX21haW5cIixjb250YWluZXJNb250aHM6XCJjb250YWluZXJfX21vbnRoc1wiLGNvbHVtbnMyOlwiY29sdW1ucy0yXCIsY29sdW1uczM6XCJjb2x1bW5zLTNcIixjb2x1bW5zNDpcImNvbHVtbnMtNFwiLHNwbGl0VmlldzpcInNwbGl0LXZpZXdcIixtb250aEl0ZW1IZWFkZXI6XCJtb250aC1pdGVtLWhlYWRlclwiLGJ1dHRvblByZXZpb3VzTW9udGg6XCJidXR0b24tcHJldmlvdXMtbW9udGhcIixidXR0b25OZXh0TW9udGg6XCJidXR0b24tbmV4dC1tb250aFwiLG1vbnRoSXRlbTpcIm1vbnRoLWl0ZW1cIixtb250aEl0ZW1OYW1lOlwibW9udGgtaXRlbS1uYW1lXCIsbW9udGhJdGVtWWVhcjpcIm1vbnRoLWl0ZW0teWVhclwiLHJlc2V0QnV0dG9uOlwicmVzZXQtYnV0dG9uXCIsbW9udGhJdGVtV2Vla2RheXNSb3c6XCJtb250aC1pdGVtLXdlZWtkYXlzLXJvd1wiLG5vUHJldmlvdXNNb250aDpcIm5vLXByZXZpb3VzLW1vbnRoXCIsbm9OZXh0TW9udGg6XCJuby1uZXh0LW1vbnRoXCIsY29udGFpbmVyRGF5czpcImNvbnRhaW5lcl9fZGF5c1wiLGRheUl0ZW06XCJkYXktaXRlbVwiLGlzVG9kYXk6XCJpcy10b2RheVwiLGlzTG9ja2VkOlwiaXMtbG9ja2VkXCIsaXNJblJhbmdlOlwiaXMtaW4tcmFuZ2VcIixpc1N0YXJ0RGF0ZTpcImlzLXN0YXJ0LWRhdGVcIixpc0ZsaXBwZWQ6XCJpcy1mbGlwcGVkXCIsaXNFbmREYXRlOlwiaXMtZW5kLWRhdGVcIixpc0hpZ2hsaWdodGVkOlwiaXMtaGlnaGxpZ2h0ZWRcIix3ZWVrTnVtYmVyOlwid2Vlay1udW1iZXJcIixjb250YWluZXJGb290ZXI6XCJjb250YWluZXJfX2Zvb3RlclwiLHByZXZpZXdEYXRlUmFuZ2U6XCJwcmV2aWV3LWRhdGUtcmFuZ2VcIixidXR0b25DYW5jZWw6XCJidXR0b24tY2FuY2VsXCIsYnV0dG9uQXBwbHk6XCJidXR0b24tYXBwbHlcIixjb250YWluZXJUb29sdGlwOlwiY29udGFpbmVyX190b29sdGlwXCJ9LHQuZXhwb3J0cz1lfSxmdW5jdGlvbih0LGUsaSl7XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3ZhciBlPVtdO3JldHVybiBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWFwKChmdW5jdGlvbihlKXt2YXIgaT1mdW5jdGlvbih0LGUpe3ZhciBpPXRbMV18fFwiXCIsbj10WzNdO2lmKCFuKXJldHVybiBpO2lmKGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGJ0b2Epe3ZhciBvPShyPW4sYT1idG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShyKSkpKSxsPVwic291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIuY29uY2F0KGEpLFwiLyojIFwiLmNvbmNhdChsLFwiICovXCIpKSxzPW4uc291cmNlcy5tYXAoKGZ1bmN0aW9uKHQpe3JldHVyblwiLyojIHNvdXJjZVVSTD1cIi5jb25jYXQobi5zb3VyY2VSb290fHxcIlwiKS5jb25jYXQodCxcIiAqL1wiKX0pKTtyZXR1cm5baV0uY29uY2F0KHMpLmNvbmNhdChbb10pLmpvaW4oXCJcXG5cIil9dmFyIHIsYSxsO3JldHVybltpXS5qb2luKFwiXFxuXCIpfShlLHQpO3JldHVybiBlWzJdP1wiQG1lZGlhIFwiLmNvbmNhdChlWzJdLFwiIHtcIikuY29uY2F0KGksXCJ9XCIpOml9KSkuam9pbihcIlwiKX0sZS5pPWZ1bmN0aW9uKHQsaSxuKXtcInN0cmluZ1wiPT10eXBlb2YgdCYmKHQ9W1tudWxsLHQsXCJcIl1dKTt2YXIgbz17fTtpZihuKWZvcih2YXIgcz0wO3M8dGhpcy5sZW5ndGg7cysrKXt2YXIgcj10aGlzW3NdWzBdO251bGwhPXImJihvW3JdPSEwKX1mb3IodmFyIGE9MDthPHQubGVuZ3RoO2ErKyl7dmFyIGw9W10uY29uY2F0KHRbYV0pO24mJm9bbFswXV18fChpJiYobFsyXT9sWzJdPVwiXCIuY29uY2F0KGksXCIgYW5kIFwiKS5jb25jYXQobFsyXSk6bFsyXT1pKSxlLnB1c2gobCkpfX0sZX19LGZ1bmN0aW9uKHQsZSxpKXtcInVzZSBzdHJpY3RcIjt2YXIgbixvPXt9LHM9ZnVuY3Rpb24oKXtyZXR1cm4gdm9pZCAwPT09biYmKG49Qm9vbGVhbih3aW5kb3cmJmRvY3VtZW50JiZkb2N1bWVudC5hbGwmJiF3aW5kb3cuYXRvYikpLG59LHI9ZnVuY3Rpb24oKXt2YXIgdD17fTtyZXR1cm4gZnVuY3Rpb24oZSl7aWYodm9pZCAwPT09dFtlXSl7dmFyIGk9ZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlKTtpZih3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQmJmkgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpdHJ5e2k9aS5jb250ZW50RG9jdW1lbnQuaGVhZH1jYXRjaCh0KXtpPW51bGx9dFtlXT1pfXJldHVybiB0W2VdfX0oKTtmdW5jdGlvbiBhKHQsZSl7Zm9yKHZhciBpPVtdLG49e30sbz0wO288dC5sZW5ndGg7bysrKXt2YXIgcz10W29dLHI9ZS5iYXNlP3NbMF0rZS5iYXNlOnNbMF0sYT17Y3NzOnNbMV0sbWVkaWE6c1syXSxzb3VyY2VNYXA6c1szXX07bltyXT9uW3JdLnBhcnRzLnB1c2goYSk6aS5wdXNoKG5bcl09e2lkOnIscGFydHM6W2FdfSl9cmV0dXJuIGl9ZnVuY3Rpb24gbCh0LGUpe2Zvcih2YXIgaT0wO2k8dC5sZW5ndGg7aSsrKXt2YXIgbj10W2ldLHM9b1tuLmlkXSxyPTA7aWYocyl7Zm9yKHMucmVmcysrO3I8cy5wYXJ0cy5sZW5ndGg7cisrKXMucGFydHNbcl0obi5wYXJ0c1tyXSk7Zm9yKDtyPG4ucGFydHMubGVuZ3RoO3IrKylzLnBhcnRzLnB1c2goZyhuLnBhcnRzW3JdLGUpKX1lbHNle2Zvcih2YXIgYT1bXTtyPG4ucGFydHMubGVuZ3RoO3IrKylhLnB1c2goZyhuLnBhcnRzW3JdLGUpKTtvW24uaWRdPXtpZDpuLmlkLHJlZnM6MSxwYXJ0czphfX19fWZ1bmN0aW9uIGModCl7dmFyIGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO2lmKHZvaWQgMD09PXQuYXR0cmlidXRlcy5ub25jZSl7dmFyIG49aS5uYztuJiYodC5hdHRyaWJ1dGVzLm5vbmNlPW4pfWlmKE9iamVjdC5rZXlzKHQuYXR0cmlidXRlcykuZm9yRWFjaCgoZnVuY3Rpb24oaSl7ZS5zZXRBdHRyaWJ1dGUoaSx0LmF0dHJpYnV0ZXNbaV0pfSkpLFwiZnVuY3Rpb25cIj09dHlwZW9mIHQuaW5zZXJ0KXQuaW5zZXJ0KGUpO2Vsc2V7dmFyIG89cih0Lmluc2VydHx8XCJoZWFkXCIpO2lmKCFvKXRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0JyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7by5hcHBlbmRDaGlsZChlKX1yZXR1cm4gZX12YXIgaCxwPShoPVtdLGZ1bmN0aW9uKHQsZSl7cmV0dXJuIGhbdF09ZSxoLmZpbHRlcihCb29sZWFuKS5qb2luKFwiXFxuXCIpfSk7ZnVuY3Rpb24gZCh0LGUsaSxuKXt2YXIgbz1pP1wiXCI6bi5jc3M7aWYodC5zdHlsZVNoZWV0KXQuc3R5bGVTaGVldC5jc3NUZXh0PXAoZSxvKTtlbHNle3ZhciBzPWRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG8pLHI9dC5jaGlsZE5vZGVzO3JbZV0mJnQucmVtb3ZlQ2hpbGQocltlXSksci5sZW5ndGg/dC5pbnNlcnRCZWZvcmUocyxyW2VdKTp0LmFwcGVuZENoaWxkKHMpfX1mdW5jdGlvbiB1KHQsZSxpKXt2YXIgbj1pLmNzcyxvPWkubWVkaWEscz1pLnNvdXJjZU1hcDtpZihvJiZ0LnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsbykscyYmYnRvYSYmKG4rPVwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIi5jb25jYXQoYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkocykpKSksXCIgKi9cIikpLHQuc3R5bGVTaGVldCl0LnN0eWxlU2hlZXQuY3NzVGV4dD1uO2Vsc2V7Zm9yKDt0LmZpcnN0Q2hpbGQ7KXQucmVtb3ZlQ2hpbGQodC5maXJzdENoaWxkKTt0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG4pKX19dmFyIG09bnVsbCxmPTA7ZnVuY3Rpb24gZyh0LGUpe3ZhciBpLG4sbztpZihlLnNpbmdsZXRvbil7dmFyIHM9ZisrO2k9bXx8KG09YyhlKSksbj1kLmJpbmQobnVsbCxpLHMsITEpLG89ZC5iaW5kKG51bGwsaSxzLCEwKX1lbHNlIGk9YyhlKSxuPXUuYmluZChudWxsLGksZSksbz1mdW5jdGlvbigpeyFmdW5jdGlvbih0KXtpZihudWxsPT09dC5wYXJlbnROb2RlKXJldHVybiExO3QucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0KX0oaSl9O3JldHVybiBuKHQpLGZ1bmN0aW9uKGUpe2lmKGUpe2lmKGUuY3NzPT09dC5jc3MmJmUubWVkaWE9PT10Lm1lZGlhJiZlLnNvdXJjZU1hcD09PXQuc291cmNlTWFwKXJldHVybjtuKHQ9ZSl9ZWxzZSBvKCl9fXQuZXhwb3J0cz1mdW5jdGlvbih0LGUpeyhlPWV8fHt9KS5hdHRyaWJ1dGVzPVwib2JqZWN0XCI9PXR5cGVvZiBlLmF0dHJpYnV0ZXM/ZS5hdHRyaWJ1dGVzOnt9LGUuc2luZ2xldG9ufHxcImJvb2xlYW5cIj09dHlwZW9mIGUuc2luZ2xldG9ufHwoZS5zaW5nbGV0b249cygpKTt2YXIgaT1hKHQsZSk7cmV0dXJuIGwoaSxlKSxmdW5jdGlvbih0KXtmb3IodmFyIG49W10scz0wO3M8aS5sZW5ndGg7cysrKXt2YXIgcj1pW3NdLGM9b1tyLmlkXTtjJiYoYy5yZWZzLS0sbi5wdXNoKGMpKX10JiZsKGEodCxlKSxlKTtmb3IodmFyIGg9MDtoPG4ubGVuZ3RoO2grKyl7dmFyIHA9bltoXTtpZigwPT09cC5yZWZzKXtmb3IodmFyIGQ9MDtkPHAucGFydHMubGVuZ3RoO2QrKylwLnBhcnRzW2RdKCk7ZGVsZXRlIG9bcC5pZF19fX19fSxmdW5jdGlvbih0LGUsaSl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49dGhpcyYmdGhpcy5fX2Fzc2lnbnx8ZnVuY3Rpb24oKXtyZXR1cm4obj1PYmplY3QuYXNzaWdufHxmdW5jdGlvbih0KXtmb3IodmFyIGUsaT0xLG49YXJndW1lbnRzLmxlbmd0aDtpPG47aSsrKWZvcih2YXIgbyBpbiBlPWFyZ3VtZW50c1tpXSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxvKSYmKHRbb109ZVtvXSk7cmV0dXJuIHR9KS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBvPWkoMCkscz1pKDEpLHI9aSgyKTtzLkxpdGVwaWNrZXIucHJvdG90eXBlLnNob3c9ZnVuY3Rpb24odCl7dm9pZCAwPT09dCYmKHQ9bnVsbCksdGhpcy5lbWl0KFwiYmVmb3JlOnNob3dcIix0KTt2YXIgZT10fHx0aGlzLm9wdGlvbnMuZWxlbWVudDtpZih0aGlzLnRyaWdnZXJFbGVtZW50PWUsIXRoaXMuaXNTaG93bmluZygpKXtpZih0aGlzLm9wdGlvbnMuaW5saW5lTW9kZSlyZXR1cm4gdGhpcy51aS5zdHlsZS5wb3NpdGlvbj1cInJlbGF0aXZlXCIsdGhpcy51aS5zdHlsZS5kaXNwbGF5PVwiaW5saW5lLWJsb2NrXCIsdGhpcy51aS5zdHlsZS50b3A9bnVsbCx0aGlzLnVpLnN0eWxlLmxlZnQ9bnVsbCx0aGlzLnVpLnN0eWxlLmJvdHRvbT1udWxsLHZvaWQodGhpcy51aS5zdHlsZS5yaWdodD1udWxsKTt0aGlzLnNjcm9sbFRvRGF0ZSh0KSx0aGlzLnJlbmRlcigpLHRoaXMudWkuc3R5bGUucG9zaXRpb249XCJhYnNvbHV0ZVwiLHRoaXMudWkuc3R5bGUuZGlzcGxheT1cImJsb2NrXCIsdGhpcy51aS5zdHlsZS56SW5kZXg9dGhpcy5vcHRpb25zLnpJbmRleDt2YXIgaT10aGlzLmZpbmRQb3NpdGlvbihlKTt0aGlzLnVpLnN0eWxlLnRvcD1pLnRvcCtcInB4XCIsdGhpcy51aS5zdHlsZS5sZWZ0PWkubGVmdCtcInB4XCIsdGhpcy51aS5zdHlsZS5yaWdodD1udWxsLHRoaXMudWkuc3R5bGUuYm90dG9tPW51bGwsdGhpcy5lbWl0KFwic2hvd1wiLHQpfX0scy5MaXRlcGlja2VyLnByb3RvdHlwZS5oaWRlPWZ1bmN0aW9uKCl7dGhpcy5pc1Nob3duaW5nKCkmJih0aGlzLmRhdGVQaWNrZWQubGVuZ3RoPTAsdGhpcy51cGRhdGVJbnB1dCgpLHRoaXMub3B0aW9ucy5pbmxpbmVNb2RlP3RoaXMucmVuZGVyKCk6KHRoaXMudWkuc3R5bGUuZGlzcGxheT1cIm5vbmVcIix0aGlzLmVtaXQoXCJoaWRlXCIpKSl9LHMuTGl0ZXBpY2tlci5wcm90b3R5cGUuZ2V0RGF0ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdldFN0YXJ0RGF0ZSgpfSxzLkxpdGVwaWNrZXIucHJvdG90eXBlLmdldFN0YXJ0RGF0ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLm9wdGlvbnMuc3RhcnREYXRlP3RoaXMub3B0aW9ucy5zdGFydERhdGUuY2xvbmUoKTpudWxsfSxzLkxpdGVwaWNrZXIucHJvdG90eXBlLmdldEVuZERhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vcHRpb25zLmVuZERhdGU/dGhpcy5vcHRpb25zLmVuZERhdGUuY2xvbmUoKTpudWxsfSxzLkxpdGVwaWNrZXIucHJvdG90eXBlLnNldERhdGU9ZnVuY3Rpb24odCxlKXt2b2lkIDA9PT1lJiYoZT0hMSk7dmFyIGk9bmV3IG8uRGF0ZVRpbWUodCx0aGlzLm9wdGlvbnMuZm9ybWF0LHRoaXMub3B0aW9ucy5sYW5nKTtyLmRhdGVJc0xvY2tlZChpLHRoaXMub3B0aW9ucyxbaV0pJiYhZT90aGlzLmVtaXQoXCJlcnJvcjpkYXRlXCIsaSk6KHRoaXMuc2V0U3RhcnREYXRlKHQpLHRoaXMub3B0aW9ucy5pbmxpbmVNb2RlJiZ0aGlzLnJlbmRlcigpLHRoaXMuZW1pdChcInNlbGVjdGVkXCIsdGhpcy5nZXREYXRlKCkpKX0scy5MaXRlcGlja2VyLnByb3RvdHlwZS5zZXRTdGFydERhdGU9ZnVuY3Rpb24odCl7dCYmKHRoaXMub3B0aW9ucy5zdGFydERhdGU9bmV3IG8uRGF0ZVRpbWUodCx0aGlzLm9wdGlvbnMuZm9ybWF0LHRoaXMub3B0aW9ucy5sYW5nKSx0aGlzLnVwZGF0ZUlucHV0KCkpfSxzLkxpdGVwaWNrZXIucHJvdG90eXBlLnNldEVuZERhdGU9ZnVuY3Rpb24odCl7dCYmKHRoaXMub3B0aW9ucy5lbmREYXRlPW5ldyBvLkRhdGVUaW1lKHQsdGhpcy5vcHRpb25zLmZvcm1hdCx0aGlzLm9wdGlvbnMubGFuZyksdGhpcy5vcHRpb25zLnN0YXJ0RGF0ZS5nZXRUaW1lKCk+dGhpcy5vcHRpb25zLmVuZERhdGUuZ2V0VGltZSgpJiYodGhpcy5vcHRpb25zLmVuZERhdGU9dGhpcy5vcHRpb25zLnN0YXJ0RGF0ZS5jbG9uZSgpLHRoaXMub3B0aW9ucy5zdGFydERhdGU9bmV3IG8uRGF0ZVRpbWUodCx0aGlzLm9wdGlvbnMuZm9ybWF0LHRoaXMub3B0aW9ucy5sYW5nKSksdGhpcy51cGRhdGVJbnB1dCgpKX0scy5MaXRlcGlja2VyLnByb3RvdHlwZS5zZXREYXRlUmFuZ2U9ZnVuY3Rpb24odCxlLGkpe3ZvaWQgMD09PWkmJihpPSExKSx0aGlzLnRyaWdnZXJFbGVtZW50PXZvaWQgMDt2YXIgbj1uZXcgby5EYXRlVGltZSh0LHRoaXMub3B0aW9ucy5mb3JtYXQsdGhpcy5vcHRpb25zLmxhbmcpLHM9bmV3IG8uRGF0ZVRpbWUoZSx0aGlzLm9wdGlvbnMuZm9ybWF0LHRoaXMub3B0aW9ucy5sYW5nKTsodGhpcy5vcHRpb25zLmRpc2FsbG93TG9ja0RheXNJblJhbmdlP3IucmFuZ2VJc0xvY2tlZChbbixzXSx0aGlzLm9wdGlvbnMpOnIuZGF0ZUlzTG9ja2VkKG4sdGhpcy5vcHRpb25zLFtuLHNdKXx8ci5kYXRlSXNMb2NrZWQocyx0aGlzLm9wdGlvbnMsW24sc10pKSYmIWk/dGhpcy5lbWl0KFwiZXJyb3I6cmFuZ2VcIixbbixzXSk6KHRoaXMuc2V0U3RhcnREYXRlKG4pLHRoaXMuc2V0RW5kRGF0ZShzKSx0aGlzLm9wdGlvbnMuaW5saW5lTW9kZSYmdGhpcy5yZW5kZXIoKSx0aGlzLnVwZGF0ZUlucHV0KCksdGhpcy5lbWl0KFwic2VsZWN0ZWRcIix0aGlzLmdldFN0YXJ0RGF0ZSgpLHRoaXMuZ2V0RW5kRGF0ZSgpKSl9LHMuTGl0ZXBpY2tlci5wcm90b3R5cGUuZ290b0RhdGU9ZnVuY3Rpb24odCxlKXt2b2lkIDA9PT1lJiYoZT0wKTt2YXIgaT1uZXcgby5EYXRlVGltZSh0KTtpLnNldERhdGUoMSksdGhpcy5jYWxlbmRhcnNbZV09aS5jbG9uZSgpLHRoaXMucmVuZGVyKCl9LHMuTGl0ZXBpY2tlci5wcm90b3R5cGUuc2V0TG9ja0RheXM9ZnVuY3Rpb24odCl7dGhpcy5vcHRpb25zLmxvY2tEYXlzPW8uRGF0ZVRpbWUuY29udmVydEFycmF5KHQsdGhpcy5vcHRpb25zLmxvY2tEYXlzRm9ybWF0KSx0aGlzLnJlbmRlcigpfSxzLkxpdGVwaWNrZXIucHJvdG90eXBlLnNldEhpZ2hsaWdodGVkRGF5cz1mdW5jdGlvbih0KXt0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0ZWREYXlzPW8uRGF0ZVRpbWUuY29udmVydEFycmF5KHQsdGhpcy5vcHRpb25zLmhpZ2hsaWdodGVkRGF5c0Zvcm1hdCksdGhpcy5yZW5kZXIoKX0scy5MaXRlcGlja2VyLnByb3RvdHlwZS5zZXRPcHRpb25zPWZ1bmN0aW9uKHQpe2RlbGV0ZSB0LmVsZW1lbnQsZGVsZXRlIHQuZWxlbWVudEVuZCxkZWxldGUgdC5wYXJlbnRFbCx0LnN0YXJ0RGF0ZSYmKHQuc3RhcnREYXRlPW5ldyBvLkRhdGVUaW1lKHQuc3RhcnREYXRlLHRoaXMub3B0aW9ucy5mb3JtYXQsdGhpcy5vcHRpb25zLmxhbmcpKSx0LmVuZERhdGUmJih0LmVuZERhdGU9bmV3IG8uRGF0ZVRpbWUodC5lbmREYXRlLHRoaXMub3B0aW9ucy5mb3JtYXQsdGhpcy5vcHRpb25zLmxhbmcpKTt2YXIgZT1uKG4oe30sdGhpcy5vcHRpb25zLmRyb3Bkb3ducyksdC5kcm9wZG93bnMpLGk9bihuKHt9LHRoaXMub3B0aW9ucy5idXR0b25UZXh0KSx0LmJ1dHRvblRleHQpLHM9bihuKHt9LHRoaXMub3B0aW9ucy50b29sdGlwVGV4dCksdC50b29sdGlwVGV4dCk7dGhpcy5vcHRpb25zPW4obih7fSx0aGlzLm9wdGlvbnMpLHQpLHRoaXMub3B0aW9ucy5kcm9wZG93bnM9bih7fSxlKSx0aGlzLm9wdGlvbnMuYnV0dG9uVGV4dD1uKHt9LGkpLHRoaXMub3B0aW9ucy50b29sdGlwVGV4dD1uKHt9LHMpLCF0aGlzLm9wdGlvbnMuc2luZ2xlTW9kZXx8dGhpcy5vcHRpb25zLnN0YXJ0RGF0ZSBpbnN0YW5jZW9mIG8uRGF0ZVRpbWV8fCh0aGlzLm9wdGlvbnMuc3RhcnREYXRlPW51bGwsdGhpcy5vcHRpb25zLmVuZERhdGU9bnVsbCksdGhpcy5vcHRpb25zLnNpbmdsZU1vZGV8fHRoaXMub3B0aW9ucy5zdGFydERhdGUgaW5zdGFuY2VvZiBvLkRhdGVUaW1lJiZ0aGlzLm9wdGlvbnMuZW5kRGF0ZSBpbnN0YW5jZW9mIG8uRGF0ZVRpbWV8fCh0aGlzLm9wdGlvbnMuc3RhcnREYXRlPW51bGwsdGhpcy5vcHRpb25zLmVuZERhdGU9bnVsbCk7Zm9yKHZhciByPTA7cjx0aGlzLm9wdGlvbnMubnVtYmVyT2ZNb250aHM7cis9MSl7dmFyIGE9dGhpcy5vcHRpb25zLnN0YXJ0RGF0ZT90aGlzLm9wdGlvbnMuc3RhcnREYXRlLmNsb25lKCk6bmV3IG8uRGF0ZVRpbWU7YS5zZXREYXRlKDEpLGEuc2V0TW9udGgoYS5nZXRNb250aCgpK3IpLHRoaXMuY2FsZW5kYXJzW3JdPWF9dGhpcy5vcHRpb25zLmxvY2tEYXlzLmxlbmd0aCYmKHRoaXMub3B0aW9ucy5sb2NrRGF5cz1vLkRhdGVUaW1lLmNvbnZlcnRBcnJheSh0aGlzLm9wdGlvbnMubG9ja0RheXMsdGhpcy5vcHRpb25zLmxvY2tEYXlzRm9ybWF0KSksdGhpcy5vcHRpb25zLmhpZ2hsaWdodGVkRGF5cy5sZW5ndGgmJih0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0ZWREYXlzPW8uRGF0ZVRpbWUuY29udmVydEFycmF5KHRoaXMub3B0aW9ucy5oaWdobGlnaHRlZERheXMsdGhpcy5vcHRpb25zLmhpZ2hsaWdodGVkRGF5c0Zvcm1hdCkpLHRoaXMucmVuZGVyKCksdGhpcy5vcHRpb25zLmlubGluZU1vZGUmJnRoaXMuc2hvdygpLHRoaXMudXBkYXRlSW5wdXQoKX0scy5MaXRlcGlja2VyLnByb3RvdHlwZS5jbGVhclNlbGVjdGlvbj1mdW5jdGlvbigpe3RoaXMub3B0aW9ucy5zdGFydERhdGU9bnVsbCx0aGlzLm9wdGlvbnMuZW5kRGF0ZT1udWxsLHRoaXMuZGF0ZVBpY2tlZC5sZW5ndGg9MCx0aGlzLnVwZGF0ZUlucHV0KCksdGhpcy5pc1Nob3duaW5nKCkmJnRoaXMucmVuZGVyKCksdGhpcy5lbWl0KFwiY2xlYXI6c2VsZWN0aW9uXCIpfSxzLkxpdGVwaWNrZXIucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXt0aGlzLnVpJiZ0aGlzLnVpLnBhcmVudE5vZGUmJih0aGlzLnVpLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy51aSksdGhpcy51aT1udWxsKSx0aGlzLmVtaXQoXCJkZXN0cm95XCIpfX1dKX0pKTsiLCIvKiFcbiAqIFxuICogcGx1Z2lucy9tb2JpbGVmcmllbmRseS5qc1xuICogTGl0ZXBpY2tlciB2Mi4wLjEyIChodHRwczovL2dpdGh1Yi5jb20vd2FraXJpbi9MaXRlcGlja2VyKVxuICogUGFja2FnZTogbGl0ZXBpY2tlciAoaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbGl0ZXBpY2tlcilcbiAqIExpY2Vuc2U6IE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3dha2lyaW4vTGl0ZXBpY2tlci9ibG9iL21hc3Rlci9MSUNFTkNFLm1kKVxuICogQ29weXJpZ2h0IDIwMTktMjAyMSBSaW5hdCBHLlxuICogICAgIFxuICogSGFzaDogYjlhNjQ4MjA3YWFiZTMxYjI5MTJcbiAqIFxuICovIWZ1bmN0aW9uKGUpe3ZhciB0PXt9O2Z1bmN0aW9uIG4ocil7aWYodFtyXSlyZXR1cm4gdFtyXS5leHBvcnRzO3ZhciBpPXRbcl09e2k6cixsOiExLGV4cG9ydHM6e319O3JldHVybiBlW3JdLmNhbGwoaS5leHBvcnRzLGksaS5leHBvcnRzLG4pLGkubD0hMCxpLmV4cG9ydHN9bi5tPWUsbi5jPXQsbi5kPWZ1bmN0aW9uKGUsdCxyKXtuLm8oZSx0KXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7ZW51bWVyYWJsZTohMCxnZXQ6cn0pfSxuLnI9ZnVuY3Rpb24oZSl7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLnRvU3RyaW5nVGFnJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOlwiTW9kdWxlXCJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX0sbi50PWZ1bmN0aW9uKGUsdCl7aWYoMSZ0JiYoZT1uKGUpKSw4JnQpcmV0dXJuIGU7aWYoNCZ0JiZcIm9iamVjdFwiPT10eXBlb2YgZSYmZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciByPU9iamVjdC5jcmVhdGUobnVsbCk7aWYobi5yKHIpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOiEwLHZhbHVlOmV9KSwyJnQmJlwic3RyaW5nXCIhPXR5cGVvZiBlKWZvcih2YXIgaSBpbiBlKW4uZChyLGksZnVuY3Rpb24odCl7cmV0dXJuIGVbdF19LmJpbmQobnVsbCxpKSk7cmV0dXJuIHJ9LG4ubj1mdW5jdGlvbihlKXt2YXIgdD1lJiZlLl9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gZS5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiBlfTtyZXR1cm4gbi5kKHQsXCJhXCIsdCksdH0sbi5vPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpfSxuLnA9XCJcIixuKG4ucz01KX0oW2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9ZnVuY3Rpb24oZSl7dmFyIHQ9W107cmV0dXJuIHQudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXAoKGZ1bmN0aW9uKHQpe3ZhciBuPWZ1bmN0aW9uKGUsdCl7dmFyIG49ZVsxXXx8XCJcIixyPWVbM107aWYoIXIpcmV0dXJuIG47aWYodCYmXCJmdW5jdGlvblwiPT10eXBlb2YgYnRvYSl7dmFyIGk9KGE9cixsPWJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KGEpKSkpLGM9XCJzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIi5jb25jYXQobCksXCIvKiMgXCIuY29uY2F0KGMsXCIgKi9cIikpLG89ci5zb3VyY2VzLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuXCIvKiMgc291cmNlVVJMPVwiLmNvbmNhdChyLnNvdXJjZVJvb3R8fFwiXCIpLmNvbmNhdChlLFwiICovXCIpfSkpO3JldHVybltuXS5jb25jYXQobykuY29uY2F0KFtpXSkuam9pbihcIlxcblwiKX12YXIgYSxsLGM7cmV0dXJuW25dLmpvaW4oXCJcXG5cIil9KHQsZSk7cmV0dXJuIHRbMl0/XCJAbWVkaWEgXCIuY29uY2F0KHRbMl0sXCIge1wiKS5jb25jYXQobixcIn1cIik6bn0pKS5qb2luKFwiXCIpfSx0Lmk9ZnVuY3Rpb24oZSxuLHIpe1wic3RyaW5nXCI9PXR5cGVvZiBlJiYoZT1bW251bGwsZSxcIlwiXV0pO3ZhciBpPXt9O2lmKHIpZm9yKHZhciBvPTA7bzx0aGlzLmxlbmd0aDtvKyspe3ZhciBhPXRoaXNbb11bMF07bnVsbCE9YSYmKGlbYV09ITApfWZvcih2YXIgbD0wO2w8ZS5sZW5ndGg7bCsrKXt2YXIgYz1bXS5jb25jYXQoZVtsXSk7ciYmaVtjWzBdXXx8KG4mJihjWzJdP2NbMl09XCJcIi5jb25jYXQobixcIiBhbmQgXCIpLmNvbmNhdChjWzJdKTpjWzJdPW4pLHQucHVzaChjKSl9fSx0fX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO3ZhciByLGk9e30sbz1mdW5jdGlvbigpe3JldHVybiB2b2lkIDA9PT1yJiYocj1Cb29sZWFuKHdpbmRvdyYmZG9jdW1lbnQmJmRvY3VtZW50LmFsbCYmIXdpbmRvdy5hdG9iKSkscn0sYT1mdW5jdGlvbigpe3ZhciBlPXt9O3JldHVybiBmdW5jdGlvbih0KXtpZih2b2lkIDA9PT1lW3RdKXt2YXIgbj1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKHQpO2lmKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCYmbiBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCl0cnl7bj1uLmNvbnRlbnREb2N1bWVudC5oZWFkfWNhdGNoKGUpe249bnVsbH1lW3RdPW59cmV0dXJuIGVbdF19fSgpO2Z1bmN0aW9uIGwoZSx0KXtmb3IodmFyIG49W10scj17fSxpPTA7aTxlLmxlbmd0aDtpKyspe3ZhciBvPWVbaV0sYT10LmJhc2U/b1swXSt0LmJhc2U6b1swXSxsPXtjc3M6b1sxXSxtZWRpYTpvWzJdLHNvdXJjZU1hcDpvWzNdfTtyW2FdP3JbYV0ucGFydHMucHVzaChsKTpuLnB1c2goclthXT17aWQ6YSxwYXJ0czpbbF19KX1yZXR1cm4gbn1mdW5jdGlvbiBjKGUsdCl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciByPWVbbl0sbz1pW3IuaWRdLGE9MDtpZihvKXtmb3Ioby5yZWZzKys7YTxvLnBhcnRzLmxlbmd0aDthKyspby5wYXJ0c1thXShyLnBhcnRzW2FdKTtmb3IoO2E8ci5wYXJ0cy5sZW5ndGg7YSsrKW8ucGFydHMucHVzaChiKHIucGFydHNbYV0sdCkpfWVsc2V7Zm9yKHZhciBsPVtdO2E8ci5wYXJ0cy5sZW5ndGg7YSsrKWwucHVzaChiKHIucGFydHNbYV0sdCkpO2lbci5pZF09e2lkOnIuaWQscmVmczoxLHBhcnRzOmx9fX19ZnVuY3Rpb24gcyhlKXt2YXIgdD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7aWYodm9pZCAwPT09ZS5hdHRyaWJ1dGVzLm5vbmNlKXt2YXIgcj1uLm5jO3ImJihlLmF0dHJpYnV0ZXMubm9uY2U9cil9aWYoT2JqZWN0LmtleXMoZS5hdHRyaWJ1dGVzKS5mb3JFYWNoKChmdW5jdGlvbihuKXt0LnNldEF0dHJpYnV0ZShuLGUuYXR0cmlidXRlc1tuXSl9KSksXCJmdW5jdGlvblwiPT10eXBlb2YgZS5pbnNlcnQpZS5pbnNlcnQodCk7ZWxzZXt2YXIgaT1hKGUuaW5zZXJ0fHxcImhlYWRcIik7aWYoIWkpdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtpLmFwcGVuZENoaWxkKHQpfXJldHVybiB0fXZhciB1LGQ9KHU9W10sZnVuY3Rpb24oZSx0KXtyZXR1cm4gdVtlXT10LHUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCJcXG5cIil9KTtmdW5jdGlvbiBwKGUsdCxuLHIpe3ZhciBpPW4/XCJcIjpyLmNzcztpZihlLnN0eWxlU2hlZXQpZS5zdHlsZVNoZWV0LmNzc1RleHQ9ZCh0LGkpO2Vsc2V7dmFyIG89ZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoaSksYT1lLmNoaWxkTm9kZXM7YVt0XSYmZS5yZW1vdmVDaGlsZChhW3RdKSxhLmxlbmd0aD9lLmluc2VydEJlZm9yZShvLGFbdF0pOmUuYXBwZW5kQ2hpbGQobyl9fWZ1bmN0aW9uIGYoZSx0LG4pe3ZhciByPW4uY3NzLGk9bi5tZWRpYSxvPW4uc291cmNlTWFwO2lmKGkmJmUuc2V0QXR0cmlidXRlKFwibWVkaWFcIixpKSxvJiZidG9hJiYocis9XCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiLmNvbmNhdChidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShvKSkpKSxcIiAqL1wiKSksZS5zdHlsZVNoZWV0KWUuc3R5bGVTaGVldC5jc3NUZXh0PXI7ZWxzZXtmb3IoO2UuZmlyc3RDaGlsZDspZS5yZW1vdmVDaGlsZChlLmZpcnN0Q2hpbGQpO2UuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocikpfX12YXIgbT1udWxsLGg9MDtmdW5jdGlvbiBiKGUsdCl7dmFyIG4scixpO2lmKHQuc2luZ2xldG9uKXt2YXIgbz1oKys7bj1tfHwobT1zKHQpKSxyPXAuYmluZChudWxsLG4sbywhMSksaT1wLmJpbmQobnVsbCxuLG8sITApfWVsc2Ugbj1zKHQpLHI9Zi5iaW5kKG51bGwsbix0KSxpPWZ1bmN0aW9uKCl7IWZ1bmN0aW9uKGUpe2lmKG51bGw9PT1lLnBhcmVudE5vZGUpcmV0dXJuITE7ZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGUpfShuKX07cmV0dXJuIHIoZSksZnVuY3Rpb24odCl7aWYodCl7aWYodC5jc3M9PT1lLmNzcyYmdC5tZWRpYT09PWUubWVkaWEmJnQuc291cmNlTWFwPT09ZS5zb3VyY2VNYXApcmV0dXJuO3IoZT10KX1lbHNlIGkoKX19ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCl7KHQ9dHx8e30pLmF0dHJpYnV0ZXM9XCJvYmplY3RcIj09dHlwZW9mIHQuYXR0cmlidXRlcz90LmF0dHJpYnV0ZXM6e30sdC5zaW5nbGV0b258fFwiYm9vbGVhblwiPT10eXBlb2YgdC5zaW5nbGV0b258fCh0LnNpbmdsZXRvbj1vKCkpO3ZhciBuPWwoZSx0KTtyZXR1cm4gYyhuLHQpLGZ1bmN0aW9uKGUpe2Zvcih2YXIgcj1bXSxvPTA7bzxuLmxlbmd0aDtvKyspe3ZhciBhPW5bb10scz1pW2EuaWRdO3MmJihzLnJlZnMtLSxyLnB1c2gocykpfWUmJmMobChlLHQpLHQpO2Zvcih2YXIgdT0wO3U8ci5sZW5ndGg7dSsrKXt2YXIgZD1yW3VdO2lmKDA9PT1kLnJlZnMpe2Zvcih2YXIgcD0wO3A8ZC5wYXJ0cy5sZW5ndGg7cCsrKWQucGFydHNbcF0oKTtkZWxldGUgaVtkLmlkXX19fX19LCwsLGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtuLnIodCk7big2KTtmdW5jdGlvbiByKGUsdCl7dmFyIG49T2JqZWN0LmtleXMoZSk7aWYoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyl7dmFyIHI9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTt0JiYocj1yLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSx0KS5lbnVtZXJhYmxlfSkpKSxuLnB1c2guYXBwbHkobixyKX1yZXR1cm4gbn1mdW5jdGlvbiBpKGUpe2Zvcih2YXIgdD0xO3Q8YXJndW1lbnRzLmxlbmd0aDt0Kyspe3ZhciBuPW51bGwhPWFyZ3VtZW50c1t0XT9hcmd1bWVudHNbdF06e307dCUyP3IoT2JqZWN0KG4pLCEwKS5mb3JFYWNoKChmdW5jdGlvbih0KXtvKGUsdCxuW3RdKX0pKTpPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycz9PYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG4pKTpyKE9iamVjdChuKSkuZm9yRWFjaCgoZnVuY3Rpb24odCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sdCkpfSkpfXJldHVybiBlfWZ1bmN0aW9uIG8oZSx0LG4pe3JldHVybiB0IGluIGU/T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7dmFsdWU6bixlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmVbdF09bixlfUxpdGVwaWNrZXIuYWRkKFwibW9iaWxlZnJpZW5kbHlcIix7aW5pdDpmdW5jdGlvbihlKXt2YXIgdD1lLm9wdGlvbnM7ZS5vcHRpb25zLm1vYmlsZWZyaWVuZGx5PWkoaSh7fSx7YnJlYWtwb2ludDo0ODB9KSx0Lm1vYmlsZWZyaWVuZGx5KSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLHt4VG91Y2hEb3duOnt2YWx1ZTpudWxsLHdyaXRhYmxlOiEwfSx5VG91Y2hEb3duOnt2YWx1ZTpudWxsLHdyaXRhYmxlOiEwfSx0b3VjaFRhcmdldE1vbnRoOnt2YWx1ZTpudWxsLHdyaXRhYmxlOiEwfX0pO3ZhciBuPSExO3RyeXt2YXIgcj1PYmplY3QuZGVmaW5lUHJvcGVydHkoe30sXCJwYXNzaXZlXCIse2dldDpmdW5jdGlvbigpe249ITB9fSk7d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0ZXN0UGFzc2l2ZVwiLG51bGwsciksd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0ZXN0UGFzc2l2ZVwiLG51bGwscil9Y2F0Y2goZSl7fWZ1bmN0aW9uIG8oKXt2YXIgdD1cInBvcnRyYWl0XCI9PT1hKCk7cmV0dXJuIHdpbmRvdy5tYXRjaE1lZGlhKFwiKG1heC1kZXZpY2UtXCIuY29uY2F0KHQ/XCJ3aWR0aFwiOlwiaGVpZ2h0XCIsXCI6IFwiKS5jb25jYXQoZS5vcHRpb25zLm1vYmlsZWZyaWVuZGx5LmJyZWFrcG9pbnQsXCJweClcIikpLm1hdGNoZXN9ZnVuY3Rpb24gYSgpe3JldHVyblwib3JpZW50YXRpb25cImluIHdpbmRvdy5zY3JlZW4mJlwidHlwZVwiaW4gd2luZG93LnNjcmVlbi5vcmllbnRhdGlvbj93aW5kb3cuc2NyZWVuLm9yaWVudGF0aW9uLnR5cGUucmVwbGFjZSgvXFwtXFx3KyQvLFwiXCIpOndpbmRvdy5tYXRjaE1lZGlhKFwiKG9yaWVudGF0aW9uOiBwb3J0cmFpdClcIikubWF0Y2hlcz9cInBvcnRyYWl0XCI6XCJsYW5kc2NhcGVcIn1mdW5jdGlvbiBsKCl7XCJwb3J0cmFpdFwiPT09YSgpPyhlLm9wdGlvbnMubnVtYmVyT2ZNb250aHM9MSxlLm9wdGlvbnMubnVtYmVyT2ZDb2x1bW5zPTEpOihlLm9wdGlvbnMubnVtYmVyT2ZNb250aHM9MixlLm9wdGlvbnMubnVtYmVyT2ZDb2x1bW5zPTIpfXZhciBjPWZ1bmN0aW9uKHQpe3ZhciBuPXQudG91Y2hlc1swXTtlLnhUb3VjaERvd249bi5jbGllbnRYLGUueVRvdWNoRG93bj1uLmNsaWVudFl9LHM9ZnVuY3Rpb24odCl7aWYoZS54VG91Y2hEb3duJiZlLnlUb3VjaERvd24pe3ZhciBuPXQudG91Y2hlc1swXS5jbGllbnRYLHI9dC50b3VjaGVzWzBdLmNsaWVudFksaT1lLnhUb3VjaERvd24tbixvPWUueVRvdWNoRG93bi1yLGE9TWF0aC5hYnMoaSk+TWF0aC5hYnMobyksbD1lLm9wdGlvbnMubnVtYmVyT2ZNb250aHMsYz1udWxsLHM9ITEsdT1cIlwiLGQ9QXJyYXkuZnJvbShlLnVpLnF1ZXJ5U2VsZWN0b3JBbGwoXCIubW9udGgtaXRlbVwiKSk7aWYoYSl7dmFyIHA9ZS5EYXRlVGltZShlLnVpLnF1ZXJ5U2VsZWN0b3IoXCIuZGF5LWl0ZW1cIikuZGF0YXNldC50aW1lKSxmPU51bWJlcihcIlwiLmNvbmNhdCgxLU1hdGguYWJzKGkpLzEwMCkpLG09MDtpZihpPjApe209LU1hdGguYWJzKGkpLGM9cC5jbG9uZSgpLmFkZChsLFwibW9udGhcIik7dmFyIGg9ZS5vcHRpb25zLm1heERhdGU7cz0haHx8Yy5pc1NhbWVPckJlZm9yZShlLkRhdGVUaW1lKGgpLFwibW9udGhcIiksdT1cIm5leHRcIn1lbHNle209TWF0aC5hYnMoaSksYz1wLmNsb25lKCkuc3VidHJhY3QobCxcIm1vbnRoXCIpO3ZhciBiPWUub3B0aW9ucy5taW5EYXRlO3M9IWJ8fGMuaXNTYW1lT3JBZnRlcihlLkRhdGVUaW1lKGIpLFwibW9udGhcIiksdT1cInByZXZcIn1zJiZkLm1hcCgoZnVuY3Rpb24oZSl7ZS5zdHlsZS5vcGFjaXR5PWYsZS5zdHlsZS50cmFuc2Zvcm09XCJ0cmFuc2xhdGVYKFwiLmNvbmNhdChtLFwicHgpXCIpfSkpfU1hdGguYWJzKGkpK01hdGguYWJzKG8pPjEwMCYmYSYmYyYmcyYmKGUudG91Y2hUYXJnZXRNb250aD11LGUuZ290b0RhdGUoYykpfX0sdT1mdW5jdGlvbih0KXtlLnRvdWNoVGFyZ2V0TW9udGh8fEFycmF5LmZyb20oZS51aS5xdWVyeVNlbGVjdG9yQWxsKFwiLm1vbnRoLWl0ZW1cIikpLm1hcCgoZnVuY3Rpb24oZSl7ZS5zdHlsZS50cmFuc2Zvcm09XCJ0cmFuc2xhdGVYKDBweClcIixlLnN0eWxlLm9wYWNpdHk9MX0pKTtlLnhUb3VjaERvd249bnVsbCxlLnlUb3VjaERvd249bnVsbH07ZS5iYWNrZHJvcD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLGUuYmFja2Ryb3AuY2xhc3NOYW1lPVwibGl0ZXBpY2tlci1iYWNrZHJvcFwiLGUuYmFja2Ryb3AuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsZS5oaWRlKCkpLHQuZWxlbWVudCYmdC5lbGVtZW50LnBhcmVudE5vZGUmJnQuZWxlbWVudC5wYXJlbnROb2RlLmFwcGVuZENoaWxkKGUuYmFja2Ryb3ApLHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib3JpZW50YXRpb25jaGFuZ2VcIiwoZnVuY3Rpb24obil7d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwoZnVuY3Rpb24gbigpe2lmKG8oKSYmZS5pc1Nob3duaW5nKCkpe3ZhciByPWEoKTtzd2l0Y2gocil7Y2FzZVwibGFuZHNjYXBlXCI6dC5udW1iZXJPZk1vbnRocz0yLHQubnVtYmVyT2ZDb2x1bW5zPTI7YnJlYWs7ZGVmYXVsdDp0Lm51bWJlck9mTW9udGhzPTEsdC5udW1iZXJPZkNvbHVtbnM9MX1lLnVpLmNsYXNzTGlzdC50b2dnbGUoXCJtb2JpbGVmcmllbmRseS1wb3J0cmFpdFwiLFwicG9ydHJhaXRcIj09PXIpLGUudWkuY2xhc3NMaXN0LnRvZ2dsZShcIm1vYmlsZWZyaWVuZGx5LWxhbmRzY2FwZVwiLFwibGFuZHNjYXBlXCI9PT1yKSxlLnJlbmRlcigpfXdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsbil9KSl9KSksdC5pbmxpbmVNb2RlJiZvKCkmJih3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJvcmllbnRhdGlvbmNoYW5nZVwiKSksd2luZG93LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwicmVzaXplXCIpKSksZS5vbihcImJlZm9yZTpzaG93XCIsKGZ1bmN0aW9uKHQpe2lmKGUudHJpZ2dlckVsZW1lbnQ9dCwhZS5vcHRpb25zLmlubGluZU1vZGUmJm8oKSl7ZS5lbWl0KFwibW9iaWxlZnJpZW5kbHkuYmVmb3JlOnNob3dcIix0KSxlLnVpLnN0eWxlLnBvc2l0aW9uPVwiZml4ZWRcIixlLnVpLnN0eWxlLmRpc3BsYXk9XCJibG9ja1wiLGwoKSxlLnNjcm9sbFRvRGF0ZSh0KSxlLnJlbmRlcigpO3ZhciBuPWEoKTtlLnVpLmNsYXNzTGlzdC5hZGQoXCJtb2JpbGVmcmllbmRseVwiKSxlLnVpLmNsYXNzTGlzdC50b2dnbGUoXCJtb2JpbGVmcmllbmRseS1wb3J0cmFpdFwiLFwicG9ydHJhaXRcIj09PW4pLGUudWkuY2xhc3NMaXN0LnRvZ2dsZShcIm1vYmlsZWZyaWVuZGx5LWxhbmRzY2FwZVwiLFwibGFuZHNjYXBlXCI9PT1uKSxlLnVpLnN0eWxlLnRvcD1cIjUwJVwiLGUudWkuc3R5bGUubGVmdD1cIjUwJVwiLGUudWkuc3R5bGUucmlnaHQ9bnVsbCxlLnVpLnN0eWxlLmJvdHRvbT1udWxsLGUudWkuc3R5bGUuekluZGV4PWUub3B0aW9ucy56SW5kZXgsZS5iYWNrZHJvcC5zdHlsZS5kaXNwbGF5PVwiYmxvY2tcIixlLmJhY2tkcm9wLnN0eWxlLnpJbmRleD1lLm9wdGlvbnMuekluZGV4LTEsZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKFwibGl0ZXBpY2tlci1vcGVuXCIpLCh0fHxlLm9wdGlvbnMuZWxlbWVudCkuYmx1cigpLGUuZW1pdChcIm1vYmlsZWZyaWVuZGx5LnNob3dcIix0KX1lbHNlIG8oKSYmKGwoKSxlLnJlbmRlcigpKX0pKSxlLm9uKFwicmVuZGVyXCIsKGZ1bmN0aW9uKHQpe2UudG91Y2hUYXJnZXRNb250aCYmQXJyYXkuZnJvbShlLnVpLnF1ZXJ5U2VsZWN0b3JBbGwoXCIubW9udGgtaXRlbVwiKSkubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC5jbGFzc0xpc3QuYWRkKFwidG91Y2gtdGFyZ2V0LVwiLmNvbmNhdChlLnRvdWNoVGFyZ2V0TW9udGgpKX0pKTtlLnRvdWNoVGFyZ2V0TW9udGg9bnVsbH0pKSxlLm9uKFwiaGlkZVwiLChmdW5jdGlvbigpe2RvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZShcImxpdGVwaWNrZXItb3BlblwiKSxlLmJhY2tkcm9wLnN0eWxlLmRpc3BsYXk9XCJub25lXCIsZS51aS5jbGFzc0xpc3QucmVtb3ZlKFwibW9iaWxlZnJpZW5kbHlcIixcIm1vYmlsZWZyaWVuZGx5LXBvcnRyYWl0XCIsXCJtb2JpbGVmcmllbmRseS1sYW5kc2NhcGVcIil9KSksZS5vbihcImRlc3Ryb3lcIiwoZnVuY3Rpb24oKXtlLmJhY2tkcm9wJiZlLmJhY2tkcm9wLnBhcmVudE5vZGUmJmUuYmFja2Ryb3AucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlLmJhY2tkcm9wKX0pKSxlLnVpLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsYywhIW4mJntwYXNzaXZlOiEwfSksZS51aS5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIscywhIW4mJntwYXNzaXZlOiEwfSksZS51aS5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIix1LCEhbiYme3Bhc3NpdmU6ITB9KX19KX0sZnVuY3Rpb24oZSx0LG4pe3ZhciByPW4oNyk7XCJzdHJpbmdcIj09dHlwZW9mIHImJihyPVtbZS5pLHIsXCJcIl1dKTt2YXIgaT17aW5zZXJ0OmZ1bmN0aW9uKGUpe3ZhciB0PWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJoZWFkXCIpLG49d2luZG93Ll9sYXN0RWxlbWVudEluc2VydGVkQnlTdHlsZUxvYWRlcjt3aW5kb3cuZGlzYWJsZUxpdGVwaWNrZXJTdHlsZXN8fChuP24ubmV4dFNpYmxpbmc/dC5pbnNlcnRCZWZvcmUoZSxuLm5leHRTaWJsaW5nKTp0LmFwcGVuZENoaWxkKGUpOnQuaW5zZXJ0QmVmb3JlKGUsdC5maXJzdENoaWxkKSx3aW5kb3cuX2xhc3RFbGVtZW50SW5zZXJ0ZWRCeVN0eWxlTG9hZGVyPWUpfSxzaW5nbGV0b246ITF9O24oMSkocixpKTtyLmxvY2FscyYmKGUuZXhwb3J0cz1yLmxvY2Fscyl9LGZ1bmN0aW9uKGUsdCxuKXsodD1uKDApKCExKSkucHVzaChbZS5pLCc6cm9vdCB7XFxuICAtLWxpdGVwaWNrZXItbW9iaWxlZnJpZW5kbHktYmFja2Ryb3AtY29sb3ItYmc6ICMwMDA7XFxufVxcblxcbi5saXRlcGlja2VyLWJhY2tkcm9wIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1saXRlcGlja2VyLW1vYmlsZWZyaWVuZGx5LWJhY2tkcm9wLWNvbG9yLWJnKTtcXG4gIG9wYWNpdHk6IDAuMztcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG4gIHRvcDogMDtcXG4gIHJpZ2h0OiAwO1xcbiAgYm90dG9tOiAwO1xcbiAgbGVmdDogMDtcXG59XFxuXFxuLmxpdGVwaWNrZXItb3BlbiB7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbn1cXG5cXG4ubGl0ZXBpY2tlci5tb2JpbGVmcmllbmRseVtkYXRhLXBsdWdpbnMqPVwibW9iaWxlZnJpZW5kbHlcIl0ge1xcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgLTUwJSk7XFxuICBmb250LXNpemU6IDEuMXJlbTtcXG4gIC0tbGl0ZXBpY2tlci1jb250YWluZXItbW9udGhzLWJveC1zaGFkb3ctY29sb3I6ICM2MTYxNjE7XFxufVxcbi5saXRlcGlja2VyLm1vYmlsZWZyaWVuZGx5LXBvcnRyYWl0IHtcXG4gIC0tbGl0ZXBpY2tlci1kYXktd2lkdGg6IDEzLjV2dztcXG4gIC0tbGl0ZXBpY2tlci1tb250aC13aWR0aDogY2FsYyh2YXIoLS1saXRlcGlja2VyLWRheS13aWR0aCkgKiA3KTtcXG59XFxuLmxpdGVwaWNrZXIubW9iaWxlZnJpZW5kbHktbGFuZHNjYXBlIHtcXG4gIC0tbGl0ZXBpY2tlci1kYXktd2lkdGg6IDUuNXZ3O1xcbiAgLS1saXRlcGlja2VyLW1vbnRoLXdpZHRoOiBjYWxjKHZhcigtLWxpdGVwaWNrZXItZGF5LXdpZHRoKSAqIDcpO1xcbn1cXG5cXG4ubGl0ZXBpY2tlcltkYXRhLXBsdWdpbnMqPVwibW9iaWxlZnJpZW5kbHlcIl0gLmNvbnRhaW5lcl9fbW9udGhzIHtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxufVxcblxcbi5saXRlcGlja2VyLm1vYmlsZWZyaWVuZGx5W2RhdGEtcGx1Z2lucyo9XCJtb2JpbGVmcmllbmRseVwiXSAuY29udGFpbmVyX19tb250aHMgLm1vbnRoLWl0ZW0taGVhZGVyIHtcXG4gIGhlaWdodDogdmFyKC0tbGl0ZXBpY2tlci1kYXktd2lkdGgpO1xcbn1cXG5cXG4ubGl0ZXBpY2tlci5tb2JpbGVmcmllbmRseVtkYXRhLXBsdWdpbnMqPVwibW9iaWxlZnJpZW5kbHlcIl0gLmNvbnRhaW5lcl9fZGF5cyA+IGRpdiB7XFxuICBoZWlnaHQ6IHZhcigtLWxpdGVwaWNrZXItZGF5LXdpZHRoKTtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxufVxcblxcblxcbi5saXRlcGlja2VyW2RhdGEtcGx1Z2lucyo9XCJtb2JpbGVmcmllbmRseVwiXSAuY29udGFpbmVyX19tb250aHMgLm1vbnRoLWl0ZW0ge1xcbiAgdHJhbnNmb3JtLW9yaWdpbjogY2VudGVyO1xcbn1cXG5cXG4ubGl0ZXBpY2tlcltkYXRhLXBsdWdpbnMqPVwibW9iaWxlZnJpZW5kbHlcIl0gLmNvbnRhaW5lcl9fbW9udGhzIC5tb250aC1pdGVtLnRvdWNoLXRhcmdldC1uZXh0IHtcXG4gIGFuaW1hdGlvbi1uYW1lOiBscC1ib3VuY2UtdGFyZ2V0LW5leHQ7XFxuICBhbmltYXRpb24tZHVyYXRpb246IC41cztcXG4gIGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGVhc2U7XFxufVxcblxcbi5saXRlcGlja2VyW2RhdGEtcGx1Z2lucyo9XCJtb2JpbGVmcmllbmRseVwiXSAuY29udGFpbmVyX19tb250aHMgLm1vbnRoLWl0ZW0udG91Y2gtdGFyZ2V0LXByZXYge1xcbiAgYW5pbWF0aW9uLW5hbWU6IGxwLWJvdW5jZS10YXJnZXQtcHJldjtcXG4gIGFuaW1hdGlvbi1kdXJhdGlvbjogLjVzO1xcbiAgYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogZWFzZTtcXG59XFxuXFxuQGtleWZyYW1lcyBscC1ib3VuY2UtdGFyZ2V0LW5leHQge1xcbiAgZnJvbSB7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgxMDBweCkgc2NhbGUoMC41KTtcXG4gIH1cXG4gIHRvIHtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDBweCkgc2NhbGUoMSk7XFxuICB9XFxufVxcblxcbkBrZXlmcmFtZXMgbHAtYm91bmNlLXRhcmdldC1wcmV2IHtcXG4gIGZyb20ge1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTEwMHB4KSBzY2FsZSgwLjUpO1xcbiAgfVxcbiAgdG8ge1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMHB4KSBzY2FsZSgxKTtcXG4gIH1cXG59JyxcIlwiXSksZS5leHBvcnRzPXR9XSk7IiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQge307IiwiLyoqXG4qIFRvbSBTZWxlY3QgdjIuMi4yXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG5cdChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5Ub21TZWxlY3QgPSBmYWN0b3J5KCkpO1xufSkodGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cdC8qKlxuXHQgKiBNaWNyb0V2ZW50IC0gdG8gbWFrZSBhbnkganMgb2JqZWN0IGFuIGV2ZW50IGVtaXR0ZXJcblx0ICpcblx0ICogLSBwdXJlIGphdmFzY3JpcHQgLSBzZXJ2ZXIgY29tcGF0aWJsZSwgYnJvd3NlciBjb21wYXRpYmxlXG5cdCAqIC0gZG9udCByZWx5IG9uIHRoZSBicm93c2VyIGRvbXNcblx0ICogLSBzdXBlciBzaW1wbGUgLSB5b3UgZ2V0IGl0IGltbWVkaWF0bHksIG5vIG1pc3RlcnksIG5vIG1hZ2ljIGludm9sdmVkXG5cdCAqXG5cdCAqIEBhdXRob3IgSmVyb21lIEV0aWVubmUgKGh0dHBzOi8vZ2l0aHViLmNvbS9qZXJvbWVldGllbm5lKVxuXHQgKi9cblxuXHQvKipcblx0ICogRXhlY3V0ZSBjYWxsYmFjayBmb3IgZWFjaCBldmVudCBpbiBzcGFjZSBzZXBhcmF0ZWQgbGlzdCBvZiBldmVudCBuYW1lc1xuXHQgKlxuXHQgKi9cblx0ZnVuY3Rpb24gZm9yRXZlbnRzKGV2ZW50cywgY2FsbGJhY2spIHtcblx0ICBldmVudHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKGV2ZW50ID0+IHtcblx0ICAgIGNhbGxiYWNrKGV2ZW50KTtcblx0ICB9KTtcblx0fVxuXG5cdGNsYXNzIE1pY3JvRXZlbnQge1xuXHQgIGNvbnN0cnVjdG9yKCkge1xuXHQgICAgdGhpcy5fZXZlbnRzID0gdm9pZCAwO1xuXHQgICAgdGhpcy5fZXZlbnRzID0ge307XG5cdCAgfVxuXG5cdCAgb24oZXZlbnRzLCBmY3QpIHtcblx0ICAgIGZvckV2ZW50cyhldmVudHMsIGV2ZW50ID0+IHtcblx0ICAgICAgY29uc3QgZXZlbnRfYXJyYXkgPSB0aGlzLl9ldmVudHNbZXZlbnRdIHx8IFtdO1xuXHQgICAgICBldmVudF9hcnJheS5wdXNoKGZjdCk7XG5cdCAgICAgIHRoaXMuX2V2ZW50c1tldmVudF0gPSBldmVudF9hcnJheTtcblx0ICAgIH0pO1xuXHQgIH1cblxuXHQgIG9mZihldmVudHMsIGZjdCkge1xuXHQgICAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG5cdCAgICBpZiAobiA9PT0gMCkge1xuXHQgICAgICB0aGlzLl9ldmVudHMgPSB7fTtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICBmb3JFdmVudHMoZXZlbnRzLCBldmVudCA9PiB7XG5cdCAgICAgIGlmIChuID09PSAxKSB7XG5cdCAgICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1tldmVudF07XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cblx0ICAgICAgY29uc3QgZXZlbnRfYXJyYXkgPSB0aGlzLl9ldmVudHNbZXZlbnRdO1xuXHQgICAgICBpZiAoZXZlbnRfYXJyYXkgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXHQgICAgICBldmVudF9hcnJheS5zcGxpY2UoZXZlbnRfYXJyYXkuaW5kZXhPZihmY3QpLCAxKTtcblx0ICAgICAgdGhpcy5fZXZlbnRzW2V2ZW50XSA9IGV2ZW50X2FycmF5O1xuXHQgICAgfSk7XG5cdCAgfVxuXG5cdCAgdHJpZ2dlcihldmVudHMsIC4uLmFyZ3MpIHtcblx0ICAgIHZhciBzZWxmID0gdGhpcztcblx0ICAgIGZvckV2ZW50cyhldmVudHMsIGV2ZW50ID0+IHtcblx0ICAgICAgY29uc3QgZXZlbnRfYXJyYXkgPSBzZWxmLl9ldmVudHNbZXZlbnRdO1xuXHQgICAgICBpZiAoZXZlbnRfYXJyYXkgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXHQgICAgICBldmVudF9hcnJheS5mb3JFYWNoKGZjdCA9PiB7XG5cdCAgICAgICAgZmN0LmFwcGx5KHNlbGYsIGFyZ3MpO1xuXHQgICAgICB9KTtcblx0ICAgIH0pO1xuXHQgIH1cblxuXHR9XG5cblx0LyoqXG5cdCAqIG1pY3JvcGx1Z2luLmpzXG5cdCAqIENvcHlyaWdodCAoYykgMjAxMyBCcmlhbiBSZWF2aXMgJiBjb250cmlidXRvcnNcblx0ICpcblx0ICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXNcblx0ICogZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XG5cdCAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXHQgKlxuXHQgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG5cdCAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0Zcblx0ICogQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG5cdCAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cdCAqXG5cdCAqIEBhdXRob3IgQnJpYW4gUmVhdmlzIDxicmlhbkB0aGlyZHJvdXRlLmNvbT5cblx0ICovXG5cdGZ1bmN0aW9uIE1pY3JvUGx1Z2luKEludGVyZmFjZSkge1xuXHQgIEludGVyZmFjZS5wbHVnaW5zID0ge307XG5cdCAgcmV0dXJuIGNsYXNzIGV4dGVuZHMgSW50ZXJmYWNlIHtcblx0ICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcblx0ICAgICAgc3VwZXIoLi4uYXJncyk7XG5cdCAgICAgIHRoaXMucGx1Z2lucyA9IHtcblx0ICAgICAgICBuYW1lczogW10sXG5cdCAgICAgICAgc2V0dGluZ3M6IHt9LFxuXHQgICAgICAgIHJlcXVlc3RlZDoge30sXG5cdCAgICAgICAgbG9hZGVkOiB7fVxuXHQgICAgICB9O1xuXHQgICAgfVxuXG5cdCAgICAvKipcblx0ICAgICAqIFJlZ2lzdGVycyBhIHBsdWdpbi5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmblxuXHQgICAgICovXG5cdCAgICBzdGF0aWMgZGVmaW5lKG5hbWUsIGZuKSB7XG5cdCAgICAgIEludGVyZmFjZS5wbHVnaW5zW25hbWVdID0ge1xuXHQgICAgICAgICduYW1lJzogbmFtZSxcblx0ICAgICAgICAnZm4nOiBmblxuXHQgICAgICB9O1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBJbml0aWFsaXplcyB0aGUgbGlzdGVkIHBsdWdpbnMgKHdpdGggb3B0aW9ucykuXG5cdCAgICAgKiBBY2NlcHRhYmxlIGZvcm1hdHM6XG5cdCAgICAgKlxuXHQgICAgICogTGlzdCAod2l0aG91dCBvcHRpb25zKTpcblx0ICAgICAqICAgWydhJywgJ2InLCAnYyddXG5cdCAgICAgKlxuXHQgICAgICogTGlzdCAod2l0aCBvcHRpb25zKTpcblx0ICAgICAqICAgW3snbmFtZSc6ICdhJywgb3B0aW9uczoge319LCB7J25hbWUnOiAnYicsIG9wdGlvbnM6IHt9fV1cblx0ICAgICAqXG5cdCAgICAgKiBIYXNoICh3aXRoIG9wdGlvbnMpOlxuXHQgICAgICogICB7J2EnOiB7IC4uLiB9LCAnYic6IHsgLi4uIH0sICdjJzogeyAuLi4gfX1cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge2FycmF5fG9iamVjdH0gcGx1Z2luc1xuXHQgICAgICovXG5cblxuXHQgICAgaW5pdGlhbGl6ZVBsdWdpbnMocGx1Z2lucykge1xuXHQgICAgICB2YXIga2V5LCBuYW1lO1xuXHQgICAgICBjb25zdCBzZWxmID0gdGhpcztcblx0ICAgICAgY29uc3QgcXVldWUgPSBbXTtcblxuXHQgICAgICBpZiAoQXJyYXkuaXNBcnJheShwbHVnaW5zKSkge1xuXHQgICAgICAgIHBsdWdpbnMuZm9yRWFjaChwbHVnaW4gPT4ge1xuXHQgICAgICAgICAgaWYgKHR5cGVvZiBwbHVnaW4gPT09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgICAgIHF1ZXVlLnB1c2gocGx1Z2luKTtcblx0ICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHNlbGYucGx1Z2lucy5zZXR0aW5nc1twbHVnaW4ubmFtZV0gPSBwbHVnaW4ub3B0aW9ucztcblx0ICAgICAgICAgICAgcXVldWUucHVzaChwbHVnaW4ubmFtZSk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICAgIH0gZWxzZSBpZiAocGx1Z2lucykge1xuXHQgICAgICAgIGZvciAoa2V5IGluIHBsdWdpbnMpIHtcblx0ICAgICAgICAgIGlmIChwbHVnaW5zLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0ICAgICAgICAgICAgc2VsZi5wbHVnaW5zLnNldHRpbmdzW2tleV0gPSBwbHVnaW5zW2tleV07XG5cdCAgICAgICAgICAgIHF1ZXVlLnB1c2goa2V5KTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICB3aGlsZSAobmFtZSA9IHF1ZXVlLnNoaWZ0KCkpIHtcblx0ICAgICAgICBzZWxmLnJlcXVpcmUobmFtZSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgbG9hZFBsdWdpbihuYW1lKSB7XG5cdCAgICAgIHZhciBzZWxmID0gdGhpcztcblx0ICAgICAgdmFyIHBsdWdpbnMgPSBzZWxmLnBsdWdpbnM7XG5cdCAgICAgIHZhciBwbHVnaW4gPSBJbnRlcmZhY2UucGx1Z2luc1tuYW1lXTtcblxuXHQgICAgICBpZiAoIUludGVyZmFjZS5wbHVnaW5zLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBcIicgKyBuYW1lICsgJ1wiIHBsdWdpbicpO1xuXHQgICAgICB9XG5cblx0ICAgICAgcGx1Z2lucy5yZXF1ZXN0ZWRbbmFtZV0gPSB0cnVlO1xuXHQgICAgICBwbHVnaW5zLmxvYWRlZFtuYW1lXSA9IHBsdWdpbi5mbi5hcHBseShzZWxmLCBbc2VsZi5wbHVnaW5zLnNldHRpbmdzW25hbWVdIHx8IHt9XSk7XG5cdCAgICAgIHBsdWdpbnMubmFtZXMucHVzaChuYW1lKTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogSW5pdGlhbGl6ZXMgYSBwbHVnaW4uXG5cdCAgICAgKlxuXHQgICAgICovXG5cblxuXHQgICAgcmVxdWlyZShuYW1lKSB7XG5cdCAgICAgIHZhciBzZWxmID0gdGhpcztcblx0ICAgICAgdmFyIHBsdWdpbnMgPSBzZWxmLnBsdWdpbnM7XG5cblx0ICAgICAgaWYgKCFzZWxmLnBsdWdpbnMubG9hZGVkLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG5cdCAgICAgICAgaWYgKHBsdWdpbnMucmVxdWVzdGVkW25hbWVdKSB7XG5cdCAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsdWdpbiBoYXMgY2lyY3VsYXIgZGVwZW5kZW5jeSAoXCInICsgbmFtZSArICdcIiknKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBzZWxmLmxvYWRQbHVnaW4obmFtZSk7XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm4gcGx1Z2lucy5sb2FkZWRbbmFtZV07XG5cdCAgICB9XG5cblx0ICB9O1xuXHR9XG5cblx0LyohIEBvcmNoaWRqcy91bmljb2RlLXZhcmlhbnRzIHwgaHR0cHM6Ly9naXRodWIuY29tL29yY2hpZGpzL3VuaWNvZGUtdmFyaWFudHMgfCBBcGFjaGUgTGljZW5zZSAodjIpICovXG5cdC8qKlxuXHQgKiBDb252ZXJ0IGFycmF5IG9mIHN0cmluZ3MgdG8gYSByZWd1bGFyIGV4cHJlc3Npb25cblx0ICpcdGV4IFsnYWInLCdhJ10gPT4gKD86YWJ8YSlcblx0ICogXHRleCBbJ2EnLCdiJ10gPT4gW2FiXVxuXHQgKiBAcGFyYW0ge3N0cmluZ1tdfSBjaGFyc1xuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHRjb25zdCBhcnJheVRvUGF0dGVybiA9IGNoYXJzID0+IHtcblx0ICBjaGFycyA9IGNoYXJzLmZpbHRlcihCb29sZWFuKTtcblxuXHQgIGlmIChjaGFycy5sZW5ndGggPCAyKSB7XG5cdCAgICByZXR1cm4gY2hhcnNbMF0gfHwgJyc7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIG1heFZhbHVlTGVuZ3RoKGNoYXJzKSA9PSAxID8gJ1snICsgY2hhcnMuam9pbignJykgKyAnXScgOiAnKD86JyArIGNoYXJzLmpvaW4oJ3wnKSArICcpJztcblx0fTtcblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nW119IGFycmF5XG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cblx0Y29uc3Qgc2VxdWVuY2VQYXR0ZXJuID0gYXJyYXkgPT4ge1xuXHQgIGlmICghaGFzRHVwbGljYXRlcyhhcnJheSkpIHtcblx0ICAgIHJldHVybiBhcnJheS5qb2luKCcnKTtcblx0ICB9XG5cblx0ICBsZXQgcGF0dGVybiA9ICcnO1xuXHQgIGxldCBwcmV2X2NoYXJfY291bnQgPSAwO1xuXG5cdCAgY29uc3QgcHJldl9wYXR0ZXJuID0gKCkgPT4ge1xuXHQgICAgaWYgKHByZXZfY2hhcl9jb3VudCA+IDEpIHtcblx0ICAgICAgcGF0dGVybiArPSAneycgKyBwcmV2X2NoYXJfY291bnQgKyAnfSc7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIGFycmF5LmZvckVhY2goKGNoYXIsIGkpID0+IHtcblx0ICAgIGlmIChjaGFyID09PSBhcnJheVtpIC0gMV0pIHtcblx0ICAgICAgcHJldl9jaGFyX2NvdW50Kys7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgcHJldl9wYXR0ZXJuKCk7XG5cdCAgICBwYXR0ZXJuICs9IGNoYXI7XG5cdCAgICBwcmV2X2NoYXJfY291bnQgPSAxO1xuXHQgIH0pO1xuXHQgIHByZXZfcGF0dGVybigpO1xuXHQgIHJldHVybiBwYXR0ZXJuO1xuXHR9O1xuXHQvKipcblx0ICogQ29udmVydCBhcnJheSBvZiBzdHJpbmdzIHRvIGEgcmVndWxhciBleHByZXNzaW9uXG5cdCAqXHRleCBbJ2FiJywnYSddID0+ICg/OmFifGEpXG5cdCAqIFx0ZXggWydhJywnYiddID0+IFthYl1cblx0ICogQHBhcmFtIHtTZXQ8c3RyaW5nPn0gY2hhcnNcblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cblxuXHRjb25zdCBzZXRUb1BhdHRlcm4gPSBjaGFycyA9PiB7XG5cdCAgbGV0IGFycmF5ID0gdG9BcnJheShjaGFycyk7XG5cdCAgcmV0dXJuIGFycmF5VG9QYXR0ZXJuKGFycmF5KTtcblx0fTtcblx0LyoqXG5cdCAqXG5cdCAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzczNzY1OTgvaW4tamF2YXNjcmlwdC1ob3ctZG8taS1jaGVjay1pZi1hbi1hcnJheS1oYXMtZHVwbGljYXRlLXZhbHVlc1xuXHQgKiBAcGFyYW0ge2FueVtdfSBhcnJheVxuXHQgKi9cblxuXHRjb25zdCBoYXNEdXBsaWNhdGVzID0gYXJyYXkgPT4ge1xuXHQgIHJldHVybiBuZXcgU2V0KGFycmF5KS5zaXplICE9PSBhcnJheS5sZW5ndGg7XG5cdH07XG5cdC8qKlxuXHQgKiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82MzAwNjYwMS93aHktZG9lcy11LXRocm93LWFuLWludmFsaWQtZXNjYXBlLWVycm9yXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cblxuXHRjb25zdCBlc2NhcGVfcmVnZXggPSBzdHIgPT4ge1xuXHQgIHJldHVybiAoc3RyICsgJycpLnJlcGxhY2UoLyhbXFwkXFwoXFwpXFwqXFwrXFwuXFw/XFxbXFxdXFxeXFx7XFx8XFx9XFxcXF0pL2d1LCAnXFxcXCQxJyk7XG5cdH07XG5cdC8qKlxuXHQgKiBSZXR1cm4gdGhlIG1heCBsZW5ndGggb2YgYXJyYXkgdmFsdWVzXG5cdCAqIEBwYXJhbSB7c3RyaW5nW119IGFycmF5XG5cdCAqXG5cdCAqL1xuXG5cdGNvbnN0IG1heFZhbHVlTGVuZ3RoID0gYXJyYXkgPT4ge1xuXHQgIHJldHVybiBhcnJheS5yZWR1Y2UoKGxvbmdlc3QsIHZhbHVlKSA9PiBNYXRoLm1heChsb25nZXN0LCB1bmljb2RlTGVuZ3RoKHZhbHVlKSksIDApO1xuXHR9O1xuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IHN0clxuXHQgKi9cblxuXHRjb25zdCB1bmljb2RlTGVuZ3RoID0gc3RyID0+IHtcblx0ICByZXR1cm4gdG9BcnJheShzdHIpLmxlbmd0aDtcblx0fTtcblx0LyoqXG5cdCAqIEBwYXJhbSB7YW55fSBwXG5cdCAqIEByZXR1cm4ge2FueVtdfVxuXHQgKi9cblxuXHRjb25zdCB0b0FycmF5ID0gcCA9PiBBcnJheS5mcm9tKHApO1xuXG5cdC8qISBAb3JjaGlkanMvdW5pY29kZS12YXJpYW50cyB8IGh0dHBzOi8vZ2l0aHViLmNvbS9vcmNoaWRqcy91bmljb2RlLXZhcmlhbnRzIHwgQXBhY2hlIExpY2Vuc2UgKHYyKSAqL1xuXHQvKipcblx0ICogR2V0IGFsbCBwb3NzaWJsZSBjb21iaW5hdGlvbnMgb2Ygc3Vic3RyaW5ncyB0aGF0IGFkZCB1cCB0byB0aGUgZ2l2ZW4gc3RyaW5nXG5cdCAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzMwMTY5NTg3L2ZpbmQtYWxsLXRoZS1jb21iaW5hdGlvbi1vZi1zdWJzdHJpbmdzLXRoYXQtYWRkLXVwLXRvLXRoZS1naXZlbi1zdHJpbmdcblx0ICogQHBhcmFtIHtzdHJpbmd9IGlucHV0XG5cdCAqIEByZXR1cm4ge3N0cmluZ1tdW119XG5cdCAqL1xuXHRjb25zdCBhbGxTdWJzdHJpbmdzID0gaW5wdXQgPT4ge1xuXHQgIGlmIChpbnB1dC5sZW5ndGggPT09IDEpIHJldHVybiBbW2lucHV0XV07XG5cdCAgLyoqIEB0eXBlIHtzdHJpbmdbXVtdfSAqL1xuXG5cdCAgbGV0IHJlc3VsdCA9IFtdO1xuXHQgIGNvbnN0IHN0YXJ0ID0gaW5wdXQuc3Vic3RyaW5nKDEpO1xuXHQgIGNvbnN0IHN1YmEgPSBhbGxTdWJzdHJpbmdzKHN0YXJ0KTtcblx0ICBzdWJhLmZvckVhY2goZnVuY3Rpb24gKHN1YnJlc3VsdCkge1xuXHQgICAgbGV0IHRtcCA9IHN1YnJlc3VsdC5zbGljZSgwKTtcblx0ICAgIHRtcFswXSA9IGlucHV0LmNoYXJBdCgwKSArIHRtcFswXTtcblx0ICAgIHJlc3VsdC5wdXNoKHRtcCk7XG5cdCAgICB0bXAgPSBzdWJyZXN1bHQuc2xpY2UoMCk7XG5cdCAgICB0bXAudW5zaGlmdChpbnB1dC5jaGFyQXQoMCkpO1xuXHQgICAgcmVzdWx0LnB1c2godG1wKTtcblx0ICB9KTtcblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdC8qISBAb3JjaGlkanMvdW5pY29kZS12YXJpYW50cyB8IGh0dHBzOi8vZ2l0aHViLmNvbS9vcmNoaWRqcy91bmljb2RlLXZhcmlhbnRzIHwgQXBhY2hlIExpY2Vuc2UgKHYyKSAqL1xuXG5cdC8qKlxuXHQgKiBAdHlwZWRlZiB7e1trZXk6c3RyaW5nXTpzdHJpbmd9fSBUVW5pY29kZU1hcFxuXHQgKiBAdHlwZWRlZiB7e1trZXk6c3RyaW5nXTpTZXQ8c3RyaW5nPn19IFRVbmljb2RlU2V0c1xuXHQgKiBAdHlwZWRlZiB7W1tudW1iZXIsbnVtYmVyXV19IFRDb2RlUG9pbnRzXG5cdCAqIEB0eXBlZGVmIHt7Zm9sZGVkOnN0cmluZyxjb21wb3NlZDpzdHJpbmcsY29kZV9wb2ludDpudW1iZXJ9fSBUQ29kZVBvaW50T2JqXG5cdCAqIEB0eXBlZGVmIHt7c3RhcnQ6bnVtYmVyLGVuZDpudW1iZXIsbGVuZ3RoOm51bWJlcixzdWJzdHI6c3RyaW5nfX0gVFNlcXVlbmNlUGFydFxuXHQgKi9cblx0LyoqIEB0eXBlIHtUQ29kZVBvaW50c30gKi9cblxuXHRjb25zdCBjb2RlX3BvaW50cyA9IFtbMCwgNjU1MzVdXTtcblx0Y29uc3QgYWNjZW50X3BhdCA9ICdbXFx1MDMwMC1cXHUwMzZGXFx1e2I3fVxcdXsyYmV9XFx1ezJiY31dJztcblx0LyoqIEB0eXBlIHtUVW5pY29kZU1hcH0gKi9cblxuXHRsZXQgdW5pY29kZV9tYXA7XG5cdC8qKiBAdHlwZSB7UmVnRXhwfSAqL1xuXG5cdGxldCBtdWx0aV9jaGFyX3JlZztcblx0Y29uc3QgbWF4X2NoYXJfbGVuZ3RoID0gMztcblx0LyoqIEB0eXBlIHtUVW5pY29kZU1hcH0gKi9cblxuXHRjb25zdCBsYXRpbl9jb252ZXJ0ID0ge307XG5cdC8qKiBAdHlwZSB7VFVuaWNvZGVNYXB9ICovXG5cblx0Y29uc3QgbGF0aW5fY29uZGVuc2VkID0ge1xuXHQgICcvJzogJ+KBhOKIlScsXG5cdCAgJzAnOiAn34AnLFxuXHQgIFwiYVwiOiBcIuKxpcmQyZFcIixcblx0ICBcImFhXCI6IFwi6pyzXCIsXG5cdCAgXCJhZVwiOiBcIsOmx73Ho1wiLFxuXHQgIFwiYW9cIjogXCLqnLVcIixcblx0ICBcImF1XCI6IFwi6py3XCIsXG5cdCAgXCJhdlwiOiBcIuqcueqcu1wiLFxuXHQgIFwiYXlcIjogXCLqnL1cIixcblx0ICBcImJcIjogXCLGgMmTxoNcIixcblx0ICBcImNcIjogXCLqnL/GiMi84oaEXCIsXG5cdCAgXCJkXCI6IFwixJHJl8mW4bSFxozqrrfUgcmmXCIsXG5cdCAgXCJlXCI6IFwiyZvHneG0h8mHXCIsXG5cdCAgXCJmXCI6IFwi6p28xpJcIixcblx0ICBcImdcIjogXCLHpcmg6p6h4bW56p2/yaJcIixcblx0ICBcImhcIjogXCLEp+KxqOKxtsmlXCIsXG5cdCAgXCJpXCI6IFwiyajEsVwiLFxuXHQgIFwialwiOiBcIsmJyLdcIixcblx0ICBcImtcIjogXCLGmeKxquqdgeqdg+qdheqeo1wiLFxuXHQgIFwibFwiOiBcIsWCxprJq+Kxoeqdieqdh+qegcmtXCIsXG5cdCAgXCJtXCI6IFwiybHJr8+7XCIsXG5cdCAgXCJuXCI6IFwi6p6lxp7JsuqekeG0jtC71IlcIixcblx0ICBcIm9cIjogXCLDuMe/yZTJteqdi+qdjeG0kVwiLFxuXHQgIFwib2VcIjogXCLFk1wiLFxuXHQgIFwib2lcIjogXCLGo1wiLFxuXHQgIFwib29cIjogXCLqnY9cIixcblx0ICBcIm91XCI6IFwiyKNcIixcblx0ICBcInBcIjogXCLGpeG1veqdkeqdk+qdlc+BXCIsXG5cdCAgXCJxXCI6IFwi6p2X6p2ZyYtcIixcblx0ICBcInJcIjogXCLJjcm96p2b6p6n6p6DXCIsXG5cdCAgXCJzXCI6IFwiw5/Iv+qeqeqehcqCXCIsXG5cdCAgXCJ0XCI6IFwixafGrcqI4rGm6p6HXCIsXG5cdCAgXCJ0aFwiOiBcIsO+XCIsXG5cdCAgXCJ0elwiOiBcIuqcqVwiLFxuXHQgIFwidVwiOiBcIsqJXCIsXG5cdCAgXCJ2XCI6IFwiyovqnZ/KjFwiLFxuXHQgIFwidnlcIjogXCLqnaFcIixcblx0ICBcIndcIjogXCLisbNcIixcblx0ICBcInlcIjogXCLGtMmP4bu/XCIsXG5cdCAgXCJ6XCI6IFwixrbIpcmA4rGs6p2jXCIsXG5cdCAgXCJodlwiOiBcIsaVXCJcblx0fTtcblxuXHRmb3IgKGxldCBsYXRpbiBpbiBsYXRpbl9jb25kZW5zZWQpIHtcblx0ICBsZXQgdW5pY29kZSA9IGxhdGluX2NvbmRlbnNlZFtsYXRpbl0gfHwgJyc7XG5cblx0ICBmb3IgKGxldCBpID0gMDsgaSA8IHVuaWNvZGUubGVuZ3RoOyBpKyspIHtcblx0ICAgIGxldCBjaGFyID0gdW5pY29kZS5zdWJzdHJpbmcoaSwgaSArIDEpO1xuXHQgICAgbGF0aW5fY29udmVydFtjaGFyXSA9IGxhdGluO1xuXHQgIH1cblx0fVxuXG5cdGNvbnN0IGNvbnZlcnRfcGF0ID0gbmV3IFJlZ0V4cChPYmplY3Qua2V5cyhsYXRpbl9jb252ZXJ0KS5qb2luKCd8JykgKyAnfCcgKyBhY2NlbnRfcGF0LCAnZ3UnKTtcblx0LyoqXG5cdCAqIEluaXRpYWxpemUgdGhlIHVuaWNvZGVfbWFwIGZyb20gdGhlIGdpdmUgY29kZSBwb2ludCByYW5nZXNcblx0ICpcblx0ICogQHBhcmFtIHtUQ29kZVBvaW50cz19IF9jb2RlX3BvaW50c1xuXHQgKi9cblxuXHRjb25zdCBpbml0aWFsaXplID0gX2NvZGVfcG9pbnRzID0+IHtcblx0ICBpZiAodW5pY29kZV9tYXAgIT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXHQgIHVuaWNvZGVfbWFwID0gZ2VuZXJhdGVNYXAoX2NvZGVfcG9pbnRzIHx8IGNvZGVfcG9pbnRzKTtcblx0fTtcblx0LyoqXG5cdCAqIEhlbHBlciBtZXRob2QgZm9yIG5vcm1hbGl6ZSBhIHN0cmluZ1xuXHQgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvbm9ybWFsaXplXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IGZvcm1cblx0ICovXG5cblx0Y29uc3Qgbm9ybWFsaXplID0gKHN0ciwgZm9ybSA9ICdORktEJykgPT4gc3RyLm5vcm1hbGl6ZShmb3JtKTtcblx0LyoqXG5cdCAqIFJlbW92ZSBhY2NlbnRzIHdpdGhvdXQgcmVvcmRlcmluZyBzdHJpbmdcblx0ICogY2FsbGluZyBzdHIubm9ybWFsaXplKCdORktEJykgb24gXFx1ezU5NH1cXHV7NTk1fVxcdXs1OTZ9IGJlY29tZXMgXFx1ezU5Nn1cXHV7NTk0fVxcdXs1OTV9XG5cdCAqIHZpYSBodHRwczovL2dpdGh1Yi5jb20va3Jpc2svRnVzZS9pc3N1ZXMvMTMzI2lzc3VlY29tbWVudC0zMTg2OTI3MDNcblx0ICogQHBhcmFtIHtzdHJpbmd9IHN0clxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXG5cdGNvbnN0IGFzY2lpZm9sZCA9IHN0ciA9PiB7XG5cdCAgcmV0dXJuIHRvQXJyYXkoc3RyKS5yZWR1Y2UoXG5cdCAgLyoqXG5cdCAgICogQHBhcmFtIHtzdHJpbmd9IHJlc3VsdFxuXHQgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFyXG5cdCAgICovXG5cdCAgKHJlc3VsdCwgY2hhcikgPT4ge1xuXHQgICAgcmV0dXJuIHJlc3VsdCArIF9hc2NpaWZvbGQoY2hhcik7XG5cdCAgfSwgJycpO1xuXHR9O1xuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IHN0clxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXG5cdGNvbnN0IF9hc2NpaWZvbGQgPSBzdHIgPT4ge1xuXHQgIHN0ciA9IG5vcm1hbGl6ZShzdHIpLnRvTG93ZXJDYXNlKCkucmVwbGFjZShjb252ZXJ0X3BhdCwgKFxuXHQgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuXHQgIGNoYXIpID0+IHtcblx0ICAgIHJldHVybiBsYXRpbl9jb252ZXJ0W2NoYXJdIHx8ICcnO1xuXHQgIH0pOyAvL3JldHVybiBzdHI7XG5cblx0ICByZXR1cm4gbm9ybWFsaXplKHN0ciwgJ05GQycpO1xuXHR9O1xuXHQvKipcblx0ICogR2VuZXJhdGUgYSBsaXN0IG9mIHVuaWNvZGUgdmFyaWFudHMgZnJvbSB0aGUgbGlzdCBvZiBjb2RlIHBvaW50c1xuXHQgKiBAcGFyYW0ge1RDb2RlUG9pbnRzfSBjb2RlX3BvaW50c1xuXHQgKiBAeWllbGQge1RDb2RlUG9pbnRPYmp9XG5cdCAqL1xuXG5cdGZ1bmN0aW9uKiBnZW5lcmF0b3IoY29kZV9wb2ludHMpIHtcblx0ICBmb3IgKGNvbnN0IFtjb2RlX3BvaW50X21pbiwgY29kZV9wb2ludF9tYXhdIG9mIGNvZGVfcG9pbnRzKSB7XG5cdCAgICBmb3IgKGxldCBpID0gY29kZV9wb2ludF9taW47IGkgPD0gY29kZV9wb2ludF9tYXg7IGkrKykge1xuXHQgICAgICBsZXQgY29tcG9zZWQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpO1xuXHQgICAgICBsZXQgZm9sZGVkID0gYXNjaWlmb2xkKGNvbXBvc2VkKTtcblxuXHQgICAgICBpZiAoZm9sZGVkID09IGNvbXBvc2VkLnRvTG93ZXJDYXNlKCkpIHtcblx0ICAgICAgICBjb250aW51ZTtcblx0ICAgICAgfSAvLyBza2lwIHdoZW4gZm9sZGVkIGlzIGEgc3RyaW5nIGxvbmdlciB0aGFuIDMgY2hhcmFjdGVycyBsb25nXG5cdCAgICAgIC8vIGJjIHRoZSByZXN1bHRpbmcgcmVnZXggcGF0dGVybnMgd2lsbCBiZSBsb25nXG5cdCAgICAgIC8vIGVnOlxuXHQgICAgICAvLyBmb2xkZWQg2LXZhNmJINin2YTZhNmHINi52YTZitmHINmI2LPZhNmFIGxlbmd0aCAxOCBjb2RlIHBvaW50IDY1MDE4XG5cdCAgICAgIC8vIGZvbGRlZCDYrNmEINis2YTYp9mE2YcgbGVuZ3RoIDggY29kZSBwb2ludCA2NTAxOVxuXG5cblx0ICAgICAgaWYgKGZvbGRlZC5sZW5ndGggPiBtYXhfY2hhcl9sZW5ndGgpIHtcblx0ICAgICAgICBjb250aW51ZTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChmb2xkZWQubGVuZ3RoID09IDApIHtcblx0ICAgICAgICBjb250aW51ZTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHlpZWxkIHtcblx0ICAgICAgICBmb2xkZWQ6IGZvbGRlZCxcblx0ICAgICAgICBjb21wb3NlZDogY29tcG9zZWQsXG5cdCAgICAgICAgY29kZV9wb2ludDogaVxuXHQgICAgICB9O1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXHQvKipcblx0ICogR2VuZXJhdGUgYSB1bmljb2RlIG1hcCBmcm9tIHRoZSBsaXN0IG9mIGNvZGUgcG9pbnRzXG5cdCAqIEBwYXJhbSB7VENvZGVQb2ludHN9IGNvZGVfcG9pbnRzXG5cdCAqIEByZXR1cm4ge1RVbmljb2RlU2V0c31cblx0ICovXG5cblx0Y29uc3QgZ2VuZXJhdGVTZXRzID0gY29kZV9wb2ludHMgPT4ge1xuXHQgIC8qKiBAdHlwZSB7e1trZXk6c3RyaW5nXTpTZXQ8c3RyaW5nPn19ICovXG5cdCAgY29uc3QgdW5pY29kZV9zZXRzID0ge307XG5cdCAgLyoqXG5cdCAgICogQHBhcmFtIHtzdHJpbmd9IGZvbGRlZFxuXHQgICAqIEBwYXJhbSB7c3RyaW5nfSB0b19hZGRcblx0ICAgKi9cblxuXHQgIGNvbnN0IGFkZE1hdGNoaW5nID0gKGZvbGRlZCwgdG9fYWRkKSA9PiB7XG5cdCAgICAvKiogQHR5cGUge1NldDxzdHJpbmc+fSAqL1xuXHQgICAgY29uc3QgZm9sZGVkX3NldCA9IHVuaWNvZGVfc2V0c1tmb2xkZWRdIHx8IG5ldyBTZXQoKTtcblx0ICAgIGNvbnN0IHBhdHQgPSBuZXcgUmVnRXhwKCdeJyArIHNldFRvUGF0dGVybihmb2xkZWRfc2V0KSArICckJywgJ2l1Jyk7XG5cblx0ICAgIGlmICh0b19hZGQubWF0Y2gocGF0dCkpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICBmb2xkZWRfc2V0LmFkZChlc2NhcGVfcmVnZXgodG9fYWRkKSk7XG5cdCAgICB1bmljb2RlX3NldHNbZm9sZGVkXSA9IGZvbGRlZF9zZXQ7XG5cdCAgfTtcblxuXHQgIGZvciAobGV0IHZhbHVlIG9mIGdlbmVyYXRvcihjb2RlX3BvaW50cykpIHtcblx0ICAgIGFkZE1hdGNoaW5nKHZhbHVlLmZvbGRlZCwgdmFsdWUuZm9sZGVkKTtcblx0ICAgIGFkZE1hdGNoaW5nKHZhbHVlLmZvbGRlZCwgdmFsdWUuY29tcG9zZWQpO1xuXHQgIH1cblxuXHQgIHJldHVybiB1bmljb2RlX3NldHM7XG5cdH07XG5cdC8qKlxuXHQgKiBHZW5lcmF0ZSBhIHVuaWNvZGUgbWFwIGZyb20gdGhlIGxpc3Qgb2YgY29kZSBwb2ludHNcblx0ICogYWUgPT4gKD86KD86YWV8w4Z8x7x8x6IpfCg/OkF84pK2fO+8oS4uLikoPzpFfMmbfOKSui4uLikpXG5cdCAqXG5cdCAqIEBwYXJhbSB7VENvZGVQb2ludHN9IGNvZGVfcG9pbnRzXG5cdCAqIEByZXR1cm4ge1RVbmljb2RlTWFwfVxuXHQgKi9cblxuXHRjb25zdCBnZW5lcmF0ZU1hcCA9IGNvZGVfcG9pbnRzID0+IHtcblx0ICAvKiogQHR5cGUge1RVbmljb2RlU2V0c30gKi9cblx0ICBjb25zdCB1bmljb2RlX3NldHMgPSBnZW5lcmF0ZVNldHMoY29kZV9wb2ludHMpO1xuXHQgIC8qKiBAdHlwZSB7VFVuaWNvZGVNYXB9ICovXG5cblx0ICBjb25zdCB1bmljb2RlX21hcCA9IHt9O1xuXHQgIC8qKiBAdHlwZSB7c3RyaW5nW119ICovXG5cblx0ICBsZXQgbXVsdGlfY2hhciA9IFtdO1xuXG5cdCAgZm9yIChsZXQgZm9sZGVkIGluIHVuaWNvZGVfc2V0cykge1xuXHQgICAgbGV0IHNldCA9IHVuaWNvZGVfc2V0c1tmb2xkZWRdO1xuXG5cdCAgICBpZiAoc2V0KSB7XG5cdCAgICAgIHVuaWNvZGVfbWFwW2ZvbGRlZF0gPSBzZXRUb1BhdHRlcm4oc2V0KTtcblx0ICAgIH1cblxuXHQgICAgaWYgKGZvbGRlZC5sZW5ndGggPiAxKSB7XG5cdCAgICAgIG11bHRpX2NoYXIucHVzaChlc2NhcGVfcmVnZXgoZm9sZGVkKSk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgbXVsdGlfY2hhci5zb3J0KChhLCBiKSA9PiBiLmxlbmd0aCAtIGEubGVuZ3RoKTtcblx0ICBjb25zdCBtdWx0aV9jaGFyX3BhdHQgPSBhcnJheVRvUGF0dGVybihtdWx0aV9jaGFyKTtcblx0ICBtdWx0aV9jaGFyX3JlZyA9IG5ldyBSZWdFeHAoJ14nICsgbXVsdGlfY2hhcl9wYXR0LCAndScpO1xuXHQgIHJldHVybiB1bmljb2RlX21hcDtcblx0fTtcblx0LyoqXG5cdCAqIE1hcCBlYWNoIGVsZW1lbnQgb2YgYW4gYXJyYXkgZnJvbSBpdCdzIGZvbGRlZCB2YWx1ZSB0byBhbGwgcG9zc2libGUgdW5pY29kZSBtYXRjaGVzXG5cdCAqIEBwYXJhbSB7c3RyaW5nW119IHN0cmluZ3Ncblx0ICogQHBhcmFtIHtudW1iZXJ9IG1pbl9yZXBsYWNlbWVudFxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXG5cdGNvbnN0IG1hcFNlcXVlbmNlID0gKHN0cmluZ3MsIG1pbl9yZXBsYWNlbWVudCA9IDEpID0+IHtcblx0ICBsZXQgY2hhcnNfcmVwbGFjZWQgPSAwO1xuXHQgIHN0cmluZ3MgPSBzdHJpbmdzLm1hcChzdHIgPT4ge1xuXHQgICAgaWYgKHVuaWNvZGVfbWFwW3N0cl0pIHtcblx0ICAgICAgY2hhcnNfcmVwbGFjZWQgKz0gc3RyLmxlbmd0aDtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHVuaWNvZGVfbWFwW3N0cl0gfHwgc3RyO1xuXHQgIH0pO1xuXG5cdCAgaWYgKGNoYXJzX3JlcGxhY2VkID49IG1pbl9yZXBsYWNlbWVudCkge1xuXHQgICAgcmV0dXJuIHNlcXVlbmNlUGF0dGVybihzdHJpbmdzKTtcblx0ICB9XG5cblx0ICByZXR1cm4gJyc7XG5cdH07XG5cdC8qKlxuXHQgKiBDb252ZXJ0IGEgc2hvcnQgc3RyaW5nIGFuZCBzcGxpdCBpdCBpbnRvIGFsbCBwb3NzaWJsZSBwYXR0ZXJuc1xuXHQgKiBLZWVwIGEgcGF0dGVybiBvbmx5IGlmIG1pbl9yZXBsYWNlbWVudCBpcyBtZXRcblx0ICpcblx0ICogJ2FiYydcblx0ICogXHRcdD0+IFtbJ2FiYyddLFsnYWInLCdjJ10sWydhJywnYmMnXSxbJ2EnLCdiJywnYyddXVxuXHQgKlx0XHQ9PiBbJ2FiYy1wYXR0ZXJuJywnYWItYy1wYXR0ZXJuJy4uLl1cblx0ICpcblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IHN0clxuXHQgKiBAcGFyYW0ge251bWJlcn0gbWluX3JlcGxhY2VtZW50XG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cblx0Y29uc3Qgc3Vic3RyaW5nc1RvUGF0dGVybiA9IChzdHIsIG1pbl9yZXBsYWNlbWVudCA9IDEpID0+IHtcblx0ICBtaW5fcmVwbGFjZW1lbnQgPSBNYXRoLm1heChtaW5fcmVwbGFjZW1lbnQsIHN0ci5sZW5ndGggLSAxKTtcblx0ICByZXR1cm4gYXJyYXlUb1BhdHRlcm4oYWxsU3Vic3RyaW5ncyhzdHIpLm1hcChzdWJfcGF0ID0+IHtcblx0ICAgIHJldHVybiBtYXBTZXF1ZW5jZShzdWJfcGF0LCBtaW5fcmVwbGFjZW1lbnQpO1xuXHQgIH0pKTtcblx0fTtcblx0LyoqXG5cdCAqIENvbnZlcnQgYW4gYXJyYXkgb2Ygc2VxdWVuY2VzIGludG8gYSBwYXR0ZXJuXG5cdCAqIFt7c3RhcnQ6MCxlbmQ6MyxsZW5ndGg6MyxzdWJzdHI6J2lpaSd9Li4uXSA9PiAoPzppaWkuLi4pXG5cdCAqXG5cdCAqIEBwYXJhbSB7U2VxdWVuY2VbXX0gc2VxdWVuY2VzXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gYWxsXG5cdCAqL1xuXG5cdGNvbnN0IHNlcXVlbmNlc1RvUGF0dGVybiA9IChzZXF1ZW5jZXMsIGFsbCA9IHRydWUpID0+IHtcblx0ICBsZXQgbWluX3JlcGxhY2VtZW50ID0gc2VxdWVuY2VzLmxlbmd0aCA+IDEgPyAxIDogMDtcblx0ICByZXR1cm4gYXJyYXlUb1BhdHRlcm4oc2VxdWVuY2VzLm1hcChzZXF1ZW5jZSA9PiB7XG5cdCAgICBsZXQgc2VxID0gW107XG5cdCAgICBjb25zdCBsZW4gPSBhbGwgPyBzZXF1ZW5jZS5sZW5ndGgoKSA6IHNlcXVlbmNlLmxlbmd0aCgpIC0gMTtcblxuXHQgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsZW47IGorKykge1xuXHQgICAgICBzZXEucHVzaChzdWJzdHJpbmdzVG9QYXR0ZXJuKHNlcXVlbmNlLnN1YnN0cnNbal0gfHwgJycsIG1pbl9yZXBsYWNlbWVudCkpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gc2VxdWVuY2VQYXR0ZXJuKHNlcSk7XG5cdCAgfSkpO1xuXHR9O1xuXHQvKipcblx0ICogUmV0dXJuIHRydWUgaWYgdGhlIHNlcXVlbmNlIGlzIGFscmVhZHkgaW4gdGhlIHNlcXVlbmNlc1xuXHQgKiBAcGFyYW0ge1NlcXVlbmNlfSBuZWVkbGVfc2VxXG5cdCAqIEBwYXJhbSB7U2VxdWVuY2VbXX0gc2VxdWVuY2VzXG5cdCAqL1xuXG5cblx0Y29uc3QgaW5TZXF1ZW5jZXMgPSAobmVlZGxlX3NlcSwgc2VxdWVuY2VzKSA9PiB7XG5cdCAgZm9yIChjb25zdCBzZXEgb2Ygc2VxdWVuY2VzKSB7XG5cdCAgICBpZiAoc2VxLnN0YXJ0ICE9IG5lZWRsZV9zZXEuc3RhcnQgfHwgc2VxLmVuZCAhPSBuZWVkbGVfc2VxLmVuZCkge1xuXHQgICAgICBjb250aW51ZTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHNlcS5zdWJzdHJzLmpvaW4oJycpICE9PSBuZWVkbGVfc2VxLnN1YnN0cnMuam9pbignJykpIHtcblx0ICAgICAgY29udGludWU7XG5cdCAgICB9XG5cblx0ICAgIGxldCBuZWVkbGVfcGFydHMgPSBuZWVkbGVfc2VxLnBhcnRzO1xuXHQgICAgLyoqXG5cdCAgICAgKiBAcGFyYW0ge1RTZXF1ZW5jZVBhcnR9IHBhcnRcblx0ICAgICAqL1xuXG5cdCAgICBjb25zdCBmaWx0ZXIgPSBwYXJ0ID0+IHtcblx0ICAgICAgZm9yIChjb25zdCBuZWVkbGVfcGFydCBvZiBuZWVkbGVfcGFydHMpIHtcblx0ICAgICAgICBpZiAobmVlZGxlX3BhcnQuc3RhcnQgPT09IHBhcnQuc3RhcnQgJiYgbmVlZGxlX3BhcnQuc3Vic3RyID09PSBwYXJ0LnN1YnN0cikge1xuXHQgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChwYXJ0Lmxlbmd0aCA9PSAxIHx8IG5lZWRsZV9wYXJ0Lmxlbmd0aCA9PSAxKSB7XG5cdCAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICB9IC8vIGNoZWNrIGZvciBvdmVybGFwcGluZyBwYXJ0c1xuXHQgICAgICAgIC8vIGEgPSBbJzo6PScsJz09J11cblx0ICAgICAgICAvLyBiID0gWyc6OicsJz09PSddXG5cdCAgICAgICAgLy8gYSA9IFsncicsJ3NtJ11cblx0ICAgICAgICAvLyBiID0gWydycycsJ20nXVxuXG5cblx0ICAgICAgICBpZiAocGFydC5zdGFydCA8IG5lZWRsZV9wYXJ0LnN0YXJ0ICYmIHBhcnQuZW5kID4gbmVlZGxlX3BhcnQuc3RhcnQpIHtcblx0ICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChuZWVkbGVfcGFydC5zdGFydCA8IHBhcnQuc3RhcnQgJiYgbmVlZGxlX3BhcnQuZW5kID4gcGFydC5zdGFydCkge1xuXHQgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfTtcblxuXHQgICAgbGV0IGZpbHRlcmVkID0gc2VxLnBhcnRzLmZpbHRlcihmaWx0ZXIpO1xuXG5cdCAgICBpZiAoZmlsdGVyZWQubGVuZ3RoID4gMCkge1xuXHQgICAgICBjb250aW51ZTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRydWU7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGZhbHNlO1xuXHR9O1xuXG5cdGNsYXNzIFNlcXVlbmNlIHtcblx0ICBjb25zdHJ1Y3RvcigpIHtcblx0ICAgIC8qKiBAdHlwZSB7VFNlcXVlbmNlUGFydFtdfSAqL1xuXHQgICAgdGhpcy5wYXJ0cyA9IFtdO1xuXHQgICAgLyoqIEB0eXBlIHtzdHJpbmdbXX0gKi9cblxuXHQgICAgdGhpcy5zdWJzdHJzID0gW107XG5cdCAgICB0aGlzLnN0YXJ0ID0gMDtcblx0ICAgIHRoaXMuZW5kID0gMDtcblx0ICB9XG5cdCAgLyoqXG5cdCAgICogQHBhcmFtIHtUU2VxdWVuY2VQYXJ0fHVuZGVmaW5lZH0gcGFydFxuXHQgICAqL1xuXG5cblx0ICBhZGQocGFydCkge1xuXHQgICAgaWYgKHBhcnQpIHtcblx0ICAgICAgdGhpcy5wYXJ0cy5wdXNoKHBhcnQpO1xuXHQgICAgICB0aGlzLnN1YnN0cnMucHVzaChwYXJ0LnN1YnN0cik7XG5cdCAgICAgIHRoaXMuc3RhcnQgPSBNYXRoLm1pbihwYXJ0LnN0YXJ0LCB0aGlzLnN0YXJ0KTtcblx0ICAgICAgdGhpcy5lbmQgPSBNYXRoLm1heChwYXJ0LmVuZCwgdGhpcy5lbmQpO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIGxhc3QoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5wYXJ0c1t0aGlzLnBhcnRzLmxlbmd0aCAtIDFdO1xuXHQgIH1cblxuXHQgIGxlbmd0aCgpIHtcblx0ICAgIHJldHVybiB0aGlzLnBhcnRzLmxlbmd0aDtcblx0ICB9XG5cdCAgLyoqXG5cdCAgICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uXG5cdCAgICogQHBhcmFtIHtUU2VxdWVuY2VQYXJ0fSBsYXN0X3BpZWNlXG5cdCAgICovXG5cblxuXHQgIGNsb25lKHBvc2l0aW9uLCBsYXN0X3BpZWNlKSB7XG5cdCAgICBsZXQgY2xvbmUgPSBuZXcgU2VxdWVuY2UoKTtcblx0ICAgIGxldCBwYXJ0cyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5wYXJ0cykpO1xuXHQgICAgbGV0IGxhc3RfcGFydCA9IHBhcnRzLnBvcCgpO1xuXG5cdCAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcblx0ICAgICAgY2xvbmUuYWRkKHBhcnQpO1xuXHQgICAgfVxuXG5cdCAgICBsZXQgbGFzdF9zdWJzdHIgPSBsYXN0X3BpZWNlLnN1YnN0ci5zdWJzdHJpbmcoMCwgcG9zaXRpb24gLSBsYXN0X3BhcnQuc3RhcnQpO1xuXHQgICAgbGV0IGNsb25lX2xhc3RfbGVuID0gbGFzdF9zdWJzdHIubGVuZ3RoO1xuXHQgICAgY2xvbmUuYWRkKHtcblx0ICAgICAgc3RhcnQ6IGxhc3RfcGFydC5zdGFydCxcblx0ICAgICAgZW5kOiBsYXN0X3BhcnQuc3RhcnQgKyBjbG9uZV9sYXN0X2xlbixcblx0ICAgICAgbGVuZ3RoOiBjbG9uZV9sYXN0X2xlbixcblx0ICAgICAgc3Vic3RyOiBsYXN0X3N1YnN0clxuXHQgICAgfSk7XG5cdCAgICByZXR1cm4gY2xvbmU7XG5cdCAgfVxuXG5cdH1cblx0LyoqXG5cdCAqIEV4cGFuZCBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBwYXR0ZXJuIHRvIGluY2x1ZGUgdW5pY29kZSB2YXJpYW50c1xuXHQgKiBcdGVnIC9hLyBiZWNvbWVzIC9h4pOQ772B4bqaw6DDocOi4bqn4bql4bqr4bqpw6PEgcSD4bqx4bqv4bq14bqzyKfHocOkx5/huqPDpce7x47IgciD4bqh4bqt4bq34biBxIXisaXJkMmRQeKStu+8ocOAw4HDguG6puG6pOG6quG6qMODxIDEguG6sOG6ruG6tOG6ssimx6DDhMee4bqiw4XHuseNyIDIguG6oOG6rOG6tuG4gMSEyLrisa8vXG5cdCAqXG5cdCAqIElzc3VlOlxuXHQgKiAg77qK77qLIFsgJ++6iiA9IFxcXFx1e2ZlOGF9JywgJ++6iyA9IFxcXFx1e2ZlOGJ9JyBdXG5cdCAqXHRiZWNvbWVzOlx02YrZlNmK2ZQgWyAn2YogPSBcXFxcdXs2NGF9JywgJ9mUID0gXFxcXHV7NjU0fScsICfZiiA9IFxcXFx1ezY0YX0nLCAn2ZQgPSBcXFxcdXs2NTR9JyBdXG5cdCAqXG5cdCAqXHTEsMSyID0gSUlKID0g4oWhSlxuXHQgKlxuXHQgKiBcdDEvMi80XG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcblx0ICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH1cblx0ICovXG5cblxuXHRjb25zdCBnZXRQYXR0ZXJuID0gc3RyID0+IHtcblx0ICBpbml0aWFsaXplKCk7XG5cdCAgc3RyID0gYXNjaWlmb2xkKHN0cik7XG5cdCAgbGV0IHBhdHRlcm4gPSAnJztcblx0ICBsZXQgc2VxdWVuY2VzID0gW25ldyBTZXF1ZW5jZSgpXTtcblxuXHQgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBsZXQgc3Vic3RyID0gc3RyLnN1YnN0cmluZyhpKTtcblx0ICAgIGxldCBtYXRjaCA9IHN1YnN0ci5tYXRjaChtdWx0aV9jaGFyX3JlZyk7XG5cdCAgICBjb25zdCBjaGFyID0gc3RyLnN1YnN0cmluZyhpLCBpICsgMSk7XG5cdCAgICBjb25zdCBtYXRjaF9zdHIgPSBtYXRjaCA/IG1hdGNoWzBdIDogbnVsbDsgLy8gbG9vcCB0aHJvdWdoIHNlcXVlbmNlc1xuXHQgICAgLy8gYWRkIGVpdGhlciB0aGUgY2hhciBvciBtdWx0aV9tYXRjaFxuXG5cdCAgICBsZXQgb3ZlcmxhcHBpbmcgPSBbXTtcblx0ICAgIGxldCBhZGRlZF90eXBlcyA9IG5ldyBTZXQoKTtcblxuXHQgICAgZm9yIChjb25zdCBzZXF1ZW5jZSBvZiBzZXF1ZW5jZXMpIHtcblx0ICAgICAgY29uc3QgbGFzdF9waWVjZSA9IHNlcXVlbmNlLmxhc3QoKTtcblxuXHQgICAgICBpZiAoIWxhc3RfcGllY2UgfHwgbGFzdF9waWVjZS5sZW5ndGggPT0gMSB8fCBsYXN0X3BpZWNlLmVuZCA8PSBpKSB7XG5cdCAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIG11bHRpIG1hdGNoXG5cdCAgICAgICAgaWYgKG1hdGNoX3N0cikge1xuXHQgICAgICAgICAgY29uc3QgbGVuID0gbWF0Y2hfc3RyLmxlbmd0aDtcblx0ICAgICAgICAgIHNlcXVlbmNlLmFkZCh7XG5cdCAgICAgICAgICAgIHN0YXJ0OiBpLFxuXHQgICAgICAgICAgICBlbmQ6IGkgKyBsZW4sXG5cdCAgICAgICAgICAgIGxlbmd0aDogbGVuLFxuXHQgICAgICAgICAgICBzdWJzdHI6IG1hdGNoX3N0clxuXHQgICAgICAgICAgfSk7XG5cdCAgICAgICAgICBhZGRlZF90eXBlcy5hZGQoJzEnKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgc2VxdWVuY2UuYWRkKHtcblx0ICAgICAgICAgICAgc3RhcnQ6IGksXG5cdCAgICAgICAgICAgIGVuZDogaSArIDEsXG5cdCAgICAgICAgICAgIGxlbmd0aDogMSxcblx0ICAgICAgICAgICAgc3Vic3RyOiBjaGFyXG5cdCAgICAgICAgICB9KTtcblx0ICAgICAgICAgIGFkZGVkX3R5cGVzLmFkZCgnMicpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSBlbHNlIGlmIChtYXRjaF9zdHIpIHtcblx0ICAgICAgICBsZXQgY2xvbmUgPSBzZXF1ZW5jZS5jbG9uZShpLCBsYXN0X3BpZWNlKTtcblx0ICAgICAgICBjb25zdCBsZW4gPSBtYXRjaF9zdHIubGVuZ3RoO1xuXHQgICAgICAgIGNsb25lLmFkZCh7XG5cdCAgICAgICAgICBzdGFydDogaSxcblx0ICAgICAgICAgIGVuZDogaSArIGxlbixcblx0ICAgICAgICAgIGxlbmd0aDogbGVuLFxuXHQgICAgICAgICAgc3Vic3RyOiBtYXRjaF9zdHJcblx0ICAgICAgICB9KTtcblx0ICAgICAgICBvdmVybGFwcGluZy5wdXNoKGNsb25lKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAvLyBkb24ndCBhZGQgY2hhclxuXHQgICAgICAgIC8vIGFkZGluZyB3b3VsZCBjcmVhdGUgaW52YWxpZCBwYXR0ZXJuczogMjM0ID0+IFsyLDM0LDRdXG5cdCAgICAgICAgYWRkZWRfdHlwZXMuYWRkKCczJyk7XG5cdCAgICAgIH1cblx0ICAgIH0gLy8gaWYgd2UgaGF2ZSBvdmVybGFwcGluZ1xuXG5cblx0ICAgIGlmIChvdmVybGFwcGluZy5sZW5ndGggPiAwKSB7XG5cdCAgICAgIC8vIFsnaWknLCdpaWknXSBiZWZvcmUgWydpJywnaScsJ2lpaSddXG5cdCAgICAgIG92ZXJsYXBwaW5nID0gb3ZlcmxhcHBpbmcuc29ydCgoYSwgYikgPT4ge1xuXHQgICAgICAgIHJldHVybiBhLmxlbmd0aCgpIC0gYi5sZW5ndGgoKTtcblx0ICAgICAgfSk7XG5cblx0ICAgICAgZm9yIChsZXQgY2xvbmUgb2Ygb3ZlcmxhcHBpbmcpIHtcblx0ICAgICAgICAvLyBkb24ndCBhZGQgaWYgd2UgYWxyZWFkeSBoYXZlIGFuIGVxdWl2YWxlbnQgc2VxdWVuY2Vcblx0ICAgICAgICBpZiAoaW5TZXF1ZW5jZXMoY2xvbmUsIHNlcXVlbmNlcykpIHtcblx0ICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHNlcXVlbmNlcy5wdXNoKGNsb25lKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGNvbnRpbnVlO1xuXHQgICAgfSAvLyBpZiB3ZSBoYXZlbid0IGRvbmUgYW55dGhpbmcgdW5pcXVlXG5cdCAgICAvLyBjbGVhbiB1cCB0aGUgcGF0dGVybnNcblx0ICAgIC8vIGhlbHBzIGtlZXAgcGF0dGVybnMgc21hbGxlclxuXHQgICAgLy8gaWYgc3RyID0gJ3LigqjjjqdhYXJzcycsIHBhdHRlcm4gd2lsbCBiZSA0NDYgaW5zdGVhZCBvZiA2NTVcblxuXG5cdCAgICBpZiAoaSA+IDAgJiYgYWRkZWRfdHlwZXMuc2l6ZSA9PSAxICYmICFhZGRlZF90eXBlcy5oYXMoJzMnKSkge1xuXHQgICAgICBwYXR0ZXJuICs9IHNlcXVlbmNlc1RvUGF0dGVybihzZXF1ZW5jZXMsIGZhbHNlKTtcblx0ICAgICAgbGV0IG5ld19zZXEgPSBuZXcgU2VxdWVuY2UoKTtcblx0ICAgICAgY29uc3Qgb2xkX3NlcSA9IHNlcXVlbmNlc1swXTtcblxuXHQgICAgICBpZiAob2xkX3NlcSkge1xuXHQgICAgICAgIG5ld19zZXEuYWRkKG9sZF9zZXEubGFzdCgpKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHNlcXVlbmNlcyA9IFtuZXdfc2VxXTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBwYXR0ZXJuICs9IHNlcXVlbmNlc1RvUGF0dGVybihzZXF1ZW5jZXMsIHRydWUpO1xuXHQgIHJldHVybiBwYXR0ZXJuO1xuXHR9O1xuXG5cdC8qISBzaWZ0ZXIuanMgfCBodHRwczovL2dpdGh1Yi5jb20vb3JjaGlkanMvc2lmdGVyLmpzIHwgQXBhY2hlIExpY2Vuc2UgKHYyKSAqL1xuXG5cdC8qKlxuXHQgKiBBIHByb3BlcnR5IGdldHRlciByZXNvbHZpbmcgZG90LW5vdGF0aW9uXG5cdCAqIEBwYXJhbSAge09iamVjdH0gIG9iaiAgICAgVGhlIHJvb3Qgb2JqZWN0IHRvIGZldGNoIHByb3BlcnR5IG9uXG5cdCAqIEBwYXJhbSAge1N0cmluZ30gIG5hbWUgICAgVGhlIG9wdGlvbmFsbHkgZG90dGVkIHByb3BlcnR5IG5hbWUgdG8gZmV0Y2hcblx0ICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgICBUaGUgcmVzb2x2ZWQgcHJvcGVydHkgdmFsdWVcblx0ICovXG5cdGNvbnN0IGdldEF0dHIgPSAob2JqLCBuYW1lKSA9PiB7XG5cdCAgaWYgKCFvYmopIHJldHVybjtcblx0ICByZXR1cm4gb2JqW25hbWVdO1xuXHR9O1xuXHQvKipcblx0ICogQSBwcm9wZXJ0eSBnZXR0ZXIgcmVzb2x2aW5nIGRvdC1ub3RhdGlvblxuXHQgKiBAcGFyYW0gIHtPYmplY3R9ICBvYmogICAgIFRoZSByb290IG9iamVjdCB0byBmZXRjaCBwcm9wZXJ0eSBvblxuXHQgKiBAcGFyYW0gIHtTdHJpbmd9ICBuYW1lICAgIFRoZSBvcHRpb25hbGx5IGRvdHRlZCBwcm9wZXJ0eSBuYW1lIHRvIGZldGNoXG5cdCAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgVGhlIHJlc29sdmVkIHByb3BlcnR5IHZhbHVlXG5cdCAqL1xuXG5cdGNvbnN0IGdldEF0dHJOZXN0aW5nID0gKG9iaiwgbmFtZSkgPT4ge1xuXHQgIGlmICghb2JqKSByZXR1cm47XG5cdCAgdmFyIHBhcnQsXG5cdCAgICAgIG5hbWVzID0gbmFtZS5zcGxpdChcIi5cIik7XG5cblx0ICB3aGlsZSAoKHBhcnQgPSBuYW1lcy5zaGlmdCgpKSAmJiAob2JqID0gb2JqW3BhcnRdKSk7XG5cblx0ICByZXR1cm4gb2JqO1xuXHR9O1xuXHQvKipcblx0ICogQ2FsY3VsYXRlcyBob3cgY2xvc2Ugb2YgYSBtYXRjaCB0aGVcblx0ICogZ2l2ZW4gdmFsdWUgaXMgYWdhaW5zdCBhIHNlYXJjaCB0b2tlbi5cblx0ICpcblx0ICovXG5cblx0Y29uc3Qgc2NvcmVWYWx1ZSA9ICh2YWx1ZSwgdG9rZW4sIHdlaWdodCkgPT4ge1xuXHQgIHZhciBzY29yZSwgcG9zO1xuXHQgIGlmICghdmFsdWUpIHJldHVybiAwO1xuXHQgIHZhbHVlID0gdmFsdWUgKyAnJztcblx0ICBpZiAodG9rZW4ucmVnZXggPT0gbnVsbCkgcmV0dXJuIDA7XG5cdCAgcG9zID0gdmFsdWUuc2VhcmNoKHRva2VuLnJlZ2V4KTtcblx0ICBpZiAocG9zID09PSAtMSkgcmV0dXJuIDA7XG5cdCAgc2NvcmUgPSB0b2tlbi5zdHJpbmcubGVuZ3RoIC8gdmFsdWUubGVuZ3RoO1xuXHQgIGlmIChwb3MgPT09IDApIHNjb3JlICs9IDAuNTtcblx0ICByZXR1cm4gc2NvcmUgKiB3ZWlnaHQ7XG5cdH07XG5cdC8qKlxuXHQgKiBDYXN0IG9iamVjdCBwcm9wZXJ0eSB0byBhbiBhcnJheSBpZiBpdCBleGlzdHMgYW5kIGhhcyBhIHZhbHVlXG5cdCAqXG5cdCAqL1xuXG5cdGNvbnN0IHByb3BUb0FycmF5ID0gKG9iaiwga2V5KSA9PiB7XG5cdCAgdmFyIHZhbHVlID0gb2JqW2tleV07XG5cdCAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSByZXR1cm4gdmFsdWU7XG5cblx0ICBpZiAodmFsdWUgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdCAgICBvYmpba2V5XSA9IFt2YWx1ZV07XG5cdCAgfVxuXHR9O1xuXHQvKipcblx0ICogSXRlcmF0ZXMgb3ZlciBhcnJheXMgYW5kIGhhc2hlcy5cblx0ICpcblx0ICogYGBgXG5cdCAqIGl0ZXJhdGUodGhpcy5pdGVtcywgZnVuY3Rpb24oaXRlbSwgaWQpIHtcblx0ICogICAgLy8gaW52b2tlZCBmb3IgZWFjaCBpdGVtXG5cdCAqIH0pO1xuXHQgKiBgYGBcblx0ICpcblx0ICovXG5cblx0Y29uc3QgaXRlcmF0ZSQxID0gKG9iamVjdCwgY2FsbGJhY2spID0+IHtcblx0ICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG5cdCAgICBvYmplY3QuZm9yRWFjaChjYWxsYmFjayk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcblx0ICAgICAgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdCAgICAgICAgY2FsbGJhY2sob2JqZWN0W2tleV0sIGtleSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdH07XG5cdGNvbnN0IGNtcCA9IChhLCBiKSA9PiB7XG5cdCAgaWYgKHR5cGVvZiBhID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgYiA9PT0gJ251bWJlcicpIHtcblx0ICAgIHJldHVybiBhID4gYiA/IDEgOiBhIDwgYiA/IC0xIDogMDtcblx0ICB9XG5cblx0ICBhID0gYXNjaWlmb2xkKGEgKyAnJykudG9Mb3dlckNhc2UoKTtcblx0ICBiID0gYXNjaWlmb2xkKGIgKyAnJykudG9Mb3dlckNhc2UoKTtcblx0ICBpZiAoYSA+IGIpIHJldHVybiAxO1xuXHQgIGlmIChiID4gYSkgcmV0dXJuIC0xO1xuXHQgIHJldHVybiAwO1xuXHR9O1xuXG5cdC8qISBzaWZ0ZXIuanMgfCBodHRwczovL2dpdGh1Yi5jb20vb3JjaGlkanMvc2lmdGVyLmpzIHwgQXBhY2hlIExpY2Vuc2UgKHYyKSAqL1xuXG5cdC8qKlxuXHQgKiBzaWZ0ZXIuanNcblx0ICogQ29weXJpZ2h0IChjKSAyMDEz4oCTMjAyMCBCcmlhbiBSZWF2aXMgJiBjb250cmlidXRvcnNcblx0ICpcblx0ICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXNcblx0ICogZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XG5cdCAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXHQgKlxuXHQgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG5cdCAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0Zcblx0ICogQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG5cdCAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cdCAqXG5cdCAqIEBhdXRob3IgQnJpYW4gUmVhdmlzIDxicmlhbkB0aGlyZHJvdXRlLmNvbT5cblx0ICovXG5cblx0Y2xhc3MgU2lmdGVyIHtcblx0ICAvLyBbXXx7fTtcblxuXHQgIC8qKlxuXHQgICAqIFRleHR1YWxseSBzZWFyY2hlcyBhcnJheXMgYW5kIGhhc2hlcyBvZiBvYmplY3RzXG5cdCAgICogYnkgcHJvcGVydHkgKG9yIG11bHRpcGxlIHByb3BlcnRpZXMpLiBEZXNpZ25lZFxuXHQgICAqIHNwZWNpZmljYWxseSBmb3IgYXV0b2NvbXBsZXRlLlxuXHQgICAqXG5cdCAgICovXG5cdCAgY29uc3RydWN0b3IoaXRlbXMsIHNldHRpbmdzKSB7XG5cdCAgICB0aGlzLml0ZW1zID0gdm9pZCAwO1xuXHQgICAgdGhpcy5zZXR0aW5ncyA9IHZvaWQgMDtcblx0ICAgIHRoaXMuaXRlbXMgPSBpdGVtcztcblx0ICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncyB8fCB7XG5cdCAgICAgIGRpYWNyaXRpY3M6IHRydWVcblx0ICAgIH07XG5cdCAgfVxuXG5cdCAgLyoqXG5cdCAgICogU3BsaXRzIGEgc2VhcmNoIHN0cmluZyBpbnRvIGFuIGFycmF5IG9mIGluZGl2aWR1YWxcblx0ICAgKiByZWdleHBzIHRvIGJlIHVzZWQgdG8gbWF0Y2ggcmVzdWx0cy5cblx0ICAgKlxuXHQgICAqL1xuXHQgIHRva2VuaXplKHF1ZXJ5LCByZXNwZWN0X3dvcmRfYm91bmRhcmllcywgd2VpZ2h0cykge1xuXHQgICAgaWYgKCFxdWVyeSB8fCAhcXVlcnkubGVuZ3RoKSByZXR1cm4gW107XG5cdCAgICBjb25zdCB0b2tlbnMgPSBbXTtcblx0ICAgIGNvbnN0IHdvcmRzID0gcXVlcnkuc3BsaXQoL1xccysvKTtcblx0ICAgIHZhciBmaWVsZF9yZWdleDtcblxuXHQgICAgaWYgKHdlaWdodHMpIHtcblx0ICAgICAgZmllbGRfcmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBPYmplY3Qua2V5cyh3ZWlnaHRzKS5tYXAoZXNjYXBlX3JlZ2V4KS5qb2luKCd8JykgKyAnKVxcOiguKikkJyk7XG5cdCAgICB9XG5cblx0ICAgIHdvcmRzLmZvckVhY2god29yZCA9PiB7XG5cdCAgICAgIGxldCBmaWVsZF9tYXRjaDtcblx0ICAgICAgbGV0IGZpZWxkID0gbnVsbDtcblx0ICAgICAgbGV0IHJlZ2V4ID0gbnVsbDsgLy8gbG9vayBmb3IgXCJmaWVsZDpxdWVyeVwiIHRva2Vuc1xuXG5cdCAgICAgIGlmIChmaWVsZF9yZWdleCAmJiAoZmllbGRfbWF0Y2ggPSB3b3JkLm1hdGNoKGZpZWxkX3JlZ2V4KSkpIHtcblx0ICAgICAgICBmaWVsZCA9IGZpZWxkX21hdGNoWzFdO1xuXHQgICAgICAgIHdvcmQgPSBmaWVsZF9tYXRjaFsyXTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmICh3b3JkLmxlbmd0aCA+IDApIHtcblx0ICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5kaWFjcml0aWNzKSB7XG5cdCAgICAgICAgICByZWdleCA9IGdldFBhdHRlcm4od29yZCkgfHwgbnVsbDtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgcmVnZXggPSBlc2NhcGVfcmVnZXgod29yZCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKHJlZ2V4ICYmIHJlc3BlY3Rfd29yZF9ib3VuZGFyaWVzKSByZWdleCA9IFwiXFxcXGJcIiArIHJlZ2V4O1xuXHQgICAgICB9XG5cblx0ICAgICAgdG9rZW5zLnB1c2goe1xuXHQgICAgICAgIHN0cmluZzogd29yZCxcblx0ICAgICAgICByZWdleDogcmVnZXggPyBuZXcgUmVnRXhwKHJlZ2V4LCAnaXUnKSA6IG51bGwsXG5cdCAgICAgICAgZmllbGQ6IGZpZWxkXG5cdCAgICAgIH0pO1xuXHQgICAgfSk7XG5cdCAgICByZXR1cm4gdG9rZW5zO1xuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIFJldHVybnMgYSBmdW5jdGlvbiB0byBiZSB1c2VkIHRvIHNjb3JlIGluZGl2aWR1YWwgcmVzdWx0cy5cblx0ICAgKlxuXHQgICAqIEdvb2QgbWF0Y2hlcyB3aWxsIGhhdmUgYSBoaWdoZXIgc2NvcmUgdGhhbiBwb29yIG1hdGNoZXMuXG5cdCAgICogSWYgYW4gaXRlbSBpcyBub3QgYSBtYXRjaCwgMCB3aWxsIGJlIHJldHVybmVkIGJ5IHRoZSBmdW5jdGlvbi5cblx0ICAgKlxuXHQgICAqIEByZXR1cm5zIHtULlNjb3JlRm59XG5cdCAgICovXG5cdCAgZ2V0U2NvcmVGdW5jdGlvbihxdWVyeSwgb3B0aW9ucykge1xuXHQgICAgdmFyIHNlYXJjaCA9IHRoaXMucHJlcGFyZVNlYXJjaChxdWVyeSwgb3B0aW9ucyk7XG5cdCAgICByZXR1cm4gdGhpcy5fZ2V0U2NvcmVGdW5jdGlvbihzZWFyY2gpO1xuXHQgIH1cblx0ICAvKipcblx0ICAgKiBAcmV0dXJucyB7VC5TY29yZUZufVxuXHQgICAqXG5cdCAgICovXG5cblxuXHQgIF9nZXRTY29yZUZ1bmN0aW9uKHNlYXJjaCkge1xuXHQgICAgY29uc3QgdG9rZW5zID0gc2VhcmNoLnRva2Vucyxcblx0ICAgICAgICAgIHRva2VuX2NvdW50ID0gdG9rZW5zLmxlbmd0aDtcblxuXHQgICAgaWYgKCF0b2tlbl9jb3VudCkge1xuXHQgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiAwO1xuXHQgICAgICB9O1xuXHQgICAgfVxuXG5cdCAgICBjb25zdCBmaWVsZHMgPSBzZWFyY2gub3B0aW9ucy5maWVsZHMsXG5cdCAgICAgICAgICB3ZWlnaHRzID0gc2VhcmNoLndlaWdodHMsXG5cdCAgICAgICAgICBmaWVsZF9jb3VudCA9IGZpZWxkcy5sZW5ndGgsXG5cdCAgICAgICAgICBnZXRBdHRyRm4gPSBzZWFyY2guZ2V0QXR0ckZuO1xuXG5cdCAgICBpZiAoIWZpZWxkX2NvdW50KSB7XG5cdCAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIDE7XG5cdCAgICAgIH07XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIENhbGN1bGF0ZXMgdGhlIHNjb3JlIG9mIGFuIG9iamVjdFxuXHQgICAgICogYWdhaW5zdCB0aGUgc2VhcmNoIHF1ZXJ5LlxuXHQgICAgICpcblx0ICAgICAqL1xuXG5cblx0ICAgIGNvbnN0IHNjb3JlT2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICBpZiAoZmllbGRfY291bnQgPT09IDEpIHtcblx0ICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRva2VuLCBkYXRhKSB7XG5cdCAgICAgICAgICBjb25zdCBmaWVsZCA9IGZpZWxkc1swXS5maWVsZDtcblx0ICAgICAgICAgIHJldHVybiBzY29yZVZhbHVlKGdldEF0dHJGbihkYXRhLCBmaWVsZCksIHRva2VuLCB3ZWlnaHRzW2ZpZWxkXSB8fCAxKTtcblx0ICAgICAgICB9O1xuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0b2tlbiwgZGF0YSkge1xuXHQgICAgICAgIHZhciBzdW0gPSAwOyAvLyBpcyB0aGUgdG9rZW4gc3BlY2lmaWMgdG8gYSBmaWVsZD9cblxuXHQgICAgICAgIGlmICh0b2tlbi5maWVsZCkge1xuXHQgICAgICAgICAgY29uc3QgdmFsdWUgPSBnZXRBdHRyRm4oZGF0YSwgdG9rZW4uZmllbGQpO1xuXG5cdCAgICAgICAgICBpZiAoIXRva2VuLnJlZ2V4ICYmIHZhbHVlKSB7XG5cdCAgICAgICAgICAgIHN1bSArPSAxIC8gZmllbGRfY291bnQ7XG5cdCAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBzdW0gKz0gc2NvcmVWYWx1ZSh2YWx1ZSwgdG9rZW4sIDEpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBpdGVyYXRlJDEod2VpZ2h0cywgKHdlaWdodCwgZmllbGQpID0+IHtcblx0ICAgICAgICAgICAgc3VtICs9IHNjb3JlVmFsdWUoZ2V0QXR0ckZuKGRhdGEsIGZpZWxkKSwgdG9rZW4sIHdlaWdodCk7XG5cdCAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gc3VtIC8gZmllbGRfY291bnQ7XG5cdCAgICAgIH07XG5cdCAgICB9KCk7XG5cblx0ICAgIGlmICh0b2tlbl9jb3VudCA9PT0gMSkge1xuXHQgICAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgICAgICByZXR1cm4gc2NvcmVPYmplY3QodG9rZW5zWzBdLCBkYXRhKTtcblx0ICAgICAgfTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHNlYXJjaC5vcHRpb25zLmNvbmp1bmN0aW9uID09PSAnYW5kJykge1xuXHQgICAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgICAgICB2YXIgc2NvcmUsXG5cdCAgICAgICAgICAgIHN1bSA9IDA7XG5cblx0ICAgICAgICBmb3IgKGxldCB0b2tlbiBvZiB0b2tlbnMpIHtcblx0ICAgICAgICAgIHNjb3JlID0gc2NvcmVPYmplY3QodG9rZW4sIGRhdGEpO1xuXHQgICAgICAgICAgaWYgKHNjb3JlIDw9IDApIHJldHVybiAwO1xuXHQgICAgICAgICAgc3VtICs9IHNjb3JlO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiBzdW0gLyB0b2tlbl9jb3VudDtcblx0ICAgICAgfTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJldHVybiBmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgICAgIHZhciBzdW0gPSAwO1xuXHQgICAgICAgIGl0ZXJhdGUkMSh0b2tlbnMsIHRva2VuID0+IHtcblx0ICAgICAgICAgIHN1bSArPSBzY29yZU9iamVjdCh0b2tlbiwgZGF0YSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgcmV0dXJuIHN1bSAvIHRva2VuX2NvdW50O1xuXHQgICAgICB9O1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGNvbXBhcmUgdHdvXG5cdCAgICogcmVzdWx0cywgZm9yIHNvcnRpbmcgcHVycG9zZXMuIElmIG5vIHNvcnRpbmcgc2hvdWxkXG5cdCAgICogYmUgcGVyZm9ybWVkLCBgbnVsbGAgd2lsbCBiZSByZXR1cm5lZC5cblx0ICAgKlxuXHQgICAqIEByZXR1cm4gZnVuY3Rpb24oYSxiKVxuXHQgICAqL1xuXHQgIGdldFNvcnRGdW5jdGlvbihxdWVyeSwgb3B0aW9ucykge1xuXHQgICAgdmFyIHNlYXJjaCA9IHRoaXMucHJlcGFyZVNlYXJjaChxdWVyeSwgb3B0aW9ucyk7XG5cdCAgICByZXR1cm4gdGhpcy5fZ2V0U29ydEZ1bmN0aW9uKHNlYXJjaCk7XG5cdCAgfVxuXG5cdCAgX2dldFNvcnRGdW5jdGlvbihzZWFyY2gpIHtcblx0ICAgIHZhciBpbXBsaWNpdF9zY29yZSxcblx0ICAgICAgICBzb3J0X2ZsZHMgPSBbXTtcblx0ICAgIGNvbnN0IHNlbGYgPSB0aGlzLFxuXHQgICAgICAgICAgb3B0aW9ucyA9IHNlYXJjaC5vcHRpb25zLFxuXHQgICAgICAgICAgc29ydCA9ICFzZWFyY2gucXVlcnkgJiYgb3B0aW9ucy5zb3J0X2VtcHR5ID8gb3B0aW9ucy5zb3J0X2VtcHR5IDogb3B0aW9ucy5zb3J0O1xuXG5cdCAgICBpZiAodHlwZW9mIHNvcnQgPT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICByZXR1cm4gc29ydC5iaW5kKHRoaXMpO1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBGZXRjaGVzIHRoZSBzcGVjaWZpZWQgc29ydCBmaWVsZCB2YWx1ZVxuXHQgICAgICogZnJvbSBhIHNlYXJjaCByZXN1bHQgaXRlbS5cblx0ICAgICAqXG5cdCAgICAgKi9cblxuXG5cdCAgICBjb25zdCBnZXRfZmllbGQgPSBmdW5jdGlvbiBnZXRfZmllbGQobmFtZSwgcmVzdWx0KSB7XG5cdCAgICAgIGlmIChuYW1lID09PSAnJHNjb3JlJykgcmV0dXJuIHJlc3VsdC5zY29yZTtcblx0ICAgICAgcmV0dXJuIHNlYXJjaC5nZXRBdHRyRm4oc2VsZi5pdGVtc1tyZXN1bHQuaWRdLCBuYW1lKTtcblx0ICAgIH07IC8vIHBhcnNlIG9wdGlvbnNcblxuXG5cdCAgICBpZiAoc29ydCkge1xuXHQgICAgICBmb3IgKGxldCBzIG9mIHNvcnQpIHtcblx0ICAgICAgICBpZiAoc2VhcmNoLnF1ZXJ5IHx8IHMuZmllbGQgIT09ICckc2NvcmUnKSB7XG5cdCAgICAgICAgICBzb3J0X2ZsZHMucHVzaChzKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH0gLy8gdGhlIFwiJHNjb3JlXCIgZmllbGQgaXMgaW1wbGllZCB0byBiZSB0aGUgcHJpbWFyeVxuXHQgICAgLy8gc29ydCBmaWVsZCwgdW5sZXNzIGl0J3MgbWFudWFsbHkgc3BlY2lmaWVkXG5cblxuXHQgICAgaWYgKHNlYXJjaC5xdWVyeSkge1xuXHQgICAgICBpbXBsaWNpdF9zY29yZSA9IHRydWU7XG5cblx0ICAgICAgZm9yIChsZXQgZmxkIG9mIHNvcnRfZmxkcykge1xuXHQgICAgICAgIGlmIChmbGQuZmllbGQgPT09ICckc2NvcmUnKSB7XG5cdCAgICAgICAgICBpbXBsaWNpdF9zY29yZSA9IGZhbHNlO1xuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKGltcGxpY2l0X3Njb3JlKSB7XG5cdCAgICAgICAgc29ydF9mbGRzLnVuc2hpZnQoe1xuXHQgICAgICAgICAgZmllbGQ6ICckc2NvcmUnLFxuXHQgICAgICAgICAgZGlyZWN0aW9uOiAnZGVzYydcblx0ICAgICAgICB9KTtcblx0ICAgICAgfSAvLyB3aXRob3V0IGEgc2VhcmNoLnF1ZXJ5LCBhbGwgaXRlbXMgd2lsbCBoYXZlIHRoZSBzYW1lIHNjb3JlXG5cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHNvcnRfZmxkcyA9IHNvcnRfZmxkcy5maWx0ZXIoZmxkID0+IGZsZC5maWVsZCAhPT0gJyRzY29yZScpO1xuXHQgICAgfSAvLyBidWlsZCBmdW5jdGlvblxuXG5cblx0ICAgIGNvbnN0IHNvcnRfZmxkc19jb3VudCA9IHNvcnRfZmxkcy5sZW5ndGg7XG5cblx0ICAgIGlmICghc29ydF9mbGRzX2NvdW50KSB7XG5cdCAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcblx0ICAgICAgdmFyIHJlc3VsdCwgZmllbGQ7XG5cblx0ICAgICAgZm9yIChsZXQgc29ydF9mbGQgb2Ygc29ydF9mbGRzKSB7XG5cdCAgICAgICAgZmllbGQgPSBzb3J0X2ZsZC5maWVsZDtcblx0ICAgICAgICBsZXQgbXVsdGlwbGllciA9IHNvcnRfZmxkLmRpcmVjdGlvbiA9PT0gJ2Rlc2MnID8gLTEgOiAxO1xuXHQgICAgICAgIHJlc3VsdCA9IG11bHRpcGxpZXIgKiBjbXAoZ2V0X2ZpZWxkKGZpZWxkLCBhKSwgZ2V0X2ZpZWxkKGZpZWxkLCBiKSk7XG5cdCAgICAgICAgaWYgKHJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiAwO1xuXHQgICAgfTtcblx0ICB9XG5cblx0ICAvKipcblx0ICAgKiBQYXJzZXMgYSBzZWFyY2ggcXVlcnkgYW5kIHJldHVybnMgYW4gb2JqZWN0XG5cdCAgICogd2l0aCB0b2tlbnMgYW5kIGZpZWxkcyByZWFkeSB0byBiZSBwb3B1bGF0ZWRcblx0ICAgKiB3aXRoIHJlc3VsdHMuXG5cdCAgICpcblx0ICAgKi9cblx0ICBwcmVwYXJlU2VhcmNoKHF1ZXJ5LCBvcHRzVXNlcikge1xuXHQgICAgY29uc3Qgd2VpZ2h0cyA9IHt9O1xuXHQgICAgdmFyIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRzVXNlcik7XG5cdCAgICBwcm9wVG9BcnJheShvcHRpb25zLCAnc29ydCcpO1xuXHQgICAgcHJvcFRvQXJyYXkob3B0aW9ucywgJ3NvcnRfZW1wdHknKTsgLy8gY29udmVydCBmaWVsZHMgdG8gbmV3IGZvcm1hdFxuXG5cdCAgICBpZiAob3B0aW9ucy5maWVsZHMpIHtcblx0ICAgICAgcHJvcFRvQXJyYXkob3B0aW9ucywgJ2ZpZWxkcycpO1xuXHQgICAgICBjb25zdCBmaWVsZHMgPSBbXTtcblx0ICAgICAgb3B0aW9ucy5maWVsZHMuZm9yRWFjaChmaWVsZCA9PiB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiBmaWVsZCA9PSAnc3RyaW5nJykge1xuXHQgICAgICAgICAgZmllbGQgPSB7XG5cdCAgICAgICAgICAgIGZpZWxkOiBmaWVsZCxcblx0ICAgICAgICAgICAgd2VpZ2h0OiAxXG5cdCAgICAgICAgICB9O1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGZpZWxkcy5wdXNoKGZpZWxkKTtcblx0ICAgICAgICB3ZWlnaHRzW2ZpZWxkLmZpZWxkXSA9ICd3ZWlnaHQnIGluIGZpZWxkID8gZmllbGQud2VpZ2h0IDogMTtcblx0ICAgICAgfSk7XG5cdCAgICAgIG9wdGlvbnMuZmllbGRzID0gZmllbGRzO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4ge1xuXHQgICAgICBvcHRpb25zOiBvcHRpb25zLFxuXHQgICAgICBxdWVyeTogcXVlcnkudG9Mb3dlckNhc2UoKS50cmltKCksXG5cdCAgICAgIHRva2VuczogdGhpcy50b2tlbml6ZShxdWVyeSwgb3B0aW9ucy5yZXNwZWN0X3dvcmRfYm91bmRhcmllcywgd2VpZ2h0cyksXG5cdCAgICAgIHRvdGFsOiAwLFxuXHQgICAgICBpdGVtczogW10sXG5cdCAgICAgIHdlaWdodHM6IHdlaWdodHMsXG5cdCAgICAgIGdldEF0dHJGbjogb3B0aW9ucy5uZXN0aW5nID8gZ2V0QXR0ck5lc3RpbmcgOiBnZXRBdHRyXG5cdCAgICB9O1xuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIFNlYXJjaGVzIHRocm91Z2ggYWxsIGl0ZW1zIGFuZCByZXR1cm5zIGEgc29ydGVkIGFycmF5IG9mIG1hdGNoZXMuXG5cdCAgICpcblx0ICAgKi9cblx0ICBzZWFyY2gocXVlcnksIG9wdGlvbnMpIHtcblx0ICAgIHZhciBzZWxmID0gdGhpcyxcblx0ICAgICAgICBzY29yZSxcblx0ICAgICAgICBzZWFyY2g7XG5cdCAgICBzZWFyY2ggPSB0aGlzLnByZXBhcmVTZWFyY2gocXVlcnksIG9wdGlvbnMpO1xuXHQgICAgb3B0aW9ucyA9IHNlYXJjaC5vcHRpb25zO1xuXHQgICAgcXVlcnkgPSBzZWFyY2gucXVlcnk7IC8vIGdlbmVyYXRlIHJlc3VsdCBzY29yaW5nIGZ1bmN0aW9uXG5cblx0ICAgIGNvbnN0IGZuX3Njb3JlID0gb3B0aW9ucy5zY29yZSB8fCBzZWxmLl9nZXRTY29yZUZ1bmN0aW9uKHNlYXJjaCk7IC8vIHBlcmZvcm0gc2VhcmNoIGFuZCBzb3J0XG5cblxuXHQgICAgaWYgKHF1ZXJ5Lmxlbmd0aCkge1xuXHQgICAgICBpdGVyYXRlJDEoc2VsZi5pdGVtcywgKGl0ZW0sIGlkKSA9PiB7XG5cdCAgICAgICAgc2NvcmUgPSBmbl9zY29yZShpdGVtKTtcblxuXHQgICAgICAgIGlmIChvcHRpb25zLmZpbHRlciA9PT0gZmFsc2UgfHwgc2NvcmUgPiAwKSB7XG5cdCAgICAgICAgICBzZWFyY2guaXRlbXMucHVzaCh7XG5cdCAgICAgICAgICAgICdzY29yZSc6IHNjb3JlLFxuXHQgICAgICAgICAgICAnaWQnOiBpZFxuXHQgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9KTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGl0ZXJhdGUkMShzZWxmLml0ZW1zLCAoXywgaWQpID0+IHtcblx0ICAgICAgICBzZWFyY2guaXRlbXMucHVzaCh7XG5cdCAgICAgICAgICAnc2NvcmUnOiAxLFxuXHQgICAgICAgICAgJ2lkJzogaWRcblx0ICAgICAgICB9KTtcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cblx0ICAgIGNvbnN0IGZuX3NvcnQgPSBzZWxmLl9nZXRTb3J0RnVuY3Rpb24oc2VhcmNoKTtcblxuXHQgICAgaWYgKGZuX3NvcnQpIHNlYXJjaC5pdGVtcy5zb3J0KGZuX3NvcnQpOyAvLyBhcHBseSBsaW1pdHNcblxuXHQgICAgc2VhcmNoLnRvdGFsID0gc2VhcmNoLml0ZW1zLmxlbmd0aDtcblxuXHQgICAgaWYgKHR5cGVvZiBvcHRpb25zLmxpbWl0ID09PSAnbnVtYmVyJykge1xuXHQgICAgICBzZWFyY2guaXRlbXMgPSBzZWFyY2guaXRlbXMuc2xpY2UoMCwgb3B0aW9ucy5saW1pdCk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBzZWFyY2g7XG5cdCAgfVxuXG5cdH1cblxuXHQvKipcblx0ICogSXRlcmF0ZXMgb3ZlciBhcnJheXMgYW5kIGhhc2hlcy5cblx0ICpcblx0ICogYGBgXG5cdCAqIGl0ZXJhdGUodGhpcy5pdGVtcywgZnVuY3Rpb24oaXRlbSwgaWQpIHtcblx0ICogICAgLy8gaW52b2tlZCBmb3IgZWFjaCBpdGVtXG5cdCAqIH0pO1xuXHQgKiBgYGBcblx0ICpcblx0ICovXG5cblx0Y29uc3QgaXRlcmF0ZSA9IChvYmplY3QsIGNhbGxiYWNrKSA9PiB7XG5cdCAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuXHQgICAgb2JqZWN0LmZvckVhY2goY2FsbGJhY2spO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG5cdCAgICAgIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHQgICAgICAgIGNhbGxiYWNrKG9iamVjdFtrZXldLCBrZXkpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm4gYSBkb20gZWxlbWVudCBmcm9tIGVpdGhlciBhIGRvbSBxdWVyeSBzdHJpbmcsIGpRdWVyeSBvYmplY3QsIGEgZG9tIGVsZW1lbnQgb3IgaHRtbCBzdHJpbmdcblx0ICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDk0MTQzL2NyZWF0aW5nLWEtbmV3LWRvbS1lbGVtZW50LWZyb20tYW4taHRtbC1zdHJpbmctdXNpbmctYnVpbHQtaW4tZG9tLW1ldGhvZHMtb3ItcHJvLzM1Mzg1NTE4IzM1Mzg1NTE4XG5cdCAqXG5cdCAqIHBhcmFtIHF1ZXJ5IHNob3VsZCBiZSB7fVxuXHQgKi9cblxuXHRjb25zdCBnZXREb20gPSBxdWVyeSA9PiB7XG5cdCAgaWYgKHF1ZXJ5LmpxdWVyeSkge1xuXHQgICAgcmV0dXJuIHF1ZXJ5WzBdO1xuXHQgIH1cblxuXHQgIGlmIChxdWVyeSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG5cdCAgICByZXR1cm4gcXVlcnk7XG5cdCAgfVxuXG5cdCAgaWYgKGlzSHRtbFN0cmluZyhxdWVyeSkpIHtcblx0ICAgIHZhciB0cGwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuXHQgICAgdHBsLmlubmVySFRNTCA9IHF1ZXJ5LnRyaW0oKTsgLy8gTmV2ZXIgcmV0dXJuIGEgdGV4dCBub2RlIG9mIHdoaXRlc3BhY2UgYXMgdGhlIHJlc3VsdFxuXG5cdCAgICByZXR1cm4gdHBsLmNvbnRlbnQuZmlyc3RDaGlsZDtcblx0ICB9XG5cblx0ICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihxdWVyeSk7XG5cdH07XG5cdGNvbnN0IGlzSHRtbFN0cmluZyA9IGFyZyA9PiB7XG5cdCAgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnICYmIGFyZy5pbmRleE9mKCc8JykgPiAtMSkge1xuXHQgICAgcmV0dXJuIHRydWU7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGZhbHNlO1xuXHR9O1xuXHRjb25zdCBlc2NhcGVRdWVyeSA9IHF1ZXJ5ID0+IHtcblx0ICByZXR1cm4gcXVlcnkucmVwbGFjZSgvWydcIlxcXFxdL2csICdcXFxcJCYnKTtcblx0fTtcblx0LyoqXG5cdCAqIERpc3BhdGNoIGFuIGV2ZW50XG5cdCAqXG5cdCAqL1xuXG5cdGNvbnN0IHRyaWdnZXJFdmVudCA9IChkb21fZWwsIGV2ZW50X25hbWUpID0+IHtcblx0ICB2YXIgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpO1xuXHQgIGV2ZW50LmluaXRFdmVudChldmVudF9uYW1lLCB0cnVlLCBmYWxzZSk7XG5cdCAgZG9tX2VsLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXHR9O1xuXHQvKipcblx0ICogQXBwbHkgQ1NTIHJ1bGVzIHRvIGEgZG9tIGVsZW1lbnRcblx0ICpcblx0ICovXG5cblx0Y29uc3QgYXBwbHlDU1MgPSAoZG9tX2VsLCBjc3MpID0+IHtcblx0ICBPYmplY3QuYXNzaWduKGRvbV9lbC5zdHlsZSwgY3NzKTtcblx0fTtcblx0LyoqXG5cdCAqIEFkZCBjc3MgY2xhc3Nlc1xuXHQgKlxuXHQgKi9cblxuXHRjb25zdCBhZGRDbGFzc2VzID0gKGVsbXRzLCAuLi5jbGFzc2VzKSA9PiB7XG5cdCAgdmFyIG5vcm1fY2xhc3NlcyA9IGNsYXNzZXNBcnJheShjbGFzc2VzKTtcblx0ICBlbG10cyA9IGNhc3RBc0FycmF5KGVsbXRzKTtcblx0ICBlbG10cy5tYXAoZWwgPT4ge1xuXHQgICAgbm9ybV9jbGFzc2VzLm1hcChjbHMgPT4ge1xuXHQgICAgICBlbC5jbGFzc0xpc3QuYWRkKGNscyk7XG5cdCAgICB9KTtcblx0ICB9KTtcblx0fTtcblx0LyoqXG5cdCAqIFJlbW92ZSBjc3MgY2xhc3Nlc1xuXHQgKlxuXHQgKi9cblxuXHRjb25zdCByZW1vdmVDbGFzc2VzID0gKGVsbXRzLCAuLi5jbGFzc2VzKSA9PiB7XG5cdCAgdmFyIG5vcm1fY2xhc3NlcyA9IGNsYXNzZXNBcnJheShjbGFzc2VzKTtcblx0ICBlbG10cyA9IGNhc3RBc0FycmF5KGVsbXRzKTtcblx0ICBlbG10cy5tYXAoZWwgPT4ge1xuXHQgICAgbm9ybV9jbGFzc2VzLm1hcChjbHMgPT4ge1xuXHQgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNscyk7XG5cdCAgICB9KTtcblx0ICB9KTtcblx0fTtcblx0LyoqXG5cdCAqIFJldHVybiBhcmd1bWVudHNcblx0ICpcblx0ICovXG5cblx0Y29uc3QgY2xhc3Nlc0FycmF5ID0gYXJncyA9PiB7XG5cdCAgdmFyIGNsYXNzZXMgPSBbXTtcblx0ICBpdGVyYXRlKGFyZ3MsIF9jbGFzc2VzID0+IHtcblx0ICAgIGlmICh0eXBlb2YgX2NsYXNzZXMgPT09ICdzdHJpbmcnKSB7XG5cdCAgICAgIF9jbGFzc2VzID0gX2NsYXNzZXMudHJpbSgpLnNwbGl0KC9bXFwxMVxcMTJcXDE0XFwxNVxcNDBdLyk7XG5cdCAgICB9XG5cblx0ICAgIGlmIChBcnJheS5pc0FycmF5KF9jbGFzc2VzKSkge1xuXHQgICAgICBjbGFzc2VzID0gY2xhc3Nlcy5jb25jYXQoX2NsYXNzZXMpO1xuXHQgICAgfVxuXHQgIH0pO1xuXHQgIHJldHVybiBjbGFzc2VzLmZpbHRlcihCb29sZWFuKTtcblx0fTtcblx0LyoqXG5cdCAqIENyZWF0ZSBhbiBhcnJheSBmcm9tIGFyZyBpZiBpdCdzIG5vdCBhbHJlYWR5IGFuIGFycmF5XG5cdCAqXG5cdCAqL1xuXG5cdGNvbnN0IGNhc3RBc0FycmF5ID0gYXJnID0+IHtcblx0ICBpZiAoIUFycmF5LmlzQXJyYXkoYXJnKSkge1xuXHQgICAgYXJnID0gW2FyZ107XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGFyZztcblx0fTtcblx0LyoqXG5cdCAqIEdldCB0aGUgY2xvc2VzdCBub2RlIHRvIHRoZSBldnQudGFyZ2V0IG1hdGNoaW5nIHRoZSBzZWxlY3RvclxuXHQgKiBTdG9wcyBhdCB3cmFwcGVyXG5cdCAqXG5cdCAqL1xuXG5cdGNvbnN0IHBhcmVudE1hdGNoID0gKHRhcmdldCwgc2VsZWN0b3IsIHdyYXBwZXIpID0+IHtcblx0ICBpZiAod3JhcHBlciAmJiAhd3JhcHBlci5jb250YWlucyh0YXJnZXQpKSB7XG5cdCAgICByZXR1cm47XG5cdCAgfVxuXG5cdCAgd2hpbGUgKHRhcmdldCAmJiB0YXJnZXQubWF0Y2hlcykge1xuXHQgICAgaWYgKHRhcmdldC5tYXRjaGVzKHNlbGVjdG9yKSkge1xuXHQgICAgICByZXR1cm4gdGFyZ2V0O1xuXHQgICAgfVxuXG5cdCAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcblx0ICB9XG5cdH07XG5cdC8qKlxuXHQgKiBHZXQgdGhlIGZpcnN0IG9yIGxhc3QgaXRlbSBmcm9tIGFuIGFycmF5XG5cdCAqXG5cdCAqID4gMCAtIHJpZ2h0IChsYXN0KVxuXHQgKiA8PSAwIC0gbGVmdCAoZmlyc3QpXG5cdCAqXG5cdCAqL1xuXG5cdGNvbnN0IGdldFRhaWwgPSAobGlzdCwgZGlyZWN0aW9uID0gMCkgPT4ge1xuXHQgIGlmIChkaXJlY3Rpb24gPiAwKSB7XG5cdCAgICByZXR1cm4gbGlzdFtsaXN0Lmxlbmd0aCAtIDFdO1xuXHQgIH1cblxuXHQgIHJldHVybiBsaXN0WzBdO1xuXHR9O1xuXHQvKipcblx0ICogUmV0dXJuIHRydWUgaWYgYW4gb2JqZWN0IGlzIGVtcHR5XG5cdCAqXG5cdCAqL1xuXG5cdGNvbnN0IGlzRW1wdHlPYmplY3QgPSBvYmogPT4ge1xuXHQgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA9PT0gMDtcblx0fTtcblx0LyoqXG5cdCAqIEdldCB0aGUgaW5kZXggb2YgYW4gZWxlbWVudCBhbW9uZ3N0IHNpYmxpbmcgbm9kZXMgb2YgdGhlIHNhbWUgdHlwZVxuXHQgKlxuXHQgKi9cblxuXHRjb25zdCBub2RlSW5kZXggPSAoZWwsIGFtb25nc3QpID0+IHtcblx0ICBpZiAoIWVsKSByZXR1cm4gLTE7XG5cdCAgYW1vbmdzdCA9IGFtb25nc3QgfHwgZWwubm9kZU5hbWU7XG5cdCAgdmFyIGkgPSAwO1xuXG5cdCAgd2hpbGUgKGVsID0gZWwucHJldmlvdXNFbGVtZW50U2libGluZykge1xuXHQgICAgaWYgKGVsLm1hdGNoZXMoYW1vbmdzdCkpIHtcblx0ICAgICAgaSsrO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiBpO1xuXHR9O1xuXHQvKipcblx0ICogU2V0IGF0dHJpYnV0ZXMgb2YgYW4gZWxlbWVudFxuXHQgKlxuXHQgKi9cblxuXHRjb25zdCBzZXRBdHRyID0gKGVsLCBhdHRycykgPT4ge1xuXHQgIGl0ZXJhdGUoYXR0cnMsICh2YWwsIGF0dHIpID0+IHtcblx0ICAgIGlmICh2YWwgPT0gbnVsbCkge1xuXHQgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBlbC5zZXRBdHRyaWJ1dGUoYXR0ciwgJycgKyB2YWwpO1xuXHQgICAgfVxuXHQgIH0pO1xuXHR9O1xuXHQvKipcblx0ICogUmVwbGFjZSBhIG5vZGVcblx0ICovXG5cblx0Y29uc3QgcmVwbGFjZU5vZGUgPSAoZXhpc3RpbmcsIHJlcGxhY2VtZW50KSA9PiB7XG5cdCAgaWYgKGV4aXN0aW5nLnBhcmVudE5vZGUpIGV4aXN0aW5nLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHJlcGxhY2VtZW50LCBleGlzdGluZyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIGhpZ2hsaWdodCB2MyB8IE1JVCBsaWNlbnNlIHwgSm9oYW5uIEJ1cmthcmQgPGpiQGVhaW8uY29tPlxuXHQgKiBIaWdobGlnaHRzIGFyYml0cmFyeSB0ZXJtcyBpbiBhIG5vZGUuXG5cdCAqXG5cdCAqIC0gTW9kaWZpZWQgYnkgTWFyc2hhbCA8YmVhdGdhdGVzQGdtYWlsLmNvbT4gMjAxMS02LTI0IChhZGRlZCByZWdleClcblx0ICogLSBNb2RpZmllZCBieSBCcmlhbiBSZWF2aXMgPGJyaWFuQHRoaXJkcm91dGUuY29tPiAyMDEyLTgtMjcgKGNsZWFudXApXG5cdCAqL1xuXHRjb25zdCBoaWdobGlnaHQgPSAoZWxlbWVudCwgcmVnZXgpID0+IHtcblx0ICBpZiAocmVnZXggPT09IG51bGwpIHJldHVybjsgLy8gY29udmV0IHN0cmluZyB0byByZWdleFxuXG5cdCAgaWYgKHR5cGVvZiByZWdleCA9PT0gJ3N0cmluZycpIHtcblx0ICAgIGlmICghcmVnZXgubGVuZ3RoKSByZXR1cm47XG5cdCAgICByZWdleCA9IG5ldyBSZWdFeHAocmVnZXgsICdpJyk7XG5cdCAgfSAvLyBXcmFwIG1hdGNoaW5nIHBhcnQgb2YgdGV4dCBub2RlIHdpdGggaGlnaGxpZ2h0aW5nIDxzcGFuPiwgZS5nLlxuXHQgIC8vIFNvY2NlciAgLT4gIDxzcGFuIGNsYXNzPVwiaGlnaGxpZ2h0XCI+U29jPC9zcGFuPmNlciAgZm9yIHJlZ2V4ID0gL3NvYy9pXG5cblxuXHQgIGNvbnN0IGhpZ2hsaWdodFRleHQgPSBub2RlID0+IHtcblx0ICAgIHZhciBtYXRjaCA9IG5vZGUuZGF0YS5tYXRjaChyZWdleCk7XG5cblx0ICAgIGlmIChtYXRjaCAmJiBub2RlLmRhdGEubGVuZ3RoID4gMCkge1xuXHQgICAgICB2YXIgc3Bhbm5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG5cdCAgICAgIHNwYW5ub2RlLmNsYXNzTmFtZSA9ICdoaWdobGlnaHQnO1xuXHQgICAgICB2YXIgbWlkZGxlYml0ID0gbm9kZS5zcGxpdFRleHQobWF0Y2guaW5kZXgpO1xuXHQgICAgICBtaWRkbGViaXQuc3BsaXRUZXh0KG1hdGNoWzBdLmxlbmd0aCk7XG5cdCAgICAgIHZhciBtaWRkbGVjbG9uZSA9IG1pZGRsZWJpdC5jbG9uZU5vZGUodHJ1ZSk7XG5cdCAgICAgIHNwYW5ub2RlLmFwcGVuZENoaWxkKG1pZGRsZWNsb25lKTtcblx0ICAgICAgcmVwbGFjZU5vZGUobWlkZGxlYml0LCBzcGFubm9kZSk7XG5cdCAgICAgIHJldHVybiAxO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gMDtcblx0ICB9OyAvLyBSZWN1cnNlIGVsZW1lbnQgbm9kZSwgbG9va2luZyBmb3IgY2hpbGQgdGV4dCBub2RlcyB0byBoaWdobGlnaHQsIHVubGVzcyBlbGVtZW50XG5cdCAgLy8gaXMgY2hpbGRsZXNzLCA8c2NyaXB0PiwgPHN0eWxlPiwgb3IgYWxyZWFkeSBoaWdobGlnaHRlZDogPHNwYW4gY2xhc3M9XCJoaWdodGxpZ2h0XCI+XG5cblxuXHQgIGNvbnN0IGhpZ2hsaWdodENoaWxkcmVuID0gbm9kZSA9PiB7XG5cdCAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBub2RlLmNoaWxkTm9kZXMgJiYgIS8oc2NyaXB0fHN0eWxlKS9pLnRlc3Qobm9kZS50YWdOYW1lKSAmJiAobm9kZS5jbGFzc05hbWUgIT09ICdoaWdobGlnaHQnIHx8IG5vZGUudGFnTmFtZSAhPT0gJ1NQQU4nKSkge1xuXHQgICAgICBBcnJheS5mcm9tKG5vZGUuY2hpbGROb2RlcykuZm9yRWFjaChlbGVtZW50ID0+IHtcblx0ICAgICAgICBoaWdobGlnaHRSZWN1cnNpdmUoZWxlbWVudCk7XG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICBjb25zdCBoaWdobGlnaHRSZWN1cnNpdmUgPSBub2RlID0+IHtcblx0ICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAzKSB7XG5cdCAgICAgIHJldHVybiBoaWdobGlnaHRUZXh0KG5vZGUpO1xuXHQgICAgfVxuXG5cdCAgICBoaWdobGlnaHRDaGlsZHJlbihub2RlKTtcblx0ICAgIHJldHVybiAwO1xuXHQgIH07XG5cblx0ICBoaWdobGlnaHRSZWN1cnNpdmUoZWxlbWVudCk7XG5cdH07XG5cdC8qKlxuXHQgKiByZW1vdmVIaWdobGlnaHQgZm4gY29waWVkIGZyb20gaGlnaGxpZ2h0IHY1IGFuZFxuXHQgKiBlZGl0ZWQgdG8gcmVtb3ZlIHdpdGgoKSwgcGFzcyBqcyBzdHJpY3QgbW9kZSwgYW5kIHVzZSB3aXRob3V0IGpxdWVyeVxuXHQgKi9cblxuXHRjb25zdCByZW1vdmVIaWdobGlnaHQgPSBlbCA9PiB7XG5cdCAgdmFyIGVsZW1lbnRzID0gZWwucXVlcnlTZWxlY3RvckFsbChcInNwYW4uaGlnaGxpZ2h0XCIpO1xuXHQgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoZWxlbWVudHMsIGZ1bmN0aW9uIChlbCkge1xuXHQgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XG5cdCAgICBwYXJlbnQucmVwbGFjZUNoaWxkKGVsLmZpcnN0Q2hpbGQsIGVsKTtcblx0ICAgIHBhcmVudC5ub3JtYWxpemUoKTtcblx0ICB9KTtcblx0fTtcblxuXHRjb25zdCBLRVlfQSA9IDY1O1xuXHRjb25zdCBLRVlfUkVUVVJOID0gMTM7XG5cdGNvbnN0IEtFWV9FU0MgPSAyNztcblx0Y29uc3QgS0VZX0xFRlQgPSAzNztcblx0Y29uc3QgS0VZX1VQID0gMzg7XG5cdGNvbnN0IEtFWV9SSUdIVCA9IDM5O1xuXHRjb25zdCBLRVlfRE9XTiA9IDQwO1xuXHRjb25zdCBLRVlfQkFDS1NQQUNFID0gODtcblx0Y29uc3QgS0VZX0RFTEVURSA9IDQ2O1xuXHRjb25zdCBLRVlfVEFCID0gOTtcblx0Y29uc3QgSVNfTUFDID0gdHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcgPyBmYWxzZSA6IC9NYWMvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cdGNvbnN0IEtFWV9TSE9SVENVVCA9IElTX01BQyA/ICdtZXRhS2V5JyA6ICdjdHJsS2V5JzsgLy8gY3RybCBrZXkgb3IgYXBwbGUga2V5IGZvciBtYVxuXG5cdHZhciBkZWZhdWx0cyA9IHtcblx0ICBvcHRpb25zOiBbXSxcblx0ICBvcHRncm91cHM6IFtdLFxuXHQgIHBsdWdpbnM6IFtdLFxuXHQgIGRlbGltaXRlcjogJywnLFxuXHQgIHNwbGl0T246IG51bGwsXG5cdCAgLy8gcmVnZXhwIG9yIHN0cmluZyBmb3Igc3BsaXR0aW5nIHVwIHZhbHVlcyBmcm9tIGEgcGFzdGUgY29tbWFuZFxuXHQgIHBlcnNpc3Q6IHRydWUsXG5cdCAgZGlhY3JpdGljczogdHJ1ZSxcblx0ICBjcmVhdGU6IG51bGwsXG5cdCAgY3JlYXRlT25CbHVyOiBmYWxzZSxcblx0ICBjcmVhdGVGaWx0ZXI6IG51bGwsXG5cdCAgaGlnaGxpZ2h0OiB0cnVlLFxuXHQgIG9wZW5PbkZvY3VzOiB0cnVlLFxuXHQgIHNob3VsZE9wZW46IG51bGwsXG5cdCAgbWF4T3B0aW9uczogNTAsXG5cdCAgbWF4SXRlbXM6IG51bGwsXG5cdCAgaGlkZVNlbGVjdGVkOiBudWxsLFxuXHQgIGR1cGxpY2F0ZXM6IGZhbHNlLFxuXHQgIGFkZFByZWNlZGVuY2U6IGZhbHNlLFxuXHQgIHNlbGVjdE9uVGFiOiBmYWxzZSxcblx0ICBwcmVsb2FkOiBudWxsLFxuXHQgIGFsbG93RW1wdHlPcHRpb246IGZhbHNlLFxuXHQgIC8vY2xvc2VBZnRlclNlbGVjdDogZmFsc2UsXG5cdCAgbG9hZFRocm90dGxlOiAzMDAsXG5cdCAgbG9hZGluZ0NsYXNzOiAnbG9hZGluZycsXG5cdCAgZGF0YUF0dHI6IG51bGwsXG5cdCAgLy8nZGF0YS1kYXRhJyxcblx0ICBvcHRncm91cEZpZWxkOiAnb3B0Z3JvdXAnLFxuXHQgIHZhbHVlRmllbGQ6ICd2YWx1ZScsXG5cdCAgbGFiZWxGaWVsZDogJ3RleHQnLFxuXHQgIGRpc2FibGVkRmllbGQ6ICdkaXNhYmxlZCcsXG5cdCAgb3B0Z3JvdXBMYWJlbEZpZWxkOiAnbGFiZWwnLFxuXHQgIG9wdGdyb3VwVmFsdWVGaWVsZDogJ3ZhbHVlJyxcblx0ICBsb2NrT3B0Z3JvdXBPcmRlcjogZmFsc2UsXG5cdCAgc29ydEZpZWxkOiAnJG9yZGVyJyxcblx0ICBzZWFyY2hGaWVsZDogWyd0ZXh0J10sXG5cdCAgc2VhcmNoQ29uanVuY3Rpb246ICdhbmQnLFxuXHQgIG1vZGU6IG51bGwsXG5cdCAgd3JhcHBlckNsYXNzOiAndHMtd3JhcHBlcicsXG5cdCAgY29udHJvbENsYXNzOiAndHMtY29udHJvbCcsXG5cdCAgZHJvcGRvd25DbGFzczogJ3RzLWRyb3Bkb3duJyxcblx0ICBkcm9wZG93bkNvbnRlbnRDbGFzczogJ3RzLWRyb3Bkb3duLWNvbnRlbnQnLFxuXHQgIGl0ZW1DbGFzczogJ2l0ZW0nLFxuXHQgIG9wdGlvbkNsYXNzOiAnb3B0aW9uJyxcblx0ICBkcm9wZG93blBhcmVudDogbnVsbCxcblx0ICBjb250cm9sSW5wdXQ6ICc8aW5wdXQgdHlwZT1cInRleHRcIiBhdXRvY29tcGxldGU9XCJvZmZcIiBzaXplPVwiMVwiIC8+Jyxcblx0ICBjb3B5Q2xhc3Nlc1RvRHJvcGRvd246IGZhbHNlLFxuXHQgIHBsYWNlaG9sZGVyOiBudWxsLFxuXHQgIGhpZGVQbGFjZWhvbGRlcjogbnVsbCxcblx0ICBzaG91bGRMb2FkOiBmdW5jdGlvbiAocXVlcnkpIHtcblx0ICAgIHJldHVybiBxdWVyeS5sZW5ndGggPiAwO1xuXHQgIH0sXG5cblx0ICAvKlxuXHQgIGxvYWQgICAgICAgICAgICAgICAgIDogbnVsbCwgLy8gZnVuY3Rpb24ocXVlcnksIGNhbGxiYWNrKSB7IC4uLiB9XG5cdCAgc2NvcmUgICAgICAgICAgICAgICAgOiBudWxsLCAvLyBmdW5jdGlvbihzZWFyY2gpIHsgLi4uIH1cblx0ICBvbkluaXRpYWxpemUgICAgICAgICA6IG51bGwsIC8vIGZ1bmN0aW9uKCkgeyAuLi4gfVxuXHQgIG9uQ2hhbmdlICAgICAgICAgICAgIDogbnVsbCwgLy8gZnVuY3Rpb24odmFsdWUpIHsgLi4uIH1cblx0ICBvbkl0ZW1BZGQgICAgICAgICAgICA6IG51bGwsIC8vIGZ1bmN0aW9uKHZhbHVlLCAkaXRlbSkgeyAuLi4gfVxuXHQgIG9uSXRlbVJlbW92ZSAgICAgICAgIDogbnVsbCwgLy8gZnVuY3Rpb24odmFsdWUpIHsgLi4uIH1cblx0ICBvbkNsZWFyICAgICAgICAgICAgICA6IG51bGwsIC8vIGZ1bmN0aW9uKCkgeyAuLi4gfVxuXHQgIG9uT3B0aW9uQWRkICAgICAgICAgIDogbnVsbCwgLy8gZnVuY3Rpb24odmFsdWUsIGRhdGEpIHsgLi4uIH1cblx0ICBvbk9wdGlvblJlbW92ZSAgICAgICA6IG51bGwsIC8vIGZ1bmN0aW9uKHZhbHVlKSB7IC4uLiB9XG5cdCAgb25PcHRpb25DbGVhciAgICAgICAgOiBudWxsLCAvLyBmdW5jdGlvbigpIHsgLi4uIH1cblx0ICBvbk9wdGlvbkdyb3VwQWRkICAgICA6IG51bGwsIC8vIGZ1bmN0aW9uKGlkLCBkYXRhKSB7IC4uLiB9XG5cdCAgb25PcHRpb25Hcm91cFJlbW92ZSAgOiBudWxsLCAvLyBmdW5jdGlvbihpZCkgeyAuLi4gfVxuXHQgIG9uT3B0aW9uR3JvdXBDbGVhciAgIDogbnVsbCwgLy8gZnVuY3Rpb24oKSB7IC4uLiB9XG5cdCAgb25Ecm9wZG93bk9wZW4gICAgICAgOiBudWxsLCAvLyBmdW5jdGlvbihkcm9wZG93bikgeyAuLi4gfVxuXHQgIG9uRHJvcGRvd25DbG9zZSAgICAgIDogbnVsbCwgLy8gZnVuY3Rpb24oZHJvcGRvd24pIHsgLi4uIH1cblx0ICBvblR5cGUgICAgICAgICAgICAgICA6IG51bGwsIC8vIGZ1bmN0aW9uKHN0cikgeyAuLi4gfVxuXHQgIG9uRGVsZXRlICAgICAgICAgICAgIDogbnVsbCwgLy8gZnVuY3Rpb24odmFsdWVzKSB7IC4uLiB9XG5cdCAgKi9cblx0ICByZW5kZXI6IHtcblx0ICAgIC8qXG5cdCAgICBpdGVtOiBudWxsLFxuXHQgICAgb3B0Z3JvdXA6IG51bGwsXG5cdCAgICBvcHRncm91cF9oZWFkZXI6IG51bGwsXG5cdCAgICBvcHRpb246IG51bGwsXG5cdCAgICBvcHRpb25fY3JlYXRlOiBudWxsXG5cdCAgICAqL1xuXHQgIH1cblx0fTtcblxuXHQvKipcblx0ICogQ29udmVydHMgYSBzY2FsYXIgdG8gaXRzIGJlc3Qgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG5cdCAqIGZvciBoYXNoIGtleXMgYW5kIEhUTUwgYXR0cmlidXRlIHZhbHVlcy5cblx0ICpcblx0ICogVHJhbnNmb3JtYXRpb25zOlxuXHQgKiAgICdzdHInICAgICAtPiAnc3RyJ1xuXHQgKiAgIG51bGwgICAgICAtPiAnJ1xuXHQgKiAgIHVuZGVmaW5lZCAtPiAnJ1xuXHQgKiAgIHRydWUgICAgICAtPiAnMSdcblx0ICogICBmYWxzZSAgICAgLT4gJzAnXG5cdCAqICAgMCAgICAgICAgIC0+ICcwJ1xuXHQgKiAgIDEgICAgICAgICAtPiAnMSdcblx0ICpcblx0ICovXG5cdGNvbnN0IGhhc2hfa2V5ID0gdmFsdWUgPT4ge1xuXHQgIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHZhbHVlID09PSBudWxsKSByZXR1cm4gbnVsbDtcblx0ICByZXR1cm4gZ2V0X2hhc2godmFsdWUpO1xuXHR9O1xuXHRjb25zdCBnZXRfaGFzaCA9IHZhbHVlID0+IHtcblx0ICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHJldHVybiB2YWx1ZSA/ICcxJyA6ICcwJztcblx0ICByZXR1cm4gdmFsdWUgKyAnJztcblx0fTtcblx0LyoqXG5cdCAqIEVzY2FwZXMgYSBzdHJpbmcgZm9yIHVzZSB3aXRoaW4gSFRNTC5cblx0ICpcblx0ICovXG5cblx0Y29uc3QgZXNjYXBlX2h0bWwgPSBzdHIgPT4ge1xuXHQgIHJldHVybiAoc3RyICsgJycpLnJlcGxhY2UoLyYvZywgJyZhbXA7JykucmVwbGFjZSgvPC9nLCAnJmx0OycpLnJlcGxhY2UoLz4vZywgJyZndDsnKS5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG5cdH07XG5cdC8qKlxuXHQgKiBEZWJvdW5jZSB0aGUgdXNlciBwcm92aWRlZCBsb2FkIGZ1bmN0aW9uXG5cdCAqXG5cdCAqL1xuXG5cdGNvbnN0IGxvYWREZWJvdW5jZSA9IChmbiwgZGVsYXkpID0+IHtcblx0ICB2YXIgdGltZW91dDtcblx0ICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlLCBjYWxsYmFjaykge1xuXHQgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG5cdCAgICBpZiAodGltZW91dCkge1xuXHQgICAgICBzZWxmLmxvYWRpbmcgPSBNYXRoLm1heChzZWxmLmxvYWRpbmcgLSAxLCAwKTtcblx0ICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXHQgICAgfVxuXG5cdCAgICB0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHRpbWVvdXQgPSBudWxsO1xuXHQgICAgICBzZWxmLmxvYWRlZFNlYXJjaGVzW3ZhbHVlXSA9IHRydWU7XG5cdCAgICAgIGZuLmNhbGwoc2VsZiwgdmFsdWUsIGNhbGxiYWNrKTtcblx0ICAgIH0sIGRlbGF5KTtcblx0ICB9O1xuXHR9O1xuXHQvKipcblx0ICogRGVib3VuY2UgYWxsIGZpcmVkIGV2ZW50cyB0eXBlcyBsaXN0ZWQgaW4gYHR5cGVzYFxuXHQgKiB3aGlsZSBleGVjdXRpbmcgdGhlIHByb3ZpZGVkIGBmbmAuXG5cdCAqXG5cdCAqL1xuXG5cdGNvbnN0IGRlYm91bmNlX2V2ZW50cyA9IChzZWxmLCB0eXBlcywgZm4pID0+IHtcblx0ICB2YXIgdHlwZTtcblx0ICB2YXIgdHJpZ2dlciA9IHNlbGYudHJpZ2dlcjtcblx0ICB2YXIgZXZlbnRfYXJncyA9IHt9OyAvLyBvdmVycmlkZSB0cmlnZ2VyIG1ldGhvZFxuXG5cdCAgc2VsZi50cmlnZ2VyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIHR5cGUgPSBhcmd1bWVudHNbMF07XG5cblx0ICAgIGlmICh0eXBlcy5pbmRleE9mKHR5cGUpICE9PSAtMSkge1xuXHQgICAgICBldmVudF9hcmdzW3R5cGVdID0gYXJndW1lbnRzO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIHRyaWdnZXIuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcblx0ICAgIH1cblx0ICB9OyAvLyBpbnZva2UgcHJvdmlkZWQgZnVuY3Rpb25cblxuXG5cdCAgZm4uYXBwbHkoc2VsZiwgW10pO1xuXHQgIHNlbGYudHJpZ2dlciA9IHRyaWdnZXI7IC8vIHRyaWdnZXIgcXVldWVkIGV2ZW50c1xuXG5cdCAgZm9yICh0eXBlIG9mIHR5cGVzKSB7XG5cdCAgICBpZiAodHlwZSBpbiBldmVudF9hcmdzKSB7XG5cdCAgICAgIHRyaWdnZXIuYXBwbHkoc2VsZiwgZXZlbnRfYXJnc1t0eXBlXSk7XG5cdCAgICB9XG5cdCAgfVxuXHR9O1xuXHQvKipcblx0ICogRGV0ZXJtaW5lcyB0aGUgY3VycmVudCBzZWxlY3Rpb24gd2l0aGluIGEgdGV4dCBpbnB1dCBjb250cm9sLlxuXHQgKiBSZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nOlxuXHQgKiAgIC0gc3RhcnRcblx0ICogICAtIGxlbmd0aFxuXHQgKlxuXHQgKi9cblxuXHRjb25zdCBnZXRTZWxlY3Rpb24gPSBpbnB1dCA9PiB7XG5cdCAgcmV0dXJuIHtcblx0ICAgIHN0YXJ0OiBpbnB1dC5zZWxlY3Rpb25TdGFydCB8fCAwLFxuXHQgICAgbGVuZ3RoOiAoaW5wdXQuc2VsZWN0aW9uRW5kIHx8IDApIC0gKGlucHV0LnNlbGVjdGlvblN0YXJ0IHx8IDApXG5cdCAgfTtcblx0fTtcblx0LyoqXG5cdCAqIFByZXZlbnQgZGVmYXVsdFxuXHQgKlxuXHQgKi9cblxuXHRjb25zdCBwcmV2ZW50RGVmYXVsdCA9IChldnQsIHN0b3AgPSBmYWxzZSkgPT4ge1xuXHQgIGlmIChldnQpIHtcblx0ICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdCAgICBpZiAoc3RvcCkge1xuXHQgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdCAgICB9XG5cdCAgfVxuXHR9O1xuXHQvKipcblx0ICogQWRkIGV2ZW50IGhlbHBlclxuXHQgKlxuXHQgKi9cblxuXHRjb25zdCBhZGRFdmVudCA9ICh0YXJnZXQsIHR5cGUsIGNhbGxiYWNrLCBvcHRpb25zKSA9PiB7XG5cdCAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgY2FsbGJhY2ssIG9wdGlvbnMpO1xuXHR9O1xuXHQvKipcblx0ICogUmV0dXJuIHRydWUgaWYgdGhlIHJlcXVlc3RlZCBrZXkgaXMgZG93blxuXHQgKiBXaWxsIHJldHVybiBmYWxzZSBpZiBtb3JlIHRoYW4gb25lIGNvbnRyb2wgY2hhcmFjdGVyIGlzIHByZXNzZWQgKCB3aGVuIFtjdHJsK3NoaWZ0K2FdICE9IFtjdHJsK2FdIClcblx0ICogVGhlIGN1cnJlbnQgZXZ0IG1heSBub3QgYWx3YXlzIHNldCAoIGVnIGNhbGxpbmcgYWR2YW5jZVNlbGVjdGlvbigpIClcblx0ICpcblx0ICovXG5cblx0Y29uc3QgaXNLZXlEb3duID0gKGtleV9uYW1lLCBldnQpID0+IHtcblx0ICBpZiAoIWV2dCkge1xuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblxuXHQgIGlmICghZXZ0W2tleV9uYW1lXSkge1xuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblxuXHQgIHZhciBjb3VudCA9IChldnQuYWx0S2V5ID8gMSA6IDApICsgKGV2dC5jdHJsS2V5ID8gMSA6IDApICsgKGV2dC5zaGlmdEtleSA/IDEgOiAwKSArIChldnQubWV0YUtleSA/IDEgOiAwKTtcblxuXHQgIGlmIChjb3VudCA9PT0gMSkge1xuXHQgICAgcmV0dXJuIHRydWU7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGZhbHNlO1xuXHR9O1xuXHQvKipcblx0ICogR2V0IHRoZSBpZCBvZiBhbiBlbGVtZW50XG5cdCAqIElmIHRoZSBpZCBhdHRyaWJ1dGUgaXMgbm90IHNldCwgc2V0IHRoZSBhdHRyaWJ1dGUgd2l0aCB0aGUgZ2l2ZW4gaWRcblx0ICpcblx0ICovXG5cblx0Y29uc3QgZ2V0SWQgPSAoZWwsIGlkKSA9PiB7XG5cdCAgY29uc3QgZXhpc3RpbmdfaWQgPSBlbC5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG5cblx0ICBpZiAoZXhpc3RpbmdfaWQpIHtcblx0ICAgIHJldHVybiBleGlzdGluZ19pZDtcblx0ICB9XG5cblx0ICBlbC5zZXRBdHRyaWJ1dGUoJ2lkJywgaWQpO1xuXHQgIHJldHVybiBpZDtcblx0fTtcblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgd2l0aCBiYWNrc2xhc2hlcyBhZGRlZCBiZWZvcmUgY2hhcmFjdGVycyB0aGF0IG5lZWQgdG8gYmUgZXNjYXBlZC5cblx0ICovXG5cblx0Y29uc3QgYWRkU2xhc2hlcyA9IHN0ciA9PiB7XG5cdCAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bXFxcXFwiJ10vZywgJ1xcXFwkJicpO1xuXHR9O1xuXHQvKipcblx0ICpcblx0ICovXG5cblx0Y29uc3QgYXBwZW5kID0gKHBhcmVudCwgbm9kZSkgPT4ge1xuXHQgIGlmIChub2RlKSBwYXJlbnQuYXBwZW5kKG5vZGUpO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIGdldFNldHRpbmdzKGlucHV0LCBzZXR0aW5nc191c2VyKSB7XG5cdCAgdmFyIHNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHMsIHNldHRpbmdzX3VzZXIpO1xuXHQgIHZhciBhdHRyX2RhdGEgPSBzZXR0aW5ncy5kYXRhQXR0cjtcblx0ICB2YXIgZmllbGRfbGFiZWwgPSBzZXR0aW5ncy5sYWJlbEZpZWxkO1xuXHQgIHZhciBmaWVsZF92YWx1ZSA9IHNldHRpbmdzLnZhbHVlRmllbGQ7XG5cdCAgdmFyIGZpZWxkX2Rpc2FibGVkID0gc2V0dGluZ3MuZGlzYWJsZWRGaWVsZDtcblx0ICB2YXIgZmllbGRfb3B0Z3JvdXAgPSBzZXR0aW5ncy5vcHRncm91cEZpZWxkO1xuXHQgIHZhciBmaWVsZF9vcHRncm91cF9sYWJlbCA9IHNldHRpbmdzLm9wdGdyb3VwTGFiZWxGaWVsZDtcblx0ICB2YXIgZmllbGRfb3B0Z3JvdXBfdmFsdWUgPSBzZXR0aW5ncy5vcHRncm91cFZhbHVlRmllbGQ7XG5cdCAgdmFyIHRhZ19uYW1lID0gaW5wdXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHQgIHZhciBwbGFjZWhvbGRlciA9IGlucHV0LmdldEF0dHJpYnV0ZSgncGxhY2Vob2xkZXInKSB8fCBpbnB1dC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcGxhY2Vob2xkZXInKTtcblxuXHQgIGlmICghcGxhY2Vob2xkZXIgJiYgIXNldHRpbmdzLmFsbG93RW1wdHlPcHRpb24pIHtcblx0ICAgIGxldCBvcHRpb24gPSBpbnB1dC5xdWVyeVNlbGVjdG9yKCdvcHRpb25bdmFsdWU9XCJcIl0nKTtcblxuXHQgICAgaWYgKG9wdGlvbikge1xuXHQgICAgICBwbGFjZWhvbGRlciA9IG9wdGlvbi50ZXh0Q29udGVudDtcblx0ICAgIH1cblx0ICB9XG5cblx0ICB2YXIgc2V0dGluZ3NfZWxlbWVudCA9IHtcblx0ICAgIHBsYWNlaG9sZGVyOiBwbGFjZWhvbGRlcixcblx0ICAgIG9wdGlvbnM6IFtdLFxuXHQgICAgb3B0Z3JvdXBzOiBbXSxcblx0ICAgIGl0ZW1zOiBbXSxcblx0ICAgIG1heEl0ZW1zOiBudWxsXG5cdCAgfTtcblx0ICAvKipcblx0ICAgKiBJbml0aWFsaXplIGZyb20gYSA8c2VsZWN0PiBlbGVtZW50LlxuXHQgICAqXG5cdCAgICovXG5cblx0ICB2YXIgaW5pdF9zZWxlY3QgPSAoKSA9PiB7XG5cdCAgICB2YXIgdGFnTmFtZTtcblx0ICAgIHZhciBvcHRpb25zID0gc2V0dGluZ3NfZWxlbWVudC5vcHRpb25zO1xuXHQgICAgdmFyIG9wdGlvbnNNYXAgPSB7fTtcblx0ICAgIHZhciBncm91cF9jb3VudCA9IDE7XG5cblx0ICAgIHZhciByZWFkRGF0YSA9IGVsID0+IHtcblx0ICAgICAgdmFyIGRhdGEgPSBPYmplY3QuYXNzaWduKHt9LCBlbC5kYXRhc2V0KTsgLy8gZ2V0IHBsYWluIG9iamVjdCBmcm9tIERPTVN0cmluZ01hcFxuXG5cdCAgICAgIHZhciBqc29uID0gYXR0cl9kYXRhICYmIGRhdGFbYXR0cl9kYXRhXTtcblxuXHQgICAgICBpZiAodHlwZW9mIGpzb24gPT09ICdzdHJpbmcnICYmIGpzb24ubGVuZ3RoKSB7XG5cdCAgICAgICAgZGF0YSA9IE9iamVjdC5hc3NpZ24oZGF0YSwgSlNPTi5wYXJzZShqc29uKSk7XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm4gZGF0YTtcblx0ICAgIH07XG5cblx0ICAgIHZhciBhZGRPcHRpb24gPSAob3B0aW9uLCBncm91cCkgPT4ge1xuXHQgICAgICB2YXIgdmFsdWUgPSBoYXNoX2tleShvcHRpb24udmFsdWUpO1xuXHQgICAgICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuO1xuXHQgICAgICBpZiAoIXZhbHVlICYmICFzZXR0aW5ncy5hbGxvd0VtcHR5T3B0aW9uKSByZXR1cm47IC8vIGlmIHRoZSBvcHRpb24gYWxyZWFkeSBleGlzdHMsIGl0J3MgcHJvYmFibHkgYmVlblxuXHQgICAgICAvLyBkdXBsaWNhdGVkIGluIGFub3RoZXIgb3B0Z3JvdXAuIGluIHRoaXMgY2FzZSwgcHVzaFxuXHQgICAgICAvLyB0aGUgY3VycmVudCBncm91cCB0byB0aGUgXCJvcHRncm91cFwiIHByb3BlcnR5IG9uIHRoZVxuXHQgICAgICAvLyBleGlzdGluZyBvcHRpb24gc28gdGhhdCBpdCdzIHJlbmRlcmVkIGluIGJvdGggcGxhY2VzLlxuXG5cdCAgICAgIGlmIChvcHRpb25zTWFwLmhhc093blByb3BlcnR5KHZhbHVlKSkge1xuXHQgICAgICAgIGlmIChncm91cCkge1xuXHQgICAgICAgICAgdmFyIGFyciA9IG9wdGlvbnNNYXBbdmFsdWVdW2ZpZWxkX29wdGdyb3VwXTtcblxuXHQgICAgICAgICAgaWYgKCFhcnIpIHtcblx0ICAgICAgICAgICAgb3B0aW9uc01hcFt2YWx1ZV1bZmllbGRfb3B0Z3JvdXBdID0gZ3JvdXA7XG5cdCAgICAgICAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGFycikpIHtcblx0ICAgICAgICAgICAgb3B0aW9uc01hcFt2YWx1ZV1bZmllbGRfb3B0Z3JvdXBdID0gW2FyciwgZ3JvdXBdO1xuXHQgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgYXJyLnB1c2goZ3JvdXApO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB2YXIgb3B0aW9uX2RhdGEgPSByZWFkRGF0YShvcHRpb24pO1xuXHQgICAgICAgIG9wdGlvbl9kYXRhW2ZpZWxkX2xhYmVsXSA9IG9wdGlvbl9kYXRhW2ZpZWxkX2xhYmVsXSB8fCBvcHRpb24udGV4dENvbnRlbnQ7XG5cdCAgICAgICAgb3B0aW9uX2RhdGFbZmllbGRfdmFsdWVdID0gb3B0aW9uX2RhdGFbZmllbGRfdmFsdWVdIHx8IHZhbHVlO1xuXHQgICAgICAgIG9wdGlvbl9kYXRhW2ZpZWxkX2Rpc2FibGVkXSA9IG9wdGlvbl9kYXRhW2ZpZWxkX2Rpc2FibGVkXSB8fCBvcHRpb24uZGlzYWJsZWQ7XG5cdCAgICAgICAgb3B0aW9uX2RhdGFbZmllbGRfb3B0Z3JvdXBdID0gb3B0aW9uX2RhdGFbZmllbGRfb3B0Z3JvdXBdIHx8IGdyb3VwO1xuXHQgICAgICAgIG9wdGlvbl9kYXRhLiRvcHRpb24gPSBvcHRpb247XG5cdCAgICAgICAgb3B0aW9uc01hcFt2YWx1ZV0gPSBvcHRpb25fZGF0YTtcblx0ICAgICAgICBvcHRpb25zLnB1c2gob3B0aW9uX2RhdGEpO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCkge1xuXHQgICAgICAgIHNldHRpbmdzX2VsZW1lbnQuaXRlbXMucHVzaCh2YWx1ZSk7XG5cdCAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIHZhciBhZGRHcm91cCA9IG9wdGdyb3VwID0+IHtcblx0ICAgICAgdmFyIGlkLCBvcHRncm91cF9kYXRhO1xuXHQgICAgICBvcHRncm91cF9kYXRhID0gcmVhZERhdGEob3B0Z3JvdXApO1xuXHQgICAgICBvcHRncm91cF9kYXRhW2ZpZWxkX29wdGdyb3VwX2xhYmVsXSA9IG9wdGdyb3VwX2RhdGFbZmllbGRfb3B0Z3JvdXBfbGFiZWxdIHx8IG9wdGdyb3VwLmdldEF0dHJpYnV0ZSgnbGFiZWwnKSB8fCAnJztcblx0ICAgICAgb3B0Z3JvdXBfZGF0YVtmaWVsZF9vcHRncm91cF92YWx1ZV0gPSBvcHRncm91cF9kYXRhW2ZpZWxkX29wdGdyb3VwX3ZhbHVlXSB8fCBncm91cF9jb3VudCsrO1xuXHQgICAgICBvcHRncm91cF9kYXRhW2ZpZWxkX2Rpc2FibGVkXSA9IG9wdGdyb3VwX2RhdGFbZmllbGRfZGlzYWJsZWRdIHx8IG9wdGdyb3VwLmRpc2FibGVkO1xuXHQgICAgICBzZXR0aW5nc19lbGVtZW50Lm9wdGdyb3Vwcy5wdXNoKG9wdGdyb3VwX2RhdGEpO1xuXHQgICAgICBpZCA9IG9wdGdyb3VwX2RhdGFbZmllbGRfb3B0Z3JvdXBfdmFsdWVdO1xuXHQgICAgICBpdGVyYXRlKG9wdGdyb3VwLmNoaWxkcmVuLCBvcHRpb24gPT4ge1xuXHQgICAgICAgIGFkZE9wdGlvbihvcHRpb24sIGlkKTtcblx0ICAgICAgfSk7XG5cdCAgICB9O1xuXG5cdCAgICBzZXR0aW5nc19lbGVtZW50Lm1heEl0ZW1zID0gaW5wdXQuaGFzQXR0cmlidXRlKCdtdWx0aXBsZScpID8gbnVsbCA6IDE7XG5cdCAgICBpdGVyYXRlKGlucHV0LmNoaWxkcmVuLCBjaGlsZCA9PiB7XG5cdCAgICAgIHRhZ05hbWUgPSBjaGlsZC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0ICAgICAgaWYgKHRhZ05hbWUgPT09ICdvcHRncm91cCcpIHtcblx0ICAgICAgICBhZGRHcm91cChjaGlsZCk7XG5cdCAgICAgIH0gZWxzZSBpZiAodGFnTmFtZSA9PT0gJ29wdGlvbicpIHtcblx0ICAgICAgICBhZGRPcHRpb24oY2hpbGQpO1xuXHQgICAgICB9XG5cdCAgICB9KTtcblx0ICB9O1xuXHQgIC8qKlxuXHQgICAqIEluaXRpYWxpemUgZnJvbSBhIDxpbnB1dCB0eXBlPVwidGV4dFwiPiBlbGVtZW50LlxuXHQgICAqXG5cdCAgICovXG5cblxuXHQgIHZhciBpbml0X3RleHRib3ggPSAoKSA9PiB7XG5cdCAgICBjb25zdCBkYXRhX3JhdyA9IGlucHV0LmdldEF0dHJpYnV0ZShhdHRyX2RhdGEpO1xuXG5cdCAgICBpZiAoIWRhdGFfcmF3KSB7XG5cdCAgICAgIHZhciB2YWx1ZSA9IGlucHV0LnZhbHVlLnRyaW0oKSB8fCAnJztcblx0ICAgICAgaWYgKCFzZXR0aW5ncy5hbGxvd0VtcHR5T3B0aW9uICYmICF2YWx1ZS5sZW5ndGgpIHJldHVybjtcblx0ICAgICAgY29uc3QgdmFsdWVzID0gdmFsdWUuc3BsaXQoc2V0dGluZ3MuZGVsaW1pdGVyKTtcblx0ICAgICAgaXRlcmF0ZSh2YWx1ZXMsIHZhbHVlID0+IHtcblx0ICAgICAgICBjb25zdCBvcHRpb24gPSB7fTtcblx0ICAgICAgICBvcHRpb25bZmllbGRfbGFiZWxdID0gdmFsdWU7XG5cdCAgICAgICAgb3B0aW9uW2ZpZWxkX3ZhbHVlXSA9IHZhbHVlO1xuXHQgICAgICAgIHNldHRpbmdzX2VsZW1lbnQub3B0aW9ucy5wdXNoKG9wdGlvbik7XG5cdCAgICAgIH0pO1xuXHQgICAgICBzZXR0aW5nc19lbGVtZW50Lml0ZW1zID0gdmFsdWVzO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgc2V0dGluZ3NfZWxlbWVudC5vcHRpb25zID0gSlNPTi5wYXJzZShkYXRhX3Jhdyk7XG5cdCAgICAgIGl0ZXJhdGUoc2V0dGluZ3NfZWxlbWVudC5vcHRpb25zLCBvcHQgPT4ge1xuXHQgICAgICAgIHNldHRpbmdzX2VsZW1lbnQuaXRlbXMucHVzaChvcHRbZmllbGRfdmFsdWVdKTtcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIGlmICh0YWdfbmFtZSA9PT0gJ3NlbGVjdCcpIHtcblx0ICAgIGluaXRfc2VsZWN0KCk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIGluaXRfdGV4dGJveCgpO1xuXHQgIH1cblxuXHQgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cywgc2V0dGluZ3NfZWxlbWVudCwgc2V0dGluZ3NfdXNlcik7XG5cdH1cblxuXHR2YXIgaW5zdGFuY2VfaSA9IDA7XG5cdGNsYXNzIFRvbVNlbGVjdCBleHRlbmRzIE1pY3JvUGx1Z2luKE1pY3JvRXZlbnQpIHtcblx0ICAvLyBAZGVwcmVjYXRlZCAxLjhcblx0ICBjb25zdHJ1Y3RvcihpbnB1dF9hcmcsIHVzZXJfc2V0dGluZ3MpIHtcblx0ICAgIHN1cGVyKCk7XG5cdCAgICB0aGlzLmNvbnRyb2xfaW5wdXQgPSB2b2lkIDA7XG5cdCAgICB0aGlzLndyYXBwZXIgPSB2b2lkIDA7XG5cdCAgICB0aGlzLmRyb3Bkb3duID0gdm9pZCAwO1xuXHQgICAgdGhpcy5jb250cm9sID0gdm9pZCAwO1xuXHQgICAgdGhpcy5kcm9wZG93bl9jb250ZW50ID0gdm9pZCAwO1xuXHQgICAgdGhpcy5mb2N1c19ub2RlID0gdm9pZCAwO1xuXHQgICAgdGhpcy5vcmRlciA9IDA7XG5cdCAgICB0aGlzLnNldHRpbmdzID0gdm9pZCAwO1xuXHQgICAgdGhpcy5pbnB1dCA9IHZvaWQgMDtcblx0ICAgIHRoaXMudGFiSW5kZXggPSB2b2lkIDA7XG5cdCAgICB0aGlzLmlzX3NlbGVjdF90YWcgPSB2b2lkIDA7XG5cdCAgICB0aGlzLnJ0bCA9IHZvaWQgMDtcblx0ICAgIHRoaXMuaW5wdXRJZCA9IHZvaWQgMDtcblx0ICAgIHRoaXMuX2Rlc3Ryb3kgPSB2b2lkIDA7XG5cdCAgICB0aGlzLnNpZnRlciA9IHZvaWQgMDtcblx0ICAgIHRoaXMuaXNPcGVuID0gZmFsc2U7XG5cdCAgICB0aGlzLmlzRGlzYWJsZWQgPSBmYWxzZTtcblx0ICAgIHRoaXMuaXNSZXF1aXJlZCA9IHZvaWQgMDtcblx0ICAgIHRoaXMuaXNJbnZhbGlkID0gZmFsc2U7XG5cdCAgICB0aGlzLmlzVmFsaWQgPSB0cnVlO1xuXHQgICAgdGhpcy5pc0xvY2tlZCA9IGZhbHNlO1xuXHQgICAgdGhpcy5pc0ZvY3VzZWQgPSBmYWxzZTtcblx0ICAgIHRoaXMuaXNJbnB1dEhpZGRlbiA9IGZhbHNlO1xuXHQgICAgdGhpcy5pc1NldHVwID0gZmFsc2U7XG5cdCAgICB0aGlzLmlnbm9yZUZvY3VzID0gZmFsc2U7XG5cdCAgICB0aGlzLmlnbm9yZUhvdmVyID0gZmFsc2U7XG5cdCAgICB0aGlzLmhhc09wdGlvbnMgPSBmYWxzZTtcblx0ICAgIHRoaXMuY3VycmVudFJlc3VsdHMgPSB2b2lkIDA7XG5cdCAgICB0aGlzLmxhc3RWYWx1ZSA9ICcnO1xuXHQgICAgdGhpcy5jYXJldFBvcyA9IDA7XG5cdCAgICB0aGlzLmxvYWRpbmcgPSAwO1xuXHQgICAgdGhpcy5sb2FkZWRTZWFyY2hlcyA9IHt9O1xuXHQgICAgdGhpcy5hY3RpdmVPcHRpb24gPSBudWxsO1xuXHQgICAgdGhpcy5hY3RpdmVJdGVtcyA9IFtdO1xuXHQgICAgdGhpcy5vcHRncm91cHMgPSB7fTtcblx0ICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuXHQgICAgdGhpcy51c2VyT3B0aW9ucyA9IHt9O1xuXHQgICAgdGhpcy5pdGVtcyA9IFtdO1xuXHQgICAgaW5zdGFuY2VfaSsrO1xuXHQgICAgdmFyIGRpcjtcblx0ICAgIHZhciBpbnB1dCA9IGdldERvbShpbnB1dF9hcmcpO1xuXG5cdCAgICBpZiAoaW5wdXQudG9tc2VsZWN0KSB7XG5cdCAgICAgIHRocm93IG5ldyBFcnJvcignVG9tIFNlbGVjdCBhbHJlYWR5IGluaXRpYWxpemVkIG9uIHRoaXMgZWxlbWVudCcpO1xuXHQgICAgfVxuXG5cdCAgICBpbnB1dC50b21zZWxlY3QgPSB0aGlzOyAvLyBkZXRlY3QgcnRsIGVudmlyb25tZW50XG5cblx0ICAgIHZhciBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUgJiYgd2luZG93LmdldENvbXB1dGVkU3R5bGUoaW5wdXQsIG51bGwpO1xuXHQgICAgZGlyID0gY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdkaXJlY3Rpb24nKTsgLy8gc2V0dXAgZGVmYXVsdCBzdGF0ZVxuXG5cdCAgICBjb25zdCBzZXR0aW5ncyA9IGdldFNldHRpbmdzKGlucHV0LCB1c2VyX3NldHRpbmdzKTtcblx0ICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcblx0ICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcblx0ICAgIHRoaXMudGFiSW5kZXggPSBpbnB1dC50YWJJbmRleCB8fCAwO1xuXHQgICAgdGhpcy5pc19zZWxlY3RfdGFnID0gaW5wdXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc2VsZWN0Jztcblx0ICAgIHRoaXMucnRsID0gL3J0bC9pLnRlc3QoZGlyKTtcblx0ICAgIHRoaXMuaW5wdXRJZCA9IGdldElkKGlucHV0LCAndG9tc2VsZWN0LScgKyBpbnN0YW5jZV9pKTtcblx0ICAgIHRoaXMuaXNSZXF1aXJlZCA9IGlucHV0LnJlcXVpcmVkOyAvLyBzZWFyY2ggc3lzdGVtXG5cblx0ICAgIHRoaXMuc2lmdGVyID0gbmV3IFNpZnRlcih0aGlzLm9wdGlvbnMsIHtcblx0ICAgICAgZGlhY3JpdGljczogc2V0dGluZ3MuZGlhY3JpdGljc1xuXHQgICAgfSk7IC8vIG9wdGlvbi1kZXBlbmRlbnQgZGVmYXVsdHNcblxuXHQgICAgc2V0dGluZ3MubW9kZSA9IHNldHRpbmdzLm1vZGUgfHwgKHNldHRpbmdzLm1heEl0ZW1zID09PSAxID8gJ3NpbmdsZScgOiAnbXVsdGknKTtcblxuXHQgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy5oaWRlU2VsZWN0ZWQgIT09ICdib29sZWFuJykge1xuXHQgICAgICBzZXR0aW5ncy5oaWRlU2VsZWN0ZWQgPSBzZXR0aW5ncy5tb2RlID09PSAnbXVsdGknO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodHlwZW9mIHNldHRpbmdzLmhpZGVQbGFjZWhvbGRlciAhPT0gJ2Jvb2xlYW4nKSB7XG5cdCAgICAgIHNldHRpbmdzLmhpZGVQbGFjZWhvbGRlciA9IHNldHRpbmdzLm1vZGUgIT09ICdtdWx0aSc7XG5cdCAgICB9IC8vIHNldCB1cCBjcmVhdGVGaWx0ZXIgY2FsbGJhY2tcblxuXG5cdCAgICB2YXIgZmlsdGVyID0gc2V0dGluZ3MuY3JlYXRlRmlsdGVyO1xuXG5cdCAgICBpZiAodHlwZW9mIGZpbHRlciAhPT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ3N0cmluZycpIHtcblx0ICAgICAgICBmaWx0ZXIgPSBuZXcgUmVnRXhwKGZpbHRlcik7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoZmlsdGVyIGluc3RhbmNlb2YgUmVnRXhwKSB7XG5cdCAgICAgICAgc2V0dGluZ3MuY3JlYXRlRmlsdGVyID0gaW5wdXQgPT4gZmlsdGVyLnRlc3QoaW5wdXQpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHNldHRpbmdzLmNyZWF0ZUZpbHRlciA9IHZhbHVlID0+IHtcblx0ICAgICAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzLmR1cGxpY2F0ZXMgfHwgIXRoaXMub3B0aW9uc1t2YWx1ZV07XG5cdCAgICAgICAgfTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICB0aGlzLmluaXRpYWxpemVQbHVnaW5zKHNldHRpbmdzLnBsdWdpbnMpO1xuXHQgICAgdGhpcy5zZXR1cENhbGxiYWNrcygpO1xuXHQgICAgdGhpcy5zZXR1cFRlbXBsYXRlcygpOyAvLyBDcmVhdGUgYWxsIGVsZW1lbnRzXG5cblx0ICAgIGNvbnN0IHdyYXBwZXIgPSBnZXREb20oJzxkaXY+Jyk7XG5cdCAgICBjb25zdCBjb250cm9sID0gZ2V0RG9tKCc8ZGl2PicpO1xuXG5cdCAgICBjb25zdCBkcm9wZG93biA9IHRoaXMuX3JlbmRlcignZHJvcGRvd24nKTtcblxuXHQgICAgY29uc3QgZHJvcGRvd25fY29udGVudCA9IGdldERvbShgPGRpdiByb2xlPVwibGlzdGJveFwiIHRhYmluZGV4PVwiLTFcIj5gKTtcblx0ICAgIGNvbnN0IGNsYXNzZXMgPSB0aGlzLmlucHV0LmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJztcblx0ICAgIGNvbnN0IGlucHV0TW9kZSA9IHNldHRpbmdzLm1vZGU7XG5cdCAgICB2YXIgY29udHJvbF9pbnB1dDtcblx0ICAgIGFkZENsYXNzZXMod3JhcHBlciwgc2V0dGluZ3Mud3JhcHBlckNsYXNzLCBjbGFzc2VzLCBpbnB1dE1vZGUpO1xuXHQgICAgYWRkQ2xhc3Nlcyhjb250cm9sLCBzZXR0aW5ncy5jb250cm9sQ2xhc3MpO1xuXHQgICAgYXBwZW5kKHdyYXBwZXIsIGNvbnRyb2wpO1xuXHQgICAgYWRkQ2xhc3Nlcyhkcm9wZG93biwgc2V0dGluZ3MuZHJvcGRvd25DbGFzcywgaW5wdXRNb2RlKTtcblxuXHQgICAgaWYgKHNldHRpbmdzLmNvcHlDbGFzc2VzVG9Ecm9wZG93bikge1xuXHQgICAgICBhZGRDbGFzc2VzKGRyb3Bkb3duLCBjbGFzc2VzKTtcblx0ICAgIH1cblxuXHQgICAgYWRkQ2xhc3Nlcyhkcm9wZG93bl9jb250ZW50LCBzZXR0aW5ncy5kcm9wZG93bkNvbnRlbnRDbGFzcyk7XG5cdCAgICBhcHBlbmQoZHJvcGRvd24sIGRyb3Bkb3duX2NvbnRlbnQpO1xuXHQgICAgZ2V0RG9tKHNldHRpbmdzLmRyb3Bkb3duUGFyZW50IHx8IHdyYXBwZXIpLmFwcGVuZENoaWxkKGRyb3Bkb3duKTsgLy8gZGVmYXVsdCBjb250cm9sSW5wdXRcblxuXHQgICAgaWYgKGlzSHRtbFN0cmluZyhzZXR0aW5ncy5jb250cm9sSW5wdXQpKSB7XG5cdCAgICAgIGNvbnRyb2xfaW5wdXQgPSBnZXREb20oc2V0dGluZ3MuY29udHJvbElucHV0KTsgLy8gc2V0IGF0dHJpYnV0ZXNcblxuXHQgICAgICB2YXIgYXR0cnMgPSBbJ2F1dG9jb3JyZWN0JywgJ2F1dG9jYXBpdGFsaXplJywgJ2F1dG9jb21wbGV0ZSddO1xuXHQgICAgICBpdGVyYXRlJDEoYXR0cnMsIGF0dHIgPT4ge1xuXHQgICAgICAgIGlmIChpbnB1dC5nZXRBdHRyaWJ1dGUoYXR0cikpIHtcblx0ICAgICAgICAgIHNldEF0dHIoY29udHJvbF9pbnB1dCwge1xuXHQgICAgICAgICAgICBbYXR0cl06IGlucHV0LmdldEF0dHJpYnV0ZShhdHRyKVxuXHQgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9KTtcblx0ICAgICAgY29udHJvbF9pbnB1dC50YWJJbmRleCA9IC0xO1xuXHQgICAgICBjb250cm9sLmFwcGVuZENoaWxkKGNvbnRyb2xfaW5wdXQpO1xuXHQgICAgICB0aGlzLmZvY3VzX25vZGUgPSBjb250cm9sX2lucHV0OyAvLyBkb20gZWxlbWVudFxuXHQgICAgfSBlbHNlIGlmIChzZXR0aW5ncy5jb250cm9sSW5wdXQpIHtcblx0ICAgICAgY29udHJvbF9pbnB1dCA9IGdldERvbShzZXR0aW5ncy5jb250cm9sSW5wdXQpO1xuXHQgICAgICB0aGlzLmZvY3VzX25vZGUgPSBjb250cm9sX2lucHV0O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgY29udHJvbF9pbnB1dCA9IGdldERvbSgnPGlucHV0Lz4nKTtcblx0ICAgICAgdGhpcy5mb2N1c19ub2RlID0gY29udHJvbDtcblx0ICAgIH1cblxuXHQgICAgdGhpcy53cmFwcGVyID0gd3JhcHBlcjtcblx0ICAgIHRoaXMuZHJvcGRvd24gPSBkcm9wZG93bjtcblx0ICAgIHRoaXMuZHJvcGRvd25fY29udGVudCA9IGRyb3Bkb3duX2NvbnRlbnQ7XG5cdCAgICB0aGlzLmNvbnRyb2wgPSBjb250cm9sO1xuXHQgICAgdGhpcy5jb250cm9sX2lucHV0ID0gY29udHJvbF9pbnB1dDtcblx0ICAgIHRoaXMuc2V0dXAoKTtcblx0ICB9XG5cdCAgLyoqXG5cdCAgICogc2V0IHVwIGV2ZW50IGJpbmRpbmdzLlxuXHQgICAqXG5cdCAgICovXG5cblxuXHQgIHNldHVwKCkge1xuXHQgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cdCAgICBjb25zdCBzZXR0aW5ncyA9IHNlbGYuc2V0dGluZ3M7XG5cdCAgICBjb25zdCBjb250cm9sX2lucHV0ID0gc2VsZi5jb250cm9sX2lucHV0O1xuXHQgICAgY29uc3QgZHJvcGRvd24gPSBzZWxmLmRyb3Bkb3duO1xuXHQgICAgY29uc3QgZHJvcGRvd25fY29udGVudCA9IHNlbGYuZHJvcGRvd25fY29udGVudDtcblx0ICAgIGNvbnN0IHdyYXBwZXIgPSBzZWxmLndyYXBwZXI7XG5cdCAgICBjb25zdCBjb250cm9sID0gc2VsZi5jb250cm9sO1xuXHQgICAgY29uc3QgaW5wdXQgPSBzZWxmLmlucHV0O1xuXHQgICAgY29uc3QgZm9jdXNfbm9kZSA9IHNlbGYuZm9jdXNfbm9kZTtcblx0ICAgIGNvbnN0IHBhc3NpdmVfZXZlbnQgPSB7XG5cdCAgICAgIHBhc3NpdmU6IHRydWVcblx0ICAgIH07XG5cdCAgICBjb25zdCBsaXN0Ym94SWQgPSBzZWxmLmlucHV0SWQgKyAnLXRzLWRyb3Bkb3duJztcblx0ICAgIHNldEF0dHIoZHJvcGRvd25fY29udGVudCwge1xuXHQgICAgICBpZDogbGlzdGJveElkXG5cdCAgICB9KTtcblx0ICAgIHNldEF0dHIoZm9jdXNfbm9kZSwge1xuXHQgICAgICByb2xlOiAnY29tYm9ib3gnLFxuXHQgICAgICAnYXJpYS1oYXNwb3B1cCc6ICdsaXN0Ym94Jyxcblx0ICAgICAgJ2FyaWEtZXhwYW5kZWQnOiAnZmFsc2UnLFxuXHQgICAgICAnYXJpYS1jb250cm9scyc6IGxpc3Rib3hJZFxuXHQgICAgfSk7XG5cdCAgICBjb25zdCBjb250cm9sX2lkID0gZ2V0SWQoZm9jdXNfbm9kZSwgc2VsZi5pbnB1dElkICsgJy10cy1jb250cm9sJyk7XG5cdCAgICBjb25zdCBxdWVyeSA9IFwibGFiZWxbZm9yPSdcIiArIGVzY2FwZVF1ZXJ5KHNlbGYuaW5wdXRJZCkgKyBcIiddXCI7XG5cdCAgICBjb25zdCBsYWJlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IocXVlcnkpO1xuXHQgICAgY29uc3QgbGFiZWxfY2xpY2sgPSBzZWxmLmZvY3VzLmJpbmQoc2VsZik7XG5cblx0ICAgIGlmIChsYWJlbCkge1xuXHQgICAgICBhZGRFdmVudChsYWJlbCwgJ2NsaWNrJywgbGFiZWxfY2xpY2spO1xuXHQgICAgICBzZXRBdHRyKGxhYmVsLCB7XG5cdCAgICAgICAgZm9yOiBjb250cm9sX2lkXG5cdCAgICAgIH0pO1xuXHQgICAgICBjb25zdCBsYWJlbF9pZCA9IGdldElkKGxhYmVsLCBzZWxmLmlucHV0SWQgKyAnLXRzLWxhYmVsJyk7XG5cdCAgICAgIHNldEF0dHIoZm9jdXNfbm9kZSwge1xuXHQgICAgICAgICdhcmlhLWxhYmVsbGVkYnknOiBsYWJlbF9pZFxuXHQgICAgICB9KTtcblx0ICAgICAgc2V0QXR0cihkcm9wZG93bl9jb250ZW50LCB7XG5cdCAgICAgICAgJ2FyaWEtbGFiZWxsZWRieSc6IGxhYmVsX2lkXG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXG5cdCAgICB3cmFwcGVyLnN0eWxlLndpZHRoID0gaW5wdXQuc3R5bGUud2lkdGg7XG5cblx0ICAgIGlmIChzZWxmLnBsdWdpbnMubmFtZXMubGVuZ3RoKSB7XG5cdCAgICAgIGNvbnN0IGNsYXNzZXNfcGx1Z2lucyA9ICdwbHVnaW4tJyArIHNlbGYucGx1Z2lucy5uYW1lcy5qb2luKCcgcGx1Z2luLScpO1xuXHQgICAgICBhZGRDbGFzc2VzKFt3cmFwcGVyLCBkcm9wZG93bl0sIGNsYXNzZXNfcGx1Z2lucyk7XG5cdCAgICB9XG5cblx0ICAgIGlmICgoc2V0dGluZ3MubWF4SXRlbXMgPT09IG51bGwgfHwgc2V0dGluZ3MubWF4SXRlbXMgPiAxKSAmJiBzZWxmLmlzX3NlbGVjdF90YWcpIHtcblx0ICAgICAgc2V0QXR0cihpbnB1dCwge1xuXHQgICAgICAgIG11bHRpcGxlOiAnbXVsdGlwbGUnXG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoc2V0dGluZ3MucGxhY2Vob2xkZXIpIHtcblx0ICAgICAgc2V0QXR0cihjb250cm9sX2lucHV0LCB7XG5cdCAgICAgICAgcGxhY2Vob2xkZXI6IHNldHRpbmdzLnBsYWNlaG9sZGVyXG5cdCAgICAgIH0pO1xuXHQgICAgfSAvLyBpZiBzcGxpdE9uIHdhcyBub3QgcGFzc2VkIGluLCBjb25zdHJ1Y3QgaXQgZnJvbSB0aGUgZGVsaW1pdGVyIHRvIGFsbG93IHBhc3RpbmcgdW5pdmVyc2FsbHlcblxuXG5cdCAgICBpZiAoIXNldHRpbmdzLnNwbGl0T24gJiYgc2V0dGluZ3MuZGVsaW1pdGVyKSB7XG5cdCAgICAgIHNldHRpbmdzLnNwbGl0T24gPSBuZXcgUmVnRXhwKCdcXFxccyonICsgZXNjYXBlX3JlZ2V4KHNldHRpbmdzLmRlbGltaXRlcikgKyAnK1xcXFxzKicpO1xuXHQgICAgfSAvLyBkZWJvdW5jZSB1c2VyIGRlZmluZWQgbG9hZCgpIGlmIGxvYWRUaHJvdHRsZSA+IDBcblx0ICAgIC8vIGFmdGVyIGluaXRpYWxpemVQbHVnaW5zKCkgc28gcGx1Z2lucyBjYW4gY3JlYXRlL21vZGlmeSB1c2VyIGRlZmluZWQgbG9hZGVyc1xuXG5cblx0ICAgIGlmIChzZXR0aW5ncy5sb2FkICYmIHNldHRpbmdzLmxvYWRUaHJvdHRsZSkge1xuXHQgICAgICBzZXR0aW5ncy5sb2FkID0gbG9hZERlYm91bmNlKHNldHRpbmdzLmxvYWQsIHNldHRpbmdzLmxvYWRUaHJvdHRsZSk7XG5cdCAgICB9XG5cblx0ICAgIHNlbGYuY29udHJvbF9pbnB1dC50eXBlID0gaW5wdXQudHlwZTtcblx0ICAgIGFkZEV2ZW50KGRyb3Bkb3duLCAnbW91c2Vtb3ZlJywgKCkgPT4ge1xuXHQgICAgICBzZWxmLmlnbm9yZUhvdmVyID0gZmFsc2U7XG5cdCAgICB9KTtcblx0ICAgIGFkZEV2ZW50KGRyb3Bkb3duLCAnbW91c2VlbnRlcicsIGUgPT4ge1xuXHQgICAgICB2YXIgdGFyZ2V0X21hdGNoID0gcGFyZW50TWF0Y2goZS50YXJnZXQsICdbZGF0YS1zZWxlY3RhYmxlXScsIGRyb3Bkb3duKTtcblx0ICAgICAgaWYgKHRhcmdldF9tYXRjaCkgc2VsZi5vbk9wdGlvbkhvdmVyKGUsIHRhcmdldF9tYXRjaCk7XG5cdCAgICB9LCB7XG5cdCAgICAgIGNhcHR1cmU6IHRydWVcblx0ICAgIH0pOyAvLyBjbGlja2luZyBvbiBhbiBvcHRpb24gc2hvdWxkIHNlbGVjdCBpdFxuXG5cdCAgICBhZGRFdmVudChkcm9wZG93biwgJ2NsaWNrJywgZXZ0ID0+IHtcblx0ICAgICAgY29uc3Qgb3B0aW9uID0gcGFyZW50TWF0Y2goZXZ0LnRhcmdldCwgJ1tkYXRhLXNlbGVjdGFibGVdJyk7XG5cblx0ICAgICAgaWYgKG9wdGlvbikge1xuXHQgICAgICAgIHNlbGYub25PcHRpb25TZWxlY3QoZXZ0LCBvcHRpb24pO1xuXHQgICAgICAgIHByZXZlbnREZWZhdWx0KGV2dCwgdHJ1ZSk7XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgYWRkRXZlbnQoY29udHJvbCwgJ2NsaWNrJywgZXZ0ID0+IHtcblx0ICAgICAgdmFyIHRhcmdldF9tYXRjaCA9IHBhcmVudE1hdGNoKGV2dC50YXJnZXQsICdbZGF0YS10cy1pdGVtXScsIGNvbnRyb2wpO1xuXG5cdCAgICAgIGlmICh0YXJnZXRfbWF0Y2ggJiYgc2VsZi5vbkl0ZW1TZWxlY3QoZXZ0LCB0YXJnZXRfbWF0Y2gpKSB7XG5cdCAgICAgICAgcHJldmVudERlZmF1bHQoZXZ0LCB0cnVlKTtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH0gLy8gcmV0YWluIGZvY3VzIChzZWUgY29udHJvbF9pbnB1dCBtb3VzZWRvd24pXG5cblxuXHQgICAgICBpZiAoY29udHJvbF9pbnB1dC52YWx1ZSAhPSAnJykge1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXG5cdCAgICAgIHNlbGYub25DbGljaygpO1xuXHQgICAgICBwcmV2ZW50RGVmYXVsdChldnQsIHRydWUpO1xuXHQgICAgfSk7IC8vIGtleWRvd24gb24gZm9jdXNfbm9kZSBmb3IgYXJyb3dfZG93bi9hcnJvd191cFxuXG5cdCAgICBhZGRFdmVudChmb2N1c19ub2RlLCAna2V5ZG93bicsIGUgPT4gc2VsZi5vbktleURvd24oZSkpOyAvLyBrZXlwcmVzcyBhbmQgaW5wdXQva2V5dXBcblxuXHQgICAgYWRkRXZlbnQoY29udHJvbF9pbnB1dCwgJ2tleXByZXNzJywgZSA9PiBzZWxmLm9uS2V5UHJlc3MoZSkpO1xuXHQgICAgYWRkRXZlbnQoY29udHJvbF9pbnB1dCwgJ2lucHV0JywgZSA9PiBzZWxmLm9uSW5wdXQoZSkpO1xuXHQgICAgYWRkRXZlbnQoZm9jdXNfbm9kZSwgJ2JsdXInLCBlID0+IHNlbGYub25CbHVyKGUpKTtcblx0ICAgIGFkZEV2ZW50KGZvY3VzX25vZGUsICdmb2N1cycsIGUgPT4gc2VsZi5vbkZvY3VzKGUpKTtcblx0ICAgIGFkZEV2ZW50KGNvbnRyb2xfaW5wdXQsICdwYXN0ZScsIGUgPT4gc2VsZi5vblBhc3RlKGUpKTtcblxuXHQgICAgY29uc3QgZG9jX21vdXNlZG93biA9IGV2dCA9PiB7XG5cdCAgICAgIC8vIGJsdXIgaWYgdGFyZ2V0IGlzIG91dHNpZGUgb2YgdGhpcyBpbnN0YW5jZVxuXHQgICAgICAvLyBkcm9wZG93biBpcyBub3QgYWx3YXlzIGluc2lkZSB3cmFwcGVyXG5cdCAgICAgIGNvbnN0IHRhcmdldCA9IGV2dC5jb21wb3NlZFBhdGgoKVswXTtcblxuXHQgICAgICBpZiAoIXdyYXBwZXIuY29udGFpbnModGFyZ2V0KSAmJiAhZHJvcGRvd24uY29udGFpbnModGFyZ2V0KSkge1xuXHQgICAgICAgIGlmIChzZWxmLmlzRm9jdXNlZCkge1xuXHQgICAgICAgICAgc2VsZi5ibHVyKCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgc2VsZi5pbnB1dFN0YXRlKCk7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9IC8vIHJldGFpbiBmb2N1cyBieSBwcmV2ZW50aW5nIG5hdGl2ZSBoYW5kbGluZy4gaWYgdGhlXG5cdCAgICAgIC8vIGV2ZW50IHRhcmdldCBpcyB0aGUgaW5wdXQgaXQgc2hvdWxkIG5vdCBiZSBtb2RpZmllZC5cblx0ICAgICAgLy8gb3RoZXJ3aXNlLCB0ZXh0IHNlbGVjdGlvbiB3aXRoaW4gdGhlIGlucHV0IHdvbid0IHdvcmsuXG5cdCAgICAgIC8vIEZpeGVzIGJ1ZyAjMjEyIHdoaWNoIGlzIG5vIGNvdmVyZWQgYnkgdGVzdHNcblxuXG5cdCAgICAgIGlmICh0YXJnZXQgPT0gY29udHJvbF9pbnB1dCAmJiBzZWxmLmlzT3Blbikge1xuXHQgICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTsgLy8gY2xpY2tpbmcgYW55d2hlcmUgaW4gdGhlIGNvbnRyb2wgc2hvdWxkIG5vdCBibHVyIHRoZSBjb250cm9sX2lucHV0ICh3aGljaCB3b3VsZCBjbG9zZSB0aGUgZHJvcGRvd24pXG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcHJldmVudERlZmF1bHQoZXZ0LCB0cnVlKTtcblx0ICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgY29uc3Qgd2luX3Njcm9sbCA9ICgpID0+IHtcblx0ICAgICAgaWYgKHNlbGYuaXNPcGVuKSB7XG5cdCAgICAgICAgc2VsZi5wb3NpdGlvbkRyb3Bkb3duKCk7XG5cdCAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIGFkZEV2ZW50KGRvY3VtZW50LCAnbW91c2Vkb3duJywgZG9jX21vdXNlZG93bik7XG5cdCAgICBhZGRFdmVudCh3aW5kb3csICdzY3JvbGwnLCB3aW5fc2Nyb2xsLCBwYXNzaXZlX2V2ZW50KTtcblx0ICAgIGFkZEV2ZW50KHdpbmRvdywgJ3Jlc2l6ZScsIHdpbl9zY3JvbGwsIHBhc3NpdmVfZXZlbnQpO1xuXG5cdCAgICB0aGlzLl9kZXN0cm95ID0gKCkgPT4ge1xuXHQgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBkb2NfbW91c2Vkb3duKTtcblx0ICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHdpbl9zY3JvbGwpO1xuXHQgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgd2luX3Njcm9sbCk7XG5cdCAgICAgIGlmIChsYWJlbCkgbGFiZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBsYWJlbF9jbGljayk7XG5cdCAgICB9OyAvLyBzdG9yZSBvcmlnaW5hbCBodG1sIGFuZCB0YWIgaW5kZXggc28gdGhhdCB0aGV5IGNhbiBiZVxuXHQgICAgLy8gcmVzdG9yZWQgd2hlbiB0aGUgZGVzdHJveSgpIG1ldGhvZCBpcyBjYWxsZWQuXG5cblxuXHQgICAgdGhpcy5yZXZlcnRTZXR0aW5ncyA9IHtcblx0ICAgICAgaW5uZXJIVE1MOiBpbnB1dC5pbm5lckhUTUwsXG5cdCAgICAgIHRhYkluZGV4OiBpbnB1dC50YWJJbmRleFxuXHQgICAgfTtcblx0ICAgIGlucHV0LnRhYkluZGV4ID0gLTE7XG5cdCAgICBpbnB1dC5pbnNlcnRBZGphY2VudEVsZW1lbnQoJ2FmdGVyZW5kJywgc2VsZi53cmFwcGVyKTtcblx0ICAgIHNlbGYuc3luYyhmYWxzZSk7XG5cdCAgICBzZXR0aW5ncy5pdGVtcyA9IFtdO1xuXHQgICAgZGVsZXRlIHNldHRpbmdzLm9wdGdyb3Vwcztcblx0ICAgIGRlbGV0ZSBzZXR0aW5ncy5vcHRpb25zO1xuXHQgICAgYWRkRXZlbnQoaW5wdXQsICdpbnZhbGlkJywgKCkgPT4ge1xuXHQgICAgICBpZiAoc2VsZi5pc1ZhbGlkKSB7XG5cdCAgICAgICAgc2VsZi5pc1ZhbGlkID0gZmFsc2U7XG5cdCAgICAgICAgc2VsZi5pc0ludmFsaWQgPSB0cnVlO1xuXHQgICAgICAgIHNlbGYucmVmcmVzaFN0YXRlKCk7XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgc2VsZi51cGRhdGVPcmlnaW5hbElucHV0KCk7XG5cdCAgICBzZWxmLnJlZnJlc2hJdGVtcygpO1xuXHQgICAgc2VsZi5jbG9zZShmYWxzZSk7XG5cdCAgICBzZWxmLmlucHV0U3RhdGUoKTtcblx0ICAgIHNlbGYuaXNTZXR1cCA9IHRydWU7XG5cblx0ICAgIGlmIChpbnB1dC5kaXNhYmxlZCkge1xuXHQgICAgICBzZWxmLmRpc2FibGUoKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHNlbGYuZW5hYmxlKCk7IC8vc2V0cyB0YWJJbmRleFxuXHQgICAgfVxuXG5cdCAgICBzZWxmLm9uKCdjaGFuZ2UnLCB0aGlzLm9uQ2hhbmdlKTtcblx0ICAgIGFkZENsYXNzZXMoaW5wdXQsICd0b21zZWxlY3RlZCcsICd0cy1oaWRkZW4tYWNjZXNzaWJsZScpO1xuXHQgICAgc2VsZi50cmlnZ2VyKCdpbml0aWFsaXplJyk7IC8vIHByZWxvYWQgb3B0aW9uc1xuXG5cdCAgICBpZiAoc2V0dGluZ3MucHJlbG9hZCA9PT0gdHJ1ZSkge1xuXHQgICAgICBzZWxmLnByZWxvYWQoKTtcblx0ICAgIH1cblx0ICB9XG5cdCAgLyoqXG5cdCAgICogUmVnaXN0ZXIgb3B0aW9ucyBhbmQgb3B0Z3JvdXBzXG5cdCAgICpcblx0ICAgKi9cblxuXG5cdCAgc2V0dXBPcHRpb25zKG9wdGlvbnMgPSBbXSwgb3B0Z3JvdXBzID0gW10pIHtcblx0ICAgIC8vIGJ1aWxkIG9wdGlvbnMgdGFibGVcblx0ICAgIHRoaXMuYWRkT3B0aW9ucyhvcHRpb25zKTsgLy8gYnVpbGQgb3B0Z3JvdXAgdGFibGVcblxuXHQgICAgaXRlcmF0ZSQxKG9wdGdyb3Vwcywgb3B0Z3JvdXAgPT4ge1xuXHQgICAgICB0aGlzLnJlZ2lzdGVyT3B0aW9uR3JvdXAob3B0Z3JvdXApO1xuXHQgICAgfSk7XG5cdCAgfVxuXHQgIC8qKlxuXHQgICAqIFNldHMgdXAgZGVmYXVsdCByZW5kZXJpbmcgZnVuY3Rpb25zLlxuXHQgICAqL1xuXG5cblx0ICBzZXR1cFRlbXBsYXRlcygpIHtcblx0ICAgIHZhciBzZWxmID0gdGhpcztcblx0ICAgIHZhciBmaWVsZF9sYWJlbCA9IHNlbGYuc2V0dGluZ3MubGFiZWxGaWVsZDtcblx0ICAgIHZhciBmaWVsZF9vcHRncm91cCA9IHNlbGYuc2V0dGluZ3Mub3B0Z3JvdXBMYWJlbEZpZWxkO1xuXHQgICAgdmFyIHRlbXBsYXRlcyA9IHtcblx0ICAgICAgJ29wdGdyb3VwJzogZGF0YSA9PiB7XG5cdCAgICAgICAgbGV0IG9wdGdyb3VwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdCAgICAgICAgb3B0Z3JvdXAuY2xhc3NOYW1lID0gJ29wdGdyb3VwJztcblx0ICAgICAgICBvcHRncm91cC5hcHBlbmRDaGlsZChkYXRhLm9wdGlvbnMpO1xuXHQgICAgICAgIHJldHVybiBvcHRncm91cDtcblx0ICAgICAgfSxcblx0ICAgICAgJ29wdGdyb3VwX2hlYWRlcic6IChkYXRhLCBlc2NhcGUpID0+IHtcblx0ICAgICAgICByZXR1cm4gJzxkaXYgY2xhc3M9XCJvcHRncm91cC1oZWFkZXJcIj4nICsgZXNjYXBlKGRhdGFbZmllbGRfb3B0Z3JvdXBdKSArICc8L2Rpdj4nO1xuXHQgICAgICB9LFxuXHQgICAgICAnb3B0aW9uJzogKGRhdGEsIGVzY2FwZSkgPT4ge1xuXHQgICAgICAgIHJldHVybiAnPGRpdj4nICsgZXNjYXBlKGRhdGFbZmllbGRfbGFiZWxdKSArICc8L2Rpdj4nO1xuXHQgICAgICB9LFxuXHQgICAgICAnaXRlbSc6IChkYXRhLCBlc2NhcGUpID0+IHtcblx0ICAgICAgICByZXR1cm4gJzxkaXY+JyArIGVzY2FwZShkYXRhW2ZpZWxkX2xhYmVsXSkgKyAnPC9kaXY+Jztcblx0ICAgICAgfSxcblx0ICAgICAgJ29wdGlvbl9jcmVhdGUnOiAoZGF0YSwgZXNjYXBlKSA9PiB7XG5cdCAgICAgICAgcmV0dXJuICc8ZGl2IGNsYXNzPVwiY3JlYXRlXCI+QWRkIDxzdHJvbmc+JyArIGVzY2FwZShkYXRhLmlucHV0KSArICc8L3N0cm9uZz4maGVsbGlwOzwvZGl2Pic7XG5cdCAgICAgIH0sXG5cdCAgICAgICdub19yZXN1bHRzJzogKCkgPT4ge1xuXHQgICAgICAgIHJldHVybiAnPGRpdiBjbGFzcz1cIm5vLXJlc3VsdHNcIj5ObyByZXN1bHRzIGZvdW5kPC9kaXY+Jztcblx0ICAgICAgfSxcblx0ICAgICAgJ2xvYWRpbmcnOiAoKSA9PiB7XG5cdCAgICAgICAgcmV0dXJuICc8ZGl2IGNsYXNzPVwic3Bpbm5lclwiPjwvZGl2Pic7XG5cdCAgICAgIH0sXG5cdCAgICAgICdub3RfbG9hZGluZyc6ICgpID0+IHt9LFxuXHQgICAgICAnZHJvcGRvd24nOiAoKSA9PiB7XG5cdCAgICAgICAgcmV0dXJuICc8ZGl2PjwvZGl2Pic7XG5cdCAgICAgIH1cblx0ICAgIH07XG5cdCAgICBzZWxmLnNldHRpbmdzLnJlbmRlciA9IE9iamVjdC5hc3NpZ24oe30sIHRlbXBsYXRlcywgc2VsZi5zZXR0aW5ncy5yZW5kZXIpO1xuXHQgIH1cblx0ICAvKipcblx0ICAgKiBNYXBzIGZpcmVkIGV2ZW50cyB0byBjYWxsYmFja3MgcHJvdmlkZWRcblx0ICAgKiBpbiB0aGUgc2V0dGluZ3MgdXNlZCB3aGVuIGNyZWF0aW5nIHRoZSBjb250cm9sLlxuXHQgICAqL1xuXG5cblx0ICBzZXR1cENhbGxiYWNrcygpIHtcblx0ICAgIHZhciBrZXksIGZuO1xuXHQgICAgdmFyIGNhbGxiYWNrcyA9IHtcblx0ICAgICAgJ2luaXRpYWxpemUnOiAnb25Jbml0aWFsaXplJyxcblx0ICAgICAgJ2NoYW5nZSc6ICdvbkNoYW5nZScsXG5cdCAgICAgICdpdGVtX2FkZCc6ICdvbkl0ZW1BZGQnLFxuXHQgICAgICAnaXRlbV9yZW1vdmUnOiAnb25JdGVtUmVtb3ZlJyxcblx0ICAgICAgJ2l0ZW1fc2VsZWN0JzogJ29uSXRlbVNlbGVjdCcsXG5cdCAgICAgICdjbGVhcic6ICdvbkNsZWFyJyxcblx0ICAgICAgJ29wdGlvbl9hZGQnOiAnb25PcHRpb25BZGQnLFxuXHQgICAgICAnb3B0aW9uX3JlbW92ZSc6ICdvbk9wdGlvblJlbW92ZScsXG5cdCAgICAgICdvcHRpb25fY2xlYXInOiAnb25PcHRpb25DbGVhcicsXG5cdCAgICAgICdvcHRncm91cF9hZGQnOiAnb25PcHRpb25Hcm91cEFkZCcsXG5cdCAgICAgICdvcHRncm91cF9yZW1vdmUnOiAnb25PcHRpb25Hcm91cFJlbW92ZScsXG5cdCAgICAgICdvcHRncm91cF9jbGVhcic6ICdvbk9wdGlvbkdyb3VwQ2xlYXInLFxuXHQgICAgICAnZHJvcGRvd25fb3Blbic6ICdvbkRyb3Bkb3duT3BlbicsXG5cdCAgICAgICdkcm9wZG93bl9jbG9zZSc6ICdvbkRyb3Bkb3duQ2xvc2UnLFxuXHQgICAgICAndHlwZSc6ICdvblR5cGUnLFxuXHQgICAgICAnbG9hZCc6ICdvbkxvYWQnLFxuXHQgICAgICAnZm9jdXMnOiAnb25Gb2N1cycsXG5cdCAgICAgICdibHVyJzogJ29uQmx1cidcblx0ICAgIH07XG5cblx0ICAgIGZvciAoa2V5IGluIGNhbGxiYWNrcykge1xuXHQgICAgICBmbiA9IHRoaXMuc2V0dGluZ3NbY2FsbGJhY2tzW2tleV1dO1xuXHQgICAgICBpZiAoZm4pIHRoaXMub24oa2V5LCBmbik7XG5cdCAgICB9XG5cdCAgfVxuXHQgIC8qKlxuXHQgICAqIFN5bmMgdGhlIFRvbSBTZWxlY3QgaW5zdGFuY2Ugd2l0aCB0aGUgb3JpZ2luYWwgaW5wdXQgb3Igc2VsZWN0XG5cdCAgICpcblx0ICAgKi9cblxuXG5cdCAgc3luYyhnZXRfc2V0dGluZ3MgPSB0cnVlKSB7XG5cdCAgICBjb25zdCBzZWxmID0gdGhpcztcblx0ICAgIGNvbnN0IHNldHRpbmdzID0gZ2V0X3NldHRpbmdzID8gZ2V0U2V0dGluZ3Moc2VsZi5pbnB1dCwge1xuXHQgICAgICBkZWxpbWl0ZXI6IHNlbGYuc2V0dGluZ3MuZGVsaW1pdGVyXG5cdCAgICB9KSA6IHNlbGYuc2V0dGluZ3M7XG5cdCAgICBzZWxmLnNldHVwT3B0aW9ucyhzZXR0aW5ncy5vcHRpb25zLCBzZXR0aW5ncy5vcHRncm91cHMpO1xuXHQgICAgc2VsZi5zZXRWYWx1ZShzZXR0aW5ncy5pdGVtcyB8fCBbXSwgdHJ1ZSk7IC8vIHNpbGVudCBwcmV2ZW50cyByZWN1cnNpb25cblxuXHQgICAgc2VsZi5sYXN0UXVlcnkgPSBudWxsOyAvLyBzbyB1cGRhdGVkIG9wdGlvbnMgd2lsbCBiZSBkaXNwbGF5ZWQgaW4gZHJvcGRvd25cblx0ICB9XG5cdCAgLyoqXG5cdCAgICogVHJpZ2dlcmVkIHdoZW4gdGhlIG1haW4gY29udHJvbCBlbGVtZW50XG5cdCAgICogaGFzIGEgY2xpY2sgZXZlbnQuXG5cdCAgICpcblx0ICAgKi9cblxuXG5cdCAgb25DbGljaygpIHtcblx0ICAgIHZhciBzZWxmID0gdGhpcztcblxuXHQgICAgaWYgKHNlbGYuYWN0aXZlSXRlbXMubGVuZ3RoID4gMCkge1xuXHQgICAgICBzZWxmLmNsZWFyQWN0aXZlSXRlbXMoKTtcblx0ICAgICAgc2VsZi5mb2N1cygpO1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIGlmIChzZWxmLmlzRm9jdXNlZCAmJiBzZWxmLmlzT3Blbikge1xuXHQgICAgICBzZWxmLmJsdXIoKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHNlbGYuZm9jdXMoKTtcblx0ICAgIH1cblx0ICB9XG5cdCAgLyoqXG5cdCAgICogQGRlcHJlY2F0ZWQgdjEuN1xuXHQgICAqXG5cdCAgICovXG5cblxuXHQgIG9uTW91c2VEb3duKCkge31cblx0ICAvKipcblx0ICAgKiBUcmlnZ2VyZWQgd2hlbiB0aGUgdmFsdWUgb2YgdGhlIGNvbnRyb2wgaGFzIGJlZW4gY2hhbmdlZC5cblx0ICAgKiBUaGlzIHNob3VsZCBwcm9wYWdhdGUgdGhlIGV2ZW50IHRvIHRoZSBvcmlnaW5hbCBET01cblx0ICAgKiBpbnB1dCAvIHNlbGVjdCBlbGVtZW50LlxuXHQgICAqL1xuXG5cblx0ICBvbkNoYW5nZSgpIHtcblx0ICAgIHRyaWdnZXJFdmVudCh0aGlzLmlucHV0LCAnaW5wdXQnKTtcblx0ICAgIHRyaWdnZXJFdmVudCh0aGlzLmlucHV0LCAnY2hhbmdlJyk7XG5cdCAgfVxuXHQgIC8qKlxuXHQgICAqIFRyaWdnZXJlZCBvbiA8aW5wdXQ+IHBhc3RlLlxuXHQgICAqXG5cdCAgICovXG5cblxuXHQgIG9uUGFzdGUoZSkge1xuXHQgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG5cdCAgICBpZiAoc2VsZi5pc0lucHV0SGlkZGVuIHx8IHNlbGYuaXNMb2NrZWQpIHtcblx0ICAgICAgcHJldmVudERlZmF1bHQoZSk7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH0gLy8gSWYgYSByZWdleCBvciBzdHJpbmcgaXMgaW5jbHVkZWQsIHRoaXMgd2lsbCBzcGxpdCB0aGUgcGFzdGVkXG5cdCAgICAvLyBpbnB1dCBhbmQgY3JlYXRlIEl0ZW1zIGZvciBlYWNoIHNlcGFyYXRlIHZhbHVlXG5cblxuXHQgICAgaWYgKCFzZWxmLnNldHRpbmdzLnNwbGl0T24pIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfSAvLyBXYWl0IGZvciBwYXN0ZWQgdGV4dCB0byBiZSByZWNvZ25pemVkIGluIHZhbHVlXG5cblxuXHQgICAgc2V0VGltZW91dCgoKSA9PiB7XG5cdCAgICAgIHZhciBwYXN0ZWRUZXh0ID0gc2VsZi5pbnB1dFZhbHVlKCk7XG5cblx0ICAgICAgaWYgKCFwYXN0ZWRUZXh0Lm1hdGNoKHNlbGYuc2V0dGluZ3Muc3BsaXRPbikpIHtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblxuXHQgICAgICB2YXIgc3BsaXRJbnB1dCA9IHBhc3RlZFRleHQudHJpbSgpLnNwbGl0KHNlbGYuc2V0dGluZ3Muc3BsaXRPbik7XG5cdCAgICAgIGl0ZXJhdGUkMShzcGxpdElucHV0LCBwaWVjZSA9PiB7XG5cdCAgICAgICAgY29uc3QgaGFzaCA9IGhhc2hfa2V5KHBpZWNlKTtcblxuXHQgICAgICAgIGlmIChoYXNoKSB7XG5cdCAgICAgICAgICBpZiAodGhpcy5vcHRpb25zW3BpZWNlXSkge1xuXHQgICAgICAgICAgICBzZWxmLmFkZEl0ZW0ocGllY2UpO1xuXHQgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgc2VsZi5jcmVhdGVJdGVtKHBpZWNlKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH0pO1xuXHQgICAgfSwgMCk7XG5cdCAgfVxuXHQgIC8qKlxuXHQgICAqIFRyaWdnZXJlZCBvbiA8aW5wdXQ+IGtleXByZXNzLlxuXHQgICAqXG5cdCAgICovXG5cblxuXHQgIG9uS2V5UHJlc3MoZSkge1xuXHQgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG5cdCAgICBpZiAoc2VsZi5pc0xvY2tlZCkge1xuXHQgICAgICBwcmV2ZW50RGVmYXVsdChlKTtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgY2hhcmFjdGVyID0gU3RyaW5nLmZyb21DaGFyQ29kZShlLmtleUNvZGUgfHwgZS53aGljaCk7XG5cblx0ICAgIGlmIChzZWxmLnNldHRpbmdzLmNyZWF0ZSAmJiBzZWxmLnNldHRpbmdzLm1vZGUgPT09ICdtdWx0aScgJiYgY2hhcmFjdGVyID09PSBzZWxmLnNldHRpbmdzLmRlbGltaXRlcikge1xuXHQgICAgICBzZWxmLmNyZWF0ZUl0ZW0oKTtcblx0ICAgICAgcHJldmVudERlZmF1bHQoZSk7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICB9XG5cdCAgLyoqXG5cdCAgICogVHJpZ2dlcmVkIG9uIDxpbnB1dD4ga2V5ZG93bi5cblx0ICAgKlxuXHQgICAqL1xuXG5cblx0ICBvbktleURvd24oZSkge1xuXHQgICAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgICAgc2VsZi5pZ25vcmVIb3ZlciA9IHRydWU7XG5cblx0ICAgIGlmIChzZWxmLmlzTG9ja2VkKSB7XG5cdCAgICAgIGlmIChlLmtleUNvZGUgIT09IEtFWV9UQUIpIHtcblx0ICAgICAgICBwcmV2ZW50RGVmYXVsdChlKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgc3dpdGNoIChlLmtleUNvZGUpIHtcblx0ICAgICAgLy8gY3RybCtBOiBzZWxlY3QgYWxsXG5cdCAgICAgIGNhc2UgS0VZX0E6XG5cdCAgICAgICAgaWYgKGlzS2V5RG93bihLRVlfU0hPUlRDVVQsIGUpKSB7XG5cdCAgICAgICAgICBpZiAoc2VsZi5jb250cm9sX2lucHV0LnZhbHVlID09ICcnKSB7XG5cdCAgICAgICAgICAgIHByZXZlbnREZWZhdWx0KGUpO1xuXHQgICAgICAgICAgICBzZWxmLnNlbGVjdEFsbCgpO1xuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIC8vIGVzYzogY2xvc2UgZHJvcGRvd25cblxuXHQgICAgICBjYXNlIEtFWV9FU0M6XG5cdCAgICAgICAgaWYgKHNlbGYuaXNPcGVuKSB7XG5cdCAgICAgICAgICBwcmV2ZW50RGVmYXVsdChlLCB0cnVlKTtcblx0ICAgICAgICAgIHNlbGYuY2xvc2UoKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBzZWxmLmNsZWFyQWN0aXZlSXRlbXMoKTtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIC8vIGRvd246IG9wZW4gZHJvcGRvd24gb3IgbW92ZSBzZWxlY3Rpb24gZG93blxuXG5cdCAgICAgIGNhc2UgS0VZX0RPV046XG5cdCAgICAgICAgaWYgKCFzZWxmLmlzT3BlbiAmJiBzZWxmLmhhc09wdGlvbnMpIHtcblx0ICAgICAgICAgIHNlbGYub3BlbigpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoc2VsZi5hY3RpdmVPcHRpb24pIHtcblx0ICAgICAgICAgIGxldCBuZXh0ID0gc2VsZi5nZXRBZGphY2VudChzZWxmLmFjdGl2ZU9wdGlvbiwgMSk7XG5cdCAgICAgICAgICBpZiAobmV4dCkgc2VsZi5zZXRBY3RpdmVPcHRpb24obmV4dCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcHJldmVudERlZmF1bHQoZSk7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICAvLyB1cDogbW92ZSBzZWxlY3Rpb24gdXBcblxuXHQgICAgICBjYXNlIEtFWV9VUDpcblx0ICAgICAgICBpZiAoc2VsZi5hY3RpdmVPcHRpb24pIHtcblx0ICAgICAgICAgIGxldCBwcmV2ID0gc2VsZi5nZXRBZGphY2VudChzZWxmLmFjdGl2ZU9wdGlvbiwgLTEpO1xuXHQgICAgICAgICAgaWYgKHByZXYpIHNlbGYuc2V0QWN0aXZlT3B0aW9uKHByZXYpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHByZXZlbnREZWZhdWx0KGUpO1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgLy8gcmV0dXJuOiBzZWxlY3QgYWN0aXZlIG9wdGlvblxuXG5cdCAgICAgIGNhc2UgS0VZX1JFVFVSTjpcblx0ICAgICAgICBpZiAoc2VsZi5jYW5TZWxlY3Qoc2VsZi5hY3RpdmVPcHRpb24pKSB7XG5cdCAgICAgICAgICBzZWxmLm9uT3B0aW9uU2VsZWN0KGUsIHNlbGYuYWN0aXZlT3B0aW9uKTtcblx0ICAgICAgICAgIHByZXZlbnREZWZhdWx0KGUpOyAvLyBpZiB0aGUgb3B0aW9uX2NyZWF0ZT1udWxsLCB0aGUgZHJvcGRvd24gbWlnaHQgYmUgY2xvc2VkXG5cdCAgICAgICAgfSBlbHNlIGlmIChzZWxmLnNldHRpbmdzLmNyZWF0ZSAmJiBzZWxmLmNyZWF0ZUl0ZW0oKSkge1xuXHQgICAgICAgICAgcHJldmVudERlZmF1bHQoZSk7IC8vIGRvbid0IHN1Ym1pdCBmb3JtIHdoZW4gc2VhcmNoaW5nIGZvciBhIHZhbHVlXG5cdCAgICAgICAgfSBlbHNlIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09IHNlbGYuY29udHJvbF9pbnB1dCAmJiBzZWxmLmlzT3Blbikge1xuXHQgICAgICAgICAgcHJldmVudERlZmF1bHQoZSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICAvLyBsZWZ0OiBtb2RpZml5IGl0ZW0gc2VsZWN0aW9uIHRvIHRoZSBsZWZ0XG5cblx0ICAgICAgY2FzZSBLRVlfTEVGVDpcblx0ICAgICAgICBzZWxmLmFkdmFuY2VTZWxlY3Rpb24oLTEsIGUpO1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgLy8gcmlnaHQ6IG1vZGlmaXkgaXRlbSBzZWxlY3Rpb24gdG8gdGhlIHJpZ2h0XG5cblx0ICAgICAgY2FzZSBLRVlfUklHSFQ6XG5cdCAgICAgICAgc2VsZi5hZHZhbmNlU2VsZWN0aW9uKDEsIGUpO1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgLy8gdGFiOiBzZWxlY3QgYWN0aXZlIG9wdGlvbiBhbmQvb3IgY3JlYXRlIGl0ZW1cblxuXHQgICAgICBjYXNlIEtFWV9UQUI6XG5cdCAgICAgICAgaWYgKHNlbGYuc2V0dGluZ3Muc2VsZWN0T25UYWIpIHtcblx0ICAgICAgICAgIGlmIChzZWxmLmNhblNlbGVjdChzZWxmLmFjdGl2ZU9wdGlvbikpIHtcblx0ICAgICAgICAgICAgc2VsZi5vbk9wdGlvblNlbGVjdChlLCBzZWxmLmFjdGl2ZU9wdGlvbik7IC8vIHByZXZlbnQgZGVmYXVsdCBbdGFiXSBiZWhhdmlvdXIgb2YganVtcCB0byB0aGUgbmV4dCBmaWVsZFxuXHQgICAgICAgICAgICAvLyBpZiBzZWxlY3QgaXNGdWxsLCB0aGVuIHRoZSBkcm9wZG93biB3b24ndCBiZSBvcGVuIGFuZCBbdGFiXSB3aWxsIHdvcmsgbm9ybWFsbHlcblxuXHQgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdChlKTtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgaWYgKHNlbGYuc2V0dGluZ3MuY3JlYXRlICYmIHNlbGYuY3JlYXRlSXRlbSgpKSB7XG5cdCAgICAgICAgICAgIHByZXZlbnREZWZhdWx0KGUpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgLy8gZGVsZXRlfGJhY2tzcGFjZTogZGVsZXRlIGl0ZW1zXG5cblx0ICAgICAgY2FzZSBLRVlfQkFDS1NQQUNFOlxuXHQgICAgICBjYXNlIEtFWV9ERUxFVEU6XG5cdCAgICAgICAgc2VsZi5kZWxldGVTZWxlY3Rpb24oZSk7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgfSAvLyBkb24ndCBlbnRlciB0ZXh0IGluIHRoZSBjb250cm9sX2lucHV0IHdoZW4gYWN0aXZlIGl0ZW1zIGFyZSBzZWxlY3RlZFxuXG5cblx0ICAgIGlmIChzZWxmLmlzSW5wdXRIaWRkZW4gJiYgIWlzS2V5RG93bihLRVlfU0hPUlRDVVQsIGUpKSB7XG5cdCAgICAgIHByZXZlbnREZWZhdWx0KGUpO1xuXHQgICAgfVxuXHQgIH1cblx0ICAvKipcblx0ICAgKiBUcmlnZ2VyZWQgb24gPGlucHV0PiBrZXl1cC5cblx0ICAgKlxuXHQgICAqL1xuXG5cblx0ICBvbklucHV0KGUpIHtcblx0ICAgIHZhciBzZWxmID0gdGhpcztcblxuXHQgICAgaWYgKHNlbGYuaXNMb2NrZWQpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgdmFsdWUgPSBzZWxmLmlucHV0VmFsdWUoKTtcblxuXHQgICAgaWYgKHNlbGYubGFzdFZhbHVlICE9PSB2YWx1ZSkge1xuXHQgICAgICBzZWxmLmxhc3RWYWx1ZSA9IHZhbHVlO1xuXG5cdCAgICAgIGlmIChzZWxmLnNldHRpbmdzLnNob3VsZExvYWQuY2FsbChzZWxmLCB2YWx1ZSkpIHtcblx0ICAgICAgICBzZWxmLmxvYWQodmFsdWUpO1xuXHQgICAgICB9XG5cblx0ICAgICAgc2VsZi5yZWZyZXNoT3B0aW9ucygpO1xuXHQgICAgICBzZWxmLnRyaWdnZXIoJ3R5cGUnLCB2YWx1ZSk7XG5cdCAgICB9XG5cdCAgfVxuXHQgIC8qKlxuXHQgICAqIFRyaWdnZXJlZCB3aGVuIHRoZSB1c2VyIHJvbGxzIG92ZXJcblx0ICAgKiBhbiBvcHRpb24gaW4gdGhlIGF1dG9jb21wbGV0ZSBkcm9wZG93biBtZW51LlxuXHQgICAqXG5cdCAgICovXG5cblxuXHQgIG9uT3B0aW9uSG92ZXIoZXZ0LCBvcHRpb24pIHtcblx0ICAgIGlmICh0aGlzLmlnbm9yZUhvdmVyKSByZXR1cm47XG5cdCAgICB0aGlzLnNldEFjdGl2ZU9wdGlvbihvcHRpb24sIGZhbHNlKTtcblx0ICB9XG5cdCAgLyoqXG5cdCAgICogVHJpZ2dlcmVkIG9uIDxpbnB1dD4gZm9jdXMuXG5cdCAgICpcblx0ICAgKi9cblxuXG5cdCAgb25Gb2N1cyhlKSB7XG5cdCAgICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgICB2YXIgd2FzRm9jdXNlZCA9IHNlbGYuaXNGb2N1c2VkO1xuXG5cdCAgICBpZiAoc2VsZi5pc0Rpc2FibGVkKSB7XG5cdCAgICAgIHNlbGYuYmx1cigpO1xuXHQgICAgICBwcmV2ZW50RGVmYXVsdChlKTtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoc2VsZi5pZ25vcmVGb2N1cykgcmV0dXJuO1xuXHQgICAgc2VsZi5pc0ZvY3VzZWQgPSB0cnVlO1xuXHQgICAgaWYgKHNlbGYuc2V0dGluZ3MucHJlbG9hZCA9PT0gJ2ZvY3VzJykgc2VsZi5wcmVsb2FkKCk7XG5cdCAgICBpZiAoIXdhc0ZvY3VzZWQpIHNlbGYudHJpZ2dlcignZm9jdXMnKTtcblxuXHQgICAgaWYgKCFzZWxmLmFjdGl2ZUl0ZW1zLmxlbmd0aCkge1xuXHQgICAgICBzZWxmLnNob3dJbnB1dCgpO1xuXHQgICAgICBzZWxmLnJlZnJlc2hPcHRpb25zKCEhc2VsZi5zZXR0aW5ncy5vcGVuT25Gb2N1cyk7XG5cdCAgICB9XG5cblx0ICAgIHNlbGYucmVmcmVzaFN0YXRlKCk7XG5cdCAgfVxuXHQgIC8qKlxuXHQgICAqIFRyaWdnZXJlZCBvbiA8aW5wdXQ+IGJsdXIuXG5cdCAgICpcblx0ICAgKi9cblxuXG5cdCAgb25CbHVyKGUpIHtcblx0ICAgIGlmIChkb2N1bWVudC5oYXNGb2N1cygpID09PSBmYWxzZSkgcmV0dXJuO1xuXHQgICAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgICAgaWYgKCFzZWxmLmlzRm9jdXNlZCkgcmV0dXJuO1xuXHQgICAgc2VsZi5pc0ZvY3VzZWQgPSBmYWxzZTtcblx0ICAgIHNlbGYuaWdub3JlRm9jdXMgPSBmYWxzZTtcblxuXHQgICAgdmFyIGRlYWN0aXZhdGUgPSAoKSA9PiB7XG5cdCAgICAgIHNlbGYuY2xvc2UoKTtcblx0ICAgICAgc2VsZi5zZXRBY3RpdmVJdGVtKCk7XG5cdCAgICAgIHNlbGYuc2V0Q2FyZXQoc2VsZi5pdGVtcy5sZW5ndGgpO1xuXHQgICAgICBzZWxmLnRyaWdnZXIoJ2JsdXInKTtcblx0ICAgIH07XG5cblx0ICAgIGlmIChzZWxmLnNldHRpbmdzLmNyZWF0ZSAmJiBzZWxmLnNldHRpbmdzLmNyZWF0ZU9uQmx1cikge1xuXHQgICAgICBzZWxmLmNyZWF0ZUl0ZW0obnVsbCwgZGVhY3RpdmF0ZSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBkZWFjdGl2YXRlKCk7XG5cdCAgICB9XG5cdCAgfVxuXHQgIC8qKlxuXHQgICAqIFRyaWdnZXJlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiBhbiBvcHRpb25cblx0ICAgKiBpbiB0aGUgYXV0b2NvbXBsZXRlIGRyb3Bkb3duIG1lbnUuXG5cdCAgICpcblx0ICAgKi9cblxuXG5cdCAgb25PcHRpb25TZWxlY3QoZXZ0LCBvcHRpb24pIHtcblx0ICAgIHZhciB2YWx1ZSxcblx0ICAgICAgICBzZWxmID0gdGhpczsgLy8gc2hvdWxkIG5vdCBiZSBwb3NzaWJsZSB0byB0cmlnZ2VyIGEgb3B0aW9uIHVuZGVyIGEgZGlzYWJsZWQgb3B0Z3JvdXBcblxuXHQgICAgaWYgKG9wdGlvbi5wYXJlbnRFbGVtZW50ICYmIG9wdGlvbi5wYXJlbnRFbGVtZW50Lm1hdGNoZXMoJ1tkYXRhLWRpc2FibGVkXScpKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgaWYgKG9wdGlvbi5jbGFzc0xpc3QuY29udGFpbnMoJ2NyZWF0ZScpKSB7XG5cdCAgICAgIHNlbGYuY3JlYXRlSXRlbShudWxsLCAoKSA9PiB7XG5cdCAgICAgICAgaWYgKHNlbGYuc2V0dGluZ3MuY2xvc2VBZnRlclNlbGVjdCkge1xuXHQgICAgICAgICAgc2VsZi5jbG9zZSgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB2YWx1ZSA9IG9wdGlvbi5kYXRhc2V0LnZhbHVlO1xuXG5cdCAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICAgICAgc2VsZi5sYXN0UXVlcnkgPSBudWxsO1xuXHQgICAgICAgIHNlbGYuYWRkSXRlbSh2YWx1ZSk7XG5cblx0ICAgICAgICBpZiAoc2VsZi5zZXR0aW5ncy5jbG9zZUFmdGVyU2VsZWN0KSB7XG5cdCAgICAgICAgICBzZWxmLmNsb3NlKCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKCFzZWxmLnNldHRpbmdzLmhpZGVTZWxlY3RlZCAmJiBldnQudHlwZSAmJiAvY2xpY2svLnRlc3QoZXZ0LnR5cGUpKSB7XG5cdCAgICAgICAgICBzZWxmLnNldEFjdGl2ZU9wdGlvbihvcHRpb24pO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0ICAvKipcblx0ICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgZ2l2ZW4gb3B0aW9uIGNhbiBiZSBzZWxlY3RlZFxuXHQgICAqXG5cdCAgICovXG5cblxuXHQgIGNhblNlbGVjdChvcHRpb24pIHtcblx0ICAgIGlmICh0aGlzLmlzT3BlbiAmJiBvcHRpb24gJiYgdGhpcy5kcm9wZG93bl9jb250ZW50LmNvbnRhaW5zKG9wdGlvbikpIHtcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cdCAgLyoqXG5cdCAgICogVHJpZ2dlcmVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIGFuIGl0ZW1cblx0ICAgKiB0aGF0IGhhcyBiZWVuIHNlbGVjdGVkLlxuXHQgICAqXG5cdCAgICovXG5cblxuXHQgIG9uSXRlbVNlbGVjdChldnQsIGl0ZW0pIHtcblx0ICAgIHZhciBzZWxmID0gdGhpcztcblxuXHQgICAgaWYgKCFzZWxmLmlzTG9ja2VkICYmIHNlbGYuc2V0dGluZ3MubW9kZSA9PT0gJ211bHRpJykge1xuXHQgICAgICBwcmV2ZW50RGVmYXVsdChldnQpO1xuXHQgICAgICBzZWxmLnNldEFjdGl2ZUl0ZW0oaXRlbSwgZXZ0KTtcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cdCAgLyoqXG5cdCAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCB0byBpbnZva2Vcblx0ICAgKiB0aGUgdXNlci1wcm92aWRlZCBvcHRpb24gcHJvdmlkZXIgLyBsb2FkZXJcblx0ICAgKlxuXHQgICAqIE5vdGUsIHRoZXJlIGlzIGEgc3VidGxlIGRpZmZlcmVuY2UgYmV0d2VlblxuXHQgICAqIHRoaXMuY2FuTG9hZCgpIGFuZCB0aGlzLnNldHRpbmdzLnNob3VsZExvYWQoKTtcblx0ICAgKlxuXHQgICAqXHQtIHNldHRpbmdzLnNob3VsZExvYWQoKSBpcyBhIHVzZXItaW5wdXQgdmFsaWRhdG9yLlxuXHQgICAqXHRXaGVuIGZhbHNlIGlzIHJldHVybmVkLCB0aGUgbm90X2xvYWRpbmcgdGVtcGxhdGVcblx0ICAgKlx0d2lsbCBiZSBhZGRlZCB0byB0aGUgZHJvcGRvd25cblx0ICAgKlxuXHQgICAqXHQtIGNhbkxvYWQoKSBpcyBsb3dlciBsZXZlbCB2YWxpZGF0b3IgdGhhdCBjaGVja3Ncblx0ICAgKiBcdHRoZSBUb20gU2VsZWN0IGluc3RhbmNlLiBUaGVyZSBpcyBubyBpbmhlcmVudCB1c2VyXG5cdCAgICpcdGZlZWRiYWNrIHdoZW4gY2FuTG9hZCByZXR1cm5zIGZhbHNlXG5cdCAgICpcblx0ICAgKi9cblxuXG5cdCAgY2FuTG9hZCh2YWx1ZSkge1xuXHQgICAgaWYgKCF0aGlzLnNldHRpbmdzLmxvYWQpIHJldHVybiBmYWxzZTtcblx0ICAgIGlmICh0aGlzLmxvYWRlZFNlYXJjaGVzLmhhc093blByb3BlcnR5KHZhbHVlKSkgcmV0dXJuIGZhbHNlO1xuXHQgICAgcmV0dXJuIHRydWU7XG5cdCAgfVxuXHQgIC8qKlxuXHQgICAqIEludm9rZXMgdGhlIHVzZXItcHJvdmlkZWQgb3B0aW9uIHByb3ZpZGVyIC8gbG9hZGVyLlxuXHQgICAqXG5cdCAgICovXG5cblxuXHQgIGxvYWQodmFsdWUpIHtcblx0ICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXHQgICAgaWYgKCFzZWxmLmNhbkxvYWQodmFsdWUpKSByZXR1cm47XG5cdCAgICBhZGRDbGFzc2VzKHNlbGYud3JhcHBlciwgc2VsZi5zZXR0aW5ncy5sb2FkaW5nQ2xhc3MpO1xuXHQgICAgc2VsZi5sb2FkaW5nKys7XG5cdCAgICBjb25zdCBjYWxsYmFjayA9IHNlbGYubG9hZENhbGxiYWNrLmJpbmQoc2VsZik7XG5cdCAgICBzZWxmLnNldHRpbmdzLmxvYWQuY2FsbChzZWxmLCB2YWx1ZSwgY2FsbGJhY2spO1xuXHQgIH1cblx0ICAvKipcblx0ICAgKiBJbnZva2VkIGJ5IHRoZSB1c2VyLXByb3ZpZGVkIG9wdGlvbiBwcm92aWRlclxuXHQgICAqXG5cdCAgICovXG5cblxuXHQgIGxvYWRDYWxsYmFjayhvcHRpb25zLCBvcHRncm91cHMpIHtcblx0ICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXHQgICAgc2VsZi5sb2FkaW5nID0gTWF0aC5tYXgoc2VsZi5sb2FkaW5nIC0gMSwgMCk7XG5cdCAgICBzZWxmLmxhc3RRdWVyeSA9IG51bGw7XG5cdCAgICBzZWxmLmNsZWFyQWN0aXZlT3B0aW9uKCk7IC8vIHdoZW4gbmV3IHJlc3VsdHMgbG9hZCwgZm9jdXMgc2hvdWxkIGJlIG9uIGZpcnN0IG9wdGlvblxuXG5cdCAgICBzZWxmLnNldHVwT3B0aW9ucyhvcHRpb25zLCBvcHRncm91cHMpO1xuXHQgICAgc2VsZi5yZWZyZXNoT3B0aW9ucyhzZWxmLmlzRm9jdXNlZCAmJiAhc2VsZi5pc0lucHV0SGlkZGVuKTtcblxuXHQgICAgaWYgKCFzZWxmLmxvYWRpbmcpIHtcblx0ICAgICAgcmVtb3ZlQ2xhc3NlcyhzZWxmLndyYXBwZXIsIHNlbGYuc2V0dGluZ3MubG9hZGluZ0NsYXNzKTtcblx0ICAgIH1cblxuXHQgICAgc2VsZi50cmlnZ2VyKCdsb2FkJywgb3B0aW9ucywgb3B0Z3JvdXBzKTtcblx0ICB9XG5cblx0ICBwcmVsb2FkKCkge1xuXHQgICAgdmFyIGNsYXNzTGlzdCA9IHRoaXMud3JhcHBlci5jbGFzc0xpc3Q7XG5cdCAgICBpZiAoY2xhc3NMaXN0LmNvbnRhaW5zKCdwcmVsb2FkZWQnKSkgcmV0dXJuO1xuXHQgICAgY2xhc3NMaXN0LmFkZCgncHJlbG9hZGVkJyk7XG5cdCAgICB0aGlzLmxvYWQoJycpO1xuXHQgIH1cblx0ICAvKipcblx0ICAgKiBTZXRzIHRoZSBpbnB1dCBmaWVsZCBvZiB0aGUgY29udHJvbCB0byB0aGUgc3BlY2lmaWVkIHZhbHVlLlxuXHQgICAqXG5cdCAgICovXG5cblxuXHQgIHNldFRleHRib3hWYWx1ZSh2YWx1ZSA9ICcnKSB7XG5cdCAgICB2YXIgaW5wdXQgPSB0aGlzLmNvbnRyb2xfaW5wdXQ7XG5cdCAgICB2YXIgY2hhbmdlZCA9IGlucHV0LnZhbHVlICE9PSB2YWx1ZTtcblxuXHQgICAgaWYgKGNoYW5nZWQpIHtcblx0ICAgICAgaW5wdXQudmFsdWUgPSB2YWx1ZTtcblx0ICAgICAgdHJpZ2dlckV2ZW50KGlucHV0LCAndXBkYXRlJyk7XG5cdCAgICAgIHRoaXMubGFzdFZhbHVlID0gdmFsdWU7XG5cdCAgICB9XG5cdCAgfVxuXHQgIC8qKlxuXHQgICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBjb250cm9sLiBJZiBtdWx0aXBsZSBpdGVtc1xuXHQgICAqIGNhbiBiZSBzZWxlY3RlZCAoZS5nLiA8c2VsZWN0IG11bHRpcGxlPiksIHRoaXMgcmV0dXJuc1xuXHQgICAqIGFuIGFycmF5LiBJZiBvbmx5IG9uZSBpdGVtIGNhbiBiZSBzZWxlY3RlZCwgdGhpc1xuXHQgICAqIHJldHVybnMgYSBzdHJpbmcuXG5cdCAgICpcblx0ICAgKi9cblxuXG5cdCAgZ2V0VmFsdWUoKSB7XG5cdCAgICBpZiAodGhpcy5pc19zZWxlY3RfdGFnICYmIHRoaXMuaW5wdXQuaGFzQXR0cmlidXRlKCdtdWx0aXBsZScpKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLml0ZW1zO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGhpcy5pdGVtcy5qb2luKHRoaXMuc2V0dGluZ3MuZGVsaW1pdGVyKTtcblx0ICB9XG5cdCAgLyoqXG5cdCAgICogUmVzZXRzIHRoZSBzZWxlY3RlZCBpdGVtcyB0byB0aGUgZ2l2ZW4gdmFsdWUuXG5cdCAgICpcblx0ICAgKi9cblxuXG5cdCAgc2V0VmFsdWUodmFsdWUsIHNpbGVudCkge1xuXHQgICAgdmFyIGV2ZW50cyA9IHNpbGVudCA/IFtdIDogWydjaGFuZ2UnXTtcblx0ICAgIGRlYm91bmNlX2V2ZW50cyh0aGlzLCBldmVudHMsICgpID0+IHtcblx0ICAgICAgdGhpcy5jbGVhcihzaWxlbnQpO1xuXHQgICAgICB0aGlzLmFkZEl0ZW1zKHZhbHVlLCBzaWxlbnQpO1xuXHQgICAgfSk7XG5cdCAgfVxuXHQgIC8qKlxuXHQgICAqIFJlc2V0cyB0aGUgbnVtYmVyIG9mIG1heCBpdGVtcyB0byB0aGUgZ2l2ZW4gdmFsdWVcblx0ICAgKlxuXHQgICAqL1xuXG5cblx0ICBzZXRNYXhJdGVtcyh2YWx1ZSkge1xuXHQgICAgaWYgKHZhbHVlID09PSAwKSB2YWx1ZSA9IG51bGw7IC8vcmVzZXQgdG8gdW5saW1pdGVkIGl0ZW1zLlxuXG5cdCAgICB0aGlzLnNldHRpbmdzLm1heEl0ZW1zID0gdmFsdWU7XG5cdCAgICB0aGlzLnJlZnJlc2hTdGF0ZSgpO1xuXHQgIH1cblx0ICAvKipcblx0ICAgKiBTZXRzIHRoZSBzZWxlY3RlZCBpdGVtLlxuXHQgICAqXG5cdCAgICovXG5cblxuXHQgIHNldEFjdGl2ZUl0ZW0oaXRlbSwgZSkge1xuXHQgICAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgICAgdmFyIGV2ZW50TmFtZTtcblx0ICAgIHZhciBpLCBiZWdpbiwgZW5kLCBzd2FwO1xuXHQgICAgdmFyIGxhc3Q7XG5cdCAgICBpZiAoc2VsZi5zZXR0aW5ncy5tb2RlID09PSAnc2luZ2xlJykgcmV0dXJuOyAvLyBjbGVhciB0aGUgYWN0aXZlIHNlbGVjdGlvblxuXG5cdCAgICBpZiAoIWl0ZW0pIHtcblx0ICAgICAgc2VsZi5jbGVhckFjdGl2ZUl0ZW1zKCk7XG5cblx0ICAgICAgaWYgKHNlbGYuaXNGb2N1c2VkKSB7XG5cdCAgICAgICAgc2VsZi5zaG93SW5wdXQoKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybjtcblx0ICAgIH0gLy8gbW9kaWZ5IHNlbGVjdGlvblxuXG5cblx0ICAgIGV2ZW50TmFtZSA9IGUgJiYgZS50eXBlLnRvTG93ZXJDYXNlKCk7XG5cblx0ICAgIGlmIChldmVudE5hbWUgPT09ICdjbGljaycgJiYgaXNLZXlEb3duKCdzaGlmdEtleScsIGUpICYmIHNlbGYuYWN0aXZlSXRlbXMubGVuZ3RoKSB7XG5cdCAgICAgIGxhc3QgPSBzZWxmLmdldExhc3RBY3RpdmUoKTtcblx0ICAgICAgYmVnaW4gPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKHNlbGYuY29udHJvbC5jaGlsZHJlbiwgbGFzdCk7XG5cdCAgICAgIGVuZCA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoc2VsZi5jb250cm9sLmNoaWxkcmVuLCBpdGVtKTtcblxuXHQgICAgICBpZiAoYmVnaW4gPiBlbmQpIHtcblx0ICAgICAgICBzd2FwID0gYmVnaW47XG5cdCAgICAgICAgYmVnaW4gPSBlbmQ7XG5cdCAgICAgICAgZW5kID0gc3dhcDtcblx0ICAgICAgfVxuXG5cdCAgICAgIGZvciAoaSA9IGJlZ2luOyBpIDw9IGVuZDsgaSsrKSB7XG5cdCAgICAgICAgaXRlbSA9IHNlbGYuY29udHJvbC5jaGlsZHJlbltpXTtcblxuXHQgICAgICAgIGlmIChzZWxmLmFjdGl2ZUl0ZW1zLmluZGV4T2YoaXRlbSkgPT09IC0xKSB7XG5cdCAgICAgICAgICBzZWxmLnNldEFjdGl2ZUl0ZW1DbGFzcyhpdGVtKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICBwcmV2ZW50RGVmYXVsdChlKTtcblx0ICAgIH0gZWxzZSBpZiAoZXZlbnROYW1lID09PSAnY2xpY2snICYmIGlzS2V5RG93bihLRVlfU0hPUlRDVVQsIGUpIHx8IGV2ZW50TmFtZSA9PT0gJ2tleWRvd24nICYmIGlzS2V5RG93bignc2hpZnRLZXknLCBlKSkge1xuXHQgICAgICBpZiAoaXRlbS5jbGFzc0xpc3QuY29udGFpbnMoJ2FjdGl2ZScpKSB7XG5cdCAgICAgICAgc2VsZi5yZW1vdmVBY3RpdmVJdGVtKGl0ZW0pO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHNlbGYuc2V0QWN0aXZlSXRlbUNsYXNzKGl0ZW0pO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBzZWxmLmNsZWFyQWN0aXZlSXRlbXMoKTtcblx0ICAgICAgc2VsZi5zZXRBY3RpdmVJdGVtQ2xhc3MoaXRlbSk7XG5cdCAgICB9IC8vIGVuc3VyZSBjb250cm9sIGhhcyBmb2N1c1xuXG5cblx0ICAgIHNlbGYuaGlkZUlucHV0KCk7XG5cblx0ICAgIGlmICghc2VsZi5pc0ZvY3VzZWQpIHtcblx0ICAgICAgc2VsZi5mb2N1cygpO1xuXHQgICAgfVxuXHQgIH1cblx0ICAvKipcblx0ICAgKiBTZXQgdGhlIGFjdGl2ZSBhbmQgbGFzdC1hY3RpdmUgY2xhc3Nlc1xuXHQgICAqXG5cdCAgICovXG5cblxuXHQgIHNldEFjdGl2ZUl0ZW1DbGFzcyhpdGVtKSB7XG5cdCAgICBjb25zdCBzZWxmID0gdGhpcztcblx0ICAgIGNvbnN0IGxhc3RfYWN0aXZlID0gc2VsZi5jb250cm9sLnF1ZXJ5U2VsZWN0b3IoJy5sYXN0LWFjdGl2ZScpO1xuXHQgICAgaWYgKGxhc3RfYWN0aXZlKSByZW1vdmVDbGFzc2VzKGxhc3RfYWN0aXZlLCAnbGFzdC1hY3RpdmUnKTtcblx0ICAgIGFkZENsYXNzZXMoaXRlbSwgJ2FjdGl2ZSBsYXN0LWFjdGl2ZScpO1xuXHQgICAgc2VsZi50cmlnZ2VyKCdpdGVtX3NlbGVjdCcsIGl0ZW0pO1xuXG5cdCAgICBpZiAoc2VsZi5hY3RpdmVJdGVtcy5pbmRleE9mKGl0ZW0pID09IC0xKSB7XG5cdCAgICAgIHNlbGYuYWN0aXZlSXRlbXMucHVzaChpdGVtKTtcblx0ICAgIH1cblx0ICB9XG5cdCAgLyoqXG5cdCAgICogUmVtb3ZlIGFjdGl2ZSBpdGVtXG5cdCAgICpcblx0ICAgKi9cblxuXG5cdCAgcmVtb3ZlQWN0aXZlSXRlbShpdGVtKSB7XG5cdCAgICB2YXIgaWR4ID0gdGhpcy5hY3RpdmVJdGVtcy5pbmRleE9mKGl0ZW0pO1xuXHQgICAgdGhpcy5hY3RpdmVJdGVtcy5zcGxpY2UoaWR4LCAxKTtcblx0ICAgIHJlbW92ZUNsYXNzZXMoaXRlbSwgJ2FjdGl2ZScpO1xuXHQgIH1cblx0ICAvKipcblx0ICAgKiBDbGVhcnMgYWxsIHRoZSBhY3RpdmUgaXRlbXNcblx0ICAgKlxuXHQgICAqL1xuXG5cblx0ICBjbGVhckFjdGl2ZUl0ZW1zKCkge1xuXHQgICAgcmVtb3ZlQ2xhc3Nlcyh0aGlzLmFjdGl2ZUl0ZW1zLCAnYWN0aXZlJyk7XG5cdCAgICB0aGlzLmFjdGl2ZUl0ZW1zID0gW107XG5cdCAgfVxuXHQgIC8qKlxuXHQgICAqIFNldHMgdGhlIHNlbGVjdGVkIGl0ZW0gaW4gdGhlIGRyb3Bkb3duIG1lbnVcblx0ICAgKiBvZiBhdmFpbGFibGUgb3B0aW9ucy5cblx0ICAgKlxuXHQgICAqL1xuXG5cblx0ICBzZXRBY3RpdmVPcHRpb24ob3B0aW9uLCBzY3JvbGwgPSB0cnVlKSB7XG5cdCAgICBpZiAob3B0aW9uID09PSB0aGlzLmFjdGl2ZU9wdGlvbikge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuY2xlYXJBY3RpdmVPcHRpb24oKTtcblx0ICAgIGlmICghb3B0aW9uKSByZXR1cm47XG5cdCAgICB0aGlzLmFjdGl2ZU9wdGlvbiA9IG9wdGlvbjtcblx0ICAgIHNldEF0dHIodGhpcy5mb2N1c19ub2RlLCB7XG5cdCAgICAgICdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnOiBvcHRpb24uZ2V0QXR0cmlidXRlKCdpZCcpXG5cdCAgICB9KTtcblx0ICAgIHNldEF0dHIob3B0aW9uLCB7XG5cdCAgICAgICdhcmlhLXNlbGVjdGVkJzogJ3RydWUnXG5cdCAgICB9KTtcblx0ICAgIGFkZENsYXNzZXMob3B0aW9uLCAnYWN0aXZlJyk7XG5cdCAgICBpZiAoc2Nyb2xsKSB0aGlzLnNjcm9sbFRvT3B0aW9uKG9wdGlvbik7XG5cdCAgfVxuXHQgIC8qKlxuXHQgICAqIFNldHMgdGhlIGRyb3Bkb3duX2NvbnRlbnQgc2Nyb2xsVG9wIHRvIGRpc3BsYXkgdGhlIG9wdGlvblxuXHQgICAqXG5cdCAgICovXG5cblxuXHQgIHNjcm9sbFRvT3B0aW9uKG9wdGlvbiwgYmVoYXZpb3IpIHtcblx0ICAgIGlmICghb3B0aW9uKSByZXR1cm47XG5cdCAgICBjb25zdCBjb250ZW50ID0gdGhpcy5kcm9wZG93bl9jb250ZW50O1xuXHQgICAgY29uc3QgaGVpZ2h0X21lbnUgPSBjb250ZW50LmNsaWVudEhlaWdodDtcblx0ICAgIGNvbnN0IHNjcm9sbFRvcCA9IGNvbnRlbnQuc2Nyb2xsVG9wIHx8IDA7XG5cdCAgICBjb25zdCBoZWlnaHRfaXRlbSA9IG9wdGlvbi5vZmZzZXRIZWlnaHQ7XG5cdCAgICBjb25zdCB5ID0gb3B0aW9uLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCAtIGNvbnRlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wICsgc2Nyb2xsVG9wO1xuXG5cdCAgICBpZiAoeSArIGhlaWdodF9pdGVtID4gaGVpZ2h0X21lbnUgKyBzY3JvbGxUb3ApIHtcblx0ICAgICAgdGhpcy5zY3JvbGwoeSAtIGhlaWdodF9tZW51ICsgaGVpZ2h0X2l0ZW0sIGJlaGF2aW9yKTtcblx0ICAgIH0gZWxzZSBpZiAoeSA8IHNjcm9sbFRvcCkge1xuXHQgICAgICB0aGlzLnNjcm9sbCh5LCBiZWhhdmlvcik7XG5cdCAgICB9XG5cdCAgfVxuXHQgIC8qKlxuXHQgICAqIFNjcm9sbCB0aGUgZHJvcGRvd24gdG8gdGhlIGdpdmVuIHBvc2l0aW9uXG5cdCAgICpcblx0ICAgKi9cblxuXG5cdCAgc2Nyb2xsKHNjcm9sbFRvcCwgYmVoYXZpb3IpIHtcblx0ICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLmRyb3Bkb3duX2NvbnRlbnQ7XG5cblx0ICAgIGlmIChiZWhhdmlvcikge1xuXHQgICAgICBjb250ZW50LnN0eWxlLnNjcm9sbEJlaGF2aW9yID0gYmVoYXZpb3I7XG5cdCAgICB9XG5cblx0ICAgIGNvbnRlbnQuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuXHQgICAgY29udGVudC5zdHlsZS5zY3JvbGxCZWhhdmlvciA9ICcnO1xuXHQgIH1cblx0ICAvKipcblx0ICAgKiBDbGVhcnMgdGhlIGFjdGl2ZSBvcHRpb25cblx0ICAgKlxuXHQgICAqL1xuXG5cblx0ICBjbGVhckFjdGl2ZU9wdGlvbigpIHtcblx0ICAgIGlmICh0aGlzLmFjdGl2ZU9wdGlvbikge1xuXHQgICAgICByZW1vdmVDbGFzc2VzKHRoaXMuYWN0aXZlT3B0aW9uLCAnYWN0aXZlJyk7XG5cdCAgICAgIHNldEF0dHIodGhpcy5hY3RpdmVPcHRpb24sIHtcblx0ICAgICAgICAnYXJpYS1zZWxlY3RlZCc6IG51bGxcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuYWN0aXZlT3B0aW9uID0gbnVsbDtcblx0ICAgIHNldEF0dHIodGhpcy5mb2N1c19ub2RlLCB7XG5cdCAgICAgICdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnOiBudWxsXG5cdCAgICB9KTtcblx0ICB9XG5cdCAgLyoqXG5cdCAgICogU2VsZWN0cyBhbGwgaXRlbXMgKENUUkwgKyBBKS5cblx0ICAgKi9cblxuXG5cdCAgc2VsZWN0QWxsKCkge1xuXHQgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cdCAgICBpZiAoc2VsZi5zZXR0aW5ncy5tb2RlID09PSAnc2luZ2xlJykgcmV0dXJuO1xuXHQgICAgY29uc3QgYWN0aXZlSXRlbXMgPSBzZWxmLmNvbnRyb2xDaGlsZHJlbigpO1xuXHQgICAgaWYgKCFhY3RpdmVJdGVtcy5sZW5ndGgpIHJldHVybjtcblx0ICAgIHNlbGYuaGlkZUlucHV0KCk7XG5cdCAgICBzZWxmLmNsb3NlKCk7XG5cdCAgICBzZWxmLmFjdGl2ZUl0ZW1zID0gYWN0aXZlSXRlbXM7XG5cdCAgICBpdGVyYXRlJDEoYWN0aXZlSXRlbXMsIGl0ZW0gPT4ge1xuXHQgICAgICBzZWxmLnNldEFjdGl2ZUl0ZW1DbGFzcyhpdGVtKTtcblx0ICAgIH0pO1xuXHQgIH1cblx0ICAvKipcblx0ICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBjb250cm9sX2lucHV0IHNob3VsZCBiZSBpbiBhIGhpZGRlbiBvciB2aXNpYmxlIHN0YXRlXG5cdCAgICpcblx0ICAgKi9cblxuXG5cdCAgaW5wdXRTdGF0ZSgpIHtcblx0ICAgIHZhciBzZWxmID0gdGhpcztcblx0ICAgIGlmICghc2VsZi5jb250cm9sLmNvbnRhaW5zKHNlbGYuY29udHJvbF9pbnB1dCkpIHJldHVybjtcblx0ICAgIHNldEF0dHIoc2VsZi5jb250cm9sX2lucHV0LCB7XG5cdCAgICAgIHBsYWNlaG9sZGVyOiBzZWxmLnNldHRpbmdzLnBsYWNlaG9sZGVyXG5cdCAgICB9KTtcblxuXHQgICAgaWYgKHNlbGYuYWN0aXZlSXRlbXMubGVuZ3RoID4gMCB8fCAhc2VsZi5pc0ZvY3VzZWQgJiYgc2VsZi5zZXR0aW5ncy5oaWRlUGxhY2Vob2xkZXIgJiYgc2VsZi5pdGVtcy5sZW5ndGggPiAwKSB7XG5cdCAgICAgIHNlbGYuc2V0VGV4dGJveFZhbHVlKCk7XG5cdCAgICAgIHNlbGYuaXNJbnB1dEhpZGRlbiA9IHRydWU7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBpZiAoc2VsZi5zZXR0aW5ncy5oaWRlUGxhY2Vob2xkZXIgJiYgc2VsZi5pdGVtcy5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgc2V0QXR0cihzZWxmLmNvbnRyb2xfaW5wdXQsIHtcblx0ICAgICAgICAgIHBsYWNlaG9sZGVyOiAnJ1xuXHQgICAgICAgIH0pO1xuXHQgICAgICB9XG5cblx0ICAgICAgc2VsZi5pc0lucHV0SGlkZGVuID0gZmFsc2U7XG5cdCAgICB9XG5cblx0ICAgIHNlbGYud3JhcHBlci5jbGFzc0xpc3QudG9nZ2xlKCdpbnB1dC1oaWRkZW4nLCBzZWxmLmlzSW5wdXRIaWRkZW4pO1xuXHQgIH1cblx0ICAvKipcblx0ICAgKiBIaWRlcyB0aGUgaW5wdXQgZWxlbWVudCBvdXQgb2Ygdmlldywgd2hpbGVcblx0ICAgKiByZXRhaW5pbmcgaXRzIGZvY3VzLlxuXHQgICAqIEBkZXByZWNhdGVkIDEuM1xuXHQgICAqL1xuXG5cblx0ICBoaWRlSW5wdXQoKSB7XG5cdCAgICB0aGlzLmlucHV0U3RhdGUoKTtcblx0ICB9XG5cdCAgLyoqXG5cdCAgICogUmVzdG9yZXMgaW5wdXQgdmlzaWJpbGl0eS5cblx0ICAgKiBAZGVwcmVjYXRlZCAxLjNcblx0ICAgKi9cblxuXG5cdCAgc2hvd0lucHV0KCkge1xuXHQgICAgdGhpcy5pbnB1dFN0YXRlKCk7XG5cdCAgfVxuXHQgIC8qKlxuXHQgICAqIEdldCB0aGUgaW5wdXQgdmFsdWVcblx0ICAgKi9cblxuXG5cdCAgaW5wdXRWYWx1ZSgpIHtcblx0ICAgIHJldHVybiB0aGlzLmNvbnRyb2xfaW5wdXQudmFsdWUudHJpbSgpO1xuXHQgIH1cblx0ICAvKipcblx0ICAgKiBHaXZlcyB0aGUgY29udHJvbCBmb2N1cy5cblx0ICAgKi9cblxuXG5cdCAgZm9jdXMoKSB7XG5cdCAgICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgICBpZiAoc2VsZi5pc0Rpc2FibGVkKSByZXR1cm47XG5cdCAgICBzZWxmLmlnbm9yZUZvY3VzID0gdHJ1ZTtcblxuXHQgICAgaWYgKHNlbGYuY29udHJvbF9pbnB1dC5vZmZzZXRXaWR0aCkge1xuXHQgICAgICBzZWxmLmNvbnRyb2xfaW5wdXQuZm9jdXMoKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHNlbGYuZm9jdXNfbm9kZS5mb2N1cygpO1xuXHQgICAgfVxuXG5cdCAgICBzZXRUaW1lb3V0KCgpID0+IHtcblx0ICAgICAgc2VsZi5pZ25vcmVGb2N1cyA9IGZhbHNlO1xuXHQgICAgICBzZWxmLm9uRm9jdXMoKTtcblx0ICAgIH0sIDApO1xuXHQgIH1cblx0ICAvKipcblx0ICAgKiBGb3JjZXMgdGhlIGNvbnRyb2wgb3V0IG9mIGZvY3VzLlxuXHQgICAqXG5cdCAgICovXG5cblxuXHQgIGJsdXIoKSB7XG5cdCAgICB0aGlzLmZvY3VzX25vZGUuYmx1cigpO1xuXHQgICAgdGhpcy5vbkJsdXIoKTtcblx0ICB9XG5cdCAgLyoqXG5cdCAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgc2NvcmVzIGFuIG9iamVjdFxuXHQgICAqIHRvIHNob3cgaG93IGdvb2Qgb2YgYSBtYXRjaCBpdCBpcyB0byB0aGVcblx0ICAgKiBwcm92aWRlZCBxdWVyeS5cblx0ICAgKlxuXHQgICAqIEByZXR1cm4ge2Z1bmN0aW9ufVxuXHQgICAqL1xuXG5cblx0ICBnZXRTY29yZUZ1bmN0aW9uKHF1ZXJ5KSB7XG5cdCAgICByZXR1cm4gdGhpcy5zaWZ0ZXIuZ2V0U2NvcmVGdW5jdGlvbihxdWVyeSwgdGhpcy5nZXRTZWFyY2hPcHRpb25zKCkpO1xuXHQgIH1cblx0ICAvKipcblx0ICAgKiBSZXR1cm5zIHNlYXJjaCBvcHRpb25zIGZvciBzaWZ0ZXIgKHRoZSBzeXN0ZW1cblx0ICAgKiBmb3Igc2NvcmluZyBhbmQgc29ydGluZyByZXN1bHRzKS5cblx0ICAgKlxuXHQgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL29yY2hpZGpzL3NpZnRlci5qc1xuXHQgICAqIEByZXR1cm4ge29iamVjdH1cblx0ICAgKi9cblxuXG5cdCAgZ2V0U2VhcmNoT3B0aW9ucygpIHtcblx0ICAgIHZhciBzZXR0aW5ncyA9IHRoaXMuc2V0dGluZ3M7XG5cdCAgICB2YXIgc29ydCA9IHNldHRpbmdzLnNvcnRGaWVsZDtcblxuXHQgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy5zb3J0RmllbGQgPT09ICdzdHJpbmcnKSB7XG5cdCAgICAgIHNvcnQgPSBbe1xuXHQgICAgICAgIGZpZWxkOiBzZXR0aW5ncy5zb3J0RmllbGRcblx0ICAgICAgfV07XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB7XG5cdCAgICAgIGZpZWxkczogc2V0dGluZ3Muc2VhcmNoRmllbGQsXG5cdCAgICAgIGNvbmp1bmN0aW9uOiBzZXR0aW5ncy5zZWFyY2hDb25qdW5jdGlvbixcblx0ICAgICAgc29ydDogc29ydCxcblx0ICAgICAgbmVzdGluZzogc2V0dGluZ3MubmVzdGluZ1xuXHQgICAgfTtcblx0ICB9XG5cdCAgLyoqXG5cdCAgICogU2VhcmNoZXMgdGhyb3VnaCBhdmFpbGFibGUgb3B0aW9ucyBhbmQgcmV0dXJuc1xuXHQgICAqIGEgc29ydGVkIGFycmF5IG9mIG1hdGNoZXMuXG5cdCAgICpcblx0ICAgKi9cblxuXG5cdCAgc2VhcmNoKHF1ZXJ5KSB7XG5cdCAgICB2YXIgcmVzdWx0LCBjYWxjdWxhdGVTY29yZTtcblx0ICAgIHZhciBzZWxmID0gdGhpcztcblx0ICAgIHZhciBvcHRpb25zID0gdGhpcy5nZXRTZWFyY2hPcHRpb25zKCk7IC8vIHZhbGlkYXRlIHVzZXItcHJvdmlkZWQgcmVzdWx0IHNjb3JpbmcgZnVuY3Rpb25cblxuXHQgICAgaWYgKHNlbGYuc2V0dGluZ3Muc2NvcmUpIHtcblx0ICAgICAgY2FsY3VsYXRlU2NvcmUgPSBzZWxmLnNldHRpbmdzLnNjb3JlLmNhbGwoc2VsZiwgcXVlcnkpO1xuXG5cdCAgICAgIGlmICh0eXBlb2YgY2FsY3VsYXRlU2NvcmUgIT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvbSBTZWxlY3QgXCJzY29yZVwiIHNldHRpbmcgbXVzdCBiZSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGZ1bmN0aW9uJyk7XG5cdCAgICAgIH1cblx0ICAgIH0gLy8gcGVyZm9ybSBzZWFyY2hcblxuXG5cdCAgICBpZiAocXVlcnkgIT09IHNlbGYubGFzdFF1ZXJ5KSB7XG5cdCAgICAgIHNlbGYubGFzdFF1ZXJ5ID0gcXVlcnk7XG5cdCAgICAgIHJlc3VsdCA9IHNlbGYuc2lmdGVyLnNlYXJjaChxdWVyeSwgT2JqZWN0LmFzc2lnbihvcHRpb25zLCB7XG5cdCAgICAgICAgc2NvcmU6IGNhbGN1bGF0ZVNjb3JlXG5cdCAgICAgIH0pKTtcblx0ICAgICAgc2VsZi5jdXJyZW50UmVzdWx0cyA9IHJlc3VsdDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJlc3VsdCA9IE9iamVjdC5hc3NpZ24oe30sIHNlbGYuY3VycmVudFJlc3VsdHMpO1xuXHQgICAgfSAvLyBmaWx0ZXIgb3V0IHNlbGVjdGVkIGl0ZW1zXG5cblxuXHQgICAgaWYgKHNlbGYuc2V0dGluZ3MuaGlkZVNlbGVjdGVkKSB7XG5cdCAgICAgIHJlc3VsdC5pdGVtcyA9IHJlc3VsdC5pdGVtcy5maWx0ZXIoaXRlbSA9PiB7XG5cdCAgICAgICAgbGV0IGhhc2hlZCA9IGhhc2hfa2V5KGl0ZW0uaWQpO1xuXHQgICAgICAgIHJldHVybiAhKGhhc2hlZCAmJiBzZWxmLml0ZW1zLmluZGV4T2YoaGFzaGVkKSAhPT0gLTEpO1xuXHQgICAgICB9KTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9XG5cdCAgLyoqXG5cdCAgICogUmVmcmVzaGVzIHRoZSBsaXN0IG9mIGF2YWlsYWJsZSBvcHRpb25zIHNob3duXG5cdCAgICogaW4gdGhlIGF1dG9jb21wbGV0ZSBkcm9wZG93biBtZW51LlxuXHQgICAqXG5cdCAgICovXG5cblxuXHQgIHJlZnJlc2hPcHRpb25zKHRyaWdnZXJEcm9wZG93biA9IHRydWUpIHtcblx0ICAgIHZhciBpLCBqLCBrLCBuLCBvcHRncm91cCwgb3B0Z3JvdXBzLCBodG1sLCBoYXNfY3JlYXRlX29wdGlvbiwgYWN0aXZlX2dyb3VwO1xuXHQgICAgdmFyIGNyZWF0ZTtcblx0ICAgIGNvbnN0IGdyb3VwcyA9IHt9O1xuXHQgICAgY29uc3QgZ3JvdXBzX29yZGVyID0gW107XG5cdCAgICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgICB2YXIgcXVlcnkgPSBzZWxmLmlucHV0VmFsdWUoKTtcblx0ICAgIGNvbnN0IHNhbWVfcXVlcnkgPSBxdWVyeSA9PT0gc2VsZi5sYXN0UXVlcnkgfHwgcXVlcnkgPT0gJycgJiYgc2VsZi5sYXN0UXVlcnkgPT0gbnVsbDtcblx0ICAgIHZhciByZXN1bHRzID0gc2VsZi5zZWFyY2gocXVlcnkpO1xuXHQgICAgdmFyIGFjdGl2ZV9vcHRpb24gPSBudWxsO1xuXHQgICAgdmFyIHNob3dfZHJvcGRvd24gPSBzZWxmLnNldHRpbmdzLnNob3VsZE9wZW4gfHwgZmFsc2U7XG5cdCAgICB2YXIgZHJvcGRvd25fY29udGVudCA9IHNlbGYuZHJvcGRvd25fY29udGVudDtcblxuXHQgICAgaWYgKHNhbWVfcXVlcnkpIHtcblx0ICAgICAgYWN0aXZlX29wdGlvbiA9IHNlbGYuYWN0aXZlT3B0aW9uO1xuXG5cdCAgICAgIGlmIChhY3RpdmVfb3B0aW9uKSB7XG5cdCAgICAgICAgYWN0aXZlX2dyb3VwID0gYWN0aXZlX29wdGlvbi5jbG9zZXN0KCdbZGF0YS1ncm91cF0nKTtcblx0ICAgICAgfVxuXHQgICAgfSAvLyBidWlsZCBtYXJrdXBcblxuXG5cdCAgICBuID0gcmVzdWx0cy5pdGVtcy5sZW5ndGg7XG5cblx0ICAgIGlmICh0eXBlb2Ygc2VsZi5zZXR0aW5ncy5tYXhPcHRpb25zID09PSAnbnVtYmVyJykge1xuXHQgICAgICBuID0gTWF0aC5taW4obiwgc2VsZi5zZXR0aW5ncy5tYXhPcHRpb25zKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKG4gPiAwKSB7XG5cdCAgICAgIHNob3dfZHJvcGRvd24gPSB0cnVlO1xuXHQgICAgfSAvLyByZW5kZXIgYW5kIGdyb3VwIGF2YWlsYWJsZSBvcHRpb25zIGluZGl2aWR1YWxseVxuXG5cblx0ICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0ICAgICAgLy8gZ2V0IG9wdGlvbiBkb20gZWxlbWVudFxuXHQgICAgICBsZXQgaXRlbSA9IHJlc3VsdHMuaXRlbXNbaV07XG5cdCAgICAgIGlmICghaXRlbSkgY29udGludWU7XG5cdCAgICAgIGxldCBvcHRfdmFsdWUgPSBpdGVtLmlkO1xuXHQgICAgICBsZXQgb3B0aW9uID0gc2VsZi5vcHRpb25zW29wdF92YWx1ZV07XG5cdCAgICAgIGlmIChvcHRpb24gPT09IHVuZGVmaW5lZCkgY29udGludWU7XG5cdCAgICAgIGxldCBvcHRfaGFzaCA9IGdldF9oYXNoKG9wdF92YWx1ZSk7XG5cdCAgICAgIGxldCBvcHRpb25fZWwgPSBzZWxmLmdldE9wdGlvbihvcHRfaGFzaCwgdHJ1ZSk7IC8vIHRvZ2dsZSAnc2VsZWN0ZWQnIGNsYXNzXG5cblx0ICAgICAgaWYgKCFzZWxmLnNldHRpbmdzLmhpZGVTZWxlY3RlZCkge1xuXHQgICAgICAgIG9wdGlvbl9lbC5jbGFzc0xpc3QudG9nZ2xlKCdzZWxlY3RlZCcsIHNlbGYuaXRlbXMuaW5jbHVkZXMob3B0X2hhc2gpKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIG9wdGdyb3VwID0gb3B0aW9uW3NlbGYuc2V0dGluZ3Mub3B0Z3JvdXBGaWVsZF0gfHwgJyc7XG5cdCAgICAgIG9wdGdyb3VwcyA9IEFycmF5LmlzQXJyYXkob3B0Z3JvdXApID8gb3B0Z3JvdXAgOiBbb3B0Z3JvdXBdO1xuXG5cdCAgICAgIGZvciAoaiA9IDAsIGsgPSBvcHRncm91cHMgJiYgb3B0Z3JvdXBzLmxlbmd0aDsgaiA8IGs7IGorKykge1xuXHQgICAgICAgIG9wdGdyb3VwID0gb3B0Z3JvdXBzW2pdO1xuXG5cdCAgICAgICAgaWYgKCFzZWxmLm9wdGdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShvcHRncm91cCkpIHtcblx0ICAgICAgICAgIG9wdGdyb3VwID0gJyc7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgbGV0IGdyb3VwX2ZyYWdtZW50ID0gZ3JvdXBzW29wdGdyb3VwXTtcblxuXHQgICAgICAgIGlmIChncm91cF9mcmFnbWVudCA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICBncm91cF9mcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0ICAgICAgICAgIGdyb3Vwc19vcmRlci5wdXNoKG9wdGdyb3VwKTtcblx0ICAgICAgICB9IC8vIG5vZGVzIGNhbiBvbmx5IGhhdmUgb25lIHBhcmVudCwgc28gaWYgdGhlIG9wdGlvbiBpcyBpbiBtdXRwbGUgZ3JvdXBzLCB3ZSBuZWVkIGEgY2xvbmVcblxuXG5cdCAgICAgICAgaWYgKGogPiAwKSB7XG5cdCAgICAgICAgICBvcHRpb25fZWwgPSBvcHRpb25fZWwuY2xvbmVOb2RlKHRydWUpO1xuXHQgICAgICAgICAgc2V0QXR0cihvcHRpb25fZWwsIHtcblx0ICAgICAgICAgICAgaWQ6IG9wdGlvbi4kaWQgKyAnLWNsb25lLScgKyBqLFxuXHQgICAgICAgICAgICAnYXJpYS1zZWxlY3RlZCc6IG51bGxcblx0ICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgb3B0aW9uX2VsLmNsYXNzTGlzdC5hZGQoJ3RzLWNsb25lZCcpO1xuXHQgICAgICAgICAgcmVtb3ZlQ2xhc3NlcyhvcHRpb25fZWwsICdhY3RpdmUnKTsgLy8gbWFrZSBzdXJlIHdlIGtlZXAgdGhlIGFjdGl2ZU9wdGlvbiBpbiB0aGUgc2FtZSBncm91cFxuXG5cdCAgICAgICAgICBpZiAoc2VsZi5hY3RpdmVPcHRpb24gJiYgc2VsZi5hY3RpdmVPcHRpb24uZGF0YXNldC52YWx1ZSA9PSBvcHRfdmFsdWUpIHtcblx0ICAgICAgICAgICAgaWYgKGFjdGl2ZV9ncm91cCAmJiBhY3RpdmVfZ3JvdXAuZGF0YXNldC5ncm91cCA9PT0gb3B0Z3JvdXAudG9TdHJpbmcoKSkge1xuXHQgICAgICAgICAgICAgIGFjdGl2ZV9vcHRpb24gPSBvcHRpb25fZWw7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICBncm91cF9mcmFnbWVudC5hcHBlbmRDaGlsZChvcHRpb25fZWwpO1xuXHQgICAgICAgIGdyb3Vwc1tvcHRncm91cF0gPSBncm91cF9mcmFnbWVudDtcblx0ICAgICAgfVxuXHQgICAgfSAvLyBzb3J0IG9wdGdyb3Vwc1xuXG5cblx0ICAgIGlmIChzZWxmLnNldHRpbmdzLmxvY2tPcHRncm91cE9yZGVyKSB7XG5cdCAgICAgIGdyb3Vwc19vcmRlci5zb3J0KChhLCBiKSA9PiB7XG5cdCAgICAgICAgY29uc3QgZ3JwX2EgPSBzZWxmLm9wdGdyb3Vwc1thXTtcblx0ICAgICAgICBjb25zdCBncnBfYiA9IHNlbGYub3B0Z3JvdXBzW2JdO1xuXHQgICAgICAgIGNvbnN0IGFfb3JkZXIgPSBncnBfYSAmJiBncnBfYS4kb3JkZXIgfHwgMDtcblx0ICAgICAgICBjb25zdCBiX29yZGVyID0gZ3JwX2IgJiYgZ3JwX2IuJG9yZGVyIHx8IDA7XG5cdCAgICAgICAgcmV0dXJuIGFfb3JkZXIgLSBiX29yZGVyO1xuXHQgICAgICB9KTtcblx0ICAgIH0gLy8gcmVuZGVyIG9wdGdyb3VwIGhlYWRlcnMgJiBqb2luIGdyb3Vwc1xuXG5cblx0ICAgIGh0bWwgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cdCAgICBpdGVyYXRlJDEoZ3JvdXBzX29yZGVyLCBvcHRncm91cCA9PiB7XG5cdCAgICAgIGxldCBncm91cF9mcmFnbWVudCA9IGdyb3Vwc1tvcHRncm91cF07XG5cdCAgICAgIGlmICghZ3JvdXBfZnJhZ21lbnQgfHwgIWdyb3VwX2ZyYWdtZW50LmNoaWxkcmVuLmxlbmd0aCkgcmV0dXJuO1xuXHQgICAgICBsZXQgZ3JvdXBfaGVhZGluZyA9IHNlbGYub3B0Z3JvdXBzW29wdGdyb3VwXTtcblxuXHQgICAgICBpZiAoZ3JvdXBfaGVhZGluZyAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgbGV0IGdyb3VwX29wdGlvbnMgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cdCAgICAgICAgbGV0IGhlYWRlciA9IHNlbGYucmVuZGVyKCdvcHRncm91cF9oZWFkZXInLCBncm91cF9oZWFkaW5nKTtcblx0ICAgICAgICBhcHBlbmQoZ3JvdXBfb3B0aW9ucywgaGVhZGVyKTtcblx0ICAgICAgICBhcHBlbmQoZ3JvdXBfb3B0aW9ucywgZ3JvdXBfZnJhZ21lbnQpO1xuXHQgICAgICAgIGxldCBncm91cF9odG1sID0gc2VsZi5yZW5kZXIoJ29wdGdyb3VwJywge1xuXHQgICAgICAgICAgZ3JvdXA6IGdyb3VwX2hlYWRpbmcsXG5cdCAgICAgICAgICBvcHRpb25zOiBncm91cF9vcHRpb25zXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgYXBwZW5kKGh0bWwsIGdyb3VwX2h0bWwpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGFwcGVuZChodG1sLCBncm91cF9mcmFnbWVudCk7XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgZHJvcGRvd25fY29udGVudC5pbm5lckhUTUwgPSAnJztcblx0ICAgIGFwcGVuZChkcm9wZG93bl9jb250ZW50LCBodG1sKTsgLy8gaGlnaGxpZ2h0IG1hdGNoaW5nIHRlcm1zIGlubGluZVxuXG5cdCAgICBpZiAoc2VsZi5zZXR0aW5ncy5oaWdobGlnaHQpIHtcblx0ICAgICAgcmVtb3ZlSGlnaGxpZ2h0KGRyb3Bkb3duX2NvbnRlbnQpO1xuXG5cdCAgICAgIGlmIChyZXN1bHRzLnF1ZXJ5Lmxlbmd0aCAmJiByZXN1bHRzLnRva2Vucy5sZW5ndGgpIHtcblx0ICAgICAgICBpdGVyYXRlJDEocmVzdWx0cy50b2tlbnMsIHRvayA9PiB7XG5cdCAgICAgICAgICBoaWdobGlnaHQoZHJvcGRvd25fY29udGVudCwgdG9rLnJlZ2V4KTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgfVxuXHQgICAgfSAvLyBoZWxwZXIgbWV0aG9kIGZvciBhZGRpbmcgdGVtcGxhdGVzIHRvIGRyb3Bkb3duXG5cblxuXHQgICAgdmFyIGFkZF90ZW1wbGF0ZSA9IHRlbXBsYXRlID0+IHtcblx0ICAgICAgbGV0IGNvbnRlbnQgPSBzZWxmLnJlbmRlcih0ZW1wbGF0ZSwge1xuXHQgICAgICAgIGlucHV0OiBxdWVyeVxuXHQgICAgICB9KTtcblxuXHQgICAgICBpZiAoY29udGVudCkge1xuXHQgICAgICAgIHNob3dfZHJvcGRvd24gPSB0cnVlO1xuXHQgICAgICAgIGRyb3Bkb3duX2NvbnRlbnQuaW5zZXJ0QmVmb3JlKGNvbnRlbnQsIGRyb3Bkb3duX2NvbnRlbnQuZmlyc3RDaGlsZCk7XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm4gY29udGVudDtcblx0ICAgIH07IC8vIGFkZCBsb2FkaW5nIG1lc3NhZ2VcblxuXG5cdCAgICBpZiAoc2VsZi5sb2FkaW5nKSB7XG5cdCAgICAgIGFkZF90ZW1wbGF0ZSgnbG9hZGluZycpOyAvLyBpbnZhbGlkIHF1ZXJ5XG5cdCAgICB9IGVsc2UgaWYgKCFzZWxmLnNldHRpbmdzLnNob3VsZExvYWQuY2FsbChzZWxmLCBxdWVyeSkpIHtcblx0ICAgICAgYWRkX3RlbXBsYXRlKCdub3RfbG9hZGluZycpOyAvLyBhZGQgbm9fcmVzdWx0cyBtZXNzYWdlXG5cdCAgICB9IGVsc2UgaWYgKHJlc3VsdHMuaXRlbXMubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgIGFkZF90ZW1wbGF0ZSgnbm9fcmVzdWx0cycpO1xuXHQgICAgfSAvLyBhZGQgY3JlYXRlIG9wdGlvblxuXG5cblx0ICAgIGhhc19jcmVhdGVfb3B0aW9uID0gc2VsZi5jYW5DcmVhdGUocXVlcnkpO1xuXG5cdCAgICBpZiAoaGFzX2NyZWF0ZV9vcHRpb24pIHtcblx0ICAgICAgY3JlYXRlID0gYWRkX3RlbXBsYXRlKCdvcHRpb25fY3JlYXRlJyk7XG5cdCAgICB9IC8vIGFjdGl2YXRlXG5cblxuXHQgICAgc2VsZi5oYXNPcHRpb25zID0gcmVzdWx0cy5pdGVtcy5sZW5ndGggPiAwIHx8IGhhc19jcmVhdGVfb3B0aW9uO1xuXG5cdCAgICBpZiAoc2hvd19kcm9wZG93bikge1xuXHQgICAgICBpZiAocmVzdWx0cy5pdGVtcy5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgaWYgKCFhY3RpdmVfb3B0aW9uICYmIHNlbGYuc2V0dGluZ3MubW9kZSA9PT0gJ3NpbmdsZScgJiYgc2VsZi5pdGVtc1swXSAhPSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgIGFjdGl2ZV9vcHRpb24gPSBzZWxmLmdldE9wdGlvbihzZWxmLml0ZW1zWzBdKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoIWRyb3Bkb3duX2NvbnRlbnQuY29udGFpbnMoYWN0aXZlX29wdGlvbikpIHtcblx0ICAgICAgICAgIGxldCBhY3RpdmVfaW5kZXggPSAwO1xuXG5cdCAgICAgICAgICBpZiAoY3JlYXRlICYmICFzZWxmLnNldHRpbmdzLmFkZFByZWNlZGVuY2UpIHtcblx0ICAgICAgICAgICAgYWN0aXZlX2luZGV4ID0gMTtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgYWN0aXZlX29wdGlvbiA9IHNlbGYuc2VsZWN0YWJsZSgpW2FjdGl2ZV9pbmRleF07XG5cdCAgICAgICAgfVxuXHQgICAgICB9IGVsc2UgaWYgKGNyZWF0ZSkge1xuXHQgICAgICAgIGFjdGl2ZV9vcHRpb24gPSBjcmVhdGU7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAodHJpZ2dlckRyb3Bkb3duICYmICFzZWxmLmlzT3Blbikge1xuXHQgICAgICAgIHNlbGYub3BlbigpO1xuXHQgICAgICAgIHNlbGYuc2Nyb2xsVG9PcHRpb24oYWN0aXZlX29wdGlvbiwgJ2F1dG8nKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHNlbGYuc2V0QWN0aXZlT3B0aW9uKGFjdGl2ZV9vcHRpb24pO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgc2VsZi5jbGVhckFjdGl2ZU9wdGlvbigpO1xuXG5cdCAgICAgIGlmICh0cmlnZ2VyRHJvcGRvd24gJiYgc2VsZi5pc09wZW4pIHtcblx0ICAgICAgICBzZWxmLmNsb3NlKGZhbHNlKTsgLy8gaWYgY3JlYXRlX29wdGlvbj1udWxsLCB3ZSB3YW50IHRoZSBkcm9wZG93biB0byBjbG9zZSBidXQgbm90IHJlc2V0IHRoZSB0ZXh0Ym94IHZhbHVlXG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdCAgLyoqXG5cdCAgICogUmV0dXJuIGxpc3Qgb2Ygc2VsZWN0YWJsZSBvcHRpb25zXG5cdCAgICpcblx0ICAgKi9cblxuXG5cdCAgc2VsZWN0YWJsZSgpIHtcblx0ICAgIHJldHVybiB0aGlzLmRyb3Bkb3duX2NvbnRlbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtc2VsZWN0YWJsZV0nKTtcblx0ICB9XG5cdCAgLyoqXG5cdCAgICogQWRkcyBhbiBhdmFpbGFibGUgb3B0aW9uLiBJZiBpdCBhbHJlYWR5IGV4aXN0cyxcblx0ICAgKiBub3RoaW5nIHdpbGwgaGFwcGVuLiBOb3RlOiB0aGlzIGRvZXMgbm90IHJlZnJlc2hcblx0ICAgKiB0aGUgb3B0aW9ucyBsaXN0IGRyb3Bkb3duICh1c2UgYHJlZnJlc2hPcHRpb25zYFxuXHQgICAqIGZvciB0aGF0KS5cblx0ICAgKlxuXHQgICAqIFVzYWdlOlxuXHQgICAqXG5cdCAgICogICB0aGlzLmFkZE9wdGlvbihkYXRhKVxuXHQgICAqXG5cdCAgICovXG5cblxuXHQgIGFkZE9wdGlvbihkYXRhLCB1c2VyX2NyZWF0ZWQgPSBmYWxzZSkge1xuXHQgICAgY29uc3Qgc2VsZiA9IHRoaXM7IC8vIEBkZXByZWNhdGVkIDEuNy43XG5cdCAgICAvLyB1c2UgYWRkT3B0aW9ucyggYXJyYXksIHVzZXJfY3JlYXRlZCApIGZvciBhZGRpbmcgbXVsdGlwbGUgb3B0aW9uc1xuXG5cdCAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuXHQgICAgICBzZWxmLmFkZE9wdGlvbnMoZGF0YSwgdXNlcl9jcmVhdGVkKTtcblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXG5cdCAgICBjb25zdCBrZXkgPSBoYXNoX2tleShkYXRhW3NlbGYuc2V0dGluZ3MudmFsdWVGaWVsZF0pO1xuXG5cdCAgICBpZiAoa2V5ID09PSBudWxsIHx8IHNlbGYub3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdCAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH1cblxuXHQgICAgZGF0YS4kb3JkZXIgPSBkYXRhLiRvcmRlciB8fCArK3NlbGYub3JkZXI7XG5cdCAgICBkYXRhLiRpZCA9IHNlbGYuaW5wdXRJZCArICctb3B0LScgKyBkYXRhLiRvcmRlcjtcblx0ICAgIHNlbGYub3B0aW9uc1trZXldID0gZGF0YTtcblx0ICAgIHNlbGYubGFzdFF1ZXJ5ID0gbnVsbDtcblxuXHQgICAgaWYgKHVzZXJfY3JlYXRlZCkge1xuXHQgICAgICBzZWxmLnVzZXJPcHRpb25zW2tleV0gPSB1c2VyX2NyZWF0ZWQ7XG5cdCAgICAgIHNlbGYudHJpZ2dlcignb3B0aW9uX2FkZCcsIGtleSwgZGF0YSk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBrZXk7XG5cdCAgfVxuXHQgIC8qKlxuXHQgICAqIEFkZCBtdWx0aXBsZSBvcHRpb25zXG5cdCAgICpcblx0ICAgKi9cblxuXG5cdCAgYWRkT3B0aW9ucyhkYXRhLCB1c2VyX2NyZWF0ZWQgPSBmYWxzZSkge1xuXHQgICAgaXRlcmF0ZSQxKGRhdGEsIGRhdCA9PiB7XG5cdCAgICAgIHRoaXMuYWRkT3B0aW9uKGRhdCwgdXNlcl9jcmVhdGVkKTtcblx0ICAgIH0pO1xuXHQgIH1cblx0ICAvKipcblx0ICAgKiBAZGVwcmVjYXRlZCAxLjcuN1xuXHQgICAqL1xuXG5cblx0ICByZWdpc3Rlck9wdGlvbihkYXRhKSB7XG5cdCAgICByZXR1cm4gdGhpcy5hZGRPcHRpb24oZGF0YSk7XG5cdCAgfVxuXHQgIC8qKlxuXHQgICAqIFJlZ2lzdGVycyBhbiBvcHRpb24gZ3JvdXAgdG8gdGhlIHBvb2wgb2Ygb3B0aW9uIGdyb3Vwcy5cblx0ICAgKlxuXHQgICAqIEByZXR1cm4ge2Jvb2xlYW58c3RyaW5nfVxuXHQgICAqL1xuXG5cblx0ICByZWdpc3Rlck9wdGlvbkdyb3VwKGRhdGEpIHtcblx0ICAgIHZhciBrZXkgPSBoYXNoX2tleShkYXRhW3RoaXMuc2V0dGluZ3Mub3B0Z3JvdXBWYWx1ZUZpZWxkXSk7XG5cdCAgICBpZiAoa2V5ID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cdCAgICBkYXRhLiRvcmRlciA9IGRhdGEuJG9yZGVyIHx8ICsrdGhpcy5vcmRlcjtcblx0ICAgIHRoaXMub3B0Z3JvdXBzW2tleV0gPSBkYXRhO1xuXHQgICAgcmV0dXJuIGtleTtcblx0ICB9XG5cdCAgLyoqXG5cdCAgICogUmVnaXN0ZXJzIGEgbmV3IG9wdGdyb3VwIGZvciBvcHRpb25zXG5cdCAgICogdG8gYmUgYnVja2V0ZWQgaW50by5cblx0ICAgKlxuXHQgICAqL1xuXG5cblx0ICBhZGRPcHRpb25Hcm91cChpZCwgZGF0YSkge1xuXHQgICAgdmFyIGhhc2hlZF9pZDtcblx0ICAgIGRhdGFbdGhpcy5zZXR0aW5ncy5vcHRncm91cFZhbHVlRmllbGRdID0gaWQ7XG5cblx0ICAgIGlmIChoYXNoZWRfaWQgPSB0aGlzLnJlZ2lzdGVyT3B0aW9uR3JvdXAoZGF0YSkpIHtcblx0ICAgICAgdGhpcy50cmlnZ2VyKCdvcHRncm91cF9hZGQnLCBoYXNoZWRfaWQsIGRhdGEpO1xuXHQgICAgfVxuXHQgIH1cblx0ICAvKipcblx0ICAgKiBSZW1vdmVzIGFuIGV4aXN0aW5nIG9wdGlvbiBncm91cC5cblx0ICAgKlxuXHQgICAqL1xuXG5cblx0ICByZW1vdmVPcHRpb25Hcm91cChpZCkge1xuXHQgICAgaWYgKHRoaXMub3B0Z3JvdXBzLmhhc093blByb3BlcnR5KGlkKSkge1xuXHQgICAgICBkZWxldGUgdGhpcy5vcHRncm91cHNbaWRdO1xuXHQgICAgICB0aGlzLmNsZWFyQ2FjaGUoKTtcblx0ICAgICAgdGhpcy50cmlnZ2VyKCdvcHRncm91cF9yZW1vdmUnLCBpZCk7XG5cdCAgICB9XG5cdCAgfVxuXHQgIC8qKlxuXHQgICAqIENsZWFycyBhbGwgZXhpc3Rpbmcgb3B0aW9uIGdyb3Vwcy5cblx0ICAgKi9cblxuXG5cdCAgY2xlYXJPcHRpb25Hcm91cHMoKSB7XG5cdCAgICB0aGlzLm9wdGdyb3VwcyA9IHt9O1xuXHQgICAgdGhpcy5jbGVhckNhY2hlKCk7XG5cdCAgICB0aGlzLnRyaWdnZXIoJ29wdGdyb3VwX2NsZWFyJyk7XG5cdCAgfVxuXHQgIC8qKlxuXHQgICAqIFVwZGF0ZXMgYW4gb3B0aW9uIGF2YWlsYWJsZSBmb3Igc2VsZWN0aW9uLiBJZlxuXHQgICAqIGl0IGlzIHZpc2libGUgaW4gdGhlIHNlbGVjdGVkIGl0ZW1zIG9yIG9wdGlvbnNcblx0ICAgKiBkcm9wZG93biwgaXQgd2lsbCBiZSByZS1yZW5kZXJlZCBhdXRvbWF0aWNhbGx5LlxuXHQgICAqXG5cdCAgICovXG5cblxuXHQgIHVwZGF0ZU9wdGlvbih2YWx1ZSwgZGF0YSkge1xuXHQgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cdCAgICB2YXIgaXRlbV9uZXc7XG5cdCAgICB2YXIgaW5kZXhfaXRlbTtcblx0ICAgIGNvbnN0IHZhbHVlX29sZCA9IGhhc2hfa2V5KHZhbHVlKTtcblx0ICAgIGNvbnN0IHZhbHVlX25ldyA9IGhhc2hfa2V5KGRhdGFbc2VsZi5zZXR0aW5ncy52YWx1ZUZpZWxkXSk7IC8vIHNhbml0eSBjaGVja3NcblxuXHQgICAgaWYgKHZhbHVlX29sZCA9PT0gbnVsbCkgcmV0dXJuO1xuXHQgICAgY29uc3QgZGF0YV9vbGQgPSBzZWxmLm9wdGlvbnNbdmFsdWVfb2xkXTtcblx0ICAgIGlmIChkYXRhX29sZCA9PSB1bmRlZmluZWQpIHJldHVybjtcblx0ICAgIGlmICh0eXBlb2YgdmFsdWVfbmV3ICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IEVycm9yKCdWYWx1ZSBtdXN0IGJlIHNldCBpbiBvcHRpb24gZGF0YScpO1xuXHQgICAgY29uc3Qgb3B0aW9uID0gc2VsZi5nZXRPcHRpb24odmFsdWVfb2xkKTtcblx0ICAgIGNvbnN0IGl0ZW0gPSBzZWxmLmdldEl0ZW0odmFsdWVfb2xkKTtcblx0ICAgIGRhdGEuJG9yZGVyID0gZGF0YS4kb3JkZXIgfHwgZGF0YV9vbGQuJG9yZGVyO1xuXHQgICAgZGVsZXRlIHNlbGYub3B0aW9uc1t2YWx1ZV9vbGRdOyAvLyBpbnZhbGlkYXRlIHJlbmRlciBjYWNoZVxuXHQgICAgLy8gZG9uJ3QgcmVtb3ZlIGV4aXN0aW5nIG5vZGUgeWV0LCB3ZSdsbCByZW1vdmUgaXQgYWZ0ZXIgcmVwbGFjaW5nIGl0XG5cblx0ICAgIHNlbGYudW5jYWNoZVZhbHVlKHZhbHVlX25ldyk7XG5cdCAgICBzZWxmLm9wdGlvbnNbdmFsdWVfbmV3XSA9IGRhdGE7IC8vIHVwZGF0ZSB0aGUgb3B0aW9uIGlmIGl0J3MgaW4gdGhlIGRyb3Bkb3duXG5cblx0ICAgIGlmIChvcHRpb24pIHtcblx0ICAgICAgaWYgKHNlbGYuZHJvcGRvd25fY29udGVudC5jb250YWlucyhvcHRpb24pKSB7XG5cdCAgICAgICAgY29uc3Qgb3B0aW9uX25ldyA9IHNlbGYuX3JlbmRlcignb3B0aW9uJywgZGF0YSk7XG5cblx0ICAgICAgICByZXBsYWNlTm9kZShvcHRpb24sIG9wdGlvbl9uZXcpO1xuXG5cdCAgICAgICAgaWYgKHNlbGYuYWN0aXZlT3B0aW9uID09PSBvcHRpb24pIHtcblx0ICAgICAgICAgIHNlbGYuc2V0QWN0aXZlT3B0aW9uKG9wdGlvbl9uZXcpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIG9wdGlvbi5yZW1vdmUoKTtcblx0ICAgIH0gLy8gdXBkYXRlIHRoZSBpdGVtIGlmIHdlIGhhdmUgb25lXG5cblxuXHQgICAgaWYgKGl0ZW0pIHtcblx0ICAgICAgaW5kZXhfaXRlbSA9IHNlbGYuaXRlbXMuaW5kZXhPZih2YWx1ZV9vbGQpO1xuXG5cdCAgICAgIGlmIChpbmRleF9pdGVtICE9PSAtMSkge1xuXHQgICAgICAgIHNlbGYuaXRlbXMuc3BsaWNlKGluZGV4X2l0ZW0sIDEsIHZhbHVlX25ldyk7XG5cdCAgICAgIH1cblxuXHQgICAgICBpdGVtX25ldyA9IHNlbGYuX3JlbmRlcignaXRlbScsIGRhdGEpO1xuXHQgICAgICBpZiAoaXRlbS5jbGFzc0xpc3QuY29udGFpbnMoJ2FjdGl2ZScpKSBhZGRDbGFzc2VzKGl0ZW1fbmV3LCAnYWN0aXZlJyk7XG5cdCAgICAgIHJlcGxhY2VOb2RlKGl0ZW0sIGl0ZW1fbmV3KTtcblx0ICAgIH0gLy8gaW52YWxpZGF0ZSBsYXN0IHF1ZXJ5IGJlY2F1c2Ugd2UgbWlnaHQgaGF2ZSB1cGRhdGVkIHRoZSBzb3J0RmllbGRcblxuXG5cdCAgICBzZWxmLmxhc3RRdWVyeSA9IG51bGw7XG5cdCAgfVxuXHQgIC8qKlxuXHQgICAqIFJlbW92ZXMgYSBzaW5nbGUgb3B0aW9uLlxuXHQgICAqXG5cdCAgICovXG5cblxuXHQgIHJlbW92ZU9wdGlvbih2YWx1ZSwgc2lsZW50KSB7XG5cdCAgICBjb25zdCBzZWxmID0gdGhpcztcblx0ICAgIHZhbHVlID0gZ2V0X2hhc2godmFsdWUpO1xuXHQgICAgc2VsZi51bmNhY2hlVmFsdWUodmFsdWUpO1xuXHQgICAgZGVsZXRlIHNlbGYudXNlck9wdGlvbnNbdmFsdWVdO1xuXHQgICAgZGVsZXRlIHNlbGYub3B0aW9uc1t2YWx1ZV07XG5cdCAgICBzZWxmLmxhc3RRdWVyeSA9IG51bGw7XG5cdCAgICBzZWxmLnRyaWdnZXIoJ29wdGlvbl9yZW1vdmUnLCB2YWx1ZSk7XG5cdCAgICBzZWxmLnJlbW92ZUl0ZW0odmFsdWUsIHNpbGVudCk7XG5cdCAgfVxuXHQgIC8qKlxuXHQgICAqIENsZWFycyBhbGwgb3B0aW9ucy5cblx0ICAgKi9cblxuXG5cdCAgY2xlYXJPcHRpb25zKGZpbHRlcikge1xuXHQgICAgY29uc3QgYm91bmRGaWx0ZXIgPSAoZmlsdGVyIHx8IHRoaXMuY2xlYXJGaWx0ZXIpLmJpbmQodGhpcyk7XG5cdCAgICB0aGlzLmxvYWRlZFNlYXJjaGVzID0ge307XG5cdCAgICB0aGlzLnVzZXJPcHRpb25zID0ge307XG5cdCAgICB0aGlzLmNsZWFyQ2FjaGUoKTtcblx0ICAgIGNvbnN0IHNlbGVjdGVkID0ge307XG5cdCAgICBpdGVyYXRlJDEodGhpcy5vcHRpb25zLCAob3B0aW9uLCBrZXkpID0+IHtcblx0ICAgICAgaWYgKGJvdW5kRmlsdGVyKG9wdGlvbiwga2V5KSkge1xuXHQgICAgICAgIHNlbGVjdGVkW2tleV0gPSBvcHRpb247XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgdGhpcy5vcHRpb25zID0gdGhpcy5zaWZ0ZXIuaXRlbXMgPSBzZWxlY3RlZDtcblx0ICAgIHRoaXMubGFzdFF1ZXJ5ID0gbnVsbDtcblx0ICAgIHRoaXMudHJpZ2dlcignb3B0aW9uX2NsZWFyJyk7XG5cdCAgfVxuXHQgIC8qKlxuXHQgICAqIFVzZWQgYnkgY2xlYXJPcHRpb25zKCkgdG8gZGVjaWRlIHdoZXRoZXIgb3Igbm90IGFuIG9wdGlvbiBzaG91bGQgYmUgcmVtb3ZlZFxuXHQgICAqIFJldHVybiB0cnVlIHRvIGtlZXAgYW4gb3B0aW9uLCBmYWxzZSB0byByZW1vdmVcblx0ICAgKlxuXHQgICAqL1xuXG5cblx0ICBjbGVhckZpbHRlcihvcHRpb24sIHZhbHVlKSB7XG5cdCAgICBpZiAodGhpcy5pdGVtcy5pbmRleE9mKHZhbHVlKSA+PSAwKSB7XG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXHQgIC8qKlxuXHQgICAqIFJldHVybnMgdGhlIGRvbSBlbGVtZW50IG9mIHRoZSBvcHRpb25cblx0ICAgKiBtYXRjaGluZyB0aGUgZ2l2ZW4gdmFsdWUuXG5cdCAgICpcblx0ICAgKi9cblxuXG5cdCAgZ2V0T3B0aW9uKHZhbHVlLCBjcmVhdGUgPSBmYWxzZSkge1xuXHQgICAgY29uc3QgaGFzaGVkID0gaGFzaF9rZXkodmFsdWUpO1xuXHQgICAgaWYgKGhhc2hlZCA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG5cdCAgICBjb25zdCBvcHRpb24gPSB0aGlzLm9wdGlvbnNbaGFzaGVkXTtcblxuXHQgICAgaWYgKG9wdGlvbiAhPSB1bmRlZmluZWQpIHtcblx0ICAgICAgaWYgKG9wdGlvbi4kZGl2KSB7XG5cdCAgICAgICAgcmV0dXJuIG9wdGlvbi4kZGl2O1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKGNyZWF0ZSkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXIoJ29wdGlvbicsIG9wdGlvbik7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIG51bGw7XG5cdCAgfVxuXHQgIC8qKlxuXHQgICAqIFJldHVybnMgdGhlIGRvbSBlbGVtZW50IG9mIHRoZSBuZXh0IG9yIHByZXZpb3VzIGRvbSBlbGVtZW50IG9mIHRoZSBzYW1lIHR5cGVcblx0ICAgKiBOb3RlOiBhZGphY2VudCBvcHRpb25zIG1heSBub3QgYmUgYWRqYWNlbnQgRE9NIGVsZW1lbnRzIChvcHRncm91cHMpXG5cdCAgICpcblx0ICAgKi9cblxuXG5cdCAgZ2V0QWRqYWNlbnQob3B0aW9uLCBkaXJlY3Rpb24sIHR5cGUgPSAnb3B0aW9uJykge1xuXHQgICAgdmFyIHNlbGYgPSB0aGlzLFxuXHQgICAgICAgIGFsbDtcblxuXHQgICAgaWYgKCFvcHRpb24pIHtcblx0ICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICB9XG5cblx0ICAgIGlmICh0eXBlID09ICdpdGVtJykge1xuXHQgICAgICBhbGwgPSBzZWxmLmNvbnRyb2xDaGlsZHJlbigpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgYWxsID0gc2VsZi5kcm9wZG93bl9jb250ZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXNlbGVjdGFibGVdJyk7XG5cdCAgICB9XG5cblx0ICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIGlmIChhbGxbaV0gIT0gb3B0aW9uKSB7XG5cdCAgICAgICAgY29udGludWU7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoZGlyZWN0aW9uID4gMCkge1xuXHQgICAgICAgIHJldHVybiBhbGxbaSArIDFdO1xuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIGFsbFtpIC0gMV07XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBudWxsO1xuXHQgIH1cblx0ICAvKipcblx0ICAgKiBSZXR1cm5zIHRoZSBkb20gZWxlbWVudCBvZiB0aGUgaXRlbVxuXHQgICAqIG1hdGNoaW5nIHRoZSBnaXZlbiB2YWx1ZS5cblx0ICAgKlxuXHQgICAqL1xuXG5cblx0ICBnZXRJdGVtKGl0ZW0pIHtcblx0ICAgIGlmICh0eXBlb2YgaXRlbSA9PSAnb2JqZWN0Jykge1xuXHQgICAgICByZXR1cm4gaXRlbTtcblx0ICAgIH1cblxuXHQgICAgdmFyIHZhbHVlID0gaGFzaF9rZXkoaXRlbSk7XG5cdCAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgPyB0aGlzLmNvbnRyb2wucXVlcnlTZWxlY3RvcihgW2RhdGEtdmFsdWU9XCIke2FkZFNsYXNoZXModmFsdWUpfVwiXWApIDogbnVsbDtcblx0ICB9XG5cdCAgLyoqXG5cdCAgICogXCJTZWxlY3RzXCIgbXVsdGlwbGUgaXRlbXMgYXQgb25jZS4gQWRkcyB0aGVtIHRvIHRoZSBsaXN0XG5cdCAgICogYXQgdGhlIGN1cnJlbnQgY2FyZXQgcG9zaXRpb24uXG5cdCAgICpcblx0ICAgKi9cblxuXG5cdCAgYWRkSXRlbXModmFsdWVzLCBzaWxlbnQpIHtcblx0ICAgIHZhciBzZWxmID0gdGhpcztcblx0ICAgIHZhciBpdGVtcyA9IEFycmF5LmlzQXJyYXkodmFsdWVzKSA/IHZhbHVlcyA6IFt2YWx1ZXNdO1xuXHQgICAgaXRlbXMgPSBpdGVtcy5maWx0ZXIoeCA9PiBzZWxmLml0ZW1zLmluZGV4T2YoeCkgPT09IC0xKTtcblx0ICAgIGNvbnN0IGxhc3RfaXRlbSA9IGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdO1xuXHQgICAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcblx0ICAgICAgc2VsZi5pc1BlbmRpbmcgPSBpdGVtICE9PSBsYXN0X2l0ZW07XG5cdCAgICAgIHNlbGYuYWRkSXRlbShpdGVtLCBzaWxlbnQpO1xuXHQgICAgfSk7XG5cdCAgfVxuXHQgIC8qKlxuXHQgICAqIFwiU2VsZWN0c1wiIGFuIGl0ZW0uIEFkZHMgaXQgdG8gdGhlIGxpc3Rcblx0ICAgKiBhdCB0aGUgY3VycmVudCBjYXJldCBwb3NpdGlvbi5cblx0ICAgKlxuXHQgICAqL1xuXG5cblx0ICBhZGRJdGVtKHZhbHVlLCBzaWxlbnQpIHtcblx0ICAgIHZhciBldmVudHMgPSBzaWxlbnQgPyBbXSA6IFsnY2hhbmdlJywgJ2Ryb3Bkb3duX2Nsb3NlJ107XG5cdCAgICBkZWJvdW5jZV9ldmVudHModGhpcywgZXZlbnRzLCAoKSA9PiB7XG5cdCAgICAgIHZhciBpdGVtLCB3YXNGdWxsO1xuXHQgICAgICBjb25zdCBzZWxmID0gdGhpcztcblx0ICAgICAgY29uc3QgaW5wdXRNb2RlID0gc2VsZi5zZXR0aW5ncy5tb2RlO1xuXHQgICAgICBjb25zdCBoYXNoZWQgPSBoYXNoX2tleSh2YWx1ZSk7XG5cblx0ICAgICAgaWYgKGhhc2hlZCAmJiBzZWxmLml0ZW1zLmluZGV4T2YoaGFzaGVkKSAhPT0gLTEpIHtcblx0ICAgICAgICBpZiAoaW5wdXRNb2RlID09PSAnc2luZ2xlJykge1xuXHQgICAgICAgICAgc2VsZi5jbG9zZSgpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChpbnB1dE1vZGUgPT09ICdzaW5nbGUnIHx8ICFzZWxmLnNldHRpbmdzLmR1cGxpY2F0ZXMpIHtcblx0ICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoaGFzaGVkID09PSBudWxsIHx8ICFzZWxmLm9wdGlvbnMuaGFzT3duUHJvcGVydHkoaGFzaGVkKSkgcmV0dXJuO1xuXHQgICAgICBpZiAoaW5wdXRNb2RlID09PSAnc2luZ2xlJykgc2VsZi5jbGVhcihzaWxlbnQpO1xuXHQgICAgICBpZiAoaW5wdXRNb2RlID09PSAnbXVsdGknICYmIHNlbGYuaXNGdWxsKCkpIHJldHVybjtcblx0ICAgICAgaXRlbSA9IHNlbGYuX3JlbmRlcignaXRlbScsIHNlbGYub3B0aW9uc1toYXNoZWRdKTtcblxuXHQgICAgICBpZiAoc2VsZi5jb250cm9sLmNvbnRhaW5zKGl0ZW0pKSB7XG5cdCAgICAgICAgLy8gZHVwbGljYXRlc1xuXHQgICAgICAgIGl0ZW0gPSBpdGVtLmNsb25lTm9kZSh0cnVlKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHdhc0Z1bGwgPSBzZWxmLmlzRnVsbCgpO1xuXHQgICAgICBzZWxmLml0ZW1zLnNwbGljZShzZWxmLmNhcmV0UG9zLCAwLCBoYXNoZWQpO1xuXHQgICAgICBzZWxmLmluc2VydEF0Q2FyZXQoaXRlbSk7XG5cblx0ICAgICAgaWYgKHNlbGYuaXNTZXR1cCkge1xuXHQgICAgICAgIC8vIHVwZGF0ZSBtZW51IC8gcmVtb3ZlIHRoZSBvcHRpb24gKGlmIHRoaXMgaXMgbm90IG9uZSBpdGVtIGJlaW5nIGFkZGVkIGFzIHBhcnQgb2Ygc2VyaWVzKVxuXHQgICAgICAgIGlmICghc2VsZi5pc1BlbmRpbmcgJiYgc2VsZi5zZXR0aW5ncy5oaWRlU2VsZWN0ZWQpIHtcblx0ICAgICAgICAgIGxldCBvcHRpb24gPSBzZWxmLmdldE9wdGlvbihoYXNoZWQpO1xuXHQgICAgICAgICAgbGV0IG5leHQgPSBzZWxmLmdldEFkamFjZW50KG9wdGlvbiwgMSk7XG5cblx0ICAgICAgICAgIGlmIChuZXh0KSB7XG5cdCAgICAgICAgICAgIHNlbGYuc2V0QWN0aXZlT3B0aW9uKG5leHQpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0gLy8gcmVmcmVzaE9wdGlvbnMgYWZ0ZXIgc2V0QWN0aXZlT3B0aW9uKCksXG5cdCAgICAgICAgLy8gb3RoZXJ3aXNlIHNldEFjdGl2ZU9wdGlvbigpIHdpbGwgYmUgY2FsbGVkIGJ5IHJlZnJlc2hPcHRpb25zKCkgd2l0aCB0aGUgd3JvbmcgdmFsdWVcblxuXG5cdCAgICAgICAgaWYgKCFzZWxmLmlzUGVuZGluZyAmJiAhc2VsZi5zZXR0aW5ncy5jbG9zZUFmdGVyU2VsZWN0KSB7XG5cdCAgICAgICAgICBzZWxmLnJlZnJlc2hPcHRpb25zKHNlbGYuaXNGb2N1c2VkICYmIGlucHV0TW9kZSAhPT0gJ3NpbmdsZScpO1xuXHQgICAgICAgIH0gLy8gaGlkZSB0aGUgbWVudSBpZiB0aGUgbWF4aW11bSBudW1iZXIgb2YgaXRlbXMgaGF2ZSBiZWVuIHNlbGVjdGVkIG9yIG5vIG9wdGlvbnMgYXJlIGxlZnRcblxuXG5cdCAgICAgICAgaWYgKHNlbGYuc2V0dGluZ3MuY2xvc2VBZnRlclNlbGVjdCAhPSBmYWxzZSAmJiBzZWxmLmlzRnVsbCgpKSB7XG5cdCAgICAgICAgICBzZWxmLmNsb3NlKCk7XG5cdCAgICAgICAgfSBlbHNlIGlmICghc2VsZi5pc1BlbmRpbmcpIHtcblx0ICAgICAgICAgIHNlbGYucG9zaXRpb25Ecm9wZG93bigpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHNlbGYudHJpZ2dlcignaXRlbV9hZGQnLCBoYXNoZWQsIGl0ZW0pO1xuXG5cdCAgICAgICAgaWYgKCFzZWxmLmlzUGVuZGluZykge1xuXHQgICAgICAgICAgc2VsZi51cGRhdGVPcmlnaW5hbElucHV0KHtcblx0ICAgICAgICAgICAgc2lsZW50OiBzaWxlbnRcblx0ICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIGlmICghc2VsZi5pc1BlbmRpbmcgfHwgIXdhc0Z1bGwgJiYgc2VsZi5pc0Z1bGwoKSkge1xuXHQgICAgICAgIHNlbGYuaW5wdXRTdGF0ZSgpO1xuXHQgICAgICAgIHNlbGYucmVmcmVzaFN0YXRlKCk7XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgIH1cblx0ICAvKipcblx0ICAgKiBSZW1vdmVzIHRoZSBzZWxlY3RlZCBpdGVtIG1hdGNoaW5nXG5cdCAgICogdGhlIHByb3ZpZGVkIHZhbHVlLlxuXHQgICAqXG5cdCAgICovXG5cblxuXHQgIHJlbW92ZUl0ZW0oaXRlbSA9IG51bGwsIHNpbGVudCkge1xuXHQgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cdCAgICBpdGVtID0gc2VsZi5nZXRJdGVtKGl0ZW0pO1xuXHQgICAgaWYgKCFpdGVtKSByZXR1cm47XG5cdCAgICB2YXIgaSwgaWR4O1xuXHQgICAgY29uc3QgdmFsdWUgPSBpdGVtLmRhdGFzZXQudmFsdWU7XG5cdCAgICBpID0gbm9kZUluZGV4KGl0ZW0pO1xuXHQgICAgaXRlbS5yZW1vdmUoKTtcblxuXHQgICAgaWYgKGl0ZW0uY2xhc3NMaXN0LmNvbnRhaW5zKCdhY3RpdmUnKSkge1xuXHQgICAgICBpZHggPSBzZWxmLmFjdGl2ZUl0ZW1zLmluZGV4T2YoaXRlbSk7XG5cdCAgICAgIHNlbGYuYWN0aXZlSXRlbXMuc3BsaWNlKGlkeCwgMSk7XG5cdCAgICAgIHJlbW92ZUNsYXNzZXMoaXRlbSwgJ2FjdGl2ZScpO1xuXHQgICAgfVxuXG5cdCAgICBzZWxmLml0ZW1zLnNwbGljZShpLCAxKTtcblx0ICAgIHNlbGYubGFzdFF1ZXJ5ID0gbnVsbDtcblxuXHQgICAgaWYgKCFzZWxmLnNldHRpbmdzLnBlcnNpc3QgJiYgc2VsZi51c2VyT3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkpIHtcblx0ICAgICAgc2VsZi5yZW1vdmVPcHRpb24odmFsdWUsIHNpbGVudCk7XG5cdCAgICB9XG5cblx0ICAgIGlmIChpIDwgc2VsZi5jYXJldFBvcykge1xuXHQgICAgICBzZWxmLnNldENhcmV0KHNlbGYuY2FyZXRQb3MgLSAxKTtcblx0ICAgIH1cblxuXHQgICAgc2VsZi51cGRhdGVPcmlnaW5hbElucHV0KHtcblx0ICAgICAgc2lsZW50OiBzaWxlbnRcblx0ICAgIH0pO1xuXHQgICAgc2VsZi5yZWZyZXNoU3RhdGUoKTtcblx0ICAgIHNlbGYucG9zaXRpb25Ecm9wZG93bigpO1xuXHQgICAgc2VsZi50cmlnZ2VyKCdpdGVtX3JlbW92ZScsIHZhbHVlLCBpdGVtKTtcblx0ICB9XG5cdCAgLyoqXG5cdCAgICogSW52b2tlcyB0aGUgYGNyZWF0ZWAgbWV0aG9kIHByb3ZpZGVkIGluIHRoZVxuXHQgICAqIFRvbVNlbGVjdCBvcHRpb25zIHRoYXQgc2hvdWxkIHByb3ZpZGUgdGhlIGRhdGFcblx0ICAgKiBmb3IgdGhlIG5ldyBpdGVtLCBnaXZlbiB0aGUgdXNlciBpbnB1dC5cblx0ICAgKlxuXHQgICAqIE9uY2UgdGhpcyBjb21wbGV0ZXMsIGl0IHdpbGwgYmUgYWRkZWRcblx0ICAgKiB0byB0aGUgaXRlbSBsaXN0LlxuXHQgICAqXG5cdCAgICovXG5cblxuXHQgIGNyZWF0ZUl0ZW0oaW5wdXQgPSBudWxsLCBjYWxsYmFjayA9ICgpID0+IHt9KSB7XG5cdCAgICAvLyB0cmlnZ2VyRHJvcGRvd24gcGFyYW1ldGVyIEBkZXByZWNhdGVkIDIuMS4xXG5cdCAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuXHQgICAgICBjYWxsYmFjayA9IGFyZ3VtZW50c1syXTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIGNhbGxiYWNrID0gKCkgPT4ge307XG5cdCAgICB9XG5cblx0ICAgIHZhciBzZWxmID0gdGhpcztcblx0ICAgIHZhciBjYXJldCA9IHNlbGYuY2FyZXRQb3M7XG5cdCAgICB2YXIgb3V0cHV0O1xuXHQgICAgaW5wdXQgPSBpbnB1dCB8fCBzZWxmLmlucHV0VmFsdWUoKTtcblxuXHQgICAgaWYgKCFzZWxmLmNhbkNyZWF0ZShpbnB1dCkpIHtcblx0ICAgICAgY2FsbGJhY2soKTtcblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXG5cdCAgICBzZWxmLmxvY2soKTtcblx0ICAgIHZhciBjcmVhdGVkID0gZmFsc2U7XG5cblx0ICAgIHZhciBjcmVhdGUgPSBkYXRhID0+IHtcblx0ICAgICAgc2VsZi51bmxvY2soKTtcblx0ICAgICAgaWYgKCFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSAnb2JqZWN0JykgcmV0dXJuIGNhbGxiYWNrKCk7XG5cdCAgICAgIHZhciB2YWx1ZSA9IGhhc2hfa2V5KGRhdGFbc2VsZi5zZXR0aW5ncy52YWx1ZUZpZWxkXSk7XG5cblx0ICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcblx0ICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHNlbGYuc2V0VGV4dGJveFZhbHVlKCk7XG5cdCAgICAgIHNlbGYuYWRkT3B0aW9uKGRhdGEsIHRydWUpO1xuXHQgICAgICBzZWxmLnNldENhcmV0KGNhcmV0KTtcblx0ICAgICAgc2VsZi5hZGRJdGVtKHZhbHVlKTtcblx0ICAgICAgY2FsbGJhY2soZGF0YSk7XG5cdCAgICAgIGNyZWF0ZWQgPSB0cnVlO1xuXHQgICAgfTtcblxuXHQgICAgaWYgKHR5cGVvZiBzZWxmLnNldHRpbmdzLmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICBvdXRwdXQgPSBzZWxmLnNldHRpbmdzLmNyZWF0ZS5jYWxsKHRoaXMsIGlucHV0LCBjcmVhdGUpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgb3V0cHV0ID0ge1xuXHQgICAgICAgIFtzZWxmLnNldHRpbmdzLmxhYmVsRmllbGRdOiBpbnB1dCxcblx0ICAgICAgICBbc2VsZi5zZXR0aW5ncy52YWx1ZUZpZWxkXTogaW5wdXRcblx0ICAgICAgfTtcblx0ICAgIH1cblxuXHQgICAgaWYgKCFjcmVhdGVkKSB7XG5cdCAgICAgIGNyZWF0ZShvdXRwdXQpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0ICB9XG5cdCAgLyoqXG5cdCAgICogUmUtcmVuZGVycyB0aGUgc2VsZWN0ZWQgaXRlbSBsaXN0cy5cblx0ICAgKi9cblxuXG5cdCAgcmVmcmVzaEl0ZW1zKCkge1xuXHQgICAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgICAgc2VsZi5sYXN0UXVlcnkgPSBudWxsO1xuXG5cdCAgICBpZiAoc2VsZi5pc1NldHVwKSB7XG5cdCAgICAgIHNlbGYuYWRkSXRlbXMoc2VsZi5pdGVtcyk7XG5cdCAgICB9XG5cblx0ICAgIHNlbGYudXBkYXRlT3JpZ2luYWxJbnB1dCgpO1xuXHQgICAgc2VsZi5yZWZyZXNoU3RhdGUoKTtcblx0ICB9XG5cdCAgLyoqXG5cdCAgICogVXBkYXRlcyBhbGwgc3RhdGUtZGVwZW5kZW50IGF0dHJpYnV0ZXNcblx0ICAgKiBhbmQgQ1NTIGNsYXNzZXMuXG5cdCAgICovXG5cblxuXHQgIHJlZnJlc2hTdGF0ZSgpIHtcblx0ICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXHQgICAgc2VsZi5yZWZyZXNoVmFsaWRpdHlTdGF0ZSgpO1xuXHQgICAgY29uc3QgaXNGdWxsID0gc2VsZi5pc0Z1bGwoKTtcblx0ICAgIGNvbnN0IGlzTG9ja2VkID0gc2VsZi5pc0xvY2tlZDtcblx0ICAgIHNlbGYud3JhcHBlci5jbGFzc0xpc3QudG9nZ2xlKCdydGwnLCBzZWxmLnJ0bCk7XG5cdCAgICBjb25zdCB3cmFwX2NsYXNzTGlzdCA9IHNlbGYud3JhcHBlci5jbGFzc0xpc3Q7XG5cdCAgICB3cmFwX2NsYXNzTGlzdC50b2dnbGUoJ2ZvY3VzJywgc2VsZi5pc0ZvY3VzZWQpO1xuXHQgICAgd3JhcF9jbGFzc0xpc3QudG9nZ2xlKCdkaXNhYmxlZCcsIHNlbGYuaXNEaXNhYmxlZCk7XG5cdCAgICB3cmFwX2NsYXNzTGlzdC50b2dnbGUoJ3JlcXVpcmVkJywgc2VsZi5pc1JlcXVpcmVkKTtcblx0ICAgIHdyYXBfY2xhc3NMaXN0LnRvZ2dsZSgnaW52YWxpZCcsICFzZWxmLmlzVmFsaWQpO1xuXHQgICAgd3JhcF9jbGFzc0xpc3QudG9nZ2xlKCdsb2NrZWQnLCBpc0xvY2tlZCk7XG5cdCAgICB3cmFwX2NsYXNzTGlzdC50b2dnbGUoJ2Z1bGwnLCBpc0Z1bGwpO1xuXHQgICAgd3JhcF9jbGFzc0xpc3QudG9nZ2xlKCdpbnB1dC1hY3RpdmUnLCBzZWxmLmlzRm9jdXNlZCAmJiAhc2VsZi5pc0lucHV0SGlkZGVuKTtcblx0ICAgIHdyYXBfY2xhc3NMaXN0LnRvZ2dsZSgnZHJvcGRvd24tYWN0aXZlJywgc2VsZi5pc09wZW4pO1xuXHQgICAgd3JhcF9jbGFzc0xpc3QudG9nZ2xlKCdoYXMtb3B0aW9ucycsIGlzRW1wdHlPYmplY3Qoc2VsZi5vcHRpb25zKSk7XG5cdCAgICB3cmFwX2NsYXNzTGlzdC50b2dnbGUoJ2hhcy1pdGVtcycsIHNlbGYuaXRlbXMubGVuZ3RoID4gMCk7XG5cdCAgfVxuXHQgIC8qKlxuXHQgICAqIFVwZGF0ZSB0aGUgYHJlcXVpcmVkYCBhdHRyaWJ1dGUgb2YgYm90aCBpbnB1dCBhbmQgY29udHJvbCBpbnB1dC5cblx0ICAgKlxuXHQgICAqIFRoZSBgcmVxdWlyZWRgIHByb3BlcnR5IG5lZWRzIHRvIGJlIGFjdGl2YXRlZCBvbiB0aGUgY29udHJvbCBpbnB1dFxuXHQgICAqIGZvciB0aGUgZXJyb3IgdG8gYmUgZGlzcGxheWVkIGF0IHRoZSByaWdodCBwbGFjZS4gYHJlcXVpcmVkYCBhbHNvXG5cdCAgICogbmVlZHMgdG8gYmUgdGVtcG9yYXJpbHkgZGVhY3RpdmF0ZWQgb24gdGhlIGlucHV0IHNpbmNlIHRoZSBpbnB1dCBpc1xuXHQgICAqIGhpZGRlbiBhbmQgY2FuJ3Qgc2hvdyBlcnJvcnMuXG5cdCAgICovXG5cblxuXHQgIHJlZnJlc2hWYWxpZGl0eVN0YXRlKCkge1xuXHQgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG5cdCAgICBpZiAoIXNlbGYuaW5wdXQudmFsaWRpdHkpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICBzZWxmLmlzVmFsaWQgPSBzZWxmLmlucHV0LnZhbGlkaXR5LnZhbGlkO1xuXHQgICAgc2VsZi5pc0ludmFsaWQgPSAhc2VsZi5pc1ZhbGlkO1xuXHQgIH1cblx0ICAvKipcblx0ICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IG1vcmUgaXRlbXMgY2FuIGJlIGFkZGVkXG5cdCAgICogdG8gdGhlIGNvbnRyb2wgd2l0aG91dCBleGNlZWRpbmcgdGhlIHVzZXItZGVmaW5lZCBtYXhpbXVtLlxuXHQgICAqXG5cdCAgICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAgICovXG5cblxuXHQgIGlzRnVsbCgpIHtcblx0ICAgIHJldHVybiB0aGlzLnNldHRpbmdzLm1heEl0ZW1zICE9PSBudWxsICYmIHRoaXMuaXRlbXMubGVuZ3RoID49IHRoaXMuc2V0dGluZ3MubWF4SXRlbXM7XG5cdCAgfVxuXHQgIC8qKlxuXHQgICAqIFJlZnJlc2hlcyB0aGUgb3JpZ2luYWwgPHNlbGVjdD4gb3IgPGlucHV0PlxuXHQgICAqIGVsZW1lbnQgdG8gcmVmbGVjdCB0aGUgY3VycmVudCBzdGF0ZS5cblx0ICAgKlxuXHQgICAqL1xuXG5cblx0ICB1cGRhdGVPcmlnaW5hbElucHV0KG9wdHMgPSB7fSkge1xuXHQgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cdCAgICB2YXIgb3B0aW9uLCBsYWJlbDtcblx0ICAgIGNvbnN0IGVtcHR5X29wdGlvbiA9IHNlbGYuaW5wdXQucXVlcnlTZWxlY3Rvcignb3B0aW9uW3ZhbHVlPVwiXCJdJyk7XG5cblx0ICAgIGlmIChzZWxmLmlzX3NlbGVjdF90YWcpIHtcblx0ICAgICAgY29uc3Qgc2VsZWN0ZWQgPSBbXTtcblx0ICAgICAgY29uc3QgaGFzX3NlbGVjdGVkID0gc2VsZi5pbnB1dC5xdWVyeVNlbGVjdG9yQWxsKCdvcHRpb246Y2hlY2tlZCcpLmxlbmd0aDtcblxuXHQgICAgICBmdW5jdGlvbiBBZGRTZWxlY3RlZChvcHRpb25fZWwsIHZhbHVlLCBsYWJlbCkge1xuXHQgICAgICAgIGlmICghb3B0aW9uX2VsKSB7XG5cdCAgICAgICAgICBvcHRpb25fZWwgPSBnZXREb20oJzxvcHRpb24gdmFsdWU9XCInICsgZXNjYXBlX2h0bWwodmFsdWUpICsgJ1wiPicgKyBlc2NhcGVfaHRtbChsYWJlbCkgKyAnPC9vcHRpb24+Jyk7XG5cdCAgICAgICAgfSAvLyBkb24ndCBtb3ZlIGVtcHR5IG9wdGlvbiBmcm9tIHRvcCBvZiBsaXN0XG5cdCAgICAgICAgLy8gZml4ZXMgYnVnIGluIGZpcmVmb3ggaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTcyNTI5M1xuXG5cblx0ICAgICAgICBpZiAob3B0aW9uX2VsICE9IGVtcHR5X29wdGlvbikge1xuXHQgICAgICAgICAgc2VsZi5pbnB1dC5hcHBlbmQob3B0aW9uX2VsKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBzZWxlY3RlZC5wdXNoKG9wdGlvbl9lbCk7IC8vIG1hcmtpbmcgZW1wdHkgb3B0aW9uIGFzIHNlbGVjdGVkIGNhbiBicmVhayB2YWxpZGF0aW9uXG5cdCAgICAgICAgLy8gZml4ZXMgaHR0cHM6Ly9naXRodWIuY29tL29yY2hpZGpzL3RvbS1zZWxlY3QvaXNzdWVzLzMwM1xuXG5cdCAgICAgICAgaWYgKG9wdGlvbl9lbCAhPSBlbXB0eV9vcHRpb24gfHwgaGFzX3NlbGVjdGVkID4gMCkge1xuXHQgICAgICAgICAgb3B0aW9uX2VsLnNlbGVjdGVkID0gdHJ1ZTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gb3B0aW9uX2VsO1xuXHQgICAgICB9IC8vIHVuc2VsZWN0IGFsbCBzZWxlY3RlZCBvcHRpb25zXG5cblxuXHQgICAgICBzZWxmLmlucHV0LnF1ZXJ5U2VsZWN0b3JBbGwoJ29wdGlvbjpjaGVja2VkJykuZm9yRWFjaChvcHRpb25fZWwgPT4ge1xuXHQgICAgICAgIG9wdGlvbl9lbC5zZWxlY3RlZCA9IGZhbHNlO1xuXHQgICAgICB9KTsgLy8gbm90aGluZyBzZWxlY3RlZD9cblxuXHQgICAgICBpZiAoc2VsZi5pdGVtcy5sZW5ndGggPT0gMCAmJiBzZWxmLnNldHRpbmdzLm1vZGUgPT0gJ3NpbmdsZScpIHtcblx0ICAgICAgICBBZGRTZWxlY3RlZChlbXB0eV9vcHRpb24sIFwiXCIsIFwiXCIpOyAvLyBvcmRlciBzZWxlY3RlZCA8b3B0aW9uPiB0YWdzIGZvciB2YWx1ZXMgaW4gc2VsZi5pdGVtc1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHNlbGYuaXRlbXMuZm9yRWFjaCh2YWx1ZSA9PiB7XG5cdCAgICAgICAgICBvcHRpb24gPSBzZWxmLm9wdGlvbnNbdmFsdWVdO1xuXHQgICAgICAgICAgbGFiZWwgPSBvcHRpb25bc2VsZi5zZXR0aW5ncy5sYWJlbEZpZWxkXSB8fCAnJztcblxuXHQgICAgICAgICAgaWYgKHNlbGVjdGVkLmluY2x1ZGVzKG9wdGlvbi4kb3B0aW9uKSkge1xuXHQgICAgICAgICAgICBjb25zdCByZXVzZV9vcHQgPSBzZWxmLmlucHV0LnF1ZXJ5U2VsZWN0b3IoYG9wdGlvblt2YWx1ZT1cIiR7YWRkU2xhc2hlcyh2YWx1ZSl9XCJdOm5vdCg6Y2hlY2tlZClgKTtcblx0ICAgICAgICAgICAgQWRkU2VsZWN0ZWQocmV1c2Vfb3B0LCB2YWx1ZSwgbGFiZWwpO1xuXHQgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgb3B0aW9uLiRvcHRpb24gPSBBZGRTZWxlY3RlZChvcHRpb24uJG9wdGlvbiwgdmFsdWUsIGxhYmVsKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgc2VsZi5pbnB1dC52YWx1ZSA9IHNlbGYuZ2V0VmFsdWUoKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHNlbGYuaXNTZXR1cCkge1xuXHQgICAgICBpZiAoIW9wdHMuc2lsZW50KSB7XG5cdCAgICAgICAgc2VsZi50cmlnZ2VyKCdjaGFuZ2UnLCBzZWxmLmdldFZhbHVlKCkpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHQgIC8qKlxuXHQgICAqIFNob3dzIHRoZSBhdXRvY29tcGxldGUgZHJvcGRvd24gY29udGFpbmluZ1xuXHQgICAqIHRoZSBhdmFpbGFibGUgb3B0aW9ucy5cblx0ICAgKi9cblxuXG5cdCAgb3BlbigpIHtcblx0ICAgIHZhciBzZWxmID0gdGhpcztcblx0ICAgIGlmIChzZWxmLmlzTG9ja2VkIHx8IHNlbGYuaXNPcGVuIHx8IHNlbGYuc2V0dGluZ3MubW9kZSA9PT0gJ211bHRpJyAmJiBzZWxmLmlzRnVsbCgpKSByZXR1cm47XG5cdCAgICBzZWxmLmlzT3BlbiA9IHRydWU7XG5cdCAgICBzZXRBdHRyKHNlbGYuZm9jdXNfbm9kZSwge1xuXHQgICAgICAnYXJpYS1leHBhbmRlZCc6ICd0cnVlJ1xuXHQgICAgfSk7XG5cdCAgICBzZWxmLnJlZnJlc2hTdGF0ZSgpO1xuXHQgICAgYXBwbHlDU1Moc2VsZi5kcm9wZG93biwge1xuXHQgICAgICB2aXNpYmlsaXR5OiAnaGlkZGVuJyxcblx0ICAgICAgZGlzcGxheTogJ2Jsb2NrJ1xuXHQgICAgfSk7XG5cdCAgICBzZWxmLnBvc2l0aW9uRHJvcGRvd24oKTtcblx0ICAgIGFwcGx5Q1NTKHNlbGYuZHJvcGRvd24sIHtcblx0ICAgICAgdmlzaWJpbGl0eTogJ3Zpc2libGUnLFxuXHQgICAgICBkaXNwbGF5OiAnYmxvY2snXG5cdCAgICB9KTtcblx0ICAgIHNlbGYuZm9jdXMoKTtcblx0ICAgIHNlbGYudHJpZ2dlcignZHJvcGRvd25fb3BlbicsIHNlbGYuZHJvcGRvd24pO1xuXHQgIH1cblx0ICAvKipcblx0ICAgKiBDbG9zZXMgdGhlIGF1dG9jb21wbGV0ZSBkcm9wZG93biBtZW51LlxuXHQgICAqL1xuXG5cblx0ICBjbG9zZShzZXRUZXh0Ym94VmFsdWUgPSB0cnVlKSB7XG5cdCAgICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgICB2YXIgdHJpZ2dlciA9IHNlbGYuaXNPcGVuO1xuXG5cdCAgICBpZiAoc2V0VGV4dGJveFZhbHVlKSB7XG5cdCAgICAgIC8vIGJlZm9yZSBibHVyKCkgdG8gcHJldmVudCBmb3JtIG9uY2hhbmdlIGV2ZW50XG5cdCAgICAgIHNlbGYuc2V0VGV4dGJveFZhbHVlKCk7XG5cblx0ICAgICAgaWYgKHNlbGYuc2V0dGluZ3MubW9kZSA9PT0gJ3NpbmdsZScgJiYgc2VsZi5pdGVtcy5sZW5ndGgpIHtcblx0ICAgICAgICBzZWxmLmhpZGVJbnB1dCgpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHNlbGYuaXNPcGVuID0gZmFsc2U7XG5cdCAgICBzZXRBdHRyKHNlbGYuZm9jdXNfbm9kZSwge1xuXHQgICAgICAnYXJpYS1leHBhbmRlZCc6ICdmYWxzZSdcblx0ICAgIH0pO1xuXHQgICAgYXBwbHlDU1Moc2VsZi5kcm9wZG93biwge1xuXHQgICAgICBkaXNwbGF5OiAnbm9uZSdcblx0ICAgIH0pO1xuXG5cdCAgICBpZiAoc2VsZi5zZXR0aW5ncy5oaWRlU2VsZWN0ZWQpIHtcblx0ICAgICAgc2VsZi5jbGVhckFjdGl2ZU9wdGlvbigpO1xuXHQgICAgfVxuXG5cdCAgICBzZWxmLnJlZnJlc2hTdGF0ZSgpO1xuXHQgICAgaWYgKHRyaWdnZXIpIHNlbGYudHJpZ2dlcignZHJvcGRvd25fY2xvc2UnLCBzZWxmLmRyb3Bkb3duKTtcblx0ICB9XG5cdCAgLyoqXG5cdCAgICogQ2FsY3VsYXRlcyBhbmQgYXBwbGllcyB0aGUgYXBwcm9wcmlhdGVcblx0ICAgKiBwb3NpdGlvbiBvZiB0aGUgZHJvcGRvd24gaWYgZHJvcGRvd25QYXJlbnQgPSAnYm9keScuXG5cdCAgICogT3RoZXJ3aXNlLCBwb3NpdGlvbiBpcyBkZXRlcm1pbmVkIGJ5IGNzc1xuXHQgICAqL1xuXG5cblx0ICBwb3NpdGlvbkRyb3Bkb3duKCkge1xuXHQgICAgaWYgKHRoaXMuc2V0dGluZ3MuZHJvcGRvd25QYXJlbnQgIT09ICdib2R5Jykge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250cm9sO1xuXHQgICAgdmFyIHJlY3QgPSBjb250ZXh0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHQgICAgdmFyIHRvcCA9IGNvbnRleHQub2Zmc2V0SGVpZ2h0ICsgcmVjdC50b3AgKyB3aW5kb3cuc2Nyb2xsWTtcblx0ICAgIHZhciBsZWZ0ID0gcmVjdC5sZWZ0ICsgd2luZG93LnNjcm9sbFg7XG5cdCAgICBhcHBseUNTUyh0aGlzLmRyb3Bkb3duLCB7XG5cdCAgICAgIHdpZHRoOiByZWN0LndpZHRoICsgJ3B4Jyxcblx0ICAgICAgdG9wOiB0b3AgKyAncHgnLFxuXHQgICAgICBsZWZ0OiBsZWZ0ICsgJ3B4J1xuXHQgICAgfSk7XG5cdCAgfVxuXHQgIC8qKlxuXHQgICAqIFJlc2V0cyAvIGNsZWFycyBhbGwgc2VsZWN0ZWQgaXRlbXNcblx0ICAgKiBmcm9tIHRoZSBjb250cm9sLlxuXHQgICAqXG5cdCAgICovXG5cblxuXHQgIGNsZWFyKHNpbGVudCkge1xuXHQgICAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgICAgaWYgKCFzZWxmLml0ZW1zLmxlbmd0aCkgcmV0dXJuO1xuXHQgICAgdmFyIGl0ZW1zID0gc2VsZi5jb250cm9sQ2hpbGRyZW4oKTtcblx0ICAgIGl0ZXJhdGUkMShpdGVtcywgaXRlbSA9PiB7XG5cdCAgICAgIHNlbGYucmVtb3ZlSXRlbShpdGVtLCB0cnVlKTtcblx0ICAgIH0pO1xuXHQgICAgc2VsZi5zaG93SW5wdXQoKTtcblx0ICAgIGlmICghc2lsZW50KSBzZWxmLnVwZGF0ZU9yaWdpbmFsSW5wdXQoKTtcblx0ICAgIHNlbGYudHJpZ2dlcignY2xlYXInKTtcblx0ICB9XG5cdCAgLyoqXG5cdCAgICogQSBoZWxwZXIgbWV0aG9kIGZvciBpbnNlcnRpbmcgYW4gZWxlbWVudFxuXHQgICAqIGF0IHRoZSBjdXJyZW50IGNhcmV0IHBvc2l0aW9uLlxuXHQgICAqXG5cdCAgICovXG5cblxuXHQgIGluc2VydEF0Q2FyZXQoZWwpIHtcblx0ICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXHQgICAgY29uc3QgY2FyZXQgPSBzZWxmLmNhcmV0UG9zO1xuXHQgICAgY29uc3QgdGFyZ2V0ID0gc2VsZi5jb250cm9sO1xuXHQgICAgdGFyZ2V0Lmluc2VydEJlZm9yZShlbCwgdGFyZ2V0LmNoaWxkcmVuW2NhcmV0XSB8fCBudWxsKTtcblx0ICAgIHNlbGYuc2V0Q2FyZXQoY2FyZXQgKyAxKTtcblx0ICB9XG5cdCAgLyoqXG5cdCAgICogUmVtb3ZlcyB0aGUgY3VycmVudCBzZWxlY3RlZCBpdGVtKHMpLlxuXHQgICAqXG5cdCAgICovXG5cblxuXHQgIGRlbGV0ZVNlbGVjdGlvbihlKSB7XG5cdCAgICB2YXIgZGlyZWN0aW9uLCBzZWxlY3Rpb24sIGNhcmV0LCB0YWlsO1xuXHQgICAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgICAgZGlyZWN0aW9uID0gZSAmJiBlLmtleUNvZGUgPT09IEtFWV9CQUNLU1BBQ0UgPyAtMSA6IDE7XG5cdCAgICBzZWxlY3Rpb24gPSBnZXRTZWxlY3Rpb24oc2VsZi5jb250cm9sX2lucHV0KTsgLy8gZGV0ZXJtaW5lIGl0ZW1zIHRoYXQgd2lsbCBiZSByZW1vdmVkXG5cblx0ICAgIGNvbnN0IHJtX2l0ZW1zID0gW107XG5cblx0ICAgIGlmIChzZWxmLmFjdGl2ZUl0ZW1zLmxlbmd0aCkge1xuXHQgICAgICB0YWlsID0gZ2V0VGFpbChzZWxmLmFjdGl2ZUl0ZW1zLCBkaXJlY3Rpb24pO1xuXHQgICAgICBjYXJldCA9IG5vZGVJbmRleCh0YWlsKTtcblxuXHQgICAgICBpZiAoZGlyZWN0aW9uID4gMCkge1xuXHQgICAgICAgIGNhcmV0Kys7XG5cdCAgICAgIH1cblxuXHQgICAgICBpdGVyYXRlJDEoc2VsZi5hY3RpdmVJdGVtcywgaXRlbSA9PiBybV9pdGVtcy5wdXNoKGl0ZW0pKTtcblx0ICAgIH0gZWxzZSBpZiAoKHNlbGYuaXNGb2N1c2VkIHx8IHNlbGYuc2V0dGluZ3MubW9kZSA9PT0gJ3NpbmdsZScpICYmIHNlbGYuaXRlbXMubGVuZ3RoKSB7XG5cdCAgICAgIGNvbnN0IGl0ZW1zID0gc2VsZi5jb250cm9sQ2hpbGRyZW4oKTtcblx0ICAgICAgbGV0IHJtX2l0ZW07XG5cblx0ICAgICAgaWYgKGRpcmVjdGlvbiA8IDAgJiYgc2VsZWN0aW9uLnN0YXJ0ID09PSAwICYmIHNlbGVjdGlvbi5sZW5ndGggPT09IDApIHtcblx0ICAgICAgICBybV9pdGVtID0gaXRlbXNbc2VsZi5jYXJldFBvcyAtIDFdO1xuXHQgICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA+IDAgJiYgc2VsZWN0aW9uLnN0YXJ0ID09PSBzZWxmLmlucHV0VmFsdWUoKS5sZW5ndGgpIHtcblx0ICAgICAgICBybV9pdGVtID0gaXRlbXNbc2VsZi5jYXJldFBvc107XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAocm1faXRlbSAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgcm1faXRlbXMucHVzaChybV9pdGVtKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAoIXNlbGYuc2hvdWxkRGVsZXRlKHJtX2l0ZW1zLCBlKSkge1xuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cblx0ICAgIHByZXZlbnREZWZhdWx0KGUsIHRydWUpOyAvLyBwZXJmb3JtIHJlbW92YWxcblxuXHQgICAgaWYgKHR5cGVvZiBjYXJldCAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgICAgc2VsZi5zZXRDYXJldChjYXJldCk7XG5cdCAgICB9XG5cblx0ICAgIHdoaWxlIChybV9pdGVtcy5sZW5ndGgpIHtcblx0ICAgICAgc2VsZi5yZW1vdmVJdGVtKHJtX2l0ZW1zLnBvcCgpKTtcblx0ICAgIH1cblxuXHQgICAgc2VsZi5zaG93SW5wdXQoKTtcblx0ICAgIHNlbGYucG9zaXRpb25Ecm9wZG93bigpO1xuXHQgICAgc2VsZi5yZWZyZXNoT3B0aW9ucyhmYWxzZSk7XG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0ICB9XG5cdCAgLyoqXG5cdCAgICogUmV0dXJuIHRydWUgaWYgdGhlIGl0ZW1zIHNob3VsZCBiZSBkZWxldGVkXG5cdCAgICovXG5cblxuXHQgIHNob3VsZERlbGV0ZShpdGVtcywgZXZ0KSB7XG5cdCAgICBjb25zdCB2YWx1ZXMgPSBpdGVtcy5tYXAoaXRlbSA9PiBpdGVtLmRhdGFzZXQudmFsdWUpOyAvLyBhbGxvdyB0aGUgY2FsbGJhY2sgdG8gYWJvcnRcblxuXHQgICAgaWYgKCF2YWx1ZXMubGVuZ3RoIHx8IHR5cGVvZiB0aGlzLnNldHRpbmdzLm9uRGVsZXRlID09PSAnZnVuY3Rpb24nICYmIHRoaXMuc2V0dGluZ3Mub25EZWxldGUodmFsdWVzLCBldnQpID09PSBmYWxzZSkge1xuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0cnVlO1xuXHQgIH1cblx0ICAvKipcblx0ICAgKiBTZWxlY3RzIHRoZSBwcmV2aW91cyAvIG5leHQgaXRlbSAoZGVwZW5kaW5nIG9uIHRoZSBgZGlyZWN0aW9uYCBhcmd1bWVudCkuXG5cdCAgICpcblx0ICAgKiA+IDAgLSByaWdodFxuXHQgICAqIDwgMCAtIGxlZnRcblx0ICAgKlxuXHQgICAqL1xuXG5cblx0ICBhZHZhbmNlU2VsZWN0aW9uKGRpcmVjdGlvbiwgZSkge1xuXHQgICAgdmFyIGxhc3RfYWN0aXZlLFxuXHQgICAgICAgIGFkamFjZW50LFxuXHQgICAgICAgIHNlbGYgPSB0aGlzO1xuXHQgICAgaWYgKHNlbGYucnRsKSBkaXJlY3Rpb24gKj0gLTE7XG5cdCAgICBpZiAoc2VsZi5pbnB1dFZhbHVlKCkubGVuZ3RoKSByZXR1cm47IC8vIGFkZCBvciByZW1vdmUgdG8gYWN0aXZlIGl0ZW1zXG5cblx0ICAgIGlmIChpc0tleURvd24oS0VZX1NIT1JUQ1VULCBlKSB8fCBpc0tleURvd24oJ3NoaWZ0S2V5JywgZSkpIHtcblx0ICAgICAgbGFzdF9hY3RpdmUgPSBzZWxmLmdldExhc3RBY3RpdmUoZGlyZWN0aW9uKTtcblxuXHQgICAgICBpZiAobGFzdF9hY3RpdmUpIHtcblx0ICAgICAgICBpZiAoIWxhc3RfYWN0aXZlLmNsYXNzTGlzdC5jb250YWlucygnYWN0aXZlJykpIHtcblx0ICAgICAgICAgIGFkamFjZW50ID0gbGFzdF9hY3RpdmU7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIGFkamFjZW50ID0gc2VsZi5nZXRBZGphY2VudChsYXN0X2FjdGl2ZSwgZGlyZWN0aW9uLCAnaXRlbScpO1xuXHQgICAgICAgIH0gLy8gaWYgbm8gYWN0aXZlIGl0ZW0sIGdldCBpdGVtcyBhZGphY2VudCB0byB0aGUgY29udHJvbCBpbnB1dFxuXG5cdCAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID4gMCkge1xuXHQgICAgICAgIGFkamFjZW50ID0gc2VsZi5jb250cm9sX2lucHV0Lm5leHRFbGVtZW50U2libGluZztcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBhZGphY2VudCA9IHNlbGYuY29udHJvbF9pbnB1dC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKGFkamFjZW50KSB7XG5cdCAgICAgICAgaWYgKGFkamFjZW50LmNsYXNzTGlzdC5jb250YWlucygnYWN0aXZlJykpIHtcblx0ICAgICAgICAgIHNlbGYucmVtb3ZlQWN0aXZlSXRlbShsYXN0X2FjdGl2ZSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgc2VsZi5zZXRBY3RpdmVJdGVtQ2xhc3MoYWRqYWNlbnQpOyAvLyBtYXJrIGFzIGxhc3RfYWN0aXZlICEhIGFmdGVyIHJlbW92ZUFjdGl2ZUl0ZW0oKSBvbiBsYXN0X2FjdGl2ZVxuXHQgICAgICB9IC8vIG1vdmUgY2FyZXQgdG8gdGhlIGxlZnQgb3IgcmlnaHRcblxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgc2VsZi5tb3ZlQ2FyZXQoZGlyZWN0aW9uKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBtb3ZlQ2FyZXQoZGlyZWN0aW9uKSB7fVxuXHQgIC8qKlxuXHQgICAqIEdldCB0aGUgbGFzdCBhY3RpdmUgaXRlbVxuXHQgICAqXG5cdCAgICovXG5cblxuXHQgIGdldExhc3RBY3RpdmUoZGlyZWN0aW9uKSB7XG5cdCAgICBsZXQgbGFzdF9hY3RpdmUgPSB0aGlzLmNvbnRyb2wucXVlcnlTZWxlY3RvcignLmxhc3QtYWN0aXZlJyk7XG5cblx0ICAgIGlmIChsYXN0X2FjdGl2ZSkge1xuXHQgICAgICByZXR1cm4gbGFzdF9hY3RpdmU7XG5cdCAgICB9XG5cblx0ICAgIHZhciByZXN1bHQgPSB0aGlzLmNvbnRyb2wucXVlcnlTZWxlY3RvckFsbCgnLmFjdGl2ZScpO1xuXG5cdCAgICBpZiAocmVzdWx0KSB7XG5cdCAgICAgIHJldHVybiBnZXRUYWlsKHJlc3VsdCwgZGlyZWN0aW9uKTtcblx0ICAgIH1cblx0ICB9XG5cdCAgLyoqXG5cdCAgICogTW92ZXMgdGhlIGNhcmV0IHRvIHRoZSBzcGVjaWZpZWQgaW5kZXguXG5cdCAgICpcblx0ICAgKiBUaGUgaW5wdXQgbXVzdCBiZSBtb3ZlZCBieSBsZWF2aW5nIGl0IGluIHBsYWNlIGFuZCBtb3ZpbmcgdGhlXG5cdCAgICogc2libGluZ3MsIGR1ZSB0byB0aGUgZmFjdCB0aGF0IGZvY3VzIGNhbm5vdCBiZSByZXN0b3JlZCBvbmNlIGxvc3Rcblx0ICAgKiBvbiBtb2JpbGUgd2Via2l0IGRldmljZXNcblx0ICAgKlxuXHQgICAqL1xuXG5cblx0ICBzZXRDYXJldChuZXdfcG9zKSB7XG5cdCAgICB0aGlzLmNhcmV0UG9zID0gdGhpcy5pdGVtcy5sZW5ndGg7XG5cdCAgfVxuXHQgIC8qKlxuXHQgICAqIFJldHVybiBsaXN0IG9mIGl0ZW0gZG9tIGVsZW1lbnRzXG5cdCAgICpcblx0ICAgKi9cblxuXG5cdCAgY29udHJvbENoaWxkcmVuKCkge1xuXHQgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5jb250cm9sLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXRzLWl0ZW1dJykpO1xuXHQgIH1cblx0ICAvKipcblx0ICAgKiBEaXNhYmxlcyB1c2VyIGlucHV0IG9uIHRoZSBjb250cm9sLiBVc2VkIHdoaWxlXG5cdCAgICogaXRlbXMgYXJlIGJlaW5nIGFzeW5jaHJvbm91c2x5IGNyZWF0ZWQuXG5cdCAgICovXG5cblxuXHQgIGxvY2soKSB7XG5cdCAgICB0aGlzLmlzTG9ja2VkID0gdHJ1ZTtcblx0ICAgIHRoaXMucmVmcmVzaFN0YXRlKCk7XG5cdCAgfVxuXHQgIC8qKlxuXHQgICAqIFJlLWVuYWJsZXMgdXNlciBpbnB1dCBvbiB0aGUgY29udHJvbC5cblx0ICAgKi9cblxuXG5cdCAgdW5sb2NrKCkge1xuXHQgICAgdGhpcy5pc0xvY2tlZCA9IGZhbHNlO1xuXHQgICAgdGhpcy5yZWZyZXNoU3RhdGUoKTtcblx0ICB9XG5cdCAgLyoqXG5cdCAgICogRGlzYWJsZXMgdXNlciBpbnB1dCBvbiB0aGUgY29udHJvbCBjb21wbGV0ZWx5LlxuXHQgICAqIFdoaWxlIGRpc2FibGVkLCBpdCBjYW5ub3QgcmVjZWl2ZSBmb2N1cy5cblx0ICAgKi9cblxuXG5cdCAgZGlzYWJsZSgpIHtcblx0ICAgIHZhciBzZWxmID0gdGhpcztcblx0ICAgIHNlbGYuaW5wdXQuZGlzYWJsZWQgPSB0cnVlO1xuXHQgICAgc2VsZi5jb250cm9sX2lucHV0LmRpc2FibGVkID0gdHJ1ZTtcblx0ICAgIHNlbGYuZm9jdXNfbm9kZS50YWJJbmRleCA9IC0xO1xuXHQgICAgc2VsZi5pc0Rpc2FibGVkID0gdHJ1ZTtcblx0ICAgIHRoaXMuY2xvc2UoKTtcblx0ICAgIHNlbGYubG9jaygpO1xuXHQgIH1cblx0ICAvKipcblx0ICAgKiBFbmFibGVzIHRoZSBjb250cm9sIHNvIHRoYXQgaXQgY2FuIHJlc3BvbmRcblx0ICAgKiB0byBmb2N1cyBhbmQgdXNlciBpbnB1dC5cblx0ICAgKi9cblxuXG5cdCAgZW5hYmxlKCkge1xuXHQgICAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgICAgc2VsZi5pbnB1dC5kaXNhYmxlZCA9IGZhbHNlO1xuXHQgICAgc2VsZi5jb250cm9sX2lucHV0LmRpc2FibGVkID0gZmFsc2U7XG5cdCAgICBzZWxmLmZvY3VzX25vZGUudGFiSW5kZXggPSBzZWxmLnRhYkluZGV4O1xuXHQgICAgc2VsZi5pc0Rpc2FibGVkID0gZmFsc2U7XG5cdCAgICBzZWxmLnVubG9jaygpO1xuXHQgIH1cblx0ICAvKipcblx0ICAgKiBDb21wbGV0ZWx5IGRlc3Ryb3lzIHRoZSBjb250cm9sIGFuZFxuXHQgICAqIHVuYmluZHMgYWxsIGV2ZW50IGxpc3RlbmVycyBzbyB0aGF0IGl0IGNhblxuXHQgICAqIGJlIGdhcmJhZ2UgY29sbGVjdGVkLlxuXHQgICAqL1xuXG5cblx0ICBkZXN0cm95KCkge1xuXHQgICAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgICAgdmFyIHJldmVydFNldHRpbmdzID0gc2VsZi5yZXZlcnRTZXR0aW5ncztcblx0ICAgIHNlbGYudHJpZ2dlcignZGVzdHJveScpO1xuXHQgICAgc2VsZi5vZmYoKTtcblx0ICAgIHNlbGYud3JhcHBlci5yZW1vdmUoKTtcblx0ICAgIHNlbGYuZHJvcGRvd24ucmVtb3ZlKCk7XG5cdCAgICBzZWxmLmlucHV0LmlubmVySFRNTCA9IHJldmVydFNldHRpbmdzLmlubmVySFRNTDtcblx0ICAgIHNlbGYuaW5wdXQudGFiSW5kZXggPSByZXZlcnRTZXR0aW5ncy50YWJJbmRleDtcblx0ICAgIHJlbW92ZUNsYXNzZXMoc2VsZi5pbnB1dCwgJ3RvbXNlbGVjdGVkJywgJ3RzLWhpZGRlbi1hY2Nlc3NpYmxlJyk7XG5cblx0ICAgIHNlbGYuX2Rlc3Ryb3koKTtcblxuXHQgICAgZGVsZXRlIHNlbGYuaW5wdXQudG9tc2VsZWN0O1xuXHQgIH1cblx0ICAvKipcblx0ICAgKiBBIGhlbHBlciBtZXRob2QgZm9yIHJlbmRlcmluZyBcIml0ZW1cIiBhbmRcblx0ICAgKiBcIm9wdGlvblwiIHRlbXBsYXRlcywgZ2l2ZW4gdGhlIGRhdGEuXG5cdCAgICpcblx0ICAgKi9cblxuXG5cdCAgcmVuZGVyKHRlbXBsYXRlTmFtZSwgZGF0YSkge1xuXHQgICAgdmFyIGlkLCBodG1sO1xuXHQgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cblx0ICAgIGlmICh0eXBlb2YgdGhpcy5zZXR0aW5ncy5yZW5kZXJbdGVtcGxhdGVOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICByZXR1cm4gbnVsbDtcblx0ICAgIH0gLy8gcmVuZGVyIG1hcmt1cFxuXG5cblx0ICAgIGh0bWwgPSBzZWxmLnNldHRpbmdzLnJlbmRlclt0ZW1wbGF0ZU5hbWVdLmNhbGwodGhpcywgZGF0YSwgZXNjYXBlX2h0bWwpO1xuXG5cdCAgICBpZiAoIWh0bWwpIHtcblx0ICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICB9XG5cblx0ICAgIGh0bWwgPSBnZXREb20oaHRtbCk7IC8vIGFkZCBtYW5kYXRvcnkgYXR0cmlidXRlc1xuXG5cdCAgICBpZiAodGVtcGxhdGVOYW1lID09PSAnb3B0aW9uJyB8fCB0ZW1wbGF0ZU5hbWUgPT09ICdvcHRpb25fY3JlYXRlJykge1xuXHQgICAgICBpZiAoZGF0YVtzZWxmLnNldHRpbmdzLmRpc2FibGVkRmllbGRdKSB7XG5cdCAgICAgICAgc2V0QXR0cihodG1sLCB7XG5cdCAgICAgICAgICAnYXJpYS1kaXNhYmxlZCc6ICd0cnVlJ1xuXHQgICAgICAgIH0pO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHNldEF0dHIoaHRtbCwge1xuXHQgICAgICAgICAgJ2RhdGEtc2VsZWN0YWJsZSc6ICcnXG5cdCAgICAgICAgfSk7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSBpZiAodGVtcGxhdGVOYW1lID09PSAnb3B0Z3JvdXAnKSB7XG5cdCAgICAgIGlkID0gZGF0YS5ncm91cFtzZWxmLnNldHRpbmdzLm9wdGdyb3VwVmFsdWVGaWVsZF07XG5cdCAgICAgIHNldEF0dHIoaHRtbCwge1xuXHQgICAgICAgICdkYXRhLWdyb3VwJzogaWRcblx0ICAgICAgfSk7XG5cblx0ICAgICAgaWYgKGRhdGEuZ3JvdXBbc2VsZi5zZXR0aW5ncy5kaXNhYmxlZEZpZWxkXSkge1xuXHQgICAgICAgIHNldEF0dHIoaHRtbCwge1xuXHQgICAgICAgICAgJ2RhdGEtZGlzYWJsZWQnOiAnJ1xuXHQgICAgICAgIH0pO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGlmICh0ZW1wbGF0ZU5hbWUgPT09ICdvcHRpb24nIHx8IHRlbXBsYXRlTmFtZSA9PT0gJ2l0ZW0nKSB7XG5cdCAgICAgIGNvbnN0IHZhbHVlID0gZ2V0X2hhc2goZGF0YVtzZWxmLnNldHRpbmdzLnZhbHVlRmllbGRdKTtcblx0ICAgICAgc2V0QXR0cihodG1sLCB7XG5cdCAgICAgICAgJ2RhdGEtdmFsdWUnOiB2YWx1ZVxuXHQgICAgICB9KTsgLy8gbWFrZSBzdXJlIHdlIGhhdmUgc29tZSBjbGFzc2VzIGlmIGEgdGVtcGxhdGUgaXMgb3ZlcndyaXR0ZW5cblxuXHQgICAgICBpZiAodGVtcGxhdGVOYW1lID09PSAnaXRlbScpIHtcblx0ICAgICAgICBhZGRDbGFzc2VzKGh0bWwsIHNlbGYuc2V0dGluZ3MuaXRlbUNsYXNzKTtcblx0ICAgICAgICBzZXRBdHRyKGh0bWwsIHtcblx0ICAgICAgICAgICdkYXRhLXRzLWl0ZW0nOiAnJ1xuXHQgICAgICAgIH0pO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGFkZENsYXNzZXMoaHRtbCwgc2VsZi5zZXR0aW5ncy5vcHRpb25DbGFzcyk7XG5cdCAgICAgICAgc2V0QXR0cihodG1sLCB7XG5cdCAgICAgICAgICByb2xlOiAnb3B0aW9uJyxcblx0ICAgICAgICAgIGlkOiBkYXRhLiRpZFxuXHQgICAgICAgIH0pOyAvLyB1cGRhdGUgY2FjaGVcblxuXHQgICAgICAgIGRhdGEuJGRpdiA9IGh0bWw7XG5cdCAgICAgICAgc2VsZi5vcHRpb25zW3ZhbHVlXSA9IGRhdGE7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGh0bWw7XG5cdCAgfVxuXHQgIC8qKlxuXHQgICAqIFR5cGUgZ3VhcmRlZCByZW5kZXJpbmdcblx0ICAgKlxuXHQgICAqL1xuXG5cblx0ICBfcmVuZGVyKHRlbXBsYXRlTmFtZSwgZGF0YSkge1xuXHQgICAgY29uc3QgaHRtbCA9IHRoaXMucmVuZGVyKHRlbXBsYXRlTmFtZSwgZGF0YSk7XG5cblx0ICAgIGlmIChodG1sID09IG51bGwpIHtcblx0ICAgICAgdGhyb3cgJ0hUTUxFbGVtZW50IGV4cGVjdGVkJztcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGh0bWw7XG5cdCAgfVxuXHQgIC8qKlxuXHQgICAqIENsZWFycyB0aGUgcmVuZGVyIGNhY2hlIGZvciBhIHRlbXBsYXRlLiBJZlxuXHQgICAqIG5vIHRlbXBsYXRlIGlzIGdpdmVuLCBjbGVhcnMgYWxsIHJlbmRlclxuXHQgICAqIGNhY2hlcy5cblx0ICAgKlxuXHQgICAqL1xuXG5cblx0ICBjbGVhckNhY2hlKCkge1xuXHQgICAgaXRlcmF0ZSQxKHRoaXMub3B0aW9ucywgb3B0aW9uID0+IHtcblx0ICAgICAgaWYgKG9wdGlvbi4kZGl2KSB7XG5cdCAgICAgICAgb3B0aW9uLiRkaXYucmVtb3ZlKCk7XG5cdCAgICAgICAgZGVsZXRlIG9wdGlvbi4kZGl2O1xuXHQgICAgICB9XG5cdCAgICB9KTtcblx0ICB9XG5cdCAgLyoqXG5cdCAgICogUmVtb3ZlcyBhIHZhbHVlIGZyb20gaXRlbSBhbmQgb3B0aW9uIGNhY2hlc1xuXHQgICAqXG5cdCAgICovXG5cblxuXHQgIHVuY2FjaGVWYWx1ZSh2YWx1ZSkge1xuXHQgICAgY29uc3Qgb3B0aW9uX2VsID0gdGhpcy5nZXRPcHRpb24odmFsdWUpO1xuXHQgICAgaWYgKG9wdGlvbl9lbCkgb3B0aW9uX2VsLnJlbW92ZSgpO1xuXHQgIH1cblx0ICAvKipcblx0ICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IHRvIGRpc3BsYXkgdGhlXG5cdCAgICogY3JlYXRlIGl0ZW0gcHJvbXB0LCBnaXZlbiBhIHVzZXIgaW5wdXQuXG5cdCAgICpcblx0ICAgKi9cblxuXG5cdCAgY2FuQ3JlYXRlKGlucHV0KSB7XG5cdCAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy5jcmVhdGUgJiYgaW5wdXQubGVuZ3RoID4gMCAmJiB0aGlzLnNldHRpbmdzLmNyZWF0ZUZpbHRlci5jYWxsKHRoaXMsIGlucHV0KTtcblx0ICB9XG5cdCAgLyoqXG5cdCAgICogV3JhcHMgdGhpcy5gbWV0aG9kYCBzbyB0aGF0IGBuZXdfZm5gIGNhbiBiZSBpbnZva2VkICdiZWZvcmUnLCAnYWZ0ZXInLCBvciAnaW5zdGVhZCcgb2YgdGhlIG9yaWdpbmFsIG1ldGhvZFxuXHQgICAqXG5cdCAgICogdGhpcy5ob29rKCdpbnN0ZWFkJywnb25LZXlEb3duJyxmdW5jdGlvbiggYXJnMSwgYXJnMiAuLi4pe1xuXHQgICAqXG5cdCAgICogfSk7XG5cdCAgICovXG5cblxuXHQgIGhvb2sod2hlbiwgbWV0aG9kLCBuZXdfZm4pIHtcblx0ICAgIHZhciBzZWxmID0gdGhpcztcblx0ICAgIHZhciBvcmlnX21ldGhvZCA9IHNlbGZbbWV0aG9kXTtcblxuXHQgICAgc2VsZlttZXRob2RdID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICB2YXIgcmVzdWx0LCByZXN1bHRfbmV3O1xuXG5cdCAgICAgIGlmICh3aGVuID09PSAnYWZ0ZXInKSB7XG5cdCAgICAgICAgcmVzdWx0ID0gb3JpZ19tZXRob2QuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHJlc3VsdF9uZXcgPSBuZXdfZm4uYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcblxuXHQgICAgICBpZiAod2hlbiA9PT0gJ2luc3RlYWQnKSB7XG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdF9uZXc7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAod2hlbiA9PT0gJ2JlZm9yZScpIHtcblx0ICAgICAgICByZXN1bHQgPSBvcmlnX21ldGhvZC5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH07XG5cdCAgfVxuXG5cdH1cblxuXHQvKipcblx0ICogUGx1Z2luOiBcImNoYW5nZV9saXN0ZW5lclwiIChUb20gU2VsZWN0KVxuXHQgKiBDb3B5cmlnaHQgKGMpIGNvbnRyaWJ1dG9yc1xuXHQgKlxuXHQgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xuXHQgKiBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcblx0ICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cdCAqXG5cdCAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcblx0ICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRlxuXHQgKiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2Vcblx0ICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblx0ICpcblx0ICovXG5cdGZ1bmN0aW9uIGNoYW5nZV9saXN0ZW5lciAoKSB7XG5cdCAgYWRkRXZlbnQodGhpcy5pbnB1dCwgJ2NoYW5nZScsICgpID0+IHtcblx0ICAgIHRoaXMuc3luYygpO1xuXHQgIH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFBsdWdpbjogXCJyZXN0b3JlX29uX2JhY2tzcGFjZVwiIChUb20gU2VsZWN0KVxuXHQgKiBDb3B5cmlnaHQgKGMpIGNvbnRyaWJ1dG9yc1xuXHQgKlxuXHQgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xuXHQgKiBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcblx0ICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cdCAqXG5cdCAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcblx0ICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRlxuXHQgKiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2Vcblx0ICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblx0ICpcblx0ICovXG5cdGZ1bmN0aW9uIGNoZWNrYm94X29wdGlvbnMgKCkge1xuXHQgIHZhciBzZWxmID0gdGhpcztcblx0ICB2YXIgb3JpZ19vbk9wdGlvblNlbGVjdCA9IHNlbGYub25PcHRpb25TZWxlY3Q7XG5cdCAgc2VsZi5zZXR0aW5ncy5oaWRlU2VsZWN0ZWQgPSBmYWxzZTsgLy8gdXBkYXRlIHRoZSBjaGVja2JveCBmb3IgYW4gb3B0aW9uXG5cblx0ICB2YXIgVXBkYXRlQ2hlY2tib3ggPSBmdW5jdGlvbiBVcGRhdGVDaGVja2JveChvcHRpb24pIHtcblx0ICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuXHQgICAgICB2YXIgY2hlY2tib3ggPSBvcHRpb24ucXVlcnlTZWxlY3RvcignaW5wdXQnKTtcblxuXHQgICAgICBpZiAoY2hlY2tib3ggaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50KSB7XG5cdCAgICAgICAgaWYgKG9wdGlvbi5jbGFzc0xpc3QuY29udGFpbnMoJ3NlbGVjdGVkJykpIHtcblx0ICAgICAgICAgIGNoZWNrYm94LmNoZWNrZWQgPSB0cnVlO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBjaGVja2JveC5jaGVja2VkID0gZmFsc2U7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9LCAxKTtcblx0ICB9OyAvLyBhZGQgY2hlY2tib3ggdG8gb3B0aW9uIHRlbXBsYXRlXG5cblxuXHQgIHNlbGYuaG9vaygnYWZ0ZXInLCAnc2V0dXBUZW1wbGF0ZXMnLCAoKSA9PiB7XG5cdCAgICB2YXIgb3JpZ19yZW5kZXJfb3B0aW9uID0gc2VsZi5zZXR0aW5ncy5yZW5kZXIub3B0aW9uO1xuXG5cdCAgICBzZWxmLnNldHRpbmdzLnJlbmRlci5vcHRpb24gPSAoZGF0YSwgZXNjYXBlX2h0bWwpID0+IHtcblx0ICAgICAgdmFyIHJlbmRlcmVkID0gZ2V0RG9tKG9yaWdfcmVuZGVyX29wdGlvbi5jYWxsKHNlbGYsIGRhdGEsIGVzY2FwZV9odG1sKSk7XG5cdCAgICAgIHZhciBjaGVja2JveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG5cdCAgICAgIGNoZWNrYm94LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKGV2dCkge1xuXHQgICAgICAgIHByZXZlbnREZWZhdWx0KGV2dCk7XG5cdCAgICAgIH0pO1xuXHQgICAgICBjaGVja2JveC50eXBlID0gJ2NoZWNrYm94Jztcblx0ICAgICAgY29uc3QgaGFzaGVkID0gaGFzaF9rZXkoZGF0YVtzZWxmLnNldHRpbmdzLnZhbHVlRmllbGRdKTtcblxuXHQgICAgICBpZiAoaGFzaGVkICYmIHNlbGYuaXRlbXMuaW5kZXhPZihoYXNoZWQpID4gLTEpIHtcblx0ICAgICAgICBjaGVja2JveC5jaGVja2VkID0gdHJ1ZTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHJlbmRlcmVkLnByZXBlbmQoY2hlY2tib3gpO1xuXHQgICAgICByZXR1cm4gcmVuZGVyZWQ7XG5cdCAgICB9O1xuXHQgIH0pOyAvLyB1bmNoZWNrIHdoZW4gaXRlbSByZW1vdmVkXG5cblx0ICBzZWxmLm9uKCdpdGVtX3JlbW92ZScsIHZhbHVlID0+IHtcblx0ICAgIHZhciBvcHRpb24gPSBzZWxmLmdldE9wdGlvbih2YWx1ZSk7XG5cblx0ICAgIGlmIChvcHRpb24pIHtcblx0ICAgICAgLy8gaWYgZHJvcGRvd24gaGFzbid0IGJlZW4gb3BlbmVkIHlldCwgdGhlIG9wdGlvbiB3b24ndCBleGlzdFxuXHQgICAgICBvcHRpb24uY2xhc3NMaXN0LnJlbW92ZSgnc2VsZWN0ZWQnKTsgLy8gc2VsZWN0ZWQgY2xhc3Mgd29uJ3QgYmUgcmVtb3ZlZCB5ZXRcblxuXHQgICAgICBVcGRhdGVDaGVja2JveChvcHRpb24pO1xuXHQgICAgfVxuXHQgIH0pOyAvLyBjaGVjayB3aGVuIGl0ZW0gYWRkZWRcblxuXHQgIHNlbGYub24oJ2l0ZW1fYWRkJywgdmFsdWUgPT4ge1xuXHQgICAgdmFyIG9wdGlvbiA9IHNlbGYuZ2V0T3B0aW9uKHZhbHVlKTtcblxuXHQgICAgaWYgKG9wdGlvbikge1xuXHQgICAgICAvLyBpZiBkcm9wZG93biBoYXNuJ3QgYmVlbiBvcGVuZWQgeWV0LCB0aGUgb3B0aW9uIHdvbid0IGV4aXN0XG5cdCAgICAgIFVwZGF0ZUNoZWNrYm94KG9wdGlvbik7XG5cdCAgICB9XG5cdCAgfSk7IC8vIHJlbW92ZSBpdGVtcyB3aGVuIHNlbGVjdGVkIG9wdGlvbiBpcyBjbGlja2VkXG5cblx0ICBzZWxmLmhvb2soJ2luc3RlYWQnLCAnb25PcHRpb25TZWxlY3QnLCAoZXZ0LCBvcHRpb24pID0+IHtcblx0ICAgIGlmIChvcHRpb24uY2xhc3NMaXN0LmNvbnRhaW5zKCdzZWxlY3RlZCcpKSB7XG5cdCAgICAgIG9wdGlvbi5jbGFzc0xpc3QucmVtb3ZlKCdzZWxlY3RlZCcpO1xuXHQgICAgICBzZWxmLnJlbW92ZUl0ZW0ob3B0aW9uLmRhdGFzZXQudmFsdWUpO1xuXHQgICAgICBzZWxmLnJlZnJlc2hPcHRpb25zKCk7XG5cdCAgICAgIHByZXZlbnREZWZhdWx0KGV2dCwgdHJ1ZSk7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgb3JpZ19vbk9wdGlvblNlbGVjdC5jYWxsKHNlbGYsIGV2dCwgb3B0aW9uKTtcblx0ICAgIFVwZGF0ZUNoZWNrYm94KG9wdGlvbik7XG5cdCAgfSk7XG5cdH1cblxuXHQvKipcblx0ICogUGx1Z2luOiBcImRyb3Bkb3duX2hlYWRlclwiIChUb20gU2VsZWN0KVxuXHQgKiBDb3B5cmlnaHQgKGMpIGNvbnRyaWJ1dG9yc1xuXHQgKlxuXHQgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xuXHQgKiBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcblx0ICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cdCAqXG5cdCAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcblx0ICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRlxuXHQgKiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2Vcblx0ICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblx0ICpcblx0ICovXG5cdGZ1bmN0aW9uIGNsZWFyX2J1dHRvbiAodXNlck9wdGlvbnMpIHtcblx0ICBjb25zdCBzZWxmID0gdGhpcztcblx0ICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG5cdCAgICBjbGFzc05hbWU6ICdjbGVhci1idXR0b24nLFxuXHQgICAgdGl0bGU6ICdDbGVhciBBbGwnLFxuXHQgICAgaHRtbDogZGF0YSA9PiB7XG5cdCAgICAgIHJldHVybiBgPGRpdiBjbGFzcz1cIiR7ZGF0YS5jbGFzc05hbWV9XCIgdGl0bGU9XCIke2RhdGEudGl0bGV9XCI+JiMxMDc5OTs8L2Rpdj5gO1xuXHQgICAgfVxuXHQgIH0sIHVzZXJPcHRpb25zKTtcblx0ICBzZWxmLm9uKCdpbml0aWFsaXplJywgKCkgPT4ge1xuXHQgICAgdmFyIGJ1dHRvbiA9IGdldERvbShvcHRpb25zLmh0bWwob3B0aW9ucykpO1xuXHQgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZXZ0ID0+IHtcblx0ICAgICAgaWYgKHNlbGYuaXNEaXNhYmxlZCkge1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXG5cdCAgICAgIHNlbGYuY2xlYXIoKTtcblxuXHQgICAgICBpZiAoc2VsZi5zZXR0aW5ncy5tb2RlID09PSAnc2luZ2xlJyAmJiBzZWxmLnNldHRpbmdzLmFsbG93RW1wdHlPcHRpb24pIHtcblx0ICAgICAgICBzZWxmLmFkZEl0ZW0oJycpO1xuXHQgICAgICB9XG5cblx0ICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG5cdCAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcblx0ICAgIH0pO1xuXHQgICAgc2VsZi5jb250cm9sLmFwcGVuZENoaWxkKGJ1dHRvbik7XG5cdCAgfSk7XG5cdH1cblxuXHQvKipcblx0ICogUGx1Z2luOiBcImRyYWdfZHJvcFwiIChUb20gU2VsZWN0KVxuXHQgKiBDb3B5cmlnaHQgKGMpIGNvbnRyaWJ1dG9yc1xuXHQgKlxuXHQgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xuXHQgKiBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcblx0ICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cdCAqXG5cdCAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcblx0ICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRlxuXHQgKiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2Vcblx0ICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblx0ICpcblx0ICovXG5cdGZ1bmN0aW9uIGRyYWdfZHJvcCAoKSB7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgIGlmICghJC5mbi5zb3J0YWJsZSkgdGhyb3cgbmV3IEVycm9yKCdUaGUgXCJkcmFnX2Ryb3BcIiBwbHVnaW4gcmVxdWlyZXMgalF1ZXJ5IFVJIFwic29ydGFibGVcIi4nKTtcblx0ICBpZiAoc2VsZi5zZXR0aW5ncy5tb2RlICE9PSAnbXVsdGknKSByZXR1cm47XG5cdCAgdmFyIG9yaWdfbG9jayA9IHNlbGYubG9jaztcblx0ICB2YXIgb3JpZ191bmxvY2sgPSBzZWxmLnVubG9jaztcblx0ICBzZWxmLmhvb2soJ2luc3RlYWQnLCAnbG9jaycsICgpID0+IHtcblx0ICAgIHZhciBzb3J0YWJsZSA9ICQoc2VsZi5jb250cm9sKS5kYXRhKCdzb3J0YWJsZScpO1xuXHQgICAgaWYgKHNvcnRhYmxlKSBzb3J0YWJsZS5kaXNhYmxlKCk7XG5cdCAgICByZXR1cm4gb3JpZ19sb2NrLmNhbGwoc2VsZik7XG5cdCAgfSk7XG5cdCAgc2VsZi5ob29rKCdpbnN0ZWFkJywgJ3VubG9jaycsICgpID0+IHtcblx0ICAgIHZhciBzb3J0YWJsZSA9ICQoc2VsZi5jb250cm9sKS5kYXRhKCdzb3J0YWJsZScpO1xuXHQgICAgaWYgKHNvcnRhYmxlKSBzb3J0YWJsZS5lbmFibGUoKTtcblx0ICAgIHJldHVybiBvcmlnX3VubG9jay5jYWxsKHNlbGYpO1xuXHQgIH0pO1xuXHQgIHNlbGYub24oJ2luaXRpYWxpemUnLCAoKSA9PiB7XG5cdCAgICB2YXIgJGNvbnRyb2wgPSAkKHNlbGYuY29udHJvbCkuc29ydGFibGUoe1xuXHQgICAgICBpdGVtczogJ1tkYXRhLXZhbHVlXScsXG5cdCAgICAgIGZvcmNlUGxhY2Vob2xkZXJTaXplOiB0cnVlLFxuXHQgICAgICBkaXNhYmxlZDogc2VsZi5pc0xvY2tlZCxcblx0ICAgICAgc3RhcnQ6IChlLCB1aSkgPT4ge1xuXHQgICAgICAgIHVpLnBsYWNlaG9sZGVyLmNzcygnd2lkdGgnLCB1aS5oZWxwZXIuY3NzKCd3aWR0aCcpKTtcblx0ICAgICAgICAkY29udHJvbC5jc3Moe1xuXHQgICAgICAgICAgb3ZlcmZsb3c6ICd2aXNpYmxlJ1xuXHQgICAgICAgIH0pO1xuXHQgICAgICB9LFxuXHQgICAgICBzdG9wOiAoKSA9PiB7XG5cdCAgICAgICAgJGNvbnRyb2wuY3NzKHtcblx0ICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJ1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcblx0ICAgICAgICAkY29udHJvbC5jaGlsZHJlbignW2RhdGEtdmFsdWVdJykuZWFjaChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICBpZiAodGhpcy5kYXRhc2V0LnZhbHVlKSB2YWx1ZXMucHVzaCh0aGlzLmRhdGFzZXQudmFsdWUpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHNlbGYuc2V0VmFsdWUodmFsdWVzKTtcblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdCAgfSk7XG5cdH1cblxuXHQvKipcblx0ICogUGx1Z2luOiBcImRyb3Bkb3duX2hlYWRlclwiIChUb20gU2VsZWN0KVxuXHQgKiBDb3B5cmlnaHQgKGMpIGNvbnRyaWJ1dG9yc1xuXHQgKlxuXHQgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xuXHQgKiBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcblx0ICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cdCAqXG5cdCAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcblx0ICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRlxuXHQgKiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2Vcblx0ICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblx0ICpcblx0ICovXG5cdGZ1bmN0aW9uIGRyb3Bkb3duX2hlYWRlciAodXNlck9wdGlvbnMpIHtcblx0ICBjb25zdCBzZWxmID0gdGhpcztcblx0ICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG5cdCAgICB0aXRsZTogJ1VudGl0bGVkJyxcblx0ICAgIGhlYWRlckNsYXNzOiAnZHJvcGRvd24taGVhZGVyJyxcblx0ICAgIHRpdGxlUm93Q2xhc3M6ICdkcm9wZG93bi1oZWFkZXItdGl0bGUnLFxuXHQgICAgbGFiZWxDbGFzczogJ2Ryb3Bkb3duLWhlYWRlci1sYWJlbCcsXG5cdCAgICBjbG9zZUNsYXNzOiAnZHJvcGRvd24taGVhZGVyLWNsb3NlJyxcblx0ICAgIGh0bWw6IGRhdGEgPT4ge1xuXHQgICAgICByZXR1cm4gJzxkaXYgY2xhc3M9XCInICsgZGF0YS5oZWFkZXJDbGFzcyArICdcIj4nICsgJzxkaXYgY2xhc3M9XCInICsgZGF0YS50aXRsZVJvd0NsYXNzICsgJ1wiPicgKyAnPHNwYW4gY2xhc3M9XCInICsgZGF0YS5sYWJlbENsYXNzICsgJ1wiPicgKyBkYXRhLnRpdGxlICsgJzwvc3Bhbj4nICsgJzxhIGNsYXNzPVwiJyArIGRhdGEuY2xvc2VDbGFzcyArICdcIj4mdGltZXM7PC9hPicgKyAnPC9kaXY+JyArICc8L2Rpdj4nO1xuXHQgICAgfVxuXHQgIH0sIHVzZXJPcHRpb25zKTtcblx0ICBzZWxmLm9uKCdpbml0aWFsaXplJywgKCkgPT4ge1xuXHQgICAgdmFyIGhlYWRlciA9IGdldERvbShvcHRpb25zLmh0bWwob3B0aW9ucykpO1xuXHQgICAgdmFyIGNsb3NlX2xpbmsgPSBoZWFkZXIucXVlcnlTZWxlY3RvcignLicgKyBvcHRpb25zLmNsb3NlQ2xhc3MpO1xuXG5cdCAgICBpZiAoY2xvc2VfbGluaykge1xuXHQgICAgICBjbG9zZV9saW5rLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZXZ0ID0+IHtcblx0ICAgICAgICBwcmV2ZW50RGVmYXVsdChldnQsIHRydWUpO1xuXHQgICAgICAgIHNlbGYuY2xvc2UoKTtcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cblx0ICAgIHNlbGYuZHJvcGRvd24uaW5zZXJ0QmVmb3JlKGhlYWRlciwgc2VsZi5kcm9wZG93bi5maXJzdENoaWxkKTtcblx0ICB9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBQbHVnaW46IFwiZHJvcGRvd25faW5wdXRcIiAoVG9tIFNlbGVjdClcblx0ICogQ29weXJpZ2h0IChjKSBjb250cmlidXRvcnNcblx0ICpcblx0ICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXNcblx0ICogZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XG5cdCAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXHQgKlxuXHQgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG5cdCAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0Zcblx0ICogQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG5cdCAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cdCAqXG5cdCAqL1xuXHRmdW5jdGlvbiBjYXJldF9wb3NpdGlvbiAoKSB7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgIC8qKlxuXHQgICAqIE1vdmVzIHRoZSBjYXJldCB0byB0aGUgc3BlY2lmaWVkIGluZGV4LlxuXHQgICAqXG5cdCAgICogVGhlIGlucHV0IG11c3QgYmUgbW92ZWQgYnkgbGVhdmluZyBpdCBpbiBwbGFjZSBhbmQgbW92aW5nIHRoZVxuXHQgICAqIHNpYmxpbmdzLCBkdWUgdG8gdGhlIGZhY3QgdGhhdCBmb2N1cyBjYW5ub3QgYmUgcmVzdG9yZWQgb25jZSBsb3N0XG5cdCAgICogb24gbW9iaWxlIHdlYmtpdCBkZXZpY2VzXG5cdCAgICpcblx0ICAgKi9cblxuXHQgIHNlbGYuaG9vaygnaW5zdGVhZCcsICdzZXRDYXJldCcsIG5ld19wb3MgPT4ge1xuXHQgICAgaWYgKHNlbGYuc2V0dGluZ3MubW9kZSA9PT0gJ3NpbmdsZScgfHwgIXNlbGYuY29udHJvbC5jb250YWlucyhzZWxmLmNvbnRyb2xfaW5wdXQpKSB7XG5cdCAgICAgIG5ld19wb3MgPSBzZWxmLml0ZW1zLmxlbmd0aDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIG5ld19wb3MgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihzZWxmLml0ZW1zLmxlbmd0aCwgbmV3X3BvcykpO1xuXG5cdCAgICAgIGlmIChuZXdfcG9zICE9IHNlbGYuY2FyZXRQb3MgJiYgIXNlbGYuaXNQZW5kaW5nKSB7XG5cdCAgICAgICAgc2VsZi5jb250cm9sQ2hpbGRyZW4oKS5mb3JFYWNoKChjaGlsZCwgaikgPT4ge1xuXHQgICAgICAgICAgaWYgKGogPCBuZXdfcG9zKSB7XG5cdCAgICAgICAgICAgIHNlbGYuY29udHJvbF9pbnB1dC5pbnNlcnRBZGphY2VudEVsZW1lbnQoJ2JlZm9yZWJlZ2luJywgY2hpbGQpO1xuXHQgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgc2VsZi5jb250cm9sLmFwcGVuZENoaWxkKGNoaWxkKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBzZWxmLmNhcmV0UG9zID0gbmV3X3Bvcztcblx0ICB9KTtcblx0ICBzZWxmLmhvb2soJ2luc3RlYWQnLCAnbW92ZUNhcmV0JywgZGlyZWN0aW9uID0+IHtcblx0ICAgIGlmICghc2VsZi5pc0ZvY3VzZWQpIHJldHVybjsgLy8gbW92ZSBjYXJldCBiZWZvcmUgb3IgYWZ0ZXIgc2VsZWN0ZWQgaXRlbXNcblxuXHQgICAgY29uc3QgbGFzdF9hY3RpdmUgPSBzZWxmLmdldExhc3RBY3RpdmUoZGlyZWN0aW9uKTtcblxuXHQgICAgaWYgKGxhc3RfYWN0aXZlKSB7XG5cdCAgICAgIGNvbnN0IGlkeCA9IG5vZGVJbmRleChsYXN0X2FjdGl2ZSk7XG5cdCAgICAgIHNlbGYuc2V0Q2FyZXQoZGlyZWN0aW9uID4gMCA/IGlkeCArIDEgOiBpZHgpO1xuXHQgICAgICBzZWxmLnNldEFjdGl2ZUl0ZW0oKTtcblx0ICAgICAgcmVtb3ZlQ2xhc3NlcyhsYXN0X2FjdGl2ZSwgJ2xhc3QtYWN0aXZlJyk7IC8vIG1vdmUgY2FyZXQgbGVmdCBvciByaWdodCBvZiBjdXJyZW50IHBvc2l0aW9uXG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBzZWxmLnNldENhcmV0KHNlbGYuY2FyZXRQb3MgKyBkaXJlY3Rpb24pO1xuXHQgICAgfVxuXHQgIH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFBsdWdpbjogXCJkcm9wZG93bl9pbnB1dFwiIChUb20gU2VsZWN0KVxuXHQgKiBDb3B5cmlnaHQgKGMpIGNvbnRyaWJ1dG9yc1xuXHQgKlxuXHQgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xuXHQgKiBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcblx0ICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cdCAqXG5cdCAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcblx0ICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRlxuXHQgKiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2Vcblx0ICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblx0ICpcblx0ICovXG5cdGZ1bmN0aW9uIGRyb3Bkb3duX2lucHV0ICgpIHtcblx0ICBjb25zdCBzZWxmID0gdGhpcztcblx0ICBzZWxmLnNldHRpbmdzLnNob3VsZE9wZW4gPSB0cnVlOyAvLyBtYWtlIHN1cmUgdGhlIGlucHV0IGlzIHNob3duIGV2ZW4gaWYgdGhlcmUgYXJlIG5vIG9wdGlvbnMgdG8gZGlzcGxheSBpbiB0aGUgZHJvcGRvd25cblxuXHQgIHNlbGYuaG9vaygnYmVmb3JlJywgJ3NldHVwJywgKCkgPT4ge1xuXHQgICAgc2VsZi5mb2N1c19ub2RlID0gc2VsZi5jb250cm9sO1xuXHQgICAgYWRkQ2xhc3NlcyhzZWxmLmNvbnRyb2xfaW5wdXQsICdkcm9wZG93bi1pbnB1dCcpO1xuXHQgICAgY29uc3QgZGl2ID0gZ2V0RG9tKCc8ZGl2IGNsYXNzPVwiZHJvcGRvd24taW5wdXQtd3JhcFwiPicpO1xuXHQgICAgZGl2LmFwcGVuZChzZWxmLmNvbnRyb2xfaW5wdXQpO1xuXHQgICAgc2VsZi5kcm9wZG93bi5pbnNlcnRCZWZvcmUoZGl2LCBzZWxmLmRyb3Bkb3duLmZpcnN0Q2hpbGQpOyAvLyBzZXQgYSBwbGFjZWhvbGRlciBpbiB0aGUgc2VsZWN0IGNvbnRyb2xcblxuXHQgICAgY29uc3QgcGxhY2Vob2xkZXIgPSBnZXREb20oJzxpbnB1dCBjbGFzcz1cIml0ZW1zLXBsYWNlaG9sZGVyXCIgdGFiaW5kZXg9XCItMVwiIC8+Jyk7XG5cdCAgICBwbGFjZWhvbGRlci5wbGFjZWhvbGRlciA9IHNlbGYuc2V0dGluZ3MucGxhY2Vob2xkZXIgfHwgJyc7XG5cdCAgICBzZWxmLmNvbnRyb2wuYXBwZW5kKHBsYWNlaG9sZGVyKTtcblx0ICB9KTtcblx0ICBzZWxmLm9uKCdpbml0aWFsaXplJywgKCkgPT4ge1xuXHQgICAgLy8gc2V0IHRhYkluZGV4IG9uIGNvbnRyb2wgdG8gLTEsIG90aGVyd2lzZSBbc2hpZnQrdGFiXSB3aWxsIHB1dCBmb2N1cyByaWdodCBiYWNrIG9uIGNvbnRyb2xfaW5wdXRcblx0ICAgIHNlbGYuY29udHJvbF9pbnB1dC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZXZ0ID0+IHtcblx0ICAgICAgLy9hZGRFdmVudChzZWxmLmNvbnRyb2xfaW5wdXQsJ2tleWRvd24nIGFzIGNvbnN0LChldnQ6S2V5Ym9hcmRFdmVudCkgPT57XG5cdCAgICAgIHN3aXRjaCAoZXZ0LmtleUNvZGUpIHtcblx0ICAgICAgICBjYXNlIEtFWV9FU0M6XG5cdCAgICAgICAgICBpZiAoc2VsZi5pc09wZW4pIHtcblx0ICAgICAgICAgICAgcHJldmVudERlZmF1bHQoZXZ0LCB0cnVlKTtcblx0ICAgICAgICAgICAgc2VsZi5jbG9zZSgpO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBzZWxmLmNsZWFyQWN0aXZlSXRlbXMoKTtcblx0ICAgICAgICAgIHJldHVybjtcblxuXHQgICAgICAgIGNhc2UgS0VZX1RBQjpcblx0ICAgICAgICAgIHNlbGYuZm9jdXNfbm9kZS50YWJJbmRleCA9IC0xO1xuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm4gc2VsZi5vbktleURvd24uY2FsbChzZWxmLCBldnQpO1xuXHQgICAgfSk7XG5cdCAgICBzZWxmLm9uKCdibHVyJywgKCkgPT4ge1xuXHQgICAgICBzZWxmLmZvY3VzX25vZGUudGFiSW5kZXggPSBzZWxmLmlzRGlzYWJsZWQgPyAtMSA6IHNlbGYudGFiSW5kZXg7XG5cdCAgICB9KTsgLy8gZ2l2ZSB0aGUgY29udHJvbF9pbnB1dCBmb2N1cyB3aGVuIHRoZSBkcm9wZG93biBpcyBvcGVuXG5cblx0ICAgIHNlbGYub24oJ2Ryb3Bkb3duX29wZW4nLCAoKSA9PiB7XG5cdCAgICAgIHNlbGYuY29udHJvbF9pbnB1dC5mb2N1cygpO1xuXHQgICAgfSk7IC8vIHByZXZlbnQgb25CbHVyIGZyb20gY2xvc2luZyB3aGVuIGZvY3VzIGlzIG9uIHRoZSBjb250cm9sX2lucHV0XG5cblx0ICAgIGNvbnN0IG9yaWdfb25CbHVyID0gc2VsZi5vbkJsdXI7XG5cdCAgICBzZWxmLmhvb2soJ2luc3RlYWQnLCAnb25CbHVyJywgZXZ0ID0+IHtcblx0ICAgICAgaWYgKGV2dCAmJiBldnQucmVsYXRlZFRhcmdldCA9PSBzZWxmLmNvbnRyb2xfaW5wdXQpIHJldHVybjtcblx0ICAgICAgcmV0dXJuIG9yaWdfb25CbHVyLmNhbGwoc2VsZik7XG5cdCAgICB9KTtcblx0ICAgIGFkZEV2ZW50KHNlbGYuY29udHJvbF9pbnB1dCwgJ2JsdXInLCAoKSA9PiBzZWxmLm9uQmx1cigpKTsgLy8gcmV0dXJuIGZvY3VzIHRvIGNvbnRyb2wgdG8gYWxsb3cgZnVydGhlciBrZXlib2FyZCBpbnB1dFxuXG5cdCAgICBzZWxmLmhvb2soJ2JlZm9yZScsICdjbG9zZScsICgpID0+IHtcblx0ICAgICAgaWYgKCFzZWxmLmlzT3BlbikgcmV0dXJuO1xuXHQgICAgICBzZWxmLmZvY3VzX25vZGUuZm9jdXMoe1xuXHQgICAgICAgIHByZXZlbnRTY3JvbGw6IHRydWVcblx0ICAgICAgfSk7XG5cdCAgICB9KTtcblx0ICB9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBQbHVnaW46IFwiaW5wdXRfYXV0b2dyb3dcIiAoVG9tIFNlbGVjdClcblx0ICpcblx0ICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXNcblx0ICogZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XG5cdCAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXHQgKlxuXHQgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG5cdCAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0Zcblx0ICogQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG5cdCAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cdCAqXG5cdCAqL1xuXHRmdW5jdGlvbiBpbnB1dF9hdXRvZ3JvdyAoKSB7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgIHNlbGYub24oJ2luaXRpYWxpemUnLCAoKSA9PiB7XG5cdCAgICB2YXIgdGVzdF9pbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcblx0ICAgIHZhciBjb250cm9sID0gc2VsZi5jb250cm9sX2lucHV0O1xuXHQgICAgdGVzdF9pbnB1dC5zdHlsZS5jc3NUZXh0ID0gJ3Bvc2l0aW9uOmFic29sdXRlOyB0b3A6LTk5OTk5cHg7IGxlZnQ6LTk5OTk5cHg7IHdpZHRoOmF1dG87IHBhZGRpbmc6MDsgd2hpdGUtc3BhY2U6cHJlOyAnO1xuXHQgICAgc2VsZi53cmFwcGVyLmFwcGVuZENoaWxkKHRlc3RfaW5wdXQpO1xuXHQgICAgdmFyIHRyYW5zZmVyX3N0eWxlcyA9IFsnbGV0dGVyU3BhY2luZycsICdmb250U2l6ZScsICdmb250RmFtaWx5JywgJ2ZvbnRXZWlnaHQnLCAndGV4dFRyYW5zZm9ybSddO1xuXG5cdCAgICBmb3IgKGNvbnN0IHN0eWxlX25hbWUgb2YgdHJhbnNmZXJfc3R5bGVzKSB7XG5cdCAgICAgIC8vIEB0cy1pZ25vcmUgVFM3MDE1IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81MDUwNjE1NC82OTc1NzZcblx0ICAgICAgdGVzdF9pbnB1dC5zdHlsZVtzdHlsZV9uYW1lXSA9IGNvbnRyb2wuc3R5bGVbc3R5bGVfbmFtZV07XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIFNldCB0aGUgY29udHJvbCB3aWR0aFxuXHQgICAgICpcblx0ICAgICAqL1xuXG5cblx0ICAgIHZhciByZXNpemUgPSAoKSA9PiB7XG5cdCAgICAgIHRlc3RfaW5wdXQudGV4dENvbnRlbnQgPSBjb250cm9sLnZhbHVlO1xuXHQgICAgICBjb250cm9sLnN0eWxlLndpZHRoID0gdGVzdF9pbnB1dC5jbGllbnRXaWR0aCArICdweCc7XG5cdCAgICB9O1xuXG5cdCAgICByZXNpemUoKTtcblx0ICAgIHNlbGYub24oJ3VwZGF0ZSBpdGVtX2FkZCBpdGVtX3JlbW92ZScsIHJlc2l6ZSk7XG5cdCAgICBhZGRFdmVudChjb250cm9sLCAnaW5wdXQnLCByZXNpemUpO1xuXHQgICAgYWRkRXZlbnQoY29udHJvbCwgJ2tleXVwJywgcmVzaXplKTtcblx0ICAgIGFkZEV2ZW50KGNvbnRyb2wsICdibHVyJywgcmVzaXplKTtcblx0ICAgIGFkZEV2ZW50KGNvbnRyb2wsICd1cGRhdGUnLCByZXNpemUpO1xuXHQgIH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFBsdWdpbjogXCJpbnB1dF9hdXRvZ3Jvd1wiIChUb20gU2VsZWN0KVxuXHQgKlxuXHQgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xuXHQgKiBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcblx0ICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cdCAqXG5cdCAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcblx0ICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRlxuXHQgKiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2Vcblx0ICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblx0ICpcblx0ICovXG5cdGZ1bmN0aW9uIG5vX2JhY2tzcGFjZV9kZWxldGUgKCkge1xuXHQgIHZhciBzZWxmID0gdGhpcztcblx0ICB2YXIgb3JpZ19kZWxldGVTZWxlY3Rpb24gPSBzZWxmLmRlbGV0ZVNlbGVjdGlvbjtcblx0ICB0aGlzLmhvb2soJ2luc3RlYWQnLCAnZGVsZXRlU2VsZWN0aW9uJywgZXZ0ID0+IHtcblx0ICAgIGlmIChzZWxmLmFjdGl2ZUl0ZW1zLmxlbmd0aCkge1xuXHQgICAgICByZXR1cm4gb3JpZ19kZWxldGVTZWxlY3Rpb24uY2FsbChzZWxmLCBldnQpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfSk7XG5cdH1cblxuXHQvKipcblx0ICogUGx1Z2luOiBcIm5vX2FjdGl2ZV9pdGVtc1wiIChUb20gU2VsZWN0KVxuXHQgKlxuXHQgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xuXHQgKiBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcblx0ICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cdCAqXG5cdCAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcblx0ICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRlxuXHQgKiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2Vcblx0ICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblx0ICpcblx0ICovXG5cdGZ1bmN0aW9uIG5vX2FjdGl2ZV9pdGVtcyAoKSB7XG5cdCAgdGhpcy5ob29rKCdpbnN0ZWFkJywgJ3NldEFjdGl2ZUl0ZW0nLCAoKSA9PiB7fSk7XG5cdCAgdGhpcy5ob29rKCdpbnN0ZWFkJywgJ3NlbGVjdEFsbCcsICgpID0+IHt9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBQbHVnaW46IFwib3B0Z3JvdXBfY29sdW1uc1wiIChUb20gU2VsZWN0LmpzKVxuXHQgKiBDb3B5cmlnaHQgKGMpIGNvbnRyaWJ1dG9yc1xuXHQgKlxuXHQgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xuXHQgKiBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcblx0ICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cdCAqXG5cdCAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcblx0ICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRlxuXHQgKiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2Vcblx0ICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblx0ICpcblx0ICovXG5cdGZ1bmN0aW9uIG9wdGdyb3VwX2NvbHVtbnMgKCkge1xuXHQgIHZhciBzZWxmID0gdGhpcztcblx0ICB2YXIgb3JpZ19rZXlkb3duID0gc2VsZi5vbktleURvd247XG5cdCAgc2VsZi5ob29rKCdpbnN0ZWFkJywgJ29uS2V5RG93bicsIGV2dCA9PiB7XG5cdCAgICB2YXIgaW5kZXgsIG9wdGlvbiwgb3B0aW9ucywgb3B0Z3JvdXA7XG5cblx0ICAgIGlmICghc2VsZi5pc09wZW4gfHwgIShldnQua2V5Q29kZSA9PT0gS0VZX0xFRlQgfHwgZXZ0LmtleUNvZGUgPT09IEtFWV9SSUdIVCkpIHtcblx0ICAgICAgcmV0dXJuIG9yaWdfa2V5ZG93bi5jYWxsKHNlbGYsIGV2dCk7XG5cdCAgICB9XG5cblx0ICAgIHNlbGYuaWdub3JlSG92ZXIgPSB0cnVlO1xuXHQgICAgb3B0Z3JvdXAgPSBwYXJlbnRNYXRjaChzZWxmLmFjdGl2ZU9wdGlvbiwgJ1tkYXRhLWdyb3VwXScpO1xuXHQgICAgaW5kZXggPSBub2RlSW5kZXgoc2VsZi5hY3RpdmVPcHRpb24sICdbZGF0YS1zZWxlY3RhYmxlXScpO1xuXG5cdCAgICBpZiAoIW9wdGdyb3VwKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgaWYgKGV2dC5rZXlDb2RlID09PSBLRVlfTEVGVCkge1xuXHQgICAgICBvcHRncm91cCA9IG9wdGdyb3VwLnByZXZpb3VzU2libGluZztcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIG9wdGdyb3VwID0gb3B0Z3JvdXAubmV4dFNpYmxpbmc7XG5cdCAgICB9XG5cblx0ICAgIGlmICghb3B0Z3JvdXApIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICBvcHRpb25zID0gb3B0Z3JvdXAucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtc2VsZWN0YWJsZV0nKTtcblx0ICAgIG9wdGlvbiA9IG9wdGlvbnNbTWF0aC5taW4ob3B0aW9ucy5sZW5ndGggLSAxLCBpbmRleCldO1xuXG5cdCAgICBpZiAob3B0aW9uKSB7XG5cdCAgICAgIHNlbGYuc2V0QWN0aXZlT3B0aW9uKG9wdGlvbik7XG5cdCAgICB9XG5cdCAgfSk7XG5cdH1cblxuXHQvKipcblx0ICogUGx1Z2luOiBcInJlbW92ZV9idXR0b25cIiAoVG9tIFNlbGVjdClcblx0ICogQ29weXJpZ2h0IChjKSBjb250cmlidXRvcnNcblx0ICpcblx0ICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXNcblx0ICogZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XG5cdCAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXHQgKlxuXHQgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG5cdCAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0Zcblx0ICogQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG5cdCAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cdCAqXG5cdCAqL1xuXHRmdW5jdGlvbiByZW1vdmVfYnV0dG9uICh1c2VyT3B0aW9ucykge1xuXHQgIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcblx0ICAgIGxhYmVsOiAnJnRpbWVzOycsXG5cdCAgICB0aXRsZTogJ1JlbW92ZScsXG5cdCAgICBjbGFzc05hbWU6ICdyZW1vdmUnLFxuXHQgICAgYXBwZW5kOiB0cnVlXG5cdCAgfSwgdXNlck9wdGlvbnMpOyAvL29wdGlvbnMuY2xhc3NOYW1lID0gJ3JlbW92ZS1zaW5nbGUnO1xuXG5cdCAgdmFyIHNlbGYgPSB0aGlzOyAvLyBvdmVycmlkZSB0aGUgcmVuZGVyIG1ldGhvZCB0byBhZGQgcmVtb3ZlIGJ1dHRvbiB0byBlYWNoIGl0ZW1cblxuXHQgIGlmICghb3B0aW9ucy5hcHBlbmQpIHtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cblx0ICB2YXIgaHRtbCA9ICc8YSBocmVmPVwiamF2YXNjcmlwdDp2b2lkKDApXCIgY2xhc3M9XCInICsgb3B0aW9ucy5jbGFzc05hbWUgKyAnXCIgdGFiaW5kZXg9XCItMVwiIHRpdGxlPVwiJyArIGVzY2FwZV9odG1sKG9wdGlvbnMudGl0bGUpICsgJ1wiPicgKyBvcHRpb25zLmxhYmVsICsgJzwvYT4nO1xuXHQgIHNlbGYuaG9vaygnYWZ0ZXInLCAnc2V0dXBUZW1wbGF0ZXMnLCAoKSA9PiB7XG5cdCAgICB2YXIgb3JpZ19yZW5kZXJfaXRlbSA9IHNlbGYuc2V0dGluZ3MucmVuZGVyLml0ZW07XG5cblx0ICAgIHNlbGYuc2V0dGluZ3MucmVuZGVyLml0ZW0gPSAoZGF0YSwgZXNjYXBlKSA9PiB7XG5cdCAgICAgIHZhciBpdGVtID0gZ2V0RG9tKG9yaWdfcmVuZGVyX2l0ZW0uY2FsbChzZWxmLCBkYXRhLCBlc2NhcGUpKTtcblx0ICAgICAgdmFyIGNsb3NlX2J1dHRvbiA9IGdldERvbShodG1sKTtcblx0ICAgICAgaXRlbS5hcHBlbmRDaGlsZChjbG9zZV9idXR0b24pO1xuXHQgICAgICBhZGRFdmVudChjbG9zZV9idXR0b24sICdtb3VzZWRvd24nLCBldnQgPT4ge1xuXHQgICAgICAgIHByZXZlbnREZWZhdWx0KGV2dCwgdHJ1ZSk7XG5cdCAgICAgIH0pO1xuXHQgICAgICBhZGRFdmVudChjbG9zZV9idXR0b24sICdjbGljaycsIGV2dCA9PiB7XG5cdCAgICAgICAgLy8gcHJvcGFnYXRpbmcgd2lsbCB0cmlnZ2VyIHRoZSBkcm9wZG93biB0byBzaG93IGZvciBzaW5nbGUgbW9kZVxuXHQgICAgICAgIHByZXZlbnREZWZhdWx0KGV2dCwgdHJ1ZSk7XG5cdCAgICAgICAgaWYgKHNlbGYuaXNMb2NrZWQpIHJldHVybjtcblx0ICAgICAgICBpZiAoIXNlbGYuc2hvdWxkRGVsZXRlKFtpdGVtXSwgZXZ0KSkgcmV0dXJuO1xuXHQgICAgICAgIHNlbGYucmVtb3ZlSXRlbShpdGVtKTtcblx0ICAgICAgICBzZWxmLnJlZnJlc2hPcHRpb25zKGZhbHNlKTtcblx0ICAgICAgICBzZWxmLmlucHV0U3RhdGUoKTtcblx0ICAgICAgfSk7XG5cdCAgICAgIHJldHVybiBpdGVtO1xuXHQgICAgfTtcblx0ICB9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBQbHVnaW46IFwicmVzdG9yZV9vbl9iYWNrc3BhY2VcIiAoVG9tIFNlbGVjdClcblx0ICogQ29weXJpZ2h0IChjKSBjb250cmlidXRvcnNcblx0ICpcblx0ICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXNcblx0ICogZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XG5cdCAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXHQgKlxuXHQgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG5cdCAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0Zcblx0ICogQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG5cdCAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cdCAqXG5cdCAqL1xuXHRmdW5jdGlvbiByZXN0b3JlX29uX2JhY2tzcGFjZSAodXNlck9wdGlvbnMpIHtcblx0ICBjb25zdCBzZWxmID0gdGhpcztcblx0ICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG5cdCAgICB0ZXh0OiBvcHRpb24gPT4ge1xuXHQgICAgICByZXR1cm4gb3B0aW9uW3NlbGYuc2V0dGluZ3MubGFiZWxGaWVsZF07XG5cdCAgICB9XG5cdCAgfSwgdXNlck9wdGlvbnMpO1xuXHQgIHNlbGYub24oJ2l0ZW1fcmVtb3ZlJywgZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICBpZiAoIXNlbGYuaXNGb2N1c2VkKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgaWYgKHNlbGYuY29udHJvbF9pbnB1dC52YWx1ZS50cmltKCkgPT09ICcnKSB7XG5cdCAgICAgIHZhciBvcHRpb24gPSBzZWxmLm9wdGlvbnNbdmFsdWVdO1xuXG5cdCAgICAgIGlmIChvcHRpb24pIHtcblx0ICAgICAgICBzZWxmLnNldFRleHRib3hWYWx1ZShvcHRpb25zLnRleHQuY2FsbChzZWxmLCBvcHRpb24pKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFBsdWdpbjogXCJyZXN0b3JlX29uX2JhY2tzcGFjZVwiIChUb20gU2VsZWN0KVxuXHQgKiBDb3B5cmlnaHQgKGMpIGNvbnRyaWJ1dG9yc1xuXHQgKlxuXHQgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xuXHQgKiBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcblx0ICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cdCAqXG5cdCAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcblx0ICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRlxuXHQgKiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2Vcblx0ICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblx0ICpcblx0ICovXG5cdGZ1bmN0aW9uIHZpcnR1YWxfc2Nyb2xsICgpIHtcblx0ICBjb25zdCBzZWxmID0gdGhpcztcblx0ICBjb25zdCBvcmlnX2NhbkxvYWQgPSBzZWxmLmNhbkxvYWQ7XG5cdCAgY29uc3Qgb3JpZ19jbGVhckFjdGl2ZU9wdGlvbiA9IHNlbGYuY2xlYXJBY3RpdmVPcHRpb247XG5cdCAgY29uc3Qgb3JpZ19sb2FkQ2FsbGJhY2sgPSBzZWxmLmxvYWRDYWxsYmFjaztcblx0ICB2YXIgcGFnaW5hdGlvbiA9IHt9O1xuXHQgIHZhciBkcm9wZG93bl9jb250ZW50O1xuXHQgIHZhciBsb2FkaW5nX21vcmUgPSBmYWxzZTtcblx0ICB2YXIgbG9hZF9tb3JlX29wdDtcblx0ICB2YXIgZGVmYXVsdF92YWx1ZXMgPSBbXTtcblxuXHQgIGlmICghc2VsZi5zZXR0aW5ncy5zaG91bGRMb2FkTW9yZSkge1xuXHQgICAgLy8gcmV0dXJuIHRydWUgaWYgYWRkaXRpb25hbCByZXN1bHRzIHNob3VsZCBiZSBsb2FkZWRcblx0ICAgIHNlbGYuc2V0dGluZ3Muc2hvdWxkTG9hZE1vcmUgPSAoKSA9PiB7XG5cdCAgICAgIGNvbnN0IHNjcm9sbF9wZXJjZW50ID0gZHJvcGRvd25fY29udGVudC5jbGllbnRIZWlnaHQgLyAoZHJvcGRvd25fY29udGVudC5zY3JvbGxIZWlnaHQgLSBkcm9wZG93bl9jb250ZW50LnNjcm9sbFRvcCk7XG5cblx0ICAgICAgaWYgKHNjcm9sbF9wZXJjZW50ID4gMC45KSB7XG5cdCAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoc2VsZi5hY3RpdmVPcHRpb24pIHtcblx0ICAgICAgICB2YXIgc2VsZWN0YWJsZSA9IHNlbGYuc2VsZWN0YWJsZSgpO1xuXHQgICAgICAgIHZhciBpbmRleCA9IEFycmF5LmZyb20oc2VsZWN0YWJsZSkuaW5kZXhPZihzZWxmLmFjdGl2ZU9wdGlvbik7XG5cblx0ICAgICAgICBpZiAoaW5kZXggPj0gc2VsZWN0YWJsZS5sZW5ndGggLSAyKSB7XG5cdCAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9O1xuXHQgIH1cblxuXHQgIGlmICghc2VsZi5zZXR0aW5ncy5maXJzdFVybCkge1xuXHQgICAgdGhyb3cgJ3ZpcnR1YWxfc2Nyb2xsIHBsdWdpbiByZXF1aXJlcyBhIGZpcnN0VXJsKCkgbWV0aG9kJztcblx0ICB9IC8vIGluIG9yZGVyIGZvciB2aXJ0dWFsIHNjcm9sbGluZyB0byB3b3JrLFxuXHQgIC8vIG9wdGlvbnMgbmVlZCB0byBiZSBvcmRlcmVkIHRoZSBzYW1lIHdheSB0aGV5J3JlIHJldHVybmVkIGZyb20gdGhlIHJlbW90ZSBkYXRhIHNvdXJjZVxuXG5cblx0ICBzZWxmLnNldHRpbmdzLnNvcnRGaWVsZCA9IFt7XG5cdCAgICBmaWVsZDogJyRvcmRlcidcblx0ICB9LCB7XG5cdCAgICBmaWVsZDogJyRzY29yZSdcblx0ICB9XTsgLy8gY2FuIHdlIGxvYWQgbW9yZSByZXN1bHRzIGZvciBnaXZlbiBxdWVyeT9cblxuXHQgIGNvbnN0IGNhbkxvYWRNb3JlID0gcXVlcnkgPT4ge1xuXHQgICAgaWYgKHR5cGVvZiBzZWxmLnNldHRpbmdzLm1heE9wdGlvbnMgPT09ICdudW1iZXInICYmIGRyb3Bkb3duX2NvbnRlbnQuY2hpbGRyZW4ubGVuZ3RoID49IHNlbGYuc2V0dGluZ3MubWF4T3B0aW9ucykge1xuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cblx0ICAgIGlmIChxdWVyeSBpbiBwYWdpbmF0aW9uICYmIHBhZ2luYXRpb25bcXVlcnldKSB7XG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfTtcblxuXHQgIGNvbnN0IGNsZWFyRmlsdGVyID0gKG9wdGlvbiwgdmFsdWUpID0+IHtcblx0ICAgIGlmIChzZWxmLml0ZW1zLmluZGV4T2YodmFsdWUpID49IDAgfHwgZGVmYXVsdF92YWx1ZXMuaW5kZXhPZih2YWx1ZSkgPj0gMCkge1xuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH07IC8vIHNldCB0aGUgbmV4dCB1cmwgdGhhdCB3aWxsIGJlXG5cblxuXHQgIHNlbGYuc2V0TmV4dFVybCA9ICh2YWx1ZSwgbmV4dF91cmwpID0+IHtcblx0ICAgIHBhZ2luYXRpb25bdmFsdWVdID0gbmV4dF91cmw7XG5cdCAgfTsgLy8gZ2V0VXJsKCkgdG8gYmUgdXNlZCBpbiBzZXR0aW5ncy5sb2FkKClcblxuXG5cdCAgc2VsZi5nZXRVcmwgPSBxdWVyeSA9PiB7XG5cdCAgICBpZiAocXVlcnkgaW4gcGFnaW5hdGlvbikge1xuXHQgICAgICBjb25zdCBuZXh0X3VybCA9IHBhZ2luYXRpb25bcXVlcnldO1xuXHQgICAgICBwYWdpbmF0aW9uW3F1ZXJ5XSA9IGZhbHNlO1xuXHQgICAgICByZXR1cm4gbmV4dF91cmw7XG5cdCAgICB9IC8vIGlmIHRoZSB1c2VyIGdvZXMgYmFjayB0byBhIHByZXZpb3VzIHF1ZXJ5XG5cdCAgICAvLyB3ZSBuZWVkIHRvIGxvYWQgdGhlIGZpcnN0IHBhZ2UgYWdhaW5cblxuXG5cdCAgICBwYWdpbmF0aW9uID0ge307XG5cdCAgICByZXR1cm4gc2VsZi5zZXR0aW5ncy5maXJzdFVybC5jYWxsKHNlbGYsIHF1ZXJ5KTtcblx0ICB9OyAvLyBkb24ndCBjbGVhciB0aGUgYWN0aXZlIG9wdGlvbiAoYW5kIGNhdXNlIHVud2FudGVkIGRyb3Bkb3duIHNjcm9sbClcblx0ICAvLyB3aGlsZSBsb2FkaW5nIG1vcmUgcmVzdWx0c1xuXG5cblx0ICBzZWxmLmhvb2soJ2luc3RlYWQnLCAnY2xlYXJBY3RpdmVPcHRpb24nLCAoKSA9PiB7XG5cdCAgICBpZiAobG9hZGluZ19tb3JlKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIG9yaWdfY2xlYXJBY3RpdmVPcHRpb24uY2FsbChzZWxmKTtcblx0ICB9KTsgLy8gb3ZlcnJpZGUgdGhlIGNhbkxvYWQgbWV0aG9kXG5cblx0ICBzZWxmLmhvb2soJ2luc3RlYWQnLCAnY2FuTG9hZCcsIHF1ZXJ5ID0+IHtcblx0ICAgIC8vIGZpcnN0IHRpbWUgdGhlIHF1ZXJ5IGhhcyBiZWVuIHNlZW5cblx0ICAgIGlmICghKHF1ZXJ5IGluIHBhZ2luYXRpb24pKSB7XG5cdCAgICAgIHJldHVybiBvcmlnX2NhbkxvYWQuY2FsbChzZWxmLCBxdWVyeSk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBjYW5Mb2FkTW9yZShxdWVyeSk7XG5cdCAgfSk7IC8vIHdyYXAgdGhlIGxvYWRcblxuXHQgIHNlbGYuaG9vaygnaW5zdGVhZCcsICdsb2FkQ2FsbGJhY2snLCAob3B0aW9ucywgb3B0Z3JvdXBzKSA9PiB7XG5cdCAgICBpZiAoIWxvYWRpbmdfbW9yZSkge1xuXHQgICAgICBzZWxmLmNsZWFyT3B0aW9ucyhjbGVhckZpbHRlcik7XG5cdCAgICB9IGVsc2UgaWYgKGxvYWRfbW9yZV9vcHQpIHtcblx0ICAgICAgY29uc3QgZmlyc3Rfb3B0aW9uID0gb3B0aW9uc1swXTtcblxuXHQgICAgICBpZiAoZmlyc3Rfb3B0aW9uICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICBsb2FkX21vcmVfb3B0LmRhdGFzZXQudmFsdWUgPSBmaXJzdF9vcHRpb25bc2VsZi5zZXR0aW5ncy52YWx1ZUZpZWxkXTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBvcmlnX2xvYWRDYWxsYmFjay5jYWxsKHNlbGYsIG9wdGlvbnMsIG9wdGdyb3Vwcyk7XG5cdCAgICBsb2FkaW5nX21vcmUgPSBmYWxzZTtcblx0ICB9KTsgLy8gYWRkIHRlbXBsYXRlcyB0byBkcm9wZG93blxuXHQgIC8vXHRsb2FkaW5nX21vcmUgaWYgd2UgaGF2ZSBhbm90aGVyIHVybCBpbiB0aGUgcXVldWVcblx0ICAvL1x0bm9fbW9yZV9yZXN1bHRzIGlmIHdlIGRvbid0IGhhdmUgYW5vdGhlciB1cmwgaW4gdGhlIHF1ZXVlXG5cblx0ICBzZWxmLmhvb2soJ2FmdGVyJywgJ3JlZnJlc2hPcHRpb25zJywgKCkgPT4ge1xuXHQgICAgY29uc3QgcXVlcnkgPSBzZWxmLmxhc3RWYWx1ZTtcblx0ICAgIHZhciBvcHRpb247XG5cblx0ICAgIGlmIChjYW5Mb2FkTW9yZShxdWVyeSkpIHtcblx0ICAgICAgb3B0aW9uID0gc2VsZi5yZW5kZXIoJ2xvYWRpbmdfbW9yZScsIHtcblx0ICAgICAgICBxdWVyeTogcXVlcnlcblx0ICAgICAgfSk7XG5cblx0ICAgICAgaWYgKG9wdGlvbikge1xuXHQgICAgICAgIG9wdGlvbi5zZXRBdHRyaWJ1dGUoJ2RhdGEtc2VsZWN0YWJsZScsICcnKTsgLy8gc28gdGhhdCBuYXZpZ2F0aW5nIGRyb3Bkb3duIHdpdGggW2Rvd25dIGtleXByZXNzZXMgY2FuIG5hdmlnYXRlIHRvIHRoaXMgbm9kZVxuXG5cdCAgICAgICAgbG9hZF9tb3JlX29wdCA9IG9wdGlvbjtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIGlmIChxdWVyeSBpbiBwYWdpbmF0aW9uICYmICFkcm9wZG93bl9jb250ZW50LnF1ZXJ5U2VsZWN0b3IoJy5uby1yZXN1bHRzJykpIHtcblx0ICAgICAgb3B0aW9uID0gc2VsZi5yZW5kZXIoJ25vX21vcmVfcmVzdWx0cycsIHtcblx0ICAgICAgICBxdWVyeTogcXVlcnlcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cblx0ICAgIGlmIChvcHRpb24pIHtcblx0ICAgICAgYWRkQ2xhc3NlcyhvcHRpb24sIHNlbGYuc2V0dGluZ3Mub3B0aW9uQ2xhc3MpO1xuXHQgICAgICBkcm9wZG93bl9jb250ZW50LmFwcGVuZChvcHRpb24pO1xuXHQgICAgfVxuXHQgIH0pOyAvLyBhZGQgc2Nyb2xsIGxpc3RlbmVyIGFuZCBkZWZhdWx0IHRlbXBsYXRlc1xuXG5cdCAgc2VsZi5vbignaW5pdGlhbGl6ZScsICgpID0+IHtcblx0ICAgIGRlZmF1bHRfdmFsdWVzID0gT2JqZWN0LmtleXMoc2VsZi5vcHRpb25zKTtcblx0ICAgIGRyb3Bkb3duX2NvbnRlbnQgPSBzZWxmLmRyb3Bkb3duX2NvbnRlbnQ7IC8vIGRlZmF1bHQgdGVtcGxhdGVzXG5cblx0ICAgIHNlbGYuc2V0dGluZ3MucmVuZGVyID0gT2JqZWN0LmFzc2lnbih7fSwge1xuXHQgICAgICBsb2FkaW5nX21vcmU6ICgpID0+IHtcblx0ICAgICAgICByZXR1cm4gYDxkaXYgY2xhc3M9XCJsb2FkaW5nLW1vcmUtcmVzdWx0c1wiPkxvYWRpbmcgbW9yZSByZXN1bHRzIC4uLiA8L2Rpdj5gO1xuXHQgICAgICB9LFxuXHQgICAgICBub19tb3JlX3Jlc3VsdHM6ICgpID0+IHtcblx0ICAgICAgICByZXR1cm4gYDxkaXYgY2xhc3M9XCJuby1tb3JlLXJlc3VsdHNcIj5ObyBtb3JlIHJlc3VsdHM8L2Rpdj5gO1xuXHQgICAgICB9XG5cdCAgICB9LCBzZWxmLnNldHRpbmdzLnJlbmRlcik7IC8vIHdhdGNoIGRyb3Bkb3duIGNvbnRlbnQgc2Nyb2xsIHBvc2l0aW9uXG5cblx0ICAgIGRyb3Bkb3duX2NvbnRlbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgKCkgPT4ge1xuXHQgICAgICBpZiAoIXNlbGYuc2V0dGluZ3Muc2hvdWxkTG9hZE1vcmUuY2FsbChzZWxmKSkge1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfSAvLyAhaW1wb3J0YW50OiB0aGlzIHdpbGwgZ2V0IGNoZWNrZWQgYWdhaW4gaW4gbG9hZCgpIGJ1dCB3ZSBzdGlsbCBuZWVkIHRvIGNoZWNrIGhlcmUgb3RoZXJ3aXNlIGxvYWRpbmdfbW9yZSB3aWxsIGJlIHNldCB0byB0cnVlXG5cblxuXHQgICAgICBpZiAoIWNhbkxvYWRNb3JlKHNlbGYubGFzdFZhbHVlKSkge1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfSAvLyBkb24ndCBjYWxsIGxvYWQoKSB0b28gbXVjaFxuXG5cblx0ICAgICAgaWYgKGxvYWRpbmdfbW9yZSkgcmV0dXJuO1xuXHQgICAgICBsb2FkaW5nX21vcmUgPSB0cnVlO1xuXHQgICAgICBzZWxmLmxvYWQuY2FsbChzZWxmLCBzZWxmLmxhc3RWYWx1ZSk7XG5cdCAgICB9KTtcblx0ICB9KTtcblx0fVxuXG5cdFRvbVNlbGVjdC5kZWZpbmUoJ2NoYW5nZV9saXN0ZW5lcicsIGNoYW5nZV9saXN0ZW5lcik7XG5cdFRvbVNlbGVjdC5kZWZpbmUoJ2NoZWNrYm94X29wdGlvbnMnLCBjaGVja2JveF9vcHRpb25zKTtcblx0VG9tU2VsZWN0LmRlZmluZSgnY2xlYXJfYnV0dG9uJywgY2xlYXJfYnV0dG9uKTtcblx0VG9tU2VsZWN0LmRlZmluZSgnZHJhZ19kcm9wJywgZHJhZ19kcm9wKTtcblx0VG9tU2VsZWN0LmRlZmluZSgnZHJvcGRvd25faGVhZGVyJywgZHJvcGRvd25faGVhZGVyKTtcblx0VG9tU2VsZWN0LmRlZmluZSgnY2FyZXRfcG9zaXRpb24nLCBjYXJldF9wb3NpdGlvbik7XG5cdFRvbVNlbGVjdC5kZWZpbmUoJ2Ryb3Bkb3duX2lucHV0JywgZHJvcGRvd25faW5wdXQpO1xuXHRUb21TZWxlY3QuZGVmaW5lKCdpbnB1dF9hdXRvZ3JvdycsIGlucHV0X2F1dG9ncm93KTtcblx0VG9tU2VsZWN0LmRlZmluZSgnbm9fYmFja3NwYWNlX2RlbGV0ZScsIG5vX2JhY2tzcGFjZV9kZWxldGUpO1xuXHRUb21TZWxlY3QuZGVmaW5lKCdub19hY3RpdmVfaXRlbXMnLCBub19hY3RpdmVfaXRlbXMpO1xuXHRUb21TZWxlY3QuZGVmaW5lKCdvcHRncm91cF9jb2x1bW5zJywgb3B0Z3JvdXBfY29sdW1ucyk7XG5cdFRvbVNlbGVjdC5kZWZpbmUoJ3JlbW92ZV9idXR0b24nLCByZW1vdmVfYnV0dG9uKTtcblx0VG9tU2VsZWN0LmRlZmluZSgncmVzdG9yZV9vbl9iYWNrc3BhY2UnLCByZXN0b3JlX29uX2JhY2tzcGFjZSk7XG5cdFRvbVNlbGVjdC5kZWZpbmUoJ3ZpcnR1YWxfc2Nyb2xsJywgdmlydHVhbF9zY3JvbGwpO1xuXG5cdHJldHVybiBUb21TZWxlY3Q7XG5cbn0pKTtcbnZhciB0b21TZWxlY3Q9ZnVuY3Rpb24oZWwsb3B0cyl7cmV0dXJuIG5ldyBUb21TZWxlY3QoZWwsb3B0cyk7fSBcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRvbS1zZWxlY3QuY29tcGxldGUuanMubWFwXG4iLCJpbXBvcnQgRHVyYXRpb24gZnJvbSBcIi4vZHVyYXRpb24uanNcIjtcbmltcG9ydCBJbnRlcnZhbCBmcm9tIFwiLi9pbnRlcnZhbC5qc1wiO1xuaW1wb3J0IFNldHRpbmdzIGZyb20gXCIuL3NldHRpbmdzLmpzXCI7XG5pbXBvcnQgSW5mbyBmcm9tIFwiLi9pbmZvLmpzXCI7XG5pbXBvcnQgRm9ybWF0dGVyIGZyb20gXCIuL2ltcGwvZm9ybWF0dGVyLmpzXCI7XG5pbXBvcnQgRml4ZWRPZmZzZXRab25lIGZyb20gXCIuL3pvbmVzL2ZpeGVkT2Zmc2V0Wm9uZS5qc1wiO1xuaW1wb3J0IExvY2FsZSBmcm9tIFwiLi9pbXBsL2xvY2FsZS5qc1wiO1xuaW1wb3J0IHtcbiAgaXNVbmRlZmluZWQsXG4gIG1heWJlQXJyYXksXG4gIGlzRGF0ZSxcbiAgaXNOdW1iZXIsXG4gIGJlc3RCeSxcbiAgZGF5c0luTW9udGgsXG4gIGRheXNJblllYXIsXG4gIGlzTGVhcFllYXIsXG4gIHdlZWtzSW5XZWVrWWVhcixcbiAgbm9ybWFsaXplT2JqZWN0LFxuICByb3VuZFRvLFxuICBvYmpUb0xvY2FsVFMsXG4gIHBhZFN0YXJ0LFxufSBmcm9tIFwiLi9pbXBsL3V0aWwuanNcIjtcbmltcG9ydCB7IG5vcm1hbGl6ZVpvbmUgfSBmcm9tIFwiLi9pbXBsL3pvbmVVdGlsLmpzXCI7XG5pbXBvcnQgZGlmZiBmcm9tIFwiLi9pbXBsL2RpZmYuanNcIjtcbmltcG9ydCB7IHBhcnNlUkZDMjgyMkRhdGUsIHBhcnNlSVNPRGF0ZSwgcGFyc2VIVFRQRGF0ZSwgcGFyc2VTUUwgfSBmcm9tIFwiLi9pbXBsL3JlZ2V4UGFyc2VyLmpzXCI7XG5pbXBvcnQge1xuICBwYXJzZUZyb21Ub2tlbnMsXG4gIGV4cGxhaW5Gcm9tVG9rZW5zLFxuICBmb3JtYXRPcHRzVG9Ub2tlbnMsXG4gIGV4cGFuZE1hY3JvVG9rZW5zLFxufSBmcm9tIFwiLi9pbXBsL3Rva2VuUGFyc2VyLmpzXCI7XG5pbXBvcnQge1xuICBncmVnb3JpYW5Ub1dlZWssXG4gIHdlZWtUb0dyZWdvcmlhbixcbiAgZ3JlZ29yaWFuVG9PcmRpbmFsLFxuICBvcmRpbmFsVG9HcmVnb3JpYW4sXG4gIGhhc0ludmFsaWRHcmVnb3JpYW5EYXRhLFxuICBoYXNJbnZhbGlkV2Vla0RhdGEsXG4gIGhhc0ludmFsaWRPcmRpbmFsRGF0YSxcbiAgaGFzSW52YWxpZFRpbWVEYXRhLFxufSBmcm9tIFwiLi9pbXBsL2NvbnZlcnNpb25zLmpzXCI7XG5pbXBvcnQgKiBhcyBGb3JtYXRzIGZyb20gXCIuL2ltcGwvZm9ybWF0cy5qc1wiO1xuaW1wb3J0IHtcbiAgSW52YWxpZEFyZ3VtZW50RXJyb3IsXG4gIENvbmZsaWN0aW5nU3BlY2lmaWNhdGlvbkVycm9yLFxuICBJbnZhbGlkVW5pdEVycm9yLFxuICBJbnZhbGlkRGF0ZVRpbWVFcnJvcixcbn0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgSW52YWxpZCBmcm9tIFwiLi9pbXBsL2ludmFsaWQuanNcIjtcblxuY29uc3QgSU5WQUxJRCA9IFwiSW52YWxpZCBEYXRlVGltZVwiO1xuY29uc3QgTUFYX0RBVEUgPSA4LjY0ZTE1O1xuXG5mdW5jdGlvbiB1bnN1cHBvcnRlZFpvbmUoem9uZSkge1xuICByZXR1cm4gbmV3IEludmFsaWQoXCJ1bnN1cHBvcnRlZCB6b25lXCIsIGB0aGUgem9uZSBcIiR7em9uZS5uYW1lfVwiIGlzIG5vdCBzdXBwb3J0ZWRgKTtcbn1cblxuLy8gd2UgY2FjaGUgd2VlayBkYXRhIG9uIHRoZSBEVCBvYmplY3QgYW5kIHRoaXMgaW50ZXJtZWRpYXRlcyB0aGUgY2FjaGVcbmZ1bmN0aW9uIHBvc3NpYmx5Q2FjaGVkV2Vla0RhdGEoZHQpIHtcbiAgaWYgKGR0LndlZWtEYXRhID09PSBudWxsKSB7XG4gICAgZHQud2Vla0RhdGEgPSBncmVnb3JpYW5Ub1dlZWsoZHQuYyk7XG4gIH1cbiAgcmV0dXJuIGR0LndlZWtEYXRhO1xufVxuXG4vLyBjbG9uZSByZWFsbHkgbWVhbnMsIFwibWFrZSBhIG5ldyBvYmplY3Qgd2l0aCB0aGVzZSBtb2RpZmljYXRpb25zXCIuIGFsbCBcInNldHRlcnNcIiByZWFsbHkgdXNlIHRoaXNcbi8vIHRvIGNyZWF0ZSBhIG5ldyBvYmplY3Qgd2hpbGUgb25seSBjaGFuZ2luZyBzb21lIG9mIHRoZSBwcm9wZXJ0aWVzXG5mdW5jdGlvbiBjbG9uZShpbnN0LCBhbHRzKSB7XG4gIGNvbnN0IGN1cnJlbnQgPSB7XG4gICAgdHM6IGluc3QudHMsXG4gICAgem9uZTogaW5zdC56b25lLFxuICAgIGM6IGluc3QuYyxcbiAgICBvOiBpbnN0Lm8sXG4gICAgbG9jOiBpbnN0LmxvYyxcbiAgICBpbnZhbGlkOiBpbnN0LmludmFsaWQsXG4gIH07XG4gIHJldHVybiBuZXcgRGF0ZVRpbWUoeyAuLi5jdXJyZW50LCAuLi5hbHRzLCBvbGQ6IGN1cnJlbnQgfSk7XG59XG5cbi8vIGZpbmQgdGhlIHJpZ2h0IG9mZnNldCBhIGdpdmVuIGxvY2FsIHRpbWUuIFRoZSBvIGlucHV0IGlzIG91ciBndWVzcywgd2hpY2ggZGV0ZXJtaW5lcyB3aGljaFxuLy8gb2Zmc2V0IHdlJ2xsIHBpY2sgaW4gYW1iaWd1b3VzIGNhc2VzIChlLmcuIHRoZXJlIGFyZSB0d28gMyBBTXMgYi9jIEZhbGxiYWNrIERTVClcbmZ1bmN0aW9uIGZpeE9mZnNldChsb2NhbFRTLCBvLCB0eikge1xuICAvLyBPdXIgVVRDIHRpbWUgaXMganVzdCBhIGd1ZXNzIGJlY2F1c2Ugb3VyIG9mZnNldCBpcyBqdXN0IGEgZ3Vlc3NcbiAgbGV0IHV0Y0d1ZXNzID0gbG9jYWxUUyAtIG8gKiA2MCAqIDEwMDA7XG5cbiAgLy8gVGVzdCB3aGV0aGVyIHRoZSB6b25lIG1hdGNoZXMgdGhlIG9mZnNldCBmb3IgdGhpcyB0c1xuICBjb25zdCBvMiA9IHR6Lm9mZnNldCh1dGNHdWVzcyk7XG5cbiAgLy8gSWYgc28sIG9mZnNldCBkaWRuJ3QgY2hhbmdlIGFuZCB3ZSdyZSBkb25lXG4gIGlmIChvID09PSBvMikge1xuICAgIHJldHVybiBbdXRjR3Vlc3MsIG9dO1xuICB9XG5cbiAgLy8gSWYgbm90LCBjaGFuZ2UgdGhlIHRzIGJ5IHRoZSBkaWZmZXJlbmNlIGluIHRoZSBvZmZzZXRcbiAgdXRjR3Vlc3MgLT0gKG8yIC0gbykgKiA2MCAqIDEwMDA7XG5cbiAgLy8gSWYgdGhhdCBnaXZlcyB1cyB0aGUgbG9jYWwgdGltZSB3ZSB3YW50LCB3ZSdyZSBkb25lXG4gIGNvbnN0IG8zID0gdHoub2Zmc2V0KHV0Y0d1ZXNzKTtcbiAgaWYgKG8yID09PSBvMykge1xuICAgIHJldHVybiBbdXRjR3Vlc3MsIG8yXTtcbiAgfVxuXG4gIC8vIElmIGl0J3MgZGlmZmVyZW50LCB3ZSdyZSBpbiBhIGhvbGUgdGltZS4gVGhlIG9mZnNldCBoYXMgY2hhbmdlZCwgYnV0IHRoZSB3ZSBkb24ndCBhZGp1c3QgdGhlIHRpbWVcbiAgcmV0dXJuIFtsb2NhbFRTIC0gTWF0aC5taW4obzIsIG8zKSAqIDYwICogMTAwMCwgTWF0aC5tYXgobzIsIG8zKV07XG59XG5cbi8vIGNvbnZlcnQgYW4gZXBvY2ggdGltZXN0YW1wIGludG8gYSBjYWxlbmRhciBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gb2Zmc2V0XG5mdW5jdGlvbiB0c1RvT2JqKHRzLCBvZmZzZXQpIHtcbiAgdHMgKz0gb2Zmc2V0ICogNjAgKiAxMDAwO1xuXG4gIGNvbnN0IGQgPSBuZXcgRGF0ZSh0cyk7XG5cbiAgcmV0dXJuIHtcbiAgICB5ZWFyOiBkLmdldFVUQ0Z1bGxZZWFyKCksXG4gICAgbW9udGg6IGQuZ2V0VVRDTW9udGgoKSArIDEsXG4gICAgZGF5OiBkLmdldFVUQ0RhdGUoKSxcbiAgICBob3VyOiBkLmdldFVUQ0hvdXJzKCksXG4gICAgbWludXRlOiBkLmdldFVUQ01pbnV0ZXMoKSxcbiAgICBzZWNvbmQ6IGQuZ2V0VVRDU2Vjb25kcygpLFxuICAgIG1pbGxpc2Vjb25kOiBkLmdldFVUQ01pbGxpc2Vjb25kcygpLFxuICB9O1xufVxuXG4vLyBjb252ZXJ0IGEgY2FsZW5kYXIgb2JqZWN0IHRvIGEgZXBvY2ggdGltZXN0YW1wXG5mdW5jdGlvbiBvYmpUb1RTKG9iaiwgb2Zmc2V0LCB6b25lKSB7XG4gIHJldHVybiBmaXhPZmZzZXQob2JqVG9Mb2NhbFRTKG9iaiksIG9mZnNldCwgem9uZSk7XG59XG5cbi8vIGNyZWF0ZSBhIG5ldyBEVCBpbnN0YW5jZSBieSBhZGRpbmcgYSBkdXJhdGlvbiwgYWRqdXN0aW5nIGZvciBEU1RzXG5mdW5jdGlvbiBhZGp1c3RUaW1lKGluc3QsIGR1cikge1xuICBjb25zdCBvUHJlID0gaW5zdC5vLFxuICAgIHllYXIgPSBpbnN0LmMueWVhciArIE1hdGgudHJ1bmMoZHVyLnllYXJzKSxcbiAgICBtb250aCA9IGluc3QuYy5tb250aCArIE1hdGgudHJ1bmMoZHVyLm1vbnRocykgKyBNYXRoLnRydW5jKGR1ci5xdWFydGVycykgKiAzLFxuICAgIGMgPSB7XG4gICAgICAuLi5pbnN0LmMsXG4gICAgICB5ZWFyLFxuICAgICAgbW9udGgsXG4gICAgICBkYXk6XG4gICAgICAgIE1hdGgubWluKGluc3QuYy5kYXksIGRheXNJbk1vbnRoKHllYXIsIG1vbnRoKSkgK1xuICAgICAgICBNYXRoLnRydW5jKGR1ci5kYXlzKSArXG4gICAgICAgIE1hdGgudHJ1bmMoZHVyLndlZWtzKSAqIDcsXG4gICAgfSxcbiAgICBtaWxsaXNUb0FkZCA9IER1cmF0aW9uLmZyb21PYmplY3Qoe1xuICAgICAgeWVhcnM6IGR1ci55ZWFycyAtIE1hdGgudHJ1bmMoZHVyLnllYXJzKSxcbiAgICAgIHF1YXJ0ZXJzOiBkdXIucXVhcnRlcnMgLSBNYXRoLnRydW5jKGR1ci5xdWFydGVycyksXG4gICAgICBtb250aHM6IGR1ci5tb250aHMgLSBNYXRoLnRydW5jKGR1ci5tb250aHMpLFxuICAgICAgd2Vla3M6IGR1ci53ZWVrcyAtIE1hdGgudHJ1bmMoZHVyLndlZWtzKSxcbiAgICAgIGRheXM6IGR1ci5kYXlzIC0gTWF0aC50cnVuYyhkdXIuZGF5cyksXG4gICAgICBob3VyczogZHVyLmhvdXJzLFxuICAgICAgbWludXRlczogZHVyLm1pbnV0ZXMsXG4gICAgICBzZWNvbmRzOiBkdXIuc2Vjb25kcyxcbiAgICAgIG1pbGxpc2Vjb25kczogZHVyLm1pbGxpc2Vjb25kcyxcbiAgICB9KS5hcyhcIm1pbGxpc2Vjb25kc1wiKSxcbiAgICBsb2NhbFRTID0gb2JqVG9Mb2NhbFRTKGMpO1xuXG4gIGxldCBbdHMsIG9dID0gZml4T2Zmc2V0KGxvY2FsVFMsIG9QcmUsIGluc3Quem9uZSk7XG5cbiAgaWYgKG1pbGxpc1RvQWRkICE9PSAwKSB7XG4gICAgdHMgKz0gbWlsbGlzVG9BZGQ7XG4gICAgLy8gdGhhdCBjb3VsZCBoYXZlIGNoYW5nZWQgdGhlIG9mZnNldCBieSBnb2luZyBvdmVyIGEgRFNULCBidXQgd2Ugd2FudCB0byBrZWVwIHRoZSB0cyB0aGUgc2FtZVxuICAgIG8gPSBpbnN0LnpvbmUub2Zmc2V0KHRzKTtcbiAgfVxuXG4gIHJldHVybiB7IHRzLCBvIH07XG59XG5cbi8vIGhlbHBlciB1c2VmdWwgaW4gdHVybmluZyB0aGUgcmVzdWx0cyBvZiBwYXJzaW5nIGludG8gcmVhbCBkYXRlc1xuLy8gYnkgaGFuZGxpbmcgdGhlIHpvbmUgb3B0aW9uc1xuZnVuY3Rpb24gcGFyc2VEYXRhVG9EYXRlVGltZShwYXJzZWQsIHBhcnNlZFpvbmUsIG9wdHMsIGZvcm1hdCwgdGV4dCwgc3BlY2lmaWNPZmZzZXQpIHtcbiAgY29uc3QgeyBzZXRab25lLCB6b25lIH0gPSBvcHRzO1xuICBpZiAoKHBhcnNlZCAmJiBPYmplY3Qua2V5cyhwYXJzZWQpLmxlbmd0aCAhPT0gMCkgfHwgcGFyc2VkWm9uZSkge1xuICAgIGNvbnN0IGludGVycHJldGF0aW9uWm9uZSA9IHBhcnNlZFpvbmUgfHwgem9uZSxcbiAgICAgIGluc3QgPSBEYXRlVGltZS5mcm9tT2JqZWN0KHBhcnNlZCwge1xuICAgICAgICAuLi5vcHRzLFxuICAgICAgICB6b25lOiBpbnRlcnByZXRhdGlvblpvbmUsXG4gICAgICAgIHNwZWNpZmljT2Zmc2V0LFxuICAgICAgfSk7XG4gICAgcmV0dXJuIHNldFpvbmUgPyBpbnN0IDogaW5zdC5zZXRab25lKHpvbmUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKFxuICAgICAgbmV3IEludmFsaWQoXCJ1bnBhcnNhYmxlXCIsIGB0aGUgaW5wdXQgXCIke3RleHR9XCIgY2FuJ3QgYmUgcGFyc2VkIGFzICR7Zm9ybWF0fWApXG4gICAgKTtcbiAgfVxufVxuXG4vLyBpZiB5b3Ugd2FudCB0byBvdXRwdXQgYSB0ZWNobmljYWwgZm9ybWF0IChlLmcuIFJGQyAyODIyKSwgdGhpcyBoZWxwZXJcbi8vIGhlbHBzIGhhbmRsZSB0aGUgZGV0YWlsc1xuZnVuY3Rpb24gdG9UZWNoRm9ybWF0KGR0LCBmb3JtYXQsIGFsbG93WiA9IHRydWUpIHtcbiAgcmV0dXJuIGR0LmlzVmFsaWRcbiAgICA/IEZvcm1hdHRlci5jcmVhdGUoTG9jYWxlLmNyZWF0ZShcImVuLVVTXCIpLCB7XG4gICAgICAgIGFsbG93WixcbiAgICAgICAgZm9yY2VTaW1wbGU6IHRydWUsXG4gICAgICB9KS5mb3JtYXREYXRlVGltZUZyb21TdHJpbmcoZHQsIGZvcm1hdClcbiAgICA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIHRvSVNPRGF0ZShvLCBleHRlbmRlZCkge1xuICBjb25zdCBsb25nRm9ybWF0ID0gby5jLnllYXIgPiA5OTk5IHx8IG8uYy55ZWFyIDwgMDtcbiAgbGV0IGMgPSBcIlwiO1xuICBpZiAobG9uZ0Zvcm1hdCAmJiBvLmMueWVhciA+PSAwKSBjICs9IFwiK1wiO1xuICBjICs9IHBhZFN0YXJ0KG8uYy55ZWFyLCBsb25nRm9ybWF0ID8gNiA6IDQpO1xuXG4gIGlmIChleHRlbmRlZCkge1xuICAgIGMgKz0gXCItXCI7XG4gICAgYyArPSBwYWRTdGFydChvLmMubW9udGgpO1xuICAgIGMgKz0gXCItXCI7XG4gICAgYyArPSBwYWRTdGFydChvLmMuZGF5KTtcbiAgfSBlbHNlIHtcbiAgICBjICs9IHBhZFN0YXJ0KG8uYy5tb250aCk7XG4gICAgYyArPSBwYWRTdGFydChvLmMuZGF5KTtcbiAgfVxuICByZXR1cm4gYztcbn1cblxuZnVuY3Rpb24gdG9JU09UaW1lKFxuICBvLFxuICBleHRlbmRlZCxcbiAgc3VwcHJlc3NTZWNvbmRzLFxuICBzdXBwcmVzc01pbGxpc2Vjb25kcyxcbiAgaW5jbHVkZU9mZnNldCxcbiAgZXh0ZW5kZWRab25lXG4pIHtcbiAgbGV0IGMgPSBwYWRTdGFydChvLmMuaG91cik7XG4gIGlmIChleHRlbmRlZCkge1xuICAgIGMgKz0gXCI6XCI7XG4gICAgYyArPSBwYWRTdGFydChvLmMubWludXRlKTtcbiAgICBpZiAoby5jLm1pbGxpc2Vjb25kICE9PSAwIHx8IG8uYy5zZWNvbmQgIT09IDAgfHwgIXN1cHByZXNzU2Vjb25kcykge1xuICAgICAgYyArPSBcIjpcIjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYyArPSBwYWRTdGFydChvLmMubWludXRlKTtcbiAgfVxuXG4gIGlmIChvLmMubWlsbGlzZWNvbmQgIT09IDAgfHwgby5jLnNlY29uZCAhPT0gMCB8fCAhc3VwcHJlc3NTZWNvbmRzKSB7XG4gICAgYyArPSBwYWRTdGFydChvLmMuc2Vjb25kKTtcblxuICAgIGlmIChvLmMubWlsbGlzZWNvbmQgIT09IDAgfHwgIXN1cHByZXNzTWlsbGlzZWNvbmRzKSB7XG4gICAgICBjICs9IFwiLlwiO1xuICAgICAgYyArPSBwYWRTdGFydChvLmMubWlsbGlzZWNvbmQsIDMpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpbmNsdWRlT2Zmc2V0KSB7XG4gICAgaWYgKG8uaXNPZmZzZXRGaXhlZCAmJiBvLm9mZnNldCA9PT0gMCAmJiAhZXh0ZW5kZWRab25lKSB7XG4gICAgICBjICs9IFwiWlwiO1xuICAgIH0gZWxzZSBpZiAoby5vIDwgMCkge1xuICAgICAgYyArPSBcIi1cIjtcbiAgICAgIGMgKz0gcGFkU3RhcnQoTWF0aC50cnVuYygtby5vIC8gNjApKTtcbiAgICAgIGMgKz0gXCI6XCI7XG4gICAgICBjICs9IHBhZFN0YXJ0KE1hdGgudHJ1bmMoLW8ubyAlIDYwKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGMgKz0gXCIrXCI7XG4gICAgICBjICs9IHBhZFN0YXJ0KE1hdGgudHJ1bmMoby5vIC8gNjApKTtcbiAgICAgIGMgKz0gXCI6XCI7XG4gICAgICBjICs9IHBhZFN0YXJ0KE1hdGgudHJ1bmMoby5vICUgNjApKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZXh0ZW5kZWRab25lKSB7XG4gICAgYyArPSBcIltcIiArIG8uem9uZS5pYW5hTmFtZSArIFwiXVwiO1xuICB9XG4gIHJldHVybiBjO1xufVxuXG4vLyBkZWZhdWx0cyBmb3IgdW5zcGVjaWZpZWQgdW5pdHMgaW4gdGhlIHN1cHBvcnRlZCBjYWxlbmRhcnNcbmNvbnN0IGRlZmF1bHRVbml0VmFsdWVzID0ge1xuICAgIG1vbnRoOiAxLFxuICAgIGRheTogMSxcbiAgICBob3VyOiAwLFxuICAgIG1pbnV0ZTogMCxcbiAgICBzZWNvbmQ6IDAsXG4gICAgbWlsbGlzZWNvbmQ6IDAsXG4gIH0sXG4gIGRlZmF1bHRXZWVrVW5pdFZhbHVlcyA9IHtcbiAgICB3ZWVrTnVtYmVyOiAxLFxuICAgIHdlZWtkYXk6IDEsXG4gICAgaG91cjogMCxcbiAgICBtaW51dGU6IDAsXG4gICAgc2Vjb25kOiAwLFxuICAgIG1pbGxpc2Vjb25kOiAwLFxuICB9LFxuICBkZWZhdWx0T3JkaW5hbFVuaXRWYWx1ZXMgPSB7XG4gICAgb3JkaW5hbDogMSxcbiAgICBob3VyOiAwLFxuICAgIG1pbnV0ZTogMCxcbiAgICBzZWNvbmQ6IDAsXG4gICAgbWlsbGlzZWNvbmQ6IDAsXG4gIH07XG5cbi8vIFVuaXRzIGluIHRoZSBzdXBwb3J0ZWQgY2FsZW5kYXJzLCBzb3J0ZWQgYnkgYmlnbmVzc1xuY29uc3Qgb3JkZXJlZFVuaXRzID0gW1wieWVhclwiLCBcIm1vbnRoXCIsIFwiZGF5XCIsIFwiaG91clwiLCBcIm1pbnV0ZVwiLCBcInNlY29uZFwiLCBcIm1pbGxpc2Vjb25kXCJdLFxuICBvcmRlcmVkV2Vla1VuaXRzID0gW1xuICAgIFwid2Vla1llYXJcIixcbiAgICBcIndlZWtOdW1iZXJcIixcbiAgICBcIndlZWtkYXlcIixcbiAgICBcImhvdXJcIixcbiAgICBcIm1pbnV0ZVwiLFxuICAgIFwic2Vjb25kXCIsXG4gICAgXCJtaWxsaXNlY29uZFwiLFxuICBdLFxuICBvcmRlcmVkT3JkaW5hbFVuaXRzID0gW1wieWVhclwiLCBcIm9yZGluYWxcIiwgXCJob3VyXCIsIFwibWludXRlXCIsIFwic2Vjb25kXCIsIFwibWlsbGlzZWNvbmRcIl07XG5cbi8vIHN0YW5kYXJkaXplIGNhc2UgYW5kIHBsdXJhbGl0eSBpbiB1bml0c1xuZnVuY3Rpb24gbm9ybWFsaXplVW5pdCh1bml0KSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSB7XG4gICAgeWVhcjogXCJ5ZWFyXCIsXG4gICAgeWVhcnM6IFwieWVhclwiLFxuICAgIG1vbnRoOiBcIm1vbnRoXCIsXG4gICAgbW9udGhzOiBcIm1vbnRoXCIsXG4gICAgZGF5OiBcImRheVwiLFxuICAgIGRheXM6IFwiZGF5XCIsXG4gICAgaG91cjogXCJob3VyXCIsXG4gICAgaG91cnM6IFwiaG91clwiLFxuICAgIG1pbnV0ZTogXCJtaW51dGVcIixcbiAgICBtaW51dGVzOiBcIm1pbnV0ZVwiLFxuICAgIHF1YXJ0ZXI6IFwicXVhcnRlclwiLFxuICAgIHF1YXJ0ZXJzOiBcInF1YXJ0ZXJcIixcbiAgICBzZWNvbmQ6IFwic2Vjb25kXCIsXG4gICAgc2Vjb25kczogXCJzZWNvbmRcIixcbiAgICBtaWxsaXNlY29uZDogXCJtaWxsaXNlY29uZFwiLFxuICAgIG1pbGxpc2Vjb25kczogXCJtaWxsaXNlY29uZFwiLFxuICAgIHdlZWtkYXk6IFwid2Vla2RheVwiLFxuICAgIHdlZWtkYXlzOiBcIndlZWtkYXlcIixcbiAgICB3ZWVrbnVtYmVyOiBcIndlZWtOdW1iZXJcIixcbiAgICB3ZWVrc251bWJlcjogXCJ3ZWVrTnVtYmVyXCIsXG4gICAgd2Vla251bWJlcnM6IFwid2Vla051bWJlclwiLFxuICAgIHdlZWt5ZWFyOiBcIndlZWtZZWFyXCIsXG4gICAgd2Vla3llYXJzOiBcIndlZWtZZWFyXCIsXG4gICAgb3JkaW5hbDogXCJvcmRpbmFsXCIsXG4gIH1bdW5pdC50b0xvd2VyQ2FzZSgpXTtcblxuICBpZiAoIW5vcm1hbGl6ZWQpIHRocm93IG5ldyBJbnZhbGlkVW5pdEVycm9yKHVuaXQpO1xuXG4gIHJldHVybiBub3JtYWxpemVkO1xufVxuXG4vLyB0aGlzIGlzIGEgZHVtYmVkIGRvd24gdmVyc2lvbiBvZiBmcm9tT2JqZWN0KCkgdGhhdCBydW5zIGFib3V0IDYwJSBmYXN0ZXJcbi8vIGJ1dCBkb2Vzbid0IGRvIGFueSB2YWxpZGF0aW9uLCBtYWtlcyBhIGJ1bmNoIG9mIGFzc3VtcHRpb25zIGFib3V0IHdoYXQgdW5pdHNcbi8vIGFyZSBwcmVzZW50LCBhbmQgc28gb24uXG5mdW5jdGlvbiBxdWlja0RUKG9iaiwgb3B0cykge1xuICBjb25zdCB6b25lID0gbm9ybWFsaXplWm9uZShvcHRzLnpvbmUsIFNldHRpbmdzLmRlZmF1bHRab25lKSxcbiAgICBsb2MgPSBMb2NhbGUuZnJvbU9iamVjdChvcHRzKSxcbiAgICB0c05vdyA9IFNldHRpbmdzLm5vdygpO1xuXG4gIGxldCB0cywgbztcblxuICAvLyBhc3N1bWUgd2UgaGF2ZSB0aGUgaGlnaGVyLW9yZGVyIHVuaXRzXG4gIGlmICghaXNVbmRlZmluZWQob2JqLnllYXIpKSB7XG4gICAgZm9yIChjb25zdCB1IG9mIG9yZGVyZWRVbml0cykge1xuICAgICAgaWYgKGlzVW5kZWZpbmVkKG9ialt1XSkpIHtcbiAgICAgICAgb2JqW3VdID0gZGVmYXVsdFVuaXRWYWx1ZXNbdV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgaW52YWxpZCA9IGhhc0ludmFsaWRHcmVnb3JpYW5EYXRhKG9iaikgfHwgaGFzSW52YWxpZFRpbWVEYXRhKG9iaik7XG4gICAgaWYgKGludmFsaWQpIHtcbiAgICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKGludmFsaWQpO1xuICAgIH1cblxuICAgIGNvbnN0IG9mZnNldFByb3ZpcyA9IHpvbmUub2Zmc2V0KHRzTm93KTtcbiAgICBbdHMsIG9dID0gb2JqVG9UUyhvYmosIG9mZnNldFByb3Zpcywgem9uZSk7XG4gIH0gZWxzZSB7XG4gICAgdHMgPSB0c05vdztcbiAgfVxuXG4gIHJldHVybiBuZXcgRGF0ZVRpbWUoeyB0cywgem9uZSwgbG9jLCBvIH0pO1xufVxuXG5mdW5jdGlvbiBkaWZmUmVsYXRpdmUoc3RhcnQsIGVuZCwgb3B0cykge1xuICBjb25zdCByb3VuZCA9IGlzVW5kZWZpbmVkKG9wdHMucm91bmQpID8gdHJ1ZSA6IG9wdHMucm91bmQsXG4gICAgZm9ybWF0ID0gKGMsIHVuaXQpID0+IHtcbiAgICAgIGMgPSByb3VuZFRvKGMsIHJvdW5kIHx8IG9wdHMuY2FsZW5kYXJ5ID8gMCA6IDIsIHRydWUpO1xuICAgICAgY29uc3QgZm9ybWF0dGVyID0gZW5kLmxvYy5jbG9uZShvcHRzKS5yZWxGb3JtYXR0ZXIob3B0cyk7XG4gICAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdChjLCB1bml0KTtcbiAgICB9LFxuICAgIGRpZmZlciA9ICh1bml0KSA9PiB7XG4gICAgICBpZiAob3B0cy5jYWxlbmRhcnkpIHtcbiAgICAgICAgaWYgKCFlbmQuaGFzU2FtZShzdGFydCwgdW5pdCkpIHtcbiAgICAgICAgICByZXR1cm4gZW5kLnN0YXJ0T2YodW5pdCkuZGlmZihzdGFydC5zdGFydE9mKHVuaXQpLCB1bml0KS5nZXQodW5pdCk7XG4gICAgICAgIH0gZWxzZSByZXR1cm4gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBlbmQuZGlmZihzdGFydCwgdW5pdCkuZ2V0KHVuaXQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgaWYgKG9wdHMudW5pdCkge1xuICAgIHJldHVybiBmb3JtYXQoZGlmZmVyKG9wdHMudW5pdCksIG9wdHMudW5pdCk7XG4gIH1cblxuICBmb3IgKGNvbnN0IHVuaXQgb2Ygb3B0cy51bml0cykge1xuICAgIGNvbnN0IGNvdW50ID0gZGlmZmVyKHVuaXQpO1xuICAgIGlmIChNYXRoLmFicyhjb3VudCkgPj0gMSkge1xuICAgICAgcmV0dXJuIGZvcm1hdChjb3VudCwgdW5pdCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBmb3JtYXQoc3RhcnQgPiBlbmQgPyAtMCA6IDAsIG9wdHMudW5pdHNbb3B0cy51bml0cy5sZW5ndGggLSAxXSk7XG59XG5cbmZ1bmN0aW9uIGxhc3RPcHRzKGFyZ0xpc3QpIHtcbiAgbGV0IG9wdHMgPSB7fSxcbiAgICBhcmdzO1xuICBpZiAoYXJnTGlzdC5sZW5ndGggPiAwICYmIHR5cGVvZiBhcmdMaXN0W2FyZ0xpc3QubGVuZ3RoIC0gMV0gPT09IFwib2JqZWN0XCIpIHtcbiAgICBvcHRzID0gYXJnTGlzdFthcmdMaXN0Lmxlbmd0aCAtIDFdO1xuICAgIGFyZ3MgPSBBcnJheS5mcm9tKGFyZ0xpc3QpLnNsaWNlKDAsIGFyZ0xpc3QubGVuZ3RoIC0gMSk7XG4gIH0gZWxzZSB7XG4gICAgYXJncyA9IEFycmF5LmZyb20oYXJnTGlzdCk7XG4gIH1cbiAgcmV0dXJuIFtvcHRzLCBhcmdzXTtcbn1cblxuLyoqXG4gKiBBIERhdGVUaW1lIGlzIGFuIGltbXV0YWJsZSBkYXRhIHN0cnVjdHVyZSByZXByZXNlbnRpbmcgYSBzcGVjaWZpYyBkYXRlIGFuZCB0aW1lIGFuZCBhY2NvbXBhbnlpbmcgbWV0aG9kcy4gSXQgY29udGFpbnMgY2xhc3MgYW5kIGluc3RhbmNlIG1ldGhvZHMgZm9yIGNyZWF0aW5nLCBwYXJzaW5nLCBpbnRlcnJvZ2F0aW5nLCB0cmFuc2Zvcm1pbmcsIGFuZCBmb3JtYXR0aW5nIHRoZW0uXG4gKlxuICogQSBEYXRlVGltZSBjb21wcmlzZXMgb2Y6XG4gKiAqIEEgdGltZXN0YW1wLiBFYWNoIERhdGVUaW1lIGluc3RhbmNlIHJlZmVycyB0byBhIHNwZWNpZmljIG1pbGxpc2Vjb25kIG9mIHRoZSBVbml4IGVwb2NoLlxuICogKiBBIHRpbWUgem9uZS4gRWFjaCBpbnN0YW5jZSBpcyBjb25zaWRlcmVkIGluIHRoZSBjb250ZXh0IG9mIGEgc3BlY2lmaWMgem9uZSAoYnkgZGVmYXVsdCB0aGUgbG9jYWwgc3lzdGVtJ3Mgem9uZSkuXG4gKiAqIENvbmZpZ3VyYXRpb24gcHJvcGVydGllcyB0aGF0IGVmZmVjdCBob3cgb3V0cHV0IHN0cmluZ3MgYXJlIGZvcm1hdHRlZCwgc3VjaCBhcyBgbG9jYWxlYCwgYG51bWJlcmluZ1N5c3RlbWAsIGFuZCBgb3V0cHV0Q2FsZW5kYXJgLlxuICpcbiAqIEhlcmUgaXMgYSBicmllZiBvdmVydmlldyBvZiB0aGUgbW9zdCBjb21tb25seSB1c2VkIGZ1bmN0aW9uYWxpdHkgaXQgcHJvdmlkZXM6XG4gKlxuICogKiAqKkNyZWF0aW9uKio6IFRvIGNyZWF0ZSBhIERhdGVUaW1lIGZyb20gaXRzIGNvbXBvbmVudHMsIHVzZSBvbmUgb2YgaXRzIGZhY3RvcnkgY2xhc3MgbWV0aG9kczoge0BsaW5rIERhdGVUaW1lLmxvY2FsfSwge0BsaW5rIERhdGVUaW1lLnV0Y30sIGFuZCAobW9zdCBmbGV4aWJseSkge0BsaW5rIERhdGVUaW1lLmZyb21PYmplY3R9LiBUbyBjcmVhdGUgb25lIGZyb20gYSBzdGFuZGFyZCBzdHJpbmcgZm9ybWF0LCB1c2Uge0BsaW5rIERhdGVUaW1lLmZyb21JU099LCB7QGxpbmsgRGF0ZVRpbWUuZnJvbUhUVFB9LCBhbmQge0BsaW5rIERhdGVUaW1lLmZyb21SRkMyODIyfS4gVG8gY3JlYXRlIG9uZSBmcm9tIGEgY3VzdG9tIHN0cmluZyBmb3JtYXQsIHVzZSB7QGxpbmsgRGF0ZVRpbWUuZnJvbUZvcm1hdH0uIFRvIGNyZWF0ZSBvbmUgZnJvbSBhIG5hdGl2ZSBKUyBkYXRlLCB1c2Uge0BsaW5rIERhdGVUaW1lLmZyb21KU0RhdGV9LlxuICogKiAqKkdyZWdvcmlhbiBjYWxlbmRhciBhbmQgdGltZSoqOiBUbyBleGFtaW5lIHRoZSBHcmVnb3JpYW4gcHJvcGVydGllcyBvZiBhIERhdGVUaW1lIGluZGl2aWR1YWxseSAoaS5lIGFzIG9wcG9zZWQgdG8gY29sbGVjdGl2ZWx5IHRocm91Z2gge0BsaW5rIERhdGVUaW1lI3RvT2JqZWN0fSksIHVzZSB0aGUge0BsaW5rIERhdGVUaW1lI3llYXJ9LCB7QGxpbmsgRGF0ZVRpbWUjbW9udGh9LFxuICoge0BsaW5rIERhdGVUaW1lI2RheX0sIHtAbGluayBEYXRlVGltZSNob3VyfSwge0BsaW5rIERhdGVUaW1lI21pbnV0ZX0sIHtAbGluayBEYXRlVGltZSNzZWNvbmR9LCB7QGxpbmsgRGF0ZVRpbWUjbWlsbGlzZWNvbmR9IGFjY2Vzc29ycy5cbiAqICogKipXZWVrIGNhbGVuZGFyKio6IEZvciBJU08gd2VlayBjYWxlbmRhciBhdHRyaWJ1dGVzLCBzZWUgdGhlIHtAbGluayBEYXRlVGltZSN3ZWVrWWVhcn0sIHtAbGluayBEYXRlVGltZSN3ZWVrTnVtYmVyfSwgYW5kIHtAbGluayBEYXRlVGltZSN3ZWVrZGF5fSBhY2Nlc3NvcnMuXG4gKiAqICoqQ29uZmlndXJhdGlvbioqIFNlZSB0aGUge0BsaW5rIERhdGVUaW1lI2xvY2FsZX0gYW5kIHtAbGluayBEYXRlVGltZSNudW1iZXJpbmdTeXN0ZW19IGFjY2Vzc29ycy5cbiAqICogKipUcmFuc2Zvcm1hdGlvbioqOiBUbyB0cmFuc2Zvcm0gdGhlIERhdGVUaW1lIGludG8gb3RoZXIgRGF0ZVRpbWVzLCB1c2Uge0BsaW5rIERhdGVUaW1lI3NldH0sIHtAbGluayBEYXRlVGltZSNyZWNvbmZpZ3VyZX0sIHtAbGluayBEYXRlVGltZSNzZXRab25lfSwge0BsaW5rIERhdGVUaW1lI3NldExvY2FsZX0sIHtAbGluayBEYXRlVGltZS5wbHVzfSwge0BsaW5rIERhdGVUaW1lI21pbnVzfSwge0BsaW5rIERhdGVUaW1lI2VuZE9mfSwge0BsaW5rIERhdGVUaW1lI3N0YXJ0T2Z9LCB7QGxpbmsgRGF0ZVRpbWUjdG9VVEN9LCBhbmQge0BsaW5rIERhdGVUaW1lI3RvTG9jYWx9LlxuICogKiAqKk91dHB1dCoqOiBUbyBjb252ZXJ0IHRoZSBEYXRlVGltZSB0byBvdGhlciByZXByZXNlbnRhdGlvbnMsIHVzZSB0aGUge0BsaW5rIERhdGVUaW1lI3RvUmVsYXRpdmV9LCB7QGxpbmsgRGF0ZVRpbWUjdG9SZWxhdGl2ZUNhbGVuZGFyfSwge0BsaW5rIERhdGVUaW1lI3RvSlNPTn0sIHtAbGluayBEYXRlVGltZSN0b0lTT30sIHtAbGluayBEYXRlVGltZSN0b0hUVFB9LCB7QGxpbmsgRGF0ZVRpbWUjdG9PYmplY3R9LCB7QGxpbmsgRGF0ZVRpbWUjdG9SRkMyODIyfSwge0BsaW5rIERhdGVUaW1lI3RvU3RyaW5nfSwge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSwge0BsaW5rIERhdGVUaW1lI3RvRm9ybWF0fSwge0BsaW5rIERhdGVUaW1lI3RvTWlsbGlzfSBhbmQge0BsaW5rIERhdGVUaW1lI3RvSlNEYXRlfS5cbiAqXG4gKiBUaGVyZSdzIHBsZW50eSBvdGhlcnMgZG9jdW1lbnRlZCBiZWxvdy4gSW4gYWRkaXRpb24sIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHN1YnRsZXIgdG9waWNzIGxpa2UgaW50ZXJuYXRpb25hbGl6YXRpb24sIHRpbWUgem9uZXMsIGFsdGVybmF0aXZlIGNhbGVuZGFycywgdmFsaWRpdHksIGFuZCBzbyBvbiwgc2VlIHRoZSBleHRlcm5hbCBkb2N1bWVudGF0aW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEYXRlVGltZSB7XG4gIC8qKlxuICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIGNvbnN0IHpvbmUgPSBjb25maWcuem9uZSB8fCBTZXR0aW5ncy5kZWZhdWx0Wm9uZTtcblxuICAgIGxldCBpbnZhbGlkID1cbiAgICAgIGNvbmZpZy5pbnZhbGlkIHx8XG4gICAgICAoTnVtYmVyLmlzTmFOKGNvbmZpZy50cykgPyBuZXcgSW52YWxpZChcImludmFsaWQgaW5wdXRcIikgOiBudWxsKSB8fFxuICAgICAgKCF6b25lLmlzVmFsaWQgPyB1bnN1cHBvcnRlZFpvbmUoem9uZSkgOiBudWxsKTtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnRzID0gaXNVbmRlZmluZWQoY29uZmlnLnRzKSA/IFNldHRpbmdzLm5vdygpIDogY29uZmlnLnRzO1xuXG4gICAgbGV0IGMgPSBudWxsLFxuICAgICAgbyA9IG51bGw7XG4gICAgaWYgKCFpbnZhbGlkKSB7XG4gICAgICBjb25zdCB1bmNoYW5nZWQgPSBjb25maWcub2xkICYmIGNvbmZpZy5vbGQudHMgPT09IHRoaXMudHMgJiYgY29uZmlnLm9sZC56b25lLmVxdWFscyh6b25lKTtcblxuICAgICAgaWYgKHVuY2hhbmdlZCkge1xuICAgICAgICBbYywgb10gPSBbY29uZmlnLm9sZC5jLCBjb25maWcub2xkLm9dO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgb3QgPSB6b25lLm9mZnNldCh0aGlzLnRzKTtcbiAgICAgICAgYyA9IHRzVG9PYmoodGhpcy50cywgb3QpO1xuICAgICAgICBpbnZhbGlkID0gTnVtYmVyLmlzTmFOKGMueWVhcikgPyBuZXcgSW52YWxpZChcImludmFsaWQgaW5wdXRcIikgOiBudWxsO1xuICAgICAgICBjID0gaW52YWxpZCA/IG51bGwgOiBjO1xuICAgICAgICBvID0gaW52YWxpZCA/IG51bGwgOiBvdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl96b25lID0gem9uZTtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmxvYyA9IGNvbmZpZy5sb2MgfHwgTG9jYWxlLmNyZWF0ZSgpO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaW52YWxpZCA9IGludmFsaWQ7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy53ZWVrRGF0YSA9IG51bGw7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5jID0gYztcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLm8gPSBvO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaXNMdXhvbkRhdGVUaW1lID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIENPTlNUUlVDVFxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmb3IgdGhlIGN1cnJlbnQgaW5zdGFudCwgaW4gdGhlIHN5c3RlbSdzIHRpbWUgem9uZS5cbiAgICpcbiAgICogVXNlIFNldHRpbmdzIHRvIG92ZXJyaWRlIHRoZXNlIGRlZmF1bHQgdmFsdWVzIGlmIG5lZWRlZC5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9JU08oKSAvL34+IG5vdyBpbiB0aGUgSVNPIGZvcm1hdFxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBub3coKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlVGltZSh7fSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbG9jYWwgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt5ZWFyXSAtIFRoZSBjYWxlbmRhciB5ZWFyLiBJZiBvbWl0dGVkIChhcyBpbiwgY2FsbCBgbG9jYWwoKWAgd2l0aCBubyBhcmd1bWVudHMpLCB0aGUgY3VycmVudCB0aW1lIHdpbGwgYmUgdXNlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gW21vbnRoPTFdIC0gVGhlIG1vbnRoLCAxLWluZGV4ZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtkYXk9MV0gLSBUaGUgZGF5IG9mIHRoZSBtb250aCwgMS1pbmRleGVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbaG91cj0wXSAtIFRoZSBob3VyIG9mIHRoZSBkYXksIGluIDI0LWhvdXIgdGltZVxuICAgKiBAcGFyYW0ge251bWJlcn0gW21pbnV0ZT0wXSAtIFRoZSBtaW51dGUgb2YgdGhlIGhvdXIsIG1lYW5pbmcgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCA1OVxuICAgKiBAcGFyYW0ge251bWJlcn0gW3NlY29uZD0wXSAtIFRoZSBzZWNvbmQgb2YgdGhlIG1pbnV0ZSwgbWVhbmluZyBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDU5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbWlsbGlzZWNvbmQ9MF0gLSBUaGUgbWlsbGlzZWNvbmQgb2YgdGhlIHNlY29uZCwgbWVhbmluZyBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDk5OVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gbm93XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKHsgem9uZTogXCJBbWVyaWNhL05ld19Zb3JrXCIgfSkgICAgICAvL34+IG5vdywgaW4gVVMgZWFzdCBjb2FzdCB0aW1lXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9+PiAyMDE3LTAxLTAxVDAwOjAwOjAwXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDMpICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9+PiAyMDE3LTAzLTAxVDAwOjAwOjAwXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDMsIDEyLCB7IGxvY2FsZTogXCJmclwiIH0pICAgICAvL34+IDIwMTctMDMtMTJUMDA6MDA6MDAsIHdpdGggYSBGcmVuY2ggbG9jYWxlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDMsIDEyLCA1KSAgICAgICAgICAgICAgICAgICAgLy9+PiAyMDE3LTAzLTEyVDA1OjAwOjAwXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDMsIDEyLCA1LCB7IHpvbmU6IFwidXRjXCIgfSkgICAvL34+IDIwMTctMDMtMTJUMDU6MDA6MDAsIGluIFVUQ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAzLCAxMiwgNSwgNDUpICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0xMlQwNTo0NTowMFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAzLCAxMiwgNSwgNDUsIDEwKSAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0xMlQwNTo0NToxMFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAzLCAxMiwgNSwgNDUsIDEwLCA3NjUpICAgICAgIC8vfj4gMjAxNy0wMy0xMlQwNTo0NToxMC43NjVcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgbG9jYWwoKSB7XG4gICAgY29uc3QgW29wdHMsIGFyZ3NdID0gbGFzdE9wdHMoYXJndW1lbnRzKSxcbiAgICAgIFt5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmRdID0gYXJncztcbiAgICByZXR1cm4gcXVpY2tEVCh7IHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCB9LCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBpbiBVVENcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt5ZWFyXSAtIFRoZSBjYWxlbmRhciB5ZWFyLiBJZiBvbWl0dGVkIChhcyBpbiwgY2FsbCBgdXRjKClgIHdpdGggbm8gYXJndW1lbnRzKSwgdGhlIGN1cnJlbnQgdGltZSB3aWxsIGJlIHVzZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFttb250aD0xXSAtIFRoZSBtb250aCwgMS1pbmRleGVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZGF5PTFdIC0gVGhlIGRheSBvZiB0aGUgbW9udGhcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtob3VyPTBdIC0gVGhlIGhvdXIgb2YgdGhlIGRheSwgaW4gMjQtaG91ciB0aW1lXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbWludXRlPTBdIC0gVGhlIG1pbnV0ZSBvZiB0aGUgaG91ciwgbWVhbmluZyBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDU5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc2Vjb25kPTBdIC0gVGhlIHNlY29uZCBvZiB0aGUgbWludXRlLCBtZWFuaW5nIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgNTlcbiAgICogQHBhcmFtIHtudW1iZXJ9IFttaWxsaXNlY29uZD0wXSAtIFRoZSBtaWxsaXNlY29uZCBvZiB0aGUgc2Vjb25kLCBtZWFuaW5nIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgOTk5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxvY2FsZV0gLSBhIGxvY2FsZSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMub3V0cHV0Q2FsZW5kYXJdIC0gdGhlIG91dHB1dCBjYWxlbmRhciB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubnVtYmVyaW5nU3lzdGVtXSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gbm93XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE3KSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMS0wMVQwMDowMDowMFpcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTcsIDMpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9+PiAyMDE3LTAzLTAxVDAwOjAwOjAwWlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNywgMywgMTIpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDA6MDA6MDBaXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE3LCAzLCAxMiwgNSkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0xMlQwNTowMDowMFpcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTcsIDMsIDEyLCA1LCA0NSkgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9+PiAyMDE3LTAzLTEyVDA1OjQ1OjAwWlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNywgMywgMTIsIDUsIDQ1LCB7IGxvY2FsZTogXCJmclwiIH0pICAgICAgICAgIC8vfj4gMjAxNy0wMy0xMlQwNTo0NTowMFogd2l0aCBhIEZyZW5jaCBsb2NhbGVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTcsIDMsIDEyLCA1LCA0NSwgMTApICAgICAgICAgICAgICAgICAgICAgICAgLy9+PiAyMDE3LTAzLTEyVDA1OjQ1OjEwWlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNywgMywgMTIsIDUsIDQ1LCAxMCwgNzY1LCB7IGxvY2FsZTogXCJmclwiIH0pIC8vfj4gMjAxNy0wMy0xMlQwNTo0NToxMC43NjVaIHdpdGggYSBGcmVuY2ggbG9jYWxlXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIHV0YygpIHtcbiAgICBjb25zdCBbb3B0cywgYXJnc10gPSBsYXN0T3B0cyhhcmd1bWVudHMpLFxuICAgICAgW3llYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZF0gPSBhcmdzO1xuXG4gICAgb3B0cy56b25lID0gRml4ZWRPZmZzZXRab25lLnV0Y0luc3RhbmNlO1xuICAgIHJldHVybiBxdWlja0RUKHsgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kIH0sIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYSBKYXZhU2NyaXB0IERhdGUgb2JqZWN0LiBVc2VzIHRoZSBkZWZhdWx0IHpvbmUuXG4gICAqIEBwYXJhbSB7RGF0ZX0gZGF0ZSAtIGEgSmF2YVNjcmlwdCBEYXRlIG9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFtvcHRpb25zLnpvbmU9J2xvY2FsJ10gLSB0aGUgem9uZSB0byBwbGFjZSB0aGUgRGF0ZVRpbWUgaW50b1xuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBmcm9tSlNEYXRlKGRhdGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHRzID0gaXNEYXRlKGRhdGUpID8gZGF0ZS52YWx1ZU9mKCkgOiBOYU47XG4gICAgaWYgKE51bWJlci5pc05hTih0cykpIHtcbiAgICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKFwiaW52YWxpZCBpbnB1dFwiKTtcbiAgICB9XG5cbiAgICBjb25zdCB6b25lVG9Vc2UgPSBub3JtYWxpemVab25lKG9wdGlvbnMuem9uZSwgU2V0dGluZ3MuZGVmYXVsdFpvbmUpO1xuICAgIGlmICghem9uZVRvVXNlLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKHVuc3VwcG9ydGVkWm9uZSh6b25lVG9Vc2UpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IERhdGVUaW1lKHtcbiAgICAgIHRzOiB0cyxcbiAgICAgIHpvbmU6IHpvbmVUb1VzZSxcbiAgICAgIGxvYzogTG9jYWxlLmZyb21PYmplY3Qob3B0aW9ucyksXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMgc2luY2UgdGhlIGVwb2NoIChtZWFuaW5nIHNpbmNlIDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuIFVzZXMgdGhlIGRlZmF1bHQgem9uZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pbGxpc2Vjb25kcyAtIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZSAxOTcwIFVUQ1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFtvcHRpb25zLnpvbmU9J2xvY2FsJ10gLSB0aGUgem9uZSB0byBwbGFjZSB0aGUgRGF0ZVRpbWUgaW50b1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubG9jYWxlXSAtIGEgbG9jYWxlIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm91dHB1dENhbGVuZGFyIC0gdGhlIG91dHB1dCBjYWxlbmRhciB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBmcm9tTWlsbGlzKG1pbGxpc2Vjb25kcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCFpc051bWJlcihtaWxsaXNlY29uZHMpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXG4gICAgICAgIGBmcm9tTWlsbGlzIHJlcXVpcmVzIGEgbnVtZXJpY2FsIGlucHV0LCBidXQgcmVjZWl2ZWQgYSAke3R5cGVvZiBtaWxsaXNlY29uZHN9IHdpdGggdmFsdWUgJHttaWxsaXNlY29uZHN9YFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKG1pbGxpc2Vjb25kcyA8IC1NQVhfREFURSB8fCBtaWxsaXNlY29uZHMgPiBNQVhfREFURSkge1xuICAgICAgLy8gdGhpcyBpc24ndCBwZXJmZWN0IGJlY2F1c2UgYmVjYXVzZSB3ZSBjYW4gc3RpbGwgZW5kIHVwIG91dCBvZiByYW5nZSBiZWNhdXNlIG9mIGFkZGl0aW9uYWwgc2hpZnRpbmcsIGJ1dCBpdCdzIGEgc3RhcnRcbiAgICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKFwiVGltZXN0YW1wIG91dCBvZiByYW5nZVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlVGltZSh7XG4gICAgICAgIHRzOiBtaWxsaXNlY29uZHMsXG4gICAgICAgIHpvbmU6IG5vcm1hbGl6ZVpvbmUob3B0aW9ucy56b25lLCBTZXR0aW5ncy5kZWZhdWx0Wm9uZSksXG4gICAgICAgIGxvYzogTG9jYWxlLmZyb21PYmplY3Qob3B0aW9ucyksXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhIG51bWJlciBvZiBzZWNvbmRzIHNpbmNlIHRoZSBlcG9jaCAobWVhbmluZyBzaW5jZSAxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLiBVc2VzIHRoZSBkZWZhdWx0IHpvbmUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzZWNvbmRzIC0gYSBudW1iZXIgb2Ygc2Vjb25kcyBzaW5jZSAxOTcwIFVUQ1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFtvcHRpb25zLnpvbmU9J2xvY2FsJ10gLSB0aGUgem9uZSB0byBwbGFjZSB0aGUgRGF0ZVRpbWUgaW50b1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubG9jYWxlXSAtIGEgbG9jYWxlIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm91dHB1dENhbGVuZGFyIC0gdGhlIG91dHB1dCBjYWxlbmRhciB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBmcm9tU2Vjb25kcyhzZWNvbmRzLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoIWlzTnVtYmVyKHNlY29uZHMpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJmcm9tU2Vjb25kcyByZXF1aXJlcyBhIG51bWVyaWNhbCBpbnB1dFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlVGltZSh7XG4gICAgICAgIHRzOiBzZWNvbmRzICogMTAwMCxcbiAgICAgICAgem9uZTogbm9ybWFsaXplWm9uZShvcHRpb25zLnpvbmUsIFNldHRpbmdzLmRlZmF1bHRab25lKSxcbiAgICAgICAgbG9jOiBMb2NhbGUuZnJvbU9iamVjdChvcHRpb25zKSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGEgSmF2YVNjcmlwdCBvYmplY3Qgd2l0aCBrZXlzIGxpa2UgJ3llYXInIGFuZCAnaG91cicgd2l0aCByZWFzb25hYmxlIGRlZmF1bHRzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gdGhlIG9iamVjdCB0byBjcmVhdGUgdGhlIERhdGVUaW1lIGZyb21cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai55ZWFyIC0gYSB5ZWFyLCBzdWNoIGFzIDE5ODdcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5tb250aCAtIGEgbW9udGgsIDEtMTJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5kYXkgLSBhIGRheSBvZiB0aGUgbW9udGgsIDEtMzEsIGRlcGVuZGluZyBvbiB0aGUgbW9udGhcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5vcmRpbmFsIC0gZGF5IG9mIHRoZSB5ZWFyLCAxLTM2NSBvciAzNjZcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai53ZWVrWWVhciAtIGFuIElTTyB3ZWVrIHllYXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai53ZWVrTnVtYmVyIC0gYW4gSVNPIHdlZWsgbnVtYmVyLCBiZXR3ZWVuIDEgYW5kIDUyIG9yIDUzLCBkZXBlbmRpbmcgb24gdGhlIHllYXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai53ZWVrZGF5IC0gYW4gSVNPIHdlZWtkYXksIDEtNywgd2hlcmUgMSBpcyBNb25kYXkgYW5kIDcgaXMgU3VuZGF5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmouaG91ciAtIGhvdXIgb2YgdGhlIGRheSwgMC0yM1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLm1pbnV0ZSAtIG1pbnV0ZSBvZiB0aGUgaG91ciwgMC01OVxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLnNlY29uZCAtIHNlY29uZCBvZiB0aGUgbWludXRlLCAwLTU5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoubWlsbGlzZWNvbmQgLSBtaWxsaXNlY29uZCBvZiB0aGUgc2Vjb25kLCAwLTk5OVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRoaXMgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdHMuem9uZT0nbG9jYWwnXSAtIGludGVycHJldCB0aGUgbnVtYmVycyBpbiB0aGUgY29udGV4dCBvZiBhIHBhcnRpY3VsYXIgem9uZS4gQ2FuIHRha2UgYW55IHZhbHVlIHRha2VuIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byBzZXRab25lKClcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nc3lzdGVtJ3MgbG9jYWxlJ10gLSBhIGxvY2FsZSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5vdXRwdXRDYWxlbmRhciAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbU9iamVjdCh7IHllYXI6IDE5ODIsIG1vbnRoOiA1LCBkYXk6IDI1fSkudG9JU09EYXRlKCkgLy89PiAnMTk4Mi0wNS0yNSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbU9iamVjdCh7IHllYXI6IDE5ODIgfSkudG9JU09EYXRlKCkgLy89PiAnMTk4Mi0wMS0wMSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbU9iamVjdCh7IGhvdXI6IDEwLCBtaW51dGU6IDI2LCBzZWNvbmQ6IDYgfSkgLy9+PiB0b2RheSBhdCAxMDoyNjowNlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tT2JqZWN0KHsgaG91cjogMTAsIG1pbnV0ZTogMjYsIHNlY29uZDogNiB9LCB7IHpvbmU6ICd1dGMnIH0pLFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tT2JqZWN0KHsgaG91cjogMTAsIG1pbnV0ZTogMjYsIHNlY29uZDogNiB9LCB7IHpvbmU6ICdsb2NhbCcgfSlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbU9iamVjdCh7IGhvdXI6IDEwLCBtaW51dGU6IDI2LCBzZWNvbmQ6IDYgfSwgeyB6b25lOiAnQW1lcmljYS9OZXdfWW9yaycgfSlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbU9iamVjdCh7IHdlZWtZZWFyOiAyMDE2LCB3ZWVrTnVtYmVyOiAyLCB3ZWVrZGF5OiAzIH0pLnRvSVNPRGF0ZSgpIC8vPT4gJzIwMTYtMDEtMTMnXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGZyb21PYmplY3Qob2JqLCBvcHRzID0ge30pIHtcbiAgICBvYmogPSBvYmogfHwge307XG4gICAgY29uc3Qgem9uZVRvVXNlID0gbm9ybWFsaXplWm9uZShvcHRzLnpvbmUsIFNldHRpbmdzLmRlZmF1bHRab25lKTtcbiAgICBpZiAoIXpvbmVUb1VzZS5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZCh1bnN1cHBvcnRlZFpvbmUoem9uZVRvVXNlKSk7XG4gICAgfVxuXG4gICAgY29uc3QgdHNOb3cgPSBTZXR0aW5ncy5ub3coKSxcbiAgICAgIG9mZnNldFByb3ZpcyA9ICFpc1VuZGVmaW5lZChvcHRzLnNwZWNpZmljT2Zmc2V0KVxuICAgICAgICA/IG9wdHMuc3BlY2lmaWNPZmZzZXRcbiAgICAgICAgOiB6b25lVG9Vc2Uub2Zmc2V0KHRzTm93KSxcbiAgICAgIG5vcm1hbGl6ZWQgPSBub3JtYWxpemVPYmplY3Qob2JqLCBub3JtYWxpemVVbml0KSxcbiAgICAgIGNvbnRhaW5zT3JkaW5hbCA9ICFpc1VuZGVmaW5lZChub3JtYWxpemVkLm9yZGluYWwpLFxuICAgICAgY29udGFpbnNHcmVnb3JZZWFyID0gIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQueWVhciksXG4gICAgICBjb250YWluc0dyZWdvck1EID0gIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQubW9udGgpIHx8ICFpc1VuZGVmaW5lZChub3JtYWxpemVkLmRheSksXG4gICAgICBjb250YWluc0dyZWdvciA9IGNvbnRhaW5zR3JlZ29yWWVhciB8fCBjb250YWluc0dyZWdvck1ELFxuICAgICAgZGVmaW5pdGVXZWVrRGVmID0gbm9ybWFsaXplZC53ZWVrWWVhciB8fCBub3JtYWxpemVkLndlZWtOdW1iZXIsXG4gICAgICBsb2MgPSBMb2NhbGUuZnJvbU9iamVjdChvcHRzKTtcblxuICAgIC8vIGNhc2VzOlxuICAgIC8vIGp1c3QgYSB3ZWVrZGF5IC0+IHRoaXMgd2VlaydzIGluc3RhbmNlIG9mIHRoYXQgd2Vla2RheSwgbm8gd29ycmllc1xuICAgIC8vIChncmVnb3JpYW4gZGF0YSBvciBvcmRpbmFsKSArICh3ZWVrWWVhciBvciB3ZWVrTnVtYmVyKSAtPiBlcnJvclxuICAgIC8vIChncmVnb3JpYW4gbW9udGggb3IgZGF5KSArIG9yZGluYWwgLT4gZXJyb3JcbiAgICAvLyBvdGhlcndpc2UganVzdCB1c2Ugd2Vla3Mgb3Igb3JkaW5hbHMgb3IgZ3JlZ29yaWFuLCBkZXBlbmRpbmcgb24gd2hhdCdzIHNwZWNpZmllZFxuXG4gICAgaWYgKChjb250YWluc0dyZWdvciB8fCBjb250YWluc09yZGluYWwpICYmIGRlZmluaXRlV2Vla0RlZikge1xuICAgICAgdGhyb3cgbmV3IENvbmZsaWN0aW5nU3BlY2lmaWNhdGlvbkVycm9yKFxuICAgICAgICBcIkNhbid0IG1peCB3ZWVrWWVhci93ZWVrTnVtYmVyIHVuaXRzIHdpdGggeWVhci9tb250aC9kYXkgb3Igb3JkaW5hbHNcIlxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoY29udGFpbnNHcmVnb3JNRCAmJiBjb250YWluc09yZGluYWwpIHtcbiAgICAgIHRocm93IG5ldyBDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvcihcIkNhbid0IG1peCBvcmRpbmFsIGRhdGVzIHdpdGggbW9udGgvZGF5XCIpO1xuICAgIH1cblxuICAgIGNvbnN0IHVzZVdlZWtEYXRhID0gZGVmaW5pdGVXZWVrRGVmIHx8IChub3JtYWxpemVkLndlZWtkYXkgJiYgIWNvbnRhaW5zR3JlZ29yKTtcblxuICAgIC8vIGNvbmZpZ3VyZSBvdXJzZWx2ZXMgdG8gZGVhbCB3aXRoIGdyZWdvcmlhbiBkYXRlcyBvciB3ZWVrIHN0dWZmXG4gICAgbGV0IHVuaXRzLFxuICAgICAgZGVmYXVsdFZhbHVlcyxcbiAgICAgIG9iak5vdyA9IHRzVG9PYmoodHNOb3csIG9mZnNldFByb3Zpcyk7XG4gICAgaWYgKHVzZVdlZWtEYXRhKSB7XG4gICAgICB1bml0cyA9IG9yZGVyZWRXZWVrVW5pdHM7XG4gICAgICBkZWZhdWx0VmFsdWVzID0gZGVmYXVsdFdlZWtVbml0VmFsdWVzO1xuICAgICAgb2JqTm93ID0gZ3JlZ29yaWFuVG9XZWVrKG9iak5vdyk7XG4gICAgfSBlbHNlIGlmIChjb250YWluc09yZGluYWwpIHtcbiAgICAgIHVuaXRzID0gb3JkZXJlZE9yZGluYWxVbml0cztcbiAgICAgIGRlZmF1bHRWYWx1ZXMgPSBkZWZhdWx0T3JkaW5hbFVuaXRWYWx1ZXM7XG4gICAgICBvYmpOb3cgPSBncmVnb3JpYW5Ub09yZGluYWwob2JqTm93KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdW5pdHMgPSBvcmRlcmVkVW5pdHM7XG4gICAgICBkZWZhdWx0VmFsdWVzID0gZGVmYXVsdFVuaXRWYWx1ZXM7XG4gICAgfVxuXG4gICAgLy8gc2V0IGRlZmF1bHQgdmFsdWVzIGZvciBtaXNzaW5nIHN0dWZmXG4gICAgbGV0IGZvdW5kRmlyc3QgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IHUgb2YgdW5pdHMpIHtcbiAgICAgIGNvbnN0IHYgPSBub3JtYWxpemVkW3VdO1xuICAgICAgaWYgKCFpc1VuZGVmaW5lZCh2KSkge1xuICAgICAgICBmb3VuZEZpcnN0ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZm91bmRGaXJzdCkge1xuICAgICAgICBub3JtYWxpemVkW3VdID0gZGVmYXVsdFZhbHVlc1t1XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vcm1hbGl6ZWRbdV0gPSBvYmpOb3dbdV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gbWFrZSBzdXJlIHRoZSB2YWx1ZXMgd2UgaGF2ZSBhcmUgaW4gcmFuZ2VcbiAgICBjb25zdCBoaWdoZXJPcmRlckludmFsaWQgPSB1c2VXZWVrRGF0YVxuICAgICAgICA/IGhhc0ludmFsaWRXZWVrRGF0YShub3JtYWxpemVkKVxuICAgICAgICA6IGNvbnRhaW5zT3JkaW5hbFxuICAgICAgICA/IGhhc0ludmFsaWRPcmRpbmFsRGF0YShub3JtYWxpemVkKVxuICAgICAgICA6IGhhc0ludmFsaWRHcmVnb3JpYW5EYXRhKG5vcm1hbGl6ZWQpLFxuICAgICAgaW52YWxpZCA9IGhpZ2hlck9yZGVySW52YWxpZCB8fCBoYXNJbnZhbGlkVGltZURhdGEobm9ybWFsaXplZCk7XG5cbiAgICBpZiAoaW52YWxpZCkge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQoaW52YWxpZCk7XG4gICAgfVxuXG4gICAgLy8gY29tcHV0ZSB0aGUgYWN0dWFsIHRpbWVcbiAgICBjb25zdCBncmVnb3JpYW4gPSB1c2VXZWVrRGF0YVxuICAgICAgICA/IHdlZWtUb0dyZWdvcmlhbihub3JtYWxpemVkKVxuICAgICAgICA6IGNvbnRhaW5zT3JkaW5hbFxuICAgICAgICA/IG9yZGluYWxUb0dyZWdvcmlhbihub3JtYWxpemVkKVxuICAgICAgICA6IG5vcm1hbGl6ZWQsXG4gICAgICBbdHNGaW5hbCwgb2Zmc2V0RmluYWxdID0gb2JqVG9UUyhncmVnb3JpYW4sIG9mZnNldFByb3Zpcywgem9uZVRvVXNlKSxcbiAgICAgIGluc3QgPSBuZXcgRGF0ZVRpbWUoe1xuICAgICAgICB0czogdHNGaW5hbCxcbiAgICAgICAgem9uZTogem9uZVRvVXNlLFxuICAgICAgICBvOiBvZmZzZXRGaW5hbCxcbiAgICAgICAgbG9jLFxuICAgICAgfSk7XG5cbiAgICAvLyBncmVnb3JpYW4gZGF0YSArIHdlZWtkYXkgc2VydmVzIG9ubHkgdG8gdmFsaWRhdGVcbiAgICBpZiAobm9ybWFsaXplZC53ZWVrZGF5ICYmIGNvbnRhaW5zR3JlZ29yICYmIG9iai53ZWVrZGF5ICE9PSBpbnN0LndlZWtkYXkpIHtcbiAgICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKFxuICAgICAgICBcIm1pc21hdGNoZWQgd2Vla2RheVwiLFxuICAgICAgICBgeW91IGNhbid0IHNwZWNpZnkgYm90aCBhIHdlZWtkYXkgb2YgJHtub3JtYWxpemVkLndlZWtkYXl9IGFuZCBhIGRhdGUgb2YgJHtpbnN0LnRvSVNPKCl9YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGFuIElTTyA4NjAxIHN0cmluZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRoZSBJU08gc3RyaW5nXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyB0byBhZmZlY3QgdGhlIGNyZWF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFtvcHRzLnpvbmU9J2xvY2FsJ10gLSB1c2UgdGhpcyB6b25lIGlmIG5vIG9mZnNldCBpcyBzcGVjaWZpZWQgaW4gdGhlIGlucHV0IHN0cmluZyBpdHNlbGYuIFdpbGwgYWxzbyBjb252ZXJ0IHRoZSB0aW1lIHRvIHRoaXMgem9uZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnNldFpvbmU9ZmFsc2VdIC0gb3ZlcnJpZGUgdGhlIHpvbmUgd2l0aCBhIGZpeGVkLW9mZnNldCB6b25lIHNwZWNpZmllZCBpbiB0aGUgc3RyaW5nIGl0c2VsZiwgaWYgaXQgc3BlY2lmaWVzIG9uZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdzeXN0ZW0ncyBsb2NhbGUnXSAtIGEgbG9jYWxlIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5vdXRwdXRDYWxlbmRhcl0gLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5udW1iZXJpbmdTeXN0ZW1dIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbUlTTygnMjAxNi0wNS0yNVQwOTowODozNC4xMjMnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tSVNPKCcyMDE2LTA1LTI1VDA5OjA4OjM0LjEyMyswNjowMCcpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21JU08oJzIwMTYtMDUtMjVUMDk6MDg6MzQuMTIzKzA2OjAwJywge3NldFpvbmU6IHRydWV9KVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tSVNPKCcyMDE2LTA1LTI1VDA5OjA4OjM0LjEyMycsIHt6b25lOiAndXRjJ30pXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21JU08oJzIwMTYtVzA1LTQnKVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBmcm9tSVNPKHRleHQsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IFt2YWxzLCBwYXJzZWRab25lXSA9IHBhcnNlSVNPRGF0ZSh0ZXh0KTtcbiAgICByZXR1cm4gcGFyc2VEYXRhVG9EYXRlVGltZSh2YWxzLCBwYXJzZWRab25lLCBvcHRzLCBcIklTTyA4NjAxXCIsIHRleHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYW4gUkZDIDI4MjIgc3RyaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGhlIFJGQyAyODIyIHN0cmluZ1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgdG8gYWZmZWN0IHRoZSBjcmVhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0cy56b25lPSdsb2NhbCddIC0gY29udmVydCB0aGUgdGltZSB0byB0aGlzIHpvbmUuIFNpbmNlIHRoZSBvZmZzZXQgaXMgYWx3YXlzIHNwZWNpZmllZCBpbiB0aGUgc3RyaW5nIGl0c2VsZiwgdGhpcyBoYXMgbm8gZWZmZWN0IG9uIHRoZSBpbnRlcnByZXRhdGlvbiBvZiBzdHJpbmcsIG1lcmVseSB0aGUgem9uZSB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGlzIGV4cHJlc3NlZCBpbi5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zZXRab25lPWZhbHNlXSAtIG92ZXJyaWRlIHRoZSB6b25lIHdpdGggYSBmaXhlZC1vZmZzZXQgem9uZSBzcGVjaWZpZWQgaW4gdGhlIHN0cmluZyBpdHNlbGYsIGlmIGl0IHNwZWNpZmllcyBvbmVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nc3lzdGVtJ3MgbG9jYWxlJ10gLSBhIGxvY2FsZSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5vdXRwdXRDYWxlbmRhciAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVJGQzI4MjIoJzI1IE5vdiAyMDE2IDEzOjIzOjEyIEdNVCcpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21SRkMyODIyKCdGcmksIDI1IE5vdiAyMDE2IDEzOjIzOjEyICswNjAwJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVJGQzI4MjIoJzI1IE5vdiAyMDE2IDEzOjIzIFonKVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBmcm9tUkZDMjgyMih0ZXh0LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBbdmFscywgcGFyc2VkWm9uZV0gPSBwYXJzZVJGQzI4MjJEYXRlKHRleHQpO1xuICAgIHJldHVybiBwYXJzZURhdGFUb0RhdGVUaW1lKHZhbHMsIHBhcnNlZFpvbmUsIG9wdHMsIFwiUkZDIDI4MjJcIiwgdGV4dCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhbiBIVFRQIGhlYWRlciBkYXRlXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1Byb3RvY29scy9yZmMyNjE2L3JmYzI2MTYtc2VjMy5odG1sI3NlYzMuMy4xXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGhlIEhUVFAgaGVhZGVyIGRhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIHRvIGFmZmVjdCB0aGUgY3JlYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdHMuem9uZT0nbG9jYWwnXSAtIGNvbnZlcnQgdGhlIHRpbWUgdG8gdGhpcyB6b25lLiBTaW5jZSBIVFRQIGRhdGVzIGFyZSBhbHdheXMgaW4gVVRDLCB0aGlzIGhhcyBubyBlZmZlY3Qgb24gdGhlIGludGVycHJldGF0aW9uIG9mIHN0cmluZywgbWVyZWx5IHRoZSB6b25lIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaXMgZXhwcmVzc2VkIGluLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnNldFpvbmU9ZmFsc2VdIC0gb3ZlcnJpZGUgdGhlIHpvbmUgd2l0aCB0aGUgZml4ZWQtb2Zmc2V0IHpvbmUgc3BlY2lmaWVkIGluIHRoZSBzdHJpbmcuIEZvciBIVFRQIGRhdGVzLCB0aGlzIGlzIGFsd2F5cyBVVEMsIHNvIHRoaXMgb3B0aW9uIGlzIGVxdWl2YWxlbnQgdG8gc2V0dGluZyB0aGUgYHpvbmVgIG9wdGlvbiB0byAndXRjJywgYnV0IHRoaXMgb3B0aW9uIGlzIGluY2x1ZGVkIGZvciBjb25zaXN0ZW5jeSB3aXRoIHNpbWlsYXIgbWV0aG9kcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nc3lzdGVtJ3MgbG9jYWxlJ10gLSBhIGxvY2FsZSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5vdXRwdXRDYWxlbmRhciAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbUhUVFAoJ1N1biwgMDYgTm92IDE5OTQgMDg6NDk6MzcgR01UJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbUhUVFAoJ1N1bmRheSwgMDYtTm92LTk0IDA4OjQ5OjM3IEdNVCcpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21IVFRQKCdTdW4gTm92ICA2IDA4OjQ5OjM3IDE5OTQnKVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBmcm9tSFRUUCh0ZXh0LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBbdmFscywgcGFyc2VkWm9uZV0gPSBwYXJzZUhUVFBEYXRlKHRleHQpO1xuICAgIHJldHVybiBwYXJzZURhdGFUb0RhdGVUaW1lKHZhbHMsIHBhcnNlZFpvbmUsIG9wdHMsIFwiSFRUUFwiLCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGFuIGlucHV0IHN0cmluZyBhbmQgZm9ybWF0IHN0cmluZy5cbiAgICogRGVmYXVsdHMgdG8gZW4tVVMgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZCwgcmVnYXJkbGVzcyBvZiB0aGUgc3lzdGVtJ3MgbG9jYWxlLiBGb3IgYSB0YWJsZSBvZiB0b2tlbnMgYW5kIHRoZWlyIGludGVycHJldGF0aW9ucywgc2VlIFtoZXJlXShodHRwczovL21vbWVudC5naXRodWIuaW8vbHV4b24vIy9wYXJzaW5nP2lkPXRhYmxlLW9mLXRva2VucykuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGhlIHN0cmluZyB0byBwYXJzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZm10IC0gdGhlIGZvcm1hdCB0aGUgc3RyaW5nIGlzIGV4cGVjdGVkIHRvIGJlIGluIChzZWUgdGhlIGxpbmsgYmVsb3cgZm9yIHRoZSBmb3JtYXRzKVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgdG8gYWZmZWN0IHRoZSBjcmVhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0cy56b25lPSdsb2NhbCddIC0gdXNlIHRoaXMgem9uZSBpZiBubyBvZmZzZXQgaXMgc3BlY2lmaWVkIGluIHRoZSBpbnB1dCBzdHJpbmcgaXRzZWxmLiBXaWxsIGFsc28gY29udmVydCB0aGUgRGF0ZVRpbWUgdG8gdGhpcyB6b25lXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc2V0Wm9uZT1mYWxzZV0gLSBvdmVycmlkZSB0aGUgem9uZSB3aXRoIGEgem9uZSBzcGVjaWZpZWQgaW4gdGhlIHN0cmluZyBpdHNlbGYsIGlmIGl0IHNwZWNpZmllcyBvbmVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nZW4tVVMnXSAtIGEgbG9jYWxlIHN0cmluZyB0byB1c2Ugd2hlbiBwYXJzaW5nLiBXaWxsIGFsc28gc2V0IHRoZSBEYXRlVGltZSB0byB0aGlzIGxvY2FsZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byB1c2Ugd2hlbiBwYXJzaW5nLiBXaWxsIGFsc28gc2V0IHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgdG8gdGhpcyBudW1iZXJpbmcgc3lzdGVtXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm91dHB1dENhbGVuZGFyIC0gdGhlIG91dHB1dCBjYWxlbmRhciB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBmcm9tRm9ybWF0KHRleHQsIGZtdCwgb3B0cyA9IHt9KSB7XG4gICAgaWYgKGlzVW5kZWZpbmVkKHRleHQpIHx8IGlzVW5kZWZpbmVkKGZtdCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImZyb21Gb3JtYXQgcmVxdWlyZXMgYW4gaW5wdXQgc3RyaW5nIGFuZCBhIGZvcm1hdFwiKTtcbiAgICB9XG5cbiAgICBjb25zdCB7IGxvY2FsZSA9IG51bGwsIG51bWJlcmluZ1N5c3RlbSA9IG51bGwgfSA9IG9wdHMsXG4gICAgICBsb2NhbGVUb1VzZSA9IExvY2FsZS5mcm9tT3B0cyh7XG4gICAgICAgIGxvY2FsZSxcbiAgICAgICAgbnVtYmVyaW5nU3lzdGVtLFxuICAgICAgICBkZWZhdWx0VG9FTjogdHJ1ZSxcbiAgICAgIH0pLFxuICAgICAgW3ZhbHMsIHBhcnNlZFpvbmUsIHNwZWNpZmljT2Zmc2V0LCBpbnZhbGlkXSA9IHBhcnNlRnJvbVRva2Vucyhsb2NhbGVUb1VzZSwgdGV4dCwgZm10KTtcbiAgICBpZiAoaW52YWxpZCkge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQoaW52YWxpZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwYXJzZURhdGFUb0RhdGVUaW1lKHZhbHMsIHBhcnNlZFpvbmUsIG9wdHMsIGBmb3JtYXQgJHtmbXR9YCwgdGV4dCwgc3BlY2lmaWNPZmZzZXQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgZnJvbUZvcm1hdCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgZnJvbVN0cmluZyh0ZXh0LCBmbXQsIG9wdHMgPSB7fSkge1xuICAgIHJldHVybiBEYXRlVGltZS5mcm9tRm9ybWF0KHRleHQsIGZtdCwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhIFNRTCBkYXRlLCB0aW1lLCBvciBkYXRldGltZVxuICAgKiBEZWZhdWx0cyB0byBlbi1VUyBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkLCByZWdhcmRsZXNzIG9mIHRoZSBzeXN0ZW0ncyBsb2NhbGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0aGUgc3RyaW5nIHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyB0byBhZmZlY3QgdGhlIGNyZWF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFtvcHRzLnpvbmU9J2xvY2FsJ10gLSB1c2UgdGhpcyB6b25lIGlmIG5vIG9mZnNldCBpcyBzcGVjaWZpZWQgaW4gdGhlIGlucHV0IHN0cmluZyBpdHNlbGYuIFdpbGwgYWxzbyBjb252ZXJ0IHRoZSBEYXRlVGltZSB0byB0aGlzIHpvbmVcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zZXRab25lPWZhbHNlXSAtIG92ZXJyaWRlIHRoZSB6b25lIHdpdGggYSB6b25lIHNwZWNpZmllZCBpbiB0aGUgc3RyaW5nIGl0c2VsZiwgaWYgaXQgc3BlY2lmaWVzIG9uZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdlbi1VUyddIC0gYSBsb2NhbGUgc3RyaW5nIHRvIHVzZSB3aGVuIHBhcnNpbmcuIFdpbGwgYWxzbyBzZXQgdGhlIERhdGVUaW1lIHRvIHRoaXMgbG9jYWxlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHVzZSB3aGVuIHBhcnNpbmcuIFdpbGwgYWxzbyBzZXQgdGhlIHJlc3VsdGluZyBEYXRlVGltZSB0byB0aGlzIG51bWJlcmluZyBzeXN0ZW1cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMub3V0cHV0Q2FsZW5kYXIgLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21TUUwoJzIwMTctMDUtMTUnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tU1FMKCcyMDE3LTA1LTE1IDA5OjEyOjM0JylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVNRTCgnMjAxNy0wNS0xNSAwOToxMjozNC4zNDInKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tU1FMKCcyMDE3LTA1LTE1IDA5OjEyOjM0LjM0MiswNjowMCcpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21TUUwoJzIwMTctMDUtMTUgMDk6MTI6MzQuMzQyIEFtZXJpY2EvTG9zX0FuZ2VsZXMnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tU1FMKCcyMDE3LTA1LTE1IDA5OjEyOjM0LjM0MiBBbWVyaWNhL0xvc19BbmdlbGVzJywgeyBzZXRab25lOiB0cnVlIH0pXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21TUUwoJzIwMTctMDUtMTUgMDk6MTI6MzQuMzQyJywgeyB6b25lOiAnQW1lcmljYS9Mb3NfQW5nZWxlcycgfSlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVNRTCgnMDk6MTI6MzQuMzQyJylcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbVNRTCh0ZXh0LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBbdmFscywgcGFyc2VkWm9uZV0gPSBwYXJzZVNRTCh0ZXh0KTtcbiAgICByZXR1cm4gcGFyc2VEYXRhVG9EYXRlVGltZSh2YWxzLCBwYXJzZWRab25lLCBvcHRzLCBcIlNRTFwiLCB0ZXh0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW52YWxpZCBEYXRlVGltZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlYXNvbiAtIHNpbXBsZSBzdHJpbmcgb2Ygd2h5IHRoaXMgRGF0ZVRpbWUgaXMgaW52YWxpZC4gU2hvdWxkIG5vdCBjb250YWluIHBhcmFtZXRlcnMgb3IgYW55dGhpbmcgZWxzZSBkYXRhLWRlcGVuZGVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtleHBsYW5hdGlvbj1udWxsXSAtIGxvbmdlciBleHBsYW5hdGlvbiwgbWF5IGluY2x1ZGUgcGFyYW1ldGVycyBhbmQgb3RoZXIgdXNlZnVsIGRlYnVnZ2luZyBpbmZvcm1hdGlvblxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBpbnZhbGlkKHJlYXNvbiwgZXhwbGFuYXRpb24gPSBudWxsKSB7XG4gICAgaWYgKCFyZWFzb24pIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcIm5lZWQgdG8gc3BlY2lmeSBhIHJlYXNvbiB0aGUgRGF0ZVRpbWUgaXMgaW52YWxpZFwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbnZhbGlkID0gcmVhc29uIGluc3RhbmNlb2YgSW52YWxpZCA/IHJlYXNvbiA6IG5ldyBJbnZhbGlkKHJlYXNvbiwgZXhwbGFuYXRpb24pO1xuXG4gICAgaWYgKFNldHRpbmdzLnRocm93T25JbnZhbGlkKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZERhdGVUaW1lRXJyb3IoaW52YWxpZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZVRpbWUoeyBpbnZhbGlkIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBvYmplY3QgaXMgYW4gaW5zdGFuY2Ugb2YgRGF0ZVRpbWUuIFdvcmtzIGFjcm9zcyBjb250ZXh0IGJvdW5kYXJpZXNcbiAgICogQHBhcmFtIHtvYmplY3R9IG9cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc0RhdGVUaW1lKG8pIHtcbiAgICByZXR1cm4gKG8gJiYgby5pc0x1eG9uRGF0ZVRpbWUpIHx8IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2R1Y2UgdGhlIGZvcm1hdCBzdHJpbmcgZm9yIGEgc2V0IG9mIG9wdGlvbnNcbiAgICogQHBhcmFtIGZvcm1hdE9wdHNcbiAgICogQHBhcmFtIGxvY2FsZU9wdHNcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBwYXJzZUZvcm1hdEZvck9wdHMoZm9ybWF0T3B0cywgbG9jYWxlT3B0cyA9IHt9KSB7XG4gICAgY29uc3QgdG9rZW5MaXN0ID0gZm9ybWF0T3B0c1RvVG9rZW5zKGZvcm1hdE9wdHMsIExvY2FsZS5mcm9tT2JqZWN0KGxvY2FsZU9wdHMpKTtcbiAgICByZXR1cm4gIXRva2VuTGlzdCA/IG51bGwgOiB0b2tlbkxpc3QubWFwKCh0KSA9PiAodCA/IHQudmFsIDogbnVsbCkpLmpvaW4oXCJcIik7XG4gIH1cblxuICAvKipcbiAgICogUHJvZHVjZSB0aGUgdGhlIGZ1bGx5IGV4cGFuZGVkIGZvcm1hdCB0b2tlbiBmb3IgdGhlIGxvY2FsZVxuICAgKiBEb2VzIE5PVCBxdW90ZSBjaGFyYWN0ZXJzLCBzbyBxdW90ZWQgdG9rZW5zIHdpbGwgbm90IHJvdW5kIHRyaXAgY29ycmVjdGx5XG4gICAqIEBwYXJhbSBmbXRcbiAgICogQHBhcmFtIGxvY2FsZU9wdHNcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBleHBhbmRGb3JtYXQoZm10LCBsb2NhbGVPcHRzID0ge30pIHtcbiAgICBjb25zdCBleHBhbmRlZCA9IGV4cGFuZE1hY3JvVG9rZW5zKEZvcm1hdHRlci5wYXJzZUZvcm1hdChmbXQpLCBMb2NhbGUuZnJvbU9iamVjdChsb2NhbGVPcHRzKSk7XG4gICAgcmV0dXJuIGV4cGFuZGVkLm1hcCgodCkgPT4gdC52YWwpLmpvaW4oXCJcIik7XG4gIH1cblxuICAvLyBJTkZPXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUgb2YgdW5pdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVuaXQgLSBhIHVuaXQgc3VjaCBhcyAnbWludXRlJyBvciAnZGF5J1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA3LCA0KS5nZXQoJ21vbnRoJyk7IC8vPT4gN1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA3LCA0KS5nZXQoJ2RheScpOyAvLz0+IDRcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0KHVuaXQpIHtcbiAgICByZXR1cm4gdGhpc1t1bml0XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIERhdGVUaW1lIGlzIHZhbGlkLiBJbnZhbGlkIERhdGVUaW1lcyBvY2N1ciB3aGVuOlxuICAgKiAqIFRoZSBEYXRlVGltZSB3YXMgY3JlYXRlZCBmcm9tIGludmFsaWQgY2FsZW5kYXIgaW5mb3JtYXRpb24sIHN1Y2ggYXMgdGhlIDEzdGggbW9udGggb3IgRmVicnVhcnkgMzBcbiAgICogKiBUaGUgRGF0ZVRpbWUgd2FzIGNyZWF0ZWQgYnkgYW4gb3BlcmF0aW9uIG9uIGFub3RoZXIgaW52YWxpZCBkYXRlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZCA9PT0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGVycm9yIGNvZGUgaWYgdGhpcyBEYXRlVGltZSBpcyBpbnZhbGlkLCBvciBudWxsIGlmIHRoZSBEYXRlVGltZSBpcyB2YWxpZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGludmFsaWRSZWFzb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZCA/IHRoaXMuaW52YWxpZC5yZWFzb24gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gZXhwbGFuYXRpb24gb2Ygd2h5IHRoaXMgRGF0ZVRpbWUgYmVjYW1lIGludmFsaWQsIG9yIG51bGwgaWYgdGhlIERhdGVUaW1lIGlzIHZhbGlkXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgaW52YWxpZEV4cGxhbmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmludmFsaWQgPyB0aGlzLmludmFsaWQuZXhwbGFuYXRpb24gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbG9jYWxlIG9mIGEgRGF0ZVRpbWUsIHN1Y2ggJ2VuLUdCJy4gVGhlIGxvY2FsZSBpcyB1c2VkIHdoZW4gZm9ybWF0dGluZyB0aGUgRGF0ZVRpbWVcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBsb2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMubG9jLmxvY2FsZSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBudW1iZXJpbmcgc3lzdGVtIG9mIGEgRGF0ZVRpbWUsIHN1Y2ggJ2JlbmcnLiBUaGUgbnVtYmVyaW5nIHN5c3RlbSBpcyB1c2VkIHdoZW4gZm9ybWF0dGluZyB0aGUgRGF0ZVRpbWVcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBudW1iZXJpbmdTeXN0ZW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMubG9jLm51bWJlcmluZ1N5c3RlbSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBvdXRwdXQgY2FsZW5kYXIgb2YgYSBEYXRlVGltZSwgc3VjaCAnaXNsYW1pYycuIFRoZSBvdXRwdXQgY2FsZW5kYXIgaXMgdXNlZCB3aGVuIGZvcm1hdHRpbmcgdGhlIERhdGVUaW1lXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgb3V0cHV0Q2FsZW5kYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMubG9jLm91dHB1dENhbGVuZGFyIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHRpbWUgem9uZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBEYXRlVGltZS5cbiAgICogQHR5cGUge1pvbmV9XG4gICAqL1xuICBnZXQgem9uZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fem9uZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG5hbWUgb2YgdGhlIHRpbWUgem9uZS5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCB6b25lTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy56b25lLm5hbWUgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgeWVhclxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSkueWVhciAvLz0+IDIwMTdcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB5ZWFyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmMueWVhciA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHF1YXJ0ZXJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUpLnF1YXJ0ZXIgLy89PiAyXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgcXVhcnRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gTWF0aC5jZWlsKHRoaXMuYy5tb250aCAvIDMpIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbW9udGggKDEtMTIpLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSkubW9udGggLy89PiA1XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbW9udGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuYy5tb250aCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRheSBvZiB0aGUgbW9udGggKDEtMzBpc2gpLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSkuZGF5IC8vPT4gMjVcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBkYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuYy5kYXkgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBob3VyIG9mIHRoZSBkYXkgKDAtMjMpLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSwgOSkuaG91ciAvLz0+IDlcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBob3VyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmMuaG91ciA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1pbnV0ZSBvZiB0aGUgaG91ciAoMC01OSkuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1LCA5LCAzMCkubWludXRlIC8vPT4gMzBcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBtaW51dGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuYy5taW51dGUgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzZWNvbmQgb2YgdGhlIG1pbnV0ZSAoMC01OSkuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1LCA5LCAzMCwgNTIpLnNlY29uZCAvLz0+IDUyXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgc2Vjb25kKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmMuc2Vjb25kIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWlsbGlzZWNvbmQgb2YgdGhlIHNlY29uZCAoMC05OTkpLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSwgOSwgMzAsIDUyLCA2NTQpLm1pbGxpc2Vjb25kIC8vPT4gNjU0XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbWlsbGlzZWNvbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuYy5taWxsaXNlY29uZCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHdlZWsgeWVhclxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMTIsIDMxKS53ZWVrWWVhciAvLz0+IDIwMTVcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB3ZWVrWWVhcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gcG9zc2libHlDYWNoZWRXZWVrRGF0YSh0aGlzKS53ZWVrWWVhciA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHdlZWsgbnVtYmVyIG9mIHRoZSB3ZWVrIHllYXIgKDEtNTJpc2gpLlxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUpLndlZWtOdW1iZXIgLy89PiAyMVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHdlZWtOdW1iZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHBvc3NpYmx5Q2FjaGVkV2Vla0RhdGEodGhpcykud2Vla051bWJlciA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRheSBvZiB0aGUgd2Vlay5cbiAgICogMSBpcyBNb25kYXkgYW5kIDcgaXMgU3VuZGF5XG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAxMSwgMzEpLndlZWtkYXkgLy89PiA0XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgd2Vla2RheSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gcG9zc2libHlDYWNoZWRXZWVrRGF0YSh0aGlzKS53ZWVrZGF5IDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgb3JkaW5hbCAobWVhbmluZyB0aGUgZGF5IG9mIHRoZSB5ZWFyKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSkub3JkaW5hbCAvLz0+IDE0NVxuICAgKiBAdHlwZSB7bnVtYmVyfERhdGVUaW1lfVxuICAgKi9cbiAgZ2V0IG9yZGluYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IGdyZWdvcmlhblRvT3JkaW5hbCh0aGlzLmMpLm9yZGluYWwgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBodW1hbiByZWFkYWJsZSBzaG9ydCBtb250aCBuYW1lLCBzdWNoIGFzICdPY3QnLlxuICAgKiBEZWZhdWx0cyB0byB0aGUgc3lzdGVtJ3MgbG9jYWxlIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMTAsIDMwKS5tb250aFNob3J0IC8vPT4gT2N0XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgbW9udGhTaG9ydCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gSW5mby5tb250aHMoXCJzaG9ydFwiLCB7IGxvY09iajogdGhpcy5sb2MgfSlbdGhpcy5tb250aCAtIDFdIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGh1bWFuIHJlYWRhYmxlIGxvbmcgbW9udGggbmFtZSwgc3VjaCBhcyAnT2N0b2JlcicuXG4gICAqIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0ncyBsb2NhbGUgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAxMCwgMzApLm1vbnRoTG9uZyAvLz0+IE9jdG9iZXJcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBtb250aExvbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IEluZm8ubW9udGhzKFwibG9uZ1wiLCB7IGxvY09iajogdGhpcy5sb2MgfSlbdGhpcy5tb250aCAtIDFdIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGh1bWFuIHJlYWRhYmxlIHNob3J0IHdlZWtkYXksIHN1Y2ggYXMgJ01vbicuXG4gICAqIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0ncyBsb2NhbGUgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAxMCwgMzApLndlZWtkYXlTaG9ydCAvLz0+IE1vblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IHdlZWtkYXlTaG9ydCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gSW5mby53ZWVrZGF5cyhcInNob3J0XCIsIHsgbG9jT2JqOiB0aGlzLmxvYyB9KVt0aGlzLndlZWtkYXkgLSAxXSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBodW1hbiByZWFkYWJsZSBsb25nIHdlZWtkYXksIHN1Y2ggYXMgJ01vbmRheScuXG4gICAqIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0ncyBsb2NhbGUgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAxMCwgMzApLndlZWtkYXlMb25nIC8vPT4gTW9uZGF5XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgd2Vla2RheUxvbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IEluZm8ud2Vla2RheXMoXCJsb25nXCIsIHsgbG9jT2JqOiB0aGlzLmxvYyB9KVt0aGlzLndlZWtkYXkgLSAxXSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBVVEMgb2Zmc2V0IG9mIHRoaXMgRGF0ZVRpbWUgaW4gbWludXRlc1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5vZmZzZXQgLy89PiAtMjQwXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygpLm9mZnNldCAvLz0+IDBcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBvZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/ICt0aGlzLm8gOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzaG9ydCBodW1hbiBuYW1lIGZvciB0aGUgem9uZSdzIGN1cnJlbnQgb2Zmc2V0LCBmb3IgZXhhbXBsZSBcIkVTVFwiIG9yIFwiRURUXCIuXG4gICAqIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0ncyBsb2NhbGUgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IG9mZnNldE5hbWVTaG9ydCgpIHtcbiAgICBpZiAodGhpcy5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gdGhpcy56b25lLm9mZnNldE5hbWUodGhpcy50cywge1xuICAgICAgICBmb3JtYXQ6IFwic2hvcnRcIixcbiAgICAgICAgbG9jYWxlOiB0aGlzLmxvY2FsZSxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsb25nIGh1bWFuIG5hbWUgZm9yIHRoZSB6b25lJ3MgY3VycmVudCBvZmZzZXQsIGZvciBleGFtcGxlIFwiRWFzdGVybiBTdGFuZGFyZCBUaW1lXCIgb3IgXCJFYXN0ZXJuIERheWxpZ2h0IFRpbWVcIi5cbiAgICogRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgb2Zmc2V0TmFtZUxvbmcoKSB7XG4gICAgaWYgKHRoaXMuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIHRoaXMuem9uZS5vZmZzZXROYW1lKHRoaXMudHMsIHtcbiAgICAgICAgZm9ybWF0OiBcImxvbmdcIixcbiAgICAgICAgbG9jYWxlOiB0aGlzLmxvY2FsZSxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHdoZXRoZXIgdGhpcyB6b25lJ3Mgb2Zmc2V0IGV2ZXIgY2hhbmdlcywgYXMgaW4gYSBEU1QuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzT2Zmc2V0Rml4ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuem9uZS5pc1VuaXZlcnNhbCA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHdoZXRoZXIgdGhlIERhdGVUaW1lIGlzIGluIGEgRFNULlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc0luRFNUKCkge1xuICAgIGlmICh0aGlzLmlzT2Zmc2V0Rml4ZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgdGhpcy5vZmZzZXQgPiB0aGlzLnNldCh7IG1vbnRoOiAxLCBkYXk6IDEgfSkub2Zmc2V0IHx8XG4gICAgICAgIHRoaXMub2Zmc2V0ID4gdGhpcy5zZXQoeyBtb250aDogNSB9KS5vZmZzZXRcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aG9zZSBEYXRlVGltZXMgd2hpY2ggaGF2ZSB0aGUgc2FtZSBsb2NhbCB0aW1lIGFzIHRoaXMgRGF0ZVRpbWUsIGJ1dCBhIGRpZmZlcmVudCBvZmZzZXQgZnJvbSBVVENcbiAgICogaW4gdGhpcyBEYXRlVGltZSdzIHpvbmUuIER1cmluZyBEU1QgY2hhbmdlcyBsb2NhbCB0aW1lIGNhbiBiZSBhbWJpZ3VvdXMsIGZvciBleGFtcGxlXG4gICAqIGAyMDIzLTEwLTI5VDAyOjMwOjAwYCBpbiBgRXVyb3BlL0JlcmxpbmAgY2FuIGhhdmUgb2Zmc2V0IGArMDE6MDBgIG9yIGArMDI6MDBgLlxuICAgKiBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiBib3RoIHBvc3NpYmxlIERhdGVUaW1lcyBpZiB0aGlzIERhdGVUaW1lJ3MgbG9jYWwgdGltZSBpcyBhbWJpZ3VvdXMuXG4gICAqIEByZXR1cm5zIHtEYXRlVGltZVtdfVxuICAgKi9cbiAgZ2V0UG9zc2libGVPZmZzZXRzKCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkIHx8IHRoaXMuaXNPZmZzZXRGaXhlZCkge1xuICAgICAgcmV0dXJuIFt0aGlzXTtcbiAgICB9XG4gICAgY29uc3QgZGF5TXMgPSA4NjQwMDAwMDtcbiAgICBjb25zdCBtaW51dGVNcyA9IDYwMDAwO1xuICAgIGNvbnN0IGxvY2FsVFMgPSBvYmpUb0xvY2FsVFModGhpcy5jKTtcbiAgICBjb25zdCBvRWFybGllciA9IHRoaXMuem9uZS5vZmZzZXQobG9jYWxUUyAtIGRheU1zKTtcbiAgICBjb25zdCBvTGF0ZXIgPSB0aGlzLnpvbmUub2Zmc2V0KGxvY2FsVFMgKyBkYXlNcyk7XG5cbiAgICBjb25zdCBvMSA9IHRoaXMuem9uZS5vZmZzZXQobG9jYWxUUyAtIG9FYXJsaWVyICogbWludXRlTXMpO1xuICAgIGNvbnN0IG8yID0gdGhpcy56b25lLm9mZnNldChsb2NhbFRTIC0gb0xhdGVyICogbWludXRlTXMpO1xuICAgIGlmIChvMSA9PT0gbzIpIHtcbiAgICAgIHJldHVybiBbdGhpc107XG4gICAgfVxuICAgIGNvbnN0IHRzMSA9IGxvY2FsVFMgLSBvMSAqIG1pbnV0ZU1zO1xuICAgIGNvbnN0IHRzMiA9IGxvY2FsVFMgLSBvMiAqIG1pbnV0ZU1zO1xuICAgIGNvbnN0IGMxID0gdHNUb09iaih0czEsIG8xKTtcbiAgICBjb25zdCBjMiA9IHRzVG9PYmoodHMyLCBvMik7XG4gICAgaWYgKFxuICAgICAgYzEuaG91ciA9PT0gYzIuaG91ciAmJlxuICAgICAgYzEubWludXRlID09PSBjMi5taW51dGUgJiZcbiAgICAgIGMxLnNlY29uZCA9PT0gYzIuc2Vjb25kICYmXG4gICAgICBjMS5taWxsaXNlY29uZCA9PT0gYzIubWlsbGlzZWNvbmRcbiAgICApIHtcbiAgICAgIHJldHVybiBbY2xvbmUodGhpcywgeyB0czogdHMxIH0pLCBjbG9uZSh0aGlzLCB7IHRzOiB0czIgfSldO1xuICAgIH1cbiAgICByZXR1cm4gW3RoaXNdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIERhdGVUaW1lIGlzIGluIGEgbGVhcCB5ZWFyLCBmYWxzZSBvdGhlcndpc2VcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNikuaXNJbkxlYXBZZWFyIC8vPT4gdHJ1ZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDEzKS5pc0luTGVhcFllYXIgLy89PiBmYWxzZVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc0luTGVhcFllYXIoKSB7XG4gICAgcmV0dXJuIGlzTGVhcFllYXIodGhpcy55ZWFyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZGF5cyBpbiB0aGlzIERhdGVUaW1lJ3MgbW9udGhcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNiwgMikuZGF5c0luTW9udGggLy89PiAyOVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE2LCAzKS5kYXlzSW5Nb250aCAvLz0+IDMxXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgZGF5c0luTW9udGgoKSB7XG4gICAgcmV0dXJuIGRheXNJbk1vbnRoKHRoaXMueWVhciwgdGhpcy5tb250aCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGRheXMgaW4gdGhpcyBEYXRlVGltZSdzIHllYXJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNikuZGF5c0luWWVhciAvLz0+IDM2NlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDEzKS5kYXlzSW5ZZWFyIC8vPT4gMzY1XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgZGF5c0luWWVhcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gZGF5c0luWWVhcih0aGlzLnllYXIpIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiB3ZWVrcyBpbiB0aGlzIERhdGVUaW1lJ3MgeWVhclxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAwNCkud2Vla3NJbldlZWtZZWFyIC8vPT4gNTNcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxMykud2Vla3NJbldlZWtZZWFyIC8vPT4gNTJcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB3ZWVrc0luV2Vla1llYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHdlZWtzSW5XZWVrWWVhcih0aGlzLndlZWtZZWFyKSA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZXNvbHZlZCBJbnRsIG9wdGlvbnMgZm9yIHRoaXMgRGF0ZVRpbWUuXG4gICAqIFRoaXMgaXMgdXNlZnVsIGluIHVuZGVyc3RhbmRpbmcgdGhlIGJlaGF2aW9yIG9mIGZvcm1hdHRpbmcgbWV0aG9kc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIHRoZSBzYW1lIG9wdGlvbnMgYXMgdG9Mb2NhbGVTdHJpbmdcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgcmVzb2x2ZWRMb2NhbGVPcHRpb25zKG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IHsgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIGNhbGVuZGFyIH0gPSBGb3JtYXR0ZXIuY3JlYXRlKFxuICAgICAgdGhpcy5sb2MuY2xvbmUob3B0cyksXG4gICAgICBvcHRzXG4gICAgKS5yZXNvbHZlZE9wdGlvbnModGhpcyk7XG4gICAgcmV0dXJuIHsgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG91dHB1dENhbGVuZGFyOiBjYWxlbmRhciB9O1xuICB9XG5cbiAgLy8gVFJBTlNGT1JNXG5cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhlIERhdGVUaW1lJ3Mgem9uZSB0byBVVEMuIFJldHVybnMgYSBuZXdseS1jb25zdHJ1Y3RlZCBEYXRlVGltZS5cbiAgICpcbiAgICogRXF1aXZhbGVudCB0byB7QGxpbmsgRGF0ZVRpbWUjc2V0Wm9uZX0oJ3V0YycpXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb2Zmc2V0PTBdIC0gb3B0aW9uYWxseSwgYW4gb2Zmc2V0IGZyb20gVVRDIGluIG1pbnV0ZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzPXt9XSAtIG9wdGlvbnMgdG8gcGFzcyB0byBgc2V0Wm9uZSgpYFxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHRvVVRDKG9mZnNldCA9IDAsIG9wdHMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLnNldFpvbmUoRml4ZWRPZmZzZXRab25lLmluc3RhbmNlKG9mZnNldCksIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhlIERhdGVUaW1lJ3Mgem9uZSB0byB0aGUgaG9zdCdzIGxvY2FsIHpvbmUuIFJldHVybnMgYSBuZXdseS1jb25zdHJ1Y3RlZCBEYXRlVGltZS5cbiAgICpcbiAgICogRXF1aXZhbGVudCB0byBgc2V0Wm9uZSgnbG9jYWwnKWBcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICB0b0xvY2FsKCkge1xuICAgIHJldHVybiB0aGlzLnNldFpvbmUoU2V0dGluZ3MuZGVmYXVsdFpvbmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhlIERhdGVUaW1lJ3Mgem9uZSB0byBzcGVjaWZpZWQgem9uZS4gUmV0dXJucyBhIG5ld2x5LWNvbnN0cnVjdGVkIERhdGVUaW1lLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCB0aGUgc2V0dGVyIGtlZXBzIHRoZSB1bmRlcmx5aW5nIHRpbWUgdGhlIHNhbWUgKGFzIGluLCB0aGUgc2FtZSB0aW1lc3RhbXApLCBidXQgdGhlIG5ldyBpbnN0YW5jZSB3aWxsIHJlcG9ydCBkaWZmZXJlbnQgbG9jYWwgdGltZXMgYW5kIGNvbnNpZGVyIERTVHMgd2hlbiBtYWtpbmcgY29tcHV0YXRpb25zLCBhcyB3aXRoIHtAbGluayBEYXRlVGltZSNwbHVzfS4gWW91IG1heSB3aXNoIHRvIHVzZSB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbH0gYW5kIHtAbGluayBEYXRlVGltZSN0b1VUQ30gd2hpY2ggcHJvdmlkZSBzaW1wbGUgY29udmVuaWVuY2Ugd3JhcHBlcnMgZm9yIGNvbW1vbmx5IHVzZWQgem9uZXMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFt6b25lPSdsb2NhbCddIC0gYSB6b25lIGlkZW50aWZpZXIuIEFzIGEgc3RyaW5nLCB0aGF0IGNhbiBiZSBhbnkgSUFOQSB6b25lIHN1cHBvcnRlZCBieSB0aGUgaG9zdCBlbnZpcm9ubWVudCwgb3IgYSBmaXhlZC1vZmZzZXQgbmFtZSBvZiB0aGUgZm9ybSAnVVRDKzMnLCBvciB0aGUgc3RyaW5ncyAnbG9jYWwnIG9yICd1dGMnLiBZb3UgbWF5IGFsc28gc3VwcGx5IGFuIGluc3RhbmNlIG9mIGEge0BsaW5rIERhdGVUaW1lI1pvbmV9IGNsYXNzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5rZWVwTG9jYWxUaW1lPWZhbHNlXSAtIElmIHRydWUsIGFkanVzdCB0aGUgdW5kZXJseWluZyB0aW1lIHNvIHRoYXQgdGhlIGxvY2FsIHRpbWUgc3RheXMgdGhlIHNhbWUsIGJ1dCBpbiB0aGUgdGFyZ2V0IHpvbmUuIFlvdSBzaG91bGQgcmFyZWx5IG5lZWQgdGhpcy5cbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzZXRab25lKHpvbmUsIHsga2VlcExvY2FsVGltZSA9IGZhbHNlLCBrZWVwQ2FsZW5kYXJUaW1lID0gZmFsc2UgfSA9IHt9KSB7XG4gICAgem9uZSA9IG5vcm1hbGl6ZVpvbmUoem9uZSwgU2V0dGluZ3MuZGVmYXVsdFpvbmUpO1xuICAgIGlmICh6b25lLmVxdWFscyh0aGlzLnpvbmUpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2UgaWYgKCF6b25lLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKHVuc3VwcG9ydGVkWm9uZSh6b25lKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBuZXdUUyA9IHRoaXMudHM7XG4gICAgICBpZiAoa2VlcExvY2FsVGltZSB8fCBrZWVwQ2FsZW5kYXJUaW1lKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldEd1ZXNzID0gem9uZS5vZmZzZXQodGhpcy50cyk7XG4gICAgICAgIGNvbnN0IGFzT2JqID0gdGhpcy50b09iamVjdCgpO1xuICAgICAgICBbbmV3VFNdID0gb2JqVG9UUyhhc09iaiwgb2Zmc2V0R3Vlc3MsIHpvbmUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNsb25lKHRoaXMsIHsgdHM6IG5ld1RTLCB6b25lIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSBsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgb3Igb3V0cHV0Q2FsZW5kYXIuIFJldHVybnMgYSBuZXdseS1jb25zdHJ1Y3RlZCBEYXRlVGltZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgLSB0aGUgcHJvcGVydGllcyB0byBzZXRcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUpLnJlY29uZmlndXJlKHsgbG9jYWxlOiAnZW4tR0InIH0pXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgcmVjb25maWd1cmUoeyBsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgb3V0cHV0Q2FsZW5kYXIgfSA9IHt9KSB7XG4gICAgY29uc3QgbG9jID0gdGhpcy5sb2MuY2xvbmUoeyBsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgb3V0cHV0Q2FsZW5kYXIgfSk7XG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIHsgbG9jIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhlIGxvY2FsZS4gUmV0dXJucyBhIG5ld2x5LWNvbnN0cnVjdGVkIERhdGVUaW1lLlxuICAgKiBKdXN0IGEgY29udmVuaWVudCBhbGlhcyBmb3IgcmVjb25maWd1cmUoeyBsb2NhbGUgfSlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUpLnNldExvY2FsZSgnZW4tR0InKVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHNldExvY2FsZShsb2NhbGUpIHtcbiAgICByZXR1cm4gdGhpcy5yZWNvbmZpZ3VyZSh7IGxvY2FsZSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSB2YWx1ZXMgb2Ygc3BlY2lmaWVkIHVuaXRzLiBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgRGF0ZVRpbWUuXG4gICAqIFlvdSBjYW4gb25seSBzZXQgdW5pdHMgd2l0aCB0aGlzIG1ldGhvZDsgZm9yIFwic2V0dGluZ1wiIG1ldGFkYXRhLCBzZWUge0BsaW5rIERhdGVUaW1lI3JlY29uZmlndXJlfSBhbmQge0BsaW5rIERhdGVUaW1lI3NldFpvbmV9LlxuICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVzIC0gYSBtYXBwaW5nIG9mIHVuaXRzIHRvIG51bWJlcnNcbiAgICogQGV4YW1wbGUgZHQuc2V0KHsgeWVhcjogMjAxNyB9KVxuICAgKiBAZXhhbXBsZSBkdC5zZXQoeyBob3VyOiA4LCBtaW51dGU6IDMwIH0pXG4gICAqIEBleGFtcGxlIGR0LnNldCh7IHdlZWtkYXk6IDUgfSlcbiAgICogQGV4YW1wbGUgZHQuc2V0KHsgeWVhcjogMjAwNSwgb3JkaW5hbDogMjM0IH0pXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc2V0KHZhbHVlcykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcblxuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVPYmplY3QodmFsdWVzLCBub3JtYWxpemVVbml0KSxcbiAgICAgIHNldHRpbmdXZWVrU3R1ZmYgPVxuICAgICAgICAhaXNVbmRlZmluZWQobm9ybWFsaXplZC53ZWVrWWVhcikgfHxcbiAgICAgICAgIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQud2Vla051bWJlcikgfHxcbiAgICAgICAgIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQud2Vla2RheSksXG4gICAgICBjb250YWluc09yZGluYWwgPSAhaXNVbmRlZmluZWQobm9ybWFsaXplZC5vcmRpbmFsKSxcbiAgICAgIGNvbnRhaW5zR3JlZ29yWWVhciA9ICFpc1VuZGVmaW5lZChub3JtYWxpemVkLnllYXIpLFxuICAgICAgY29udGFpbnNHcmVnb3JNRCA9ICFpc1VuZGVmaW5lZChub3JtYWxpemVkLm1vbnRoKSB8fCAhaXNVbmRlZmluZWQobm9ybWFsaXplZC5kYXkpLFxuICAgICAgY29udGFpbnNHcmVnb3IgPSBjb250YWluc0dyZWdvclllYXIgfHwgY29udGFpbnNHcmVnb3JNRCxcbiAgICAgIGRlZmluaXRlV2Vla0RlZiA9IG5vcm1hbGl6ZWQud2Vla1llYXIgfHwgbm9ybWFsaXplZC53ZWVrTnVtYmVyO1xuXG4gICAgaWYgKChjb250YWluc0dyZWdvciB8fCBjb250YWluc09yZGluYWwpICYmIGRlZmluaXRlV2Vla0RlZikge1xuICAgICAgdGhyb3cgbmV3IENvbmZsaWN0aW5nU3BlY2lmaWNhdGlvbkVycm9yKFxuICAgICAgICBcIkNhbid0IG1peCB3ZWVrWWVhci93ZWVrTnVtYmVyIHVuaXRzIHdpdGggeWVhci9tb250aC9kYXkgb3Igb3JkaW5hbHNcIlxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoY29udGFpbnNHcmVnb3JNRCAmJiBjb250YWluc09yZGluYWwpIHtcbiAgICAgIHRocm93IG5ldyBDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvcihcIkNhbid0IG1peCBvcmRpbmFsIGRhdGVzIHdpdGggbW9udGgvZGF5XCIpO1xuICAgIH1cblxuICAgIGxldCBtaXhlZDtcbiAgICBpZiAoc2V0dGluZ1dlZWtTdHVmZikge1xuICAgICAgbWl4ZWQgPSB3ZWVrVG9HcmVnb3JpYW4oeyAuLi5ncmVnb3JpYW5Ub1dlZWsodGhpcy5jKSwgLi4ubm9ybWFsaXplZCB9KTtcbiAgICB9IGVsc2UgaWYgKCFpc1VuZGVmaW5lZChub3JtYWxpemVkLm9yZGluYWwpKSB7XG4gICAgICBtaXhlZCA9IG9yZGluYWxUb0dyZWdvcmlhbih7IC4uLmdyZWdvcmlhblRvT3JkaW5hbCh0aGlzLmMpLCAuLi5ub3JtYWxpemVkIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBtaXhlZCA9IHsgLi4udGhpcy50b09iamVjdCgpLCAuLi5ub3JtYWxpemVkIH07XG5cbiAgICAgIC8vIGlmIHdlIGRpZG4ndCBzZXQgdGhlIGRheSBidXQgd2UgZW5kZWQgdXAgb24gYW4gb3ZlcmZsb3cgZGF0ZSxcbiAgICAgIC8vIHVzZSB0aGUgbGFzdCBkYXkgb2YgdGhlIHJpZ2h0IG1vbnRoXG4gICAgICBpZiAoaXNVbmRlZmluZWQobm9ybWFsaXplZC5kYXkpKSB7XG4gICAgICAgIG1peGVkLmRheSA9IE1hdGgubWluKGRheXNJbk1vbnRoKG1peGVkLnllYXIsIG1peGVkLm1vbnRoKSwgbWl4ZWQuZGF5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBbdHMsIG9dID0gb2JqVG9UUyhtaXhlZCwgdGhpcy5vLCB0aGlzLnpvbmUpO1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHRzLCBvIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIHBlcmlvZCBvZiB0aW1lIHRvIHRoaXMgRGF0ZVRpbWUgYW5kIHJldHVybiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lXG4gICAqXG4gICAqIEFkZGluZyBob3VycywgbWludXRlcywgc2Vjb25kcywgb3IgbWlsbGlzZWNvbmRzIGluY3JlYXNlcyB0aGUgdGltZXN0YW1wIGJ5IHRoZSByaWdodCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLiBBZGRpbmcgZGF5cywgbW9udGhzLCBvciB5ZWFycyBzaGlmdHMgdGhlIGNhbGVuZGFyLCBhY2NvdW50aW5nIGZvciBEU1RzIGFuZCBsZWFwIHllYXJzIGFsb25nIHRoZSB3YXkuIFRodXMsIGBkdC5wbHVzKHsgaG91cnM6IDI0IH0pYCBtYXkgcmVzdWx0IGluIGEgZGlmZmVyZW50IHRpbWUgdGhhbiBgZHQucGx1cyh7IGRheXM6IDEgfSlgIGlmIHRoZXJlJ3MgYSBEU1Qgc2hpZnQgaW4gYmV0d2Vlbi5cbiAgICogQHBhcmFtIHtEdXJhdGlvbnxPYmplY3R8bnVtYmVyfSBkdXJhdGlvbiAtIFRoZSBhbW91bnQgdG8gYWRkLiBFaXRoZXIgYSBMdXhvbiBEdXJhdGlvbiwgYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLCB0aGUgb2JqZWN0IGFyZ3VtZW50IHRvIER1cmF0aW9uLmZyb21PYmplY3QoKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKDEyMykgLy9+PiBpbiAxMjMgbWlsbGlzZWNvbmRzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoeyBtaW51dGVzOiAxNSB9KSAvL34+IGluIDE1IG1pbnV0ZXNcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cyh7IGRheXM6IDEgfSkgLy9+PiB0aGlzIHRpbWUgdG9tb3Jyb3dcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cyh7IGRheXM6IC0xIH0pIC8vfj4gdGhpcyB0aW1lIHllc3RlcmRheVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKHsgaG91cnM6IDMsIG1pbnV0ZXM6IDEzIH0pIC8vfj4gaW4gMyBociwgMTMgbWluXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAzLCBtaW51dGVzOiAxMyB9KSkgLy9+PiBpbiAzIGhyLCAxMyBtaW5cbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBwbHVzKGR1cmF0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IGR1ciA9IER1cmF0aW9uLmZyb21EdXJhdGlvbkxpa2UoZHVyYXRpb24pO1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCBhZGp1c3RUaW1lKHRoaXMsIGR1cikpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1YnRyYWN0IGEgcGVyaW9kIG9mIHRpbWUgdG8gdGhpcyBEYXRlVGltZSBhbmQgcmV0dXJuIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWVcbiAgICogU2VlIHtAbGluayBEYXRlVGltZSNwbHVzfVxuICAgKiBAcGFyYW0ge0R1cmF0aW9ufE9iamVjdHxudW1iZXJ9IGR1cmF0aW9uIC0gVGhlIGFtb3VudCB0byBzdWJ0cmFjdC4gRWl0aGVyIGEgTHV4b24gRHVyYXRpb24sIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgdGhlIG9iamVjdCBhcmd1bWVudCB0byBEdXJhdGlvbi5mcm9tT2JqZWN0KClcbiAgIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgbWludXMoZHVyYXRpb24pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgZHVyID0gRHVyYXRpb24uZnJvbUR1cmF0aW9uTGlrZShkdXJhdGlvbikubmVnYXRlKCk7XG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIGFkanVzdFRpbWUodGhpcywgZHVyKSk7XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGlzIERhdGVUaW1lIHRvIHRoZSBiZWdpbm5pbmcgb2YgYSB1bml0IG9mIHRpbWUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1bml0IC0gVGhlIHVuaXQgdG8gZ28gdG8gdGhlIGJlZ2lubmluZyBvZi4gQ2FuIGJlICd5ZWFyJywgJ3F1YXJ0ZXInLCAnbW9udGgnLCAnd2VlaycsICdkYXknLCAnaG91cicsICdtaW51dGUnLCAnc2Vjb25kJywgb3IgJ21pbGxpc2Vjb25kJy5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMywgMykuc3RhcnRPZignbW9udGgnKS50b0lTT0RhdGUoKTsgLy89PiAnMjAxNC0wMy0wMSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMywgMykuc3RhcnRPZigneWVhcicpLnRvSVNPRGF0ZSgpOyAvLz0+ICcyMDE0LTAxLTAxJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzKS5zdGFydE9mKCd3ZWVrJykudG9JU09EYXRlKCk7IC8vPT4gJzIwMTQtMDMtMDMnLCB3ZWVrcyBhbHdheXMgc3RhcnQgb24gTW9uZGF5c1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzLCA1LCAzMCkuc3RhcnRPZignZGF5JykudG9JU09UaW1lKCk7IC8vPT4gJzAwOjAwLjAwMC0wNTowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMywgMywgNSwgMzApLnN0YXJ0T2YoJ2hvdXInKS50b0lTT1RpbWUoKTsgLy89PiAnMDU6MDA6MDAuMDAwLTA1OjAwJ1xuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXJ0T2YodW5pdCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCBvID0ge30sXG4gICAgICBub3JtYWxpemVkVW5pdCA9IER1cmF0aW9uLm5vcm1hbGl6ZVVuaXQodW5pdCk7XG4gICAgc3dpdGNoIChub3JtYWxpemVkVW5pdCkge1xuICAgICAgY2FzZSBcInllYXJzXCI6XG4gICAgICAgIG8ubW9udGggPSAxO1xuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgY2FzZSBcInF1YXJ0ZXJzXCI6XG4gICAgICBjYXNlIFwibW9udGhzXCI6XG4gICAgICAgIG8uZGF5ID0gMTtcbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGNhc2UgXCJ3ZWVrc1wiOlxuICAgICAgY2FzZSBcImRheXNcIjpcbiAgICAgICAgby5ob3VyID0gMDtcbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGNhc2UgXCJob3Vyc1wiOlxuICAgICAgICBvLm1pbnV0ZSA9IDA7XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBjYXNlIFwibWludXRlc1wiOlxuICAgICAgICBvLnNlY29uZCA9IDA7XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBjYXNlIFwic2Vjb25kc1wiOlxuICAgICAgICBvLm1pbGxpc2Vjb25kID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibWlsbGlzZWNvbmRzXCI6XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gbm8gZGVmYXVsdCwgaW52YWxpZCB1bml0cyB0aHJvdyBpbiBub3JtYWxpemVVbml0KClcbiAgICB9XG5cbiAgICBpZiAobm9ybWFsaXplZFVuaXQgPT09IFwid2Vla3NcIikge1xuICAgICAgby53ZWVrZGF5ID0gMTtcbiAgICB9XG5cbiAgICBpZiAobm9ybWFsaXplZFVuaXQgPT09IFwicXVhcnRlcnNcIikge1xuICAgICAgY29uc3QgcSA9IE1hdGguY2VpbCh0aGlzLm1vbnRoIC8gMyk7XG4gICAgICBvLm1vbnRoID0gKHEgLSAxKSAqIDMgKyAxO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNldChvKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoaXMgRGF0ZVRpbWUgdG8gdGhlIGVuZCAobWVhbmluZyB0aGUgbGFzdCBtaWxsaXNlY29uZCkgb2YgYSB1bml0IG9mIHRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVuaXQgLSBUaGUgdW5pdCB0byBnbyB0byB0aGUgZW5kIG9mLiBDYW4gYmUgJ3llYXInLCAncXVhcnRlcicsICdtb250aCcsICd3ZWVrJywgJ2RheScsICdob3VyJywgJ21pbnV0ZScsICdzZWNvbmQnLCBvciAnbWlsbGlzZWNvbmQnLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzKS5lbmRPZignbW9udGgnKS50b0lTTygpOyAvLz0+ICcyMDE0LTAzLTMxVDIzOjU5OjU5Ljk5OS0wNTowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMywgMykuZW5kT2YoJ3llYXInKS50b0lTTygpOyAvLz0+ICcyMDE0LTEyLTMxVDIzOjU5OjU5Ljk5OS0wNTowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMywgMykuZW5kT2YoJ3dlZWsnKS50b0lTTygpOyAvLyA9PiAnMjAxNC0wMy0wOVQyMzo1OTo1OS45OTktMDU6MDAnLCB3ZWVrcyBzdGFydCBvbiBNb25kYXlzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMsIDUsIDMwKS5lbmRPZignZGF5JykudG9JU08oKTsgLy89PiAnMjAxNC0wMy0wM1QyMzo1OTo1OS45OTktMDU6MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMsIDUsIDMwKS5lbmRPZignaG91cicpLnRvSVNPKCk7IC8vPT4gJzIwMTQtMDMtMDNUMDU6NTk6NTkuOTk5LTA1OjAwJ1xuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIGVuZE9mKHVuaXQpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkXG4gICAgICA/IHRoaXMucGx1cyh7IFt1bml0XTogMSB9KVxuICAgICAgICAgIC5zdGFydE9mKHVuaXQpXG4gICAgICAgICAgLm1pbnVzKDEpXG4gICAgICA6IHRoaXM7XG4gIH1cblxuICAvLyBPVVRQVVRcblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lIGZvcm1hdHRlZCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBmb3JtYXQgc3RyaW5nLlxuICAgKiAqKllvdSBtYXkgbm90IHdhbnQgdGhpcy4qKiBTZWUge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3IgYSBtb3JlIGZsZXhpYmxlIGZvcm1hdHRpbmcgdG9vbC4gRm9yIGEgdGFibGUgb2YgdG9rZW5zIGFuZCB0aGVpciBpbnRlcnByZXRhdGlvbnMsIHNlZSBbaGVyZV0oaHR0cHM6Ly9tb21lbnQuZ2l0aHViLmlvL2x1eG9uLyMvZm9ybWF0dGluZz9pZD10YWJsZS1vZi10b2tlbnMpLlxuICAgKiBEZWZhdWx0cyB0byBlbi1VUyBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkLCByZWdhcmRsZXNzIG9mIHRoZSBzeXN0ZW0ncyBsb2NhbGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmbXQgLSB0aGUgZm9ybWF0IHN0cmluZ1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdHMgdG8gb3ZlcnJpZGUgdGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBvbiB0aGlzIERhdGVUaW1lXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvRm9ybWF0KCd5eXl5IExMTCBkZCcpIC8vPT4gJzIwMTcgQXByIDIyJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5zZXRMb2NhbGUoJ2ZyJykudG9Gb3JtYXQoJ3l5eXkgTExMIGRkJykgLy89PiAnMjAxNyBhdnIuIDIyJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0Zvcm1hdCgneXl5eSBMTEwgZGQnLCB7IGxvY2FsZTogXCJmclwiIH0pIC8vPT4gJzIwMTcgYXZyLiAyMidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Gb3JtYXQoXCJISCAnaG91cnMgYW5kJyBtbSAnbWludXRlcydcIikgLy89PiAnMjAgaG91cnMgYW5kIDU1IG1pbnV0ZXMnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvRm9ybWF0KGZtdCwgb3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZFxuICAgICAgPyBGb3JtYXR0ZXIuY3JlYXRlKHRoaXMubG9jLnJlZGVmYXVsdFRvRU4ob3B0cykpLmZvcm1hdERhdGVUaW1lRnJvbVN0cmluZyh0aGlzLCBmbXQpXG4gICAgICA6IElOVkFMSUQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGxvY2FsaXplZCBzdHJpbmcgcmVwcmVzZW50aW5nIHRoaXMgZGF0ZS4gQWNjZXB0cyB0aGUgc2FtZSBvcHRpb25zIGFzIHRoZSBJbnRsLkRhdGVUaW1lRm9ybWF0IGNvbnN0cnVjdG9yIGFuZCBhbnkgcHJlc2V0cyBkZWZpbmVkIGJ5IEx1eG9uLCBzdWNoIGFzIGBEYXRlVGltZS5EQVRFX0ZVTExgIG9yIGBEYXRlVGltZS5USU1FX1NJTVBMRWAuXG4gICAqIFRoZSBleGFjdCBiZWhhdmlvciBvZiB0aGlzIG1ldGhvZCBpcyBicm93c2VyLXNwZWNpZmljLCBidXQgaW4gZ2VuZXJhbCBpdCB3aWxsIHJldHVybiBhbiBhcHByb3ByaWF0ZSByZXByZXNlbnRhdGlvblxuICAgKiBvZiB0aGUgRGF0ZVRpbWUgaW4gdGhlIGFzc2lnbmVkIGxvY2FsZS5cbiAgICogRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZVRpbWVGb3JtYXRcbiAgICogQHBhcmFtIGZvcm1hdE9wdHMge09iamVjdH0gLSBJbnRsLkRhdGVUaW1lRm9ybWF0IGNvbnN0cnVjdG9yIG9wdGlvbnMgYW5kIGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdHMgdG8gb3ZlcnJpZGUgdGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBvbiB0aGlzIERhdGVUaW1lXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlU3RyaW5nKCk7IC8vPT4gNC8yMC8yMDE3XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnNldExvY2FsZSgnZW4tZ2InKS50b0xvY2FsZVN0cmluZygpOyAvLz0+ICcyMC8wNC8yMDE3J1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0xvY2FsZVN0cmluZyhEYXRlVGltZS5EQVRFX0ZVTEwpOyAvLz0+ICdBcHJpbCAyMCwgMjAxNydcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Mb2NhbGVTdHJpbmcoRGF0ZVRpbWUuREFURV9GVUxMLCB7IGxvY2FsZTogJ2ZyJyB9KTsgLy89PiAnMjggYW/Du3QgMjAyMidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Mb2NhbGVTdHJpbmcoRGF0ZVRpbWUuVElNRV9TSU1QTEUpOyAvLz0+ICcxMTozMiBBTSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Mb2NhbGVTdHJpbmcoRGF0ZVRpbWUuREFURVRJTUVfU0hPUlQpOyAvLz0+ICc0LzIwLzIwMTcsIDExOjMyIEFNJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0xvY2FsZVN0cmluZyh7IHdlZWtkYXk6ICdsb25nJywgbW9udGg6ICdsb25nJywgZGF5OiAnMi1kaWdpdCcgfSk7IC8vPT4gJ1RodXJzZGF5LCBBcHJpbCAyMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Mb2NhbGVTdHJpbmcoeyB3ZWVrZGF5OiAnc2hvcnQnLCBtb250aDogJ3Nob3J0JywgZGF5OiAnMi1kaWdpdCcsIGhvdXI6ICcyLWRpZ2l0JywgbWludXRlOiAnMi1kaWdpdCcgfSk7IC8vPT4gJ1RodSwgQXByIDIwLCAxMToyNyBBTSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Mb2NhbGVTdHJpbmcoeyBob3VyOiAnMi1kaWdpdCcsIG1pbnV0ZTogJzItZGlnaXQnLCBob3VyQ3ljbGU6ICdoMjMnIH0pOyAvLz0+ICcxMTozMidcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9Mb2NhbGVTdHJpbmcoZm9ybWF0T3B0cyA9IEZvcm1hdHMuREFURV9TSE9SVCwgb3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZFxuICAgICAgPyBGb3JtYXR0ZXIuY3JlYXRlKHRoaXMubG9jLmNsb25lKG9wdHMpLCBmb3JtYXRPcHRzKS5mb3JtYXREYXRlVGltZSh0aGlzKVxuICAgICAgOiBJTlZBTElEO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgb2YgZm9ybWF0IFwicGFydHNcIiwgbWVhbmluZyBpbmRpdmlkdWFsIHRva2VucyBhbG9uZyB3aXRoIG1ldGFkYXRhLiBUaGlzIGlzIGFsbG93cyBjYWxsZXJzIHRvIHBvc3QtcHJvY2VzcyBpbmRpdmlkdWFsIHNlY3Rpb25zIG9mIHRoZSBmb3JtYXR0ZWQgb3V0cHV0LlxuICAgKiBEZWZhdWx0cyB0byB0aGUgc3lzdGVtJ3MgbG9jYWxlIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlVGltZUZvcm1hdC9mb3JtYXRUb1BhcnRzXG4gICAqIEBwYXJhbSBvcHRzIHtPYmplY3R9IC0gSW50bC5EYXRlVGltZUZvcm1hdCBjb25zdHJ1Y3RvciBvcHRpb25zLCBzYW1lIGFzIGB0b0xvY2FsZVN0cmluZ2AuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlUGFydHMoKTsgLy89PiBbXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLz0+ICAgeyB0eXBlOiAnZGF5JywgdmFsdWU6ICcyNScgfSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vPT4gICB7IHR5cGU6ICdsaXRlcmFsJywgdmFsdWU6ICcvJyB9LFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy89PiAgIHsgdHlwZTogJ21vbnRoJywgdmFsdWU6ICcwNScgfSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vPT4gICB7IHR5cGU6ICdsaXRlcmFsJywgdmFsdWU6ICcvJyB9LFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy89PiAgIHsgdHlwZTogJ3llYXInLCB2YWx1ZTogJzE5ODInIH1cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vPT4gXVxuICAgKi9cbiAgdG9Mb2NhbGVQYXJ0cyhvcHRzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkXG4gICAgICA/IEZvcm1hdHRlci5jcmVhdGUodGhpcy5sb2MuY2xvbmUob3B0cyksIG9wdHMpLmZvcm1hdERhdGVUaW1lUGFydHModGhpcylcbiAgICAgIDogW107XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMS1jb21wbGlhbnQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc3VwcHJlc3NNaWxsaXNlY29uZHM9ZmFsc2VdIC0gZXhjbHVkZSBtaWxsaXNlY29uZHMgZnJvbSB0aGUgZm9ybWF0IGlmIHRoZXkncmUgMFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnN1cHByZXNzU2Vjb25kcz1mYWxzZV0gLSBleGNsdWRlIHNlY29uZHMgZnJvbSB0aGUgZm9ybWF0IGlmIHRoZXkncmUgMFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVPZmZzZXQ9dHJ1ZV0gLSBpbmNsdWRlIHRoZSBvZmZzZXQsIHN1Y2ggYXMgJ1onIG9yICctMDQ6MDAnXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuZXh0ZW5kZWRab25lPWZhbHNlXSAtIGFkZCB0aGUgdGltZSB6b25lIGZvcm1hdCBleHRlbnNpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmZvcm1hdD0nZXh0ZW5kZWQnXSAtIGNob29zZSBiZXR3ZWVuIHRoZSBiYXNpYyBhbmQgZXh0ZW5kZWQgZm9ybWF0XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygxOTgzLCA1LCAyNSkudG9JU08oKSAvLz0+ICcxOTgyLTA1LTI1VDAwOjAwOjAwLjAwMFonXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvSVNPKCkgLy89PiAnMjAxNy0wNC0yMlQyMDo0NzowNS4zMzUtMDQ6MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvSVNPKHsgaW5jbHVkZU9mZnNldDogZmFsc2UgfSkgLy89PiAnMjAxNy0wNC0yMlQyMDo0NzowNS4zMzUnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvSVNPKHsgZm9ybWF0OiAnYmFzaWMnIH0pIC8vPT4gJzIwMTcwNDIyVDIwNDcwNS4zMzUtMDQwMCdcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9JU08oe1xuICAgIGZvcm1hdCA9IFwiZXh0ZW5kZWRcIixcbiAgICBzdXBwcmVzc1NlY29uZHMgPSBmYWxzZSxcbiAgICBzdXBwcmVzc01pbGxpc2Vjb25kcyA9IGZhbHNlLFxuICAgIGluY2x1ZGVPZmZzZXQgPSB0cnVlLFxuICAgIGV4dGVuZGVkWm9uZSA9IGZhbHNlLFxuICB9ID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgZXh0ID0gZm9ybWF0ID09PSBcImV4dGVuZGVkXCI7XG5cbiAgICBsZXQgYyA9IHRvSVNPRGF0ZSh0aGlzLCBleHQpO1xuICAgIGMgKz0gXCJUXCI7XG4gICAgYyArPSB0b0lTT1RpbWUodGhpcywgZXh0LCBzdXBwcmVzc1NlY29uZHMsIHN1cHByZXNzTWlsbGlzZWNvbmRzLCBpbmNsdWRlT2Zmc2V0LCBleHRlbmRlZFpvbmUpO1xuICAgIHJldHVybiBjO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEtY29tcGxpYW50IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lJ3MgZGF0ZSBjb21wb25lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5mb3JtYXQ9J2V4dGVuZGVkJ10gLSBjaG9vc2UgYmV0d2VlbiB0aGUgYmFzaWMgYW5kIGV4dGVuZGVkIGZvcm1hdFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMTk4MiwgNSwgMjUpLnRvSVNPRGF0ZSgpIC8vPT4gJzE5ODItMDUtMjUnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygxOTgyLCA1LCAyNSkudG9JU09EYXRlKHsgZm9ybWF0OiAnYmFzaWMnIH0pIC8vPT4gJzE5ODIwNTI1J1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0lTT0RhdGUoeyBmb3JtYXQgPSBcImV4dGVuZGVkXCIgfSA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0b0lTT0RhdGUodGhpcywgZm9ybWF0ID09PSBcImV4dGVuZGVkXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEtY29tcGxpYW50IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lJ3Mgd2VlayBkYXRlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygxOTgyLCA1LCAyNSkudG9JU09XZWVrRGF0ZSgpIC8vPT4gJzE5ODItVzIxLTInXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSVNPV2Vla0RhdGUoKSB7XG4gICAgcmV0dXJuIHRvVGVjaEZvcm1hdCh0aGlzLCBcImtra2stJ1cnV1ctY1wiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSdzIHRpbWUgY29tcG9uZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnN1cHByZXNzTWlsbGlzZWNvbmRzPWZhbHNlXSAtIGV4Y2x1ZGUgbWlsbGlzZWNvbmRzIGZyb20gdGhlIGZvcm1hdCBpZiB0aGV5J3JlIDBcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zdXBwcmVzc1NlY29uZHM9ZmFsc2VdIC0gZXhjbHVkZSBzZWNvbmRzIGZyb20gdGhlIGZvcm1hdCBpZiB0aGV5J3JlIDBcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlT2Zmc2V0PXRydWVdIC0gaW5jbHVkZSB0aGUgb2Zmc2V0LCBzdWNoIGFzICdaJyBvciAnLTA0OjAwJ1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmV4dGVuZGVkWm9uZT10cnVlXSAtIGFkZCB0aGUgdGltZSB6b25lIGZvcm1hdCBleHRlbnNpb25cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlUHJlZml4PWZhbHNlXSAtIGluY2x1ZGUgdGhlIGBUYCBwcmVmaXhcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmZvcm1hdD0nZXh0ZW5kZWQnXSAtIGNob29zZSBiZXR3ZWVuIHRoZSBiYXNpYyBhbmQgZXh0ZW5kZWQgZm9ybWF0XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygpLnNldCh7IGhvdXI6IDcsIG1pbnV0ZTogMzQgfSkudG9JU09UaW1lKCkgLy89PiAnMDc6MzQ6MTkuMzYxWidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKCkuc2V0KHsgaG91cjogNywgbWludXRlOiAzNCwgc2Vjb25kczogMCwgbWlsbGlzZWNvbmRzOiAwIH0pLnRvSVNPVGltZSh7IHN1cHByZXNzU2Vjb25kczogdHJ1ZSB9KSAvLz0+ICcwNzozNFonXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygpLnNldCh7IGhvdXI6IDcsIG1pbnV0ZTogMzQgfSkudG9JU09UaW1lKHsgZm9ybWF0OiAnYmFzaWMnIH0pIC8vPT4gJzA3MzQxOS4zNjFaJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoKS5zZXQoeyBob3VyOiA3LCBtaW51dGU6IDM0IH0pLnRvSVNPVGltZSh7IGluY2x1ZGVQcmVmaXg6IHRydWUgfSkgLy89PiAnVDA3OjM0OjE5LjM2MVonXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSVNPVGltZSh7XG4gICAgc3VwcHJlc3NNaWxsaXNlY29uZHMgPSBmYWxzZSxcbiAgICBzdXBwcmVzc1NlY29uZHMgPSBmYWxzZSxcbiAgICBpbmNsdWRlT2Zmc2V0ID0gdHJ1ZSxcbiAgICBpbmNsdWRlUHJlZml4ID0gZmFsc2UsXG4gICAgZXh0ZW5kZWRab25lID0gZmFsc2UsXG4gICAgZm9ybWF0ID0gXCJleHRlbmRlZFwiLFxuICB9ID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgbGV0IGMgPSBpbmNsdWRlUHJlZml4ID8gXCJUXCIgOiBcIlwiO1xuICAgIHJldHVybiAoXG4gICAgICBjICtcbiAgICAgIHRvSVNPVGltZShcbiAgICAgICAgdGhpcyxcbiAgICAgICAgZm9ybWF0ID09PSBcImV4dGVuZGVkXCIsXG4gICAgICAgIHN1cHByZXNzU2Vjb25kcyxcbiAgICAgICAgc3VwcHJlc3NNaWxsaXNlY29uZHMsXG4gICAgICAgIGluY2x1ZGVPZmZzZXQsXG4gICAgICAgIGV4dGVuZGVkWm9uZVxuICAgICAgKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBSRkMgMjgyMi1jb21wYXRpYmxlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE0LCA3LCAxMykudG9SRkMyODIyKCkgLy89PiAnU3VuLCAxMyBKdWwgMjAxNCAwMDowMDowMCArMDAwMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgNywgMTMpLnRvUkZDMjgyMigpIC8vPT4gJ1N1biwgMTMgSnVsIDIwMTQgMDA6MDA6MDAgLTA0MDAnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvUkZDMjgyMigpIHtcbiAgICByZXR1cm4gdG9UZWNoRm9ybWF0KHRoaXMsIFwiRUVFLCBkZCBMTEwgeXl5eSBISDptbTpzcyBaWlpcIiwgZmFsc2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSBhcHByb3ByaWF0ZSBmb3IgdXNlIGluIEhUVFAgaGVhZGVycy4gVGhlIG91dHB1dCBpcyBhbHdheXMgZXhwcmVzc2VkIGluIEdNVC5cbiAgICogU3BlY2lmaWNhbGx5LCB0aGUgc3RyaW5nIGNvbmZvcm1zIHRvIFJGQyAxMTIzLlxuICAgKiBAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9Qcm90b2NvbHMvcmZjMjYxNi9yZmMyNjE2LXNlYzMuaHRtbCNzZWMzLjMuMVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNCwgNywgMTMpLnRvSFRUUCgpIC8vPT4gJ1N1biwgMTMgSnVsIDIwMTQgMDA6MDA6MDAgR01UJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNCwgNywgMTMsIDE5KS50b0hUVFAoKSAvLz0+ICdTdW4sIDEzIEp1bCAyMDE0IDE5OjAwOjAwIEdNVCdcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9IVFRQKCkge1xuICAgIHJldHVybiB0b1RlY2hGb3JtYXQodGhpcy50b1VUQygpLCBcIkVFRSwgZGQgTExMIHl5eXkgSEg6bW06c3MgJ0dNVCdcIik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lIGFwcHJvcHJpYXRlIGZvciB1c2UgaW4gU1FMIERhdGVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTQsIDcsIDEzKS50b1NRTERhdGUoKSAvLz0+ICcyMDE0LTA3LTEzJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b1NRTERhdGUoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdG9JU09EYXRlKHRoaXMsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSBhcHByb3ByaWF0ZSBmb3IgdXNlIGluIFNRTCBUaW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVab25lPWZhbHNlXSAtIGluY2x1ZGUgdGhlIHpvbmUsIHN1Y2ggYXMgJ0FtZXJpY2EvTmV3X1lvcmsnLiBPdmVycmlkZXMgaW5jbHVkZU9mZnNldC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlT2Zmc2V0PXRydWVdIC0gaW5jbHVkZSB0aGUgb2Zmc2V0LCBzdWNoIGFzICdaJyBvciAnLTA0OjAwJ1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVPZmZzZXRTcGFjZT10cnVlXSAtIGluY2x1ZGUgdGhlIHNwYWNlIGJldHdlZW4gdGhlIHRpbWUgYW5kIHRoZSBvZmZzZXQsIHN1Y2ggYXMgJzA1OjE1OjE2LjM0NSAtMDQ6MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygpLnRvU1FMKCkgLy89PiAnMDU6MTU6MTYuMzQ1J1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b1NRTCgpIC8vPT4gJzA1OjE1OjE2LjM0NSAtMDQ6MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvU1FMKHsgaW5jbHVkZU9mZnNldDogZmFsc2UgfSkgLy89PiAnMDU6MTU6MTYuMzQ1J1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b1NRTCh7IGluY2x1ZGVab25lOiBmYWxzZSB9KSAvLz0+ICcwNToxNToxNi4zNDUgQW1lcmljYS9OZXdfWW9yaydcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9TUUxUaW1lKHsgaW5jbHVkZU9mZnNldCA9IHRydWUsIGluY2x1ZGVab25lID0gZmFsc2UsIGluY2x1ZGVPZmZzZXRTcGFjZSA9IHRydWUgfSA9IHt9KSB7XG4gICAgbGV0IGZtdCA9IFwiSEg6bW06c3MuU1NTXCI7XG5cbiAgICBpZiAoaW5jbHVkZVpvbmUgfHwgaW5jbHVkZU9mZnNldCkge1xuICAgICAgaWYgKGluY2x1ZGVPZmZzZXRTcGFjZSkge1xuICAgICAgICBmbXQgKz0gXCIgXCI7XG4gICAgICB9XG4gICAgICBpZiAoaW5jbHVkZVpvbmUpIHtcbiAgICAgICAgZm10ICs9IFwielwiO1xuICAgICAgfSBlbHNlIGlmIChpbmNsdWRlT2Zmc2V0KSB7XG4gICAgICAgIGZtdCArPSBcIlpaXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRvVGVjaEZvcm1hdCh0aGlzLCBmbXQsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSBhcHByb3ByaWF0ZSBmb3IgdXNlIGluIFNRTCBEYXRlVGltZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlWm9uZT1mYWxzZV0gLSBpbmNsdWRlIHRoZSB6b25lLCBzdWNoIGFzICdBbWVyaWNhL05ld19Zb3JrJy4gT3ZlcnJpZGVzIGluY2x1ZGVPZmZzZXQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZU9mZnNldD10cnVlXSAtIGluY2x1ZGUgdGhlIG9mZnNldCwgc3VjaCBhcyAnWicgb3IgJy0wNDowMCdcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlT2Zmc2V0U3BhY2U9dHJ1ZV0gLSBpbmNsdWRlIHRoZSBzcGFjZSBiZXR3ZWVuIHRoZSB0aW1lIGFuZCB0aGUgb2Zmc2V0LCBzdWNoIGFzICcwNToxNToxNi4zNDUgLTA0OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNCwgNywgMTMpLnRvU1FMKCkgLy89PiAnMjAxNC0wNy0xMyAwMDowMDowMC4wMDAgWidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgNywgMTMpLnRvU1FMKCkgLy89PiAnMjAxNC0wNy0xMyAwMDowMDowMC4wMDAgLTA0OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCA3LCAxMykudG9TUUwoeyBpbmNsdWRlT2Zmc2V0OiBmYWxzZSB9KSAvLz0+ICcyMDE0LTA3LTEzIDAwOjAwOjAwLjAwMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgNywgMTMpLnRvU1FMKHsgaW5jbHVkZVpvbmU6IHRydWUgfSkgLy89PiAnMjAxNC0wNy0xMyAwMDowMDowMC4wMDAgQW1lcmljYS9OZXdfWW9yaydcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9TUUwob3B0cyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBgJHt0aGlzLnRvU1FMRGF0ZSgpfSAke3RoaXMudG9TUUxUaW1lKG9wdHMpfWA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lIGFwcHJvcHJpYXRlIGZvciBkZWJ1Z2dpbmdcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudG9JU08oKSA6IElOVkFMSUQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZXBvY2ggbWlsbGlzZWNvbmRzIG9mIHRoaXMgRGF0ZVRpbWUuIEFsaWFzIG9mIHtAbGluayBEYXRlVGltZSN0b01pbGxpc31cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgdmFsdWVPZigpIHtcbiAgICByZXR1cm4gdGhpcy50b01pbGxpcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVwb2NoIG1pbGxpc2Vjb25kcyBvZiB0aGlzIERhdGVUaW1lLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICB0b01pbGxpcygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy50cyA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlcG9jaCBzZWNvbmRzIG9mIHRoaXMgRGF0ZVRpbWUuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHRvU2Vjb25kcygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy50cyAvIDEwMDAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZXBvY2ggc2Vjb25kcyAoYXMgYSB3aG9sZSBudW1iZXIpIG9mIHRoaXMgRGF0ZVRpbWUuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHRvVW5peEludGVnZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IE1hdGguZmxvb3IodGhpcy50cyAvIDEwMDApIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSBhcHByb3ByaWF0ZSBmb3IgdXNlIGluIEpTT04uXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b0lTTygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBCU09OIHNlcmlhbGl6YWJsZSBlcXVpdmFsZW50IHRvIHRoaXMgRGF0ZVRpbWUuXG4gICAqIEByZXR1cm4ge0RhdGV9XG4gICAqL1xuICB0b0JTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9KU0RhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgSmF2YVNjcmlwdCBvYmplY3Qgd2l0aCB0aGlzIERhdGVUaW1lJ3MgeWVhciwgbW9udGgsIGRheSwgYW5kIHNvIG9uLlxuICAgKiBAcGFyYW0gb3B0cyAtIG9wdGlvbnMgZm9yIGdlbmVyYXRpbmcgdGhlIG9iamVjdFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVDb25maWc9ZmFsc2VdIC0gaW5jbHVkZSBjb25maWd1cmF0aW9uIGF0dHJpYnV0ZXMgaW4gdGhlIG91dHB1dFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b09iamVjdCgpIC8vPT4geyB5ZWFyOiAyMDE3LCBtb250aDogNCwgZGF5OiAyMiwgaG91cjogMjAsIG1pbnV0ZTogNDksIHNlY29uZDogNDIsIG1pbGxpc2Vjb25kOiAyNjggfVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICB0b09iamVjdChvcHRzID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHt9O1xuXG4gICAgY29uc3QgYmFzZSA9IHsgLi4udGhpcy5jIH07XG5cbiAgICBpZiAob3B0cy5pbmNsdWRlQ29uZmlnKSB7XG4gICAgICBiYXNlLm91dHB1dENhbGVuZGFyID0gdGhpcy5vdXRwdXRDYWxlbmRhcjtcbiAgICAgIGJhc2UubnVtYmVyaW5nU3lzdGVtID0gdGhpcy5sb2MubnVtYmVyaW5nU3lzdGVtO1xuICAgICAgYmFzZS5sb2NhbGUgPSB0aGlzLmxvYy5sb2NhbGU7XG4gICAgfVxuICAgIHJldHVybiBiYXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBKYXZhU2NyaXB0IERhdGUgZXF1aXZhbGVudCB0byB0aGlzIERhdGVUaW1lLlxuICAgKiBAcmV0dXJuIHtEYXRlfVxuICAgKi9cbiAgdG9KU0RhdGUoKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMuaXNWYWxpZCA/IHRoaXMudHMgOiBOYU4pO1xuICB9XG5cbiAgLy8gQ09NUEFSRVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0d28gRGF0ZVRpbWVzIGFzIGEgRHVyYXRpb24uXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IG90aGVyRGF0ZVRpbWUgLSB0aGUgRGF0ZVRpbWUgdG8gY29tcGFyZSB0aGlzIG9uZSB0b1xuICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gW3VuaXQ9WydtaWxsaXNlY29uZHMnXV0gLSB0aGUgdW5pdCBvciBhcnJheSBvZiB1bml0cyAoc3VjaCBhcyAnaG91cnMnIG9yICdkYXlzJykgdG8gaW5jbHVkZSBpbiB0aGUgZHVyYXRpb24uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyB0aGF0IGFmZmVjdCB0aGUgY3JlYXRpb24gb2YgdGhlIER1cmF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5jb252ZXJzaW9uQWNjdXJhY3k9J2Nhc3VhbCddIC0gdGhlIGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgaTEgPSBEYXRlVGltZS5mcm9tSVNPKCcxOTgyLTA1LTI1VDA5OjQ1JyksXG4gICAqICAgICBpMiA9IERhdGVUaW1lLmZyb21JU08oJzE5ODMtMTAtMTRUMTA6MzAnKTtcbiAgICogaTIuZGlmZihpMSkudG9PYmplY3QoKSAvLz0+IHsgbWlsbGlzZWNvbmRzOiA0MzgwNzUwMDAwMCB9XG4gICAqIGkyLmRpZmYoaTEsICdob3VycycpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAxMjE2OC43NSB9XG4gICAqIGkyLmRpZmYoaTEsIFsnbW9udGhzJywgJ2RheXMnXSkudG9PYmplY3QoKSAvLz0+IHsgbW9udGhzOiAxNiwgZGF5czogMTkuMDMxMjUgfVxuICAgKiBpMi5kaWZmKGkxLCBbJ21vbnRocycsICdkYXlzJywgJ2hvdXJzJ10pLnRvT2JqZWN0KCkgLy89PiB7IG1vbnRoczogMTYsIGRheXM6IDE5LCBob3VyczogMC43NSB9XG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgZGlmZihvdGhlckRhdGVUaW1lLCB1bml0ID0gXCJtaWxsaXNlY29uZHNcIiwgb3B0cyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQgfHwgIW90aGVyRGF0ZVRpbWUuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLmludmFsaWQoXCJjcmVhdGVkIGJ5IGRpZmZpbmcgYW4gaW52YWxpZCBEYXRlVGltZVwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBkdXJPcHRzID0geyBsb2NhbGU6IHRoaXMubG9jYWxlLCBudW1iZXJpbmdTeXN0ZW06IHRoaXMubnVtYmVyaW5nU3lzdGVtLCAuLi5vcHRzIH07XG5cbiAgICBjb25zdCB1bml0cyA9IG1heWJlQXJyYXkodW5pdCkubWFwKER1cmF0aW9uLm5vcm1hbGl6ZVVuaXQpLFxuICAgICAgb3RoZXJJc0xhdGVyID0gb3RoZXJEYXRlVGltZS52YWx1ZU9mKCkgPiB0aGlzLnZhbHVlT2YoKSxcbiAgICAgIGVhcmxpZXIgPSBvdGhlcklzTGF0ZXIgPyB0aGlzIDogb3RoZXJEYXRlVGltZSxcbiAgICAgIGxhdGVyID0gb3RoZXJJc0xhdGVyID8gb3RoZXJEYXRlVGltZSA6IHRoaXMsXG4gICAgICBkaWZmZWQgPSBkaWZmKGVhcmxpZXIsIGxhdGVyLCB1bml0cywgZHVyT3B0cyk7XG5cbiAgICByZXR1cm4gb3RoZXJJc0xhdGVyID8gZGlmZmVkLm5lZ2F0ZSgpIDogZGlmZmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoaXMgRGF0ZVRpbWUgYW5kIHJpZ2h0IG5vdy5cbiAgICogU2VlIHtAbGluayBEYXRlVGltZSNkaWZmfVxuICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gW3VuaXQ9WydtaWxsaXNlY29uZHMnXV0gLSB0aGUgdW5pdCBvciB1bml0cyB1bml0cyAoc3VjaCBhcyAnaG91cnMnIG9yICdkYXlzJykgdG8gaW5jbHVkZSBpbiB0aGUgZHVyYXRpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIHRoYXQgYWZmZWN0IHRoZSBjcmVhdGlvbiBvZiB0aGUgRHVyYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmNvbnZlcnNpb25BY2N1cmFjeT0nY2FzdWFsJ10gLSB0aGUgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgZGlmZk5vdyh1bml0ID0gXCJtaWxsaXNlY29uZHNcIiwgb3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZGlmZihEYXRlVGltZS5ub3coKSwgdW5pdCwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIEludGVydmFsIHNwYW5uaW5nIGJldHdlZW4gdGhpcyBEYXRlVGltZSBhbmQgYW5vdGhlciBEYXRlVGltZVxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSBvdGhlckRhdGVUaW1lIC0gdGhlIG90aGVyIGVuZCBwb2ludCBvZiB0aGUgSW50ZXJ2YWxcbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqL1xuICB1bnRpbChvdGhlckRhdGVUaW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IEludGVydmFsLmZyb21EYXRlVGltZXModGhpcywgb3RoZXJEYXRlVGltZSkgOiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgRGF0ZVRpbWUgaXMgaW4gdGhlIHNhbWUgdW5pdCBvZiB0aW1lIGFzIGFub3RoZXIgRGF0ZVRpbWUuXG4gICAqIEhpZ2hlci1vcmRlciB1bml0cyBtdXN0IGFsc28gYmUgaWRlbnRpY2FsIGZvciB0aGlzIGZ1bmN0aW9uIHRvIHJldHVybiBgdHJ1ZWAuXG4gICAqIE5vdGUgdGhhdCB0aW1lIHpvbmVzIGFyZSAqKmlnbm9yZWQqKiBpbiB0aGlzIGNvbXBhcmlzb24sIHdoaWNoIGNvbXBhcmVzIHRoZSAqKmxvY2FsKiogY2FsZW5kYXIgdGltZS4gVXNlIHtAbGluayBEYXRlVGltZSNzZXRab25lfSB0byBjb252ZXJ0IG9uZSBvZiB0aGUgZGF0ZXMgaWYgbmVlZGVkLlxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSBvdGhlckRhdGVUaW1lIC0gdGhlIG90aGVyIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1bml0IC0gdGhlIHVuaXQgb2YgdGltZSB0byBjaGVjayBzYW1lbmVzcyBvblxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5oYXNTYW1lKG90aGVyRFQsICdkYXknKTsgLy9+PiB0cnVlIGlmIG90aGVyRFQgaXMgaW4gdGhlIHNhbWUgY3VycmVudCBjYWxlbmRhciBkYXlcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc1NhbWUob3RoZXJEYXRlVGltZSwgdW5pdCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gZmFsc2U7XG5cbiAgICBjb25zdCBpbnB1dE1zID0gb3RoZXJEYXRlVGltZS52YWx1ZU9mKCk7XG4gICAgY29uc3QgYWRqdXN0ZWRUb1pvbmUgPSB0aGlzLnNldFpvbmUob3RoZXJEYXRlVGltZS56b25lLCB7IGtlZXBMb2NhbFRpbWU6IHRydWUgfSk7XG4gICAgcmV0dXJuIGFkanVzdGVkVG9ab25lLnN0YXJ0T2YodW5pdCkgPD0gaW5wdXRNcyAmJiBpbnB1dE1zIDw9IGFkanVzdGVkVG9ab25lLmVuZE9mKHVuaXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVxdWFsaXR5IGNoZWNrXG4gICAqIFR3byBEYXRlVGltZXMgYXJlIGVxdWFsIGlmIGFuZCBvbmx5IGlmIHRoZXkgcmVwcmVzZW50IHRoZSBzYW1lIG1pbGxpc2Vjb25kLCBoYXZlIHRoZSBzYW1lIHpvbmUgYW5kIGxvY2F0aW9uLCBhbmQgYXJlIGJvdGggdmFsaWQuXG4gICAqIFRvIGNvbXBhcmUganVzdCB0aGUgbWlsbGlzZWNvbmQgdmFsdWVzLCB1c2UgYCtkdDEgPT09ICtkdDJgLlxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSBvdGhlciAtIHRoZSBvdGhlciBEYXRlVGltZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMuaXNWYWxpZCAmJlxuICAgICAgb3RoZXIuaXNWYWxpZCAmJlxuICAgICAgdGhpcy52YWx1ZU9mKCkgPT09IG90aGVyLnZhbHVlT2YoKSAmJlxuICAgICAgdGhpcy56b25lLmVxdWFscyhvdGhlci56b25lKSAmJlxuICAgICAgdGhpcy5sb2MuZXF1YWxzKG90aGVyLmxvYylcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB0aGlzIHRpbWUgcmVsYXRpdmUgdG8gbm93LCBzdWNoIGFzIFwiaW4gdHdvIGRheXNcIi4gQ2FuIG9ubHkgaW50ZXJuYXRpb25hbGl6ZSBpZiB5b3VyXG4gICAqIHBsYXRmb3JtIHN1cHBvcnRzIEludGwuUmVsYXRpdmVUaW1lRm9ybWF0LiBSb3VuZHMgZG93biBieSBkZWZhdWx0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgdGhhdCBhZmZlY3QgdGhlIG91dHB1dFxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSBbb3B0aW9ucy5iYXNlPURhdGVUaW1lLm5vdygpXSAtIHRoZSBEYXRlVGltZSB0byB1c2UgYXMgdGhlIGJhc2lzIHRvIHdoaWNoIHRoaXMgdGltZSBpcyBjb21wYXJlZC4gRGVmYXVsdHMgdG8gbm93LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc3R5bGU9XCJsb25nXCJdIC0gdGhlIHN0eWxlIG9mIHVuaXRzLCBtdXN0IGJlIFwibG9uZ1wiLCBcInNob3J0XCIsIG9yIFwibmFycm93XCJcbiAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IG9wdGlvbnMudW5pdCAtIHVzZSBhIHNwZWNpZmljIHVuaXQgb3IgYXJyYXkgb2YgdW5pdHM7IGlmIG9taXR0ZWQsIG9yIGFuIGFycmF5LCB0aGUgbWV0aG9kIHdpbGwgcGljayB0aGUgYmVzdCB1bml0LiBVc2UgYW4gYXJyYXkgb3Igb25lIG9mIFwieWVhcnNcIiwgXCJxdWFydGVyc1wiLCBcIm1vbnRoc1wiLCBcIndlZWtzXCIsIFwiZGF5c1wiLCBcImhvdXJzXCIsIFwibWludXRlc1wiLCBvciBcInNlY29uZHNcIlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJvdW5kPXRydWVdIC0gd2hldGhlciB0byByb3VuZCB0aGUgbnVtYmVycyBpbiB0aGUgb3V0cHV0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucGFkZGluZz0wXSAtIHBhZGRpbmcgaW4gbWlsbGlzZWNvbmRzLiBUaGlzIGFsbG93cyB5b3UgdG8gcm91bmQgdXAgdGhlIHJlc3VsdCBpZiBpdCBmaXRzIGluc2lkZSB0aGUgdGhyZXNob2xkLiBEb24ndCB1c2UgaW4gY29tYmluYXRpb24gd2l0aCB7cm91bmQ6IGZhbHNlfSBiZWNhdXNlIHRoZSBkZWNpbWFsIG91dHB1dCB3aWxsIGluY2x1ZGUgdGhlIHBhZGRpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmxvY2FsZSAtIG92ZXJyaWRlIHRoZSBsb2NhbGUgb2YgdGhpcyBEYXRlVGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5udW1iZXJpbmdTeXN0ZW0gLSBvdmVycmlkZSB0aGUgbnVtYmVyaW5nU3lzdGVtIG9mIHRoaXMgRGF0ZVRpbWUuIFRoZSBJbnRsIHN5c3RlbSBtYXkgY2hvb3NlIG5vdCB0byBob25vciB0aGlzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoeyBkYXlzOiAxIH0pLnRvUmVsYXRpdmUoKSAvLz0+IFwiaW4gMSBkYXlcIlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5zZXRMb2NhbGUoXCJlc1wiKS50b1JlbGF0aXZlKHsgZGF5czogMSB9KSAvLz0+IFwiZGVudHJvIGRlIDEgZMOtYVwiXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoeyBkYXlzOiAxIH0pLnRvUmVsYXRpdmUoeyBsb2NhbGU6IFwiZnJcIiB9KSAvLz0+IFwiZGFucyAyMyBoZXVyZXNcIlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5taW51cyh7IGRheXM6IDIgfSkudG9SZWxhdGl2ZSgpIC8vPT4gXCIyIGRheXMgYWdvXCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkubWludXMoeyBkYXlzOiAyIH0pLnRvUmVsYXRpdmUoeyB1bml0OiBcImhvdXJzXCIgfSkgLy89PiBcIjQ4IGhvdXJzIGFnb1wiXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLm1pbnVzKHsgaG91cnM6IDM2IH0pLnRvUmVsYXRpdmUoeyByb3VuZDogZmFsc2UgfSkgLy89PiBcIjEuNSBkYXlzIGFnb1wiXG4gICAqL1xuICB0b1JlbGF0aXZlKG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBiYXNlID0gb3B0aW9ucy5iYXNlIHx8IERhdGVUaW1lLmZyb21PYmplY3Qoe30sIHsgem9uZTogdGhpcy56b25lIH0pLFxuICAgICAgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZyA/ICh0aGlzIDwgYmFzZSA/IC1vcHRpb25zLnBhZGRpbmcgOiBvcHRpb25zLnBhZGRpbmcpIDogMDtcbiAgICBsZXQgdW5pdHMgPSBbXCJ5ZWFyc1wiLCBcIm1vbnRoc1wiLCBcImRheXNcIiwgXCJob3Vyc1wiLCBcIm1pbnV0ZXNcIiwgXCJzZWNvbmRzXCJdO1xuICAgIGxldCB1bml0ID0gb3B0aW9ucy51bml0O1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMudW5pdCkpIHtcbiAgICAgIHVuaXRzID0gb3B0aW9ucy51bml0O1xuICAgICAgdW5pdCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGRpZmZSZWxhdGl2ZShiYXNlLCB0aGlzLnBsdXMocGFkZGluZyksIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBudW1lcmljOiBcImFsd2F5c1wiLFxuICAgICAgdW5pdHMsXG4gICAgICB1bml0LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBkYXRlIHJlbGF0aXZlIHRvIHRvZGF5LCBzdWNoIGFzIFwieWVzdGVyZGF5XCIgb3IgXCJuZXh0IG1vbnRoXCIuXG4gICAqIE9ubHkgaW50ZXJuYXRpb25hbGl6ZXMgb24gcGxhdGZvcm1zIHRoYXQgc3VwcG9ydHMgSW50bC5SZWxhdGl2ZVRpbWVGb3JtYXQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyB0aGF0IGFmZmVjdCB0aGUgb3V0cHV0XG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IFtvcHRpb25zLmJhc2U9RGF0ZVRpbWUubm93KCldIC0gdGhlIERhdGVUaW1lIHRvIHVzZSBhcyB0aGUgYmFzaXMgdG8gd2hpY2ggdGhpcyB0aW1lIGlzIGNvbXBhcmVkLiBEZWZhdWx0cyB0byBub3cuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmxvY2FsZSAtIG92ZXJyaWRlIHRoZSBsb2NhbGUgb2YgdGhpcyBEYXRlVGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy51bml0IC0gdXNlIGEgc3BlY2lmaWMgdW5pdDsgaWYgb21pdHRlZCwgdGhlIG1ldGhvZCB3aWxsIHBpY2sgdGhlIHVuaXQuIFVzZSBvbmUgb2YgXCJ5ZWFyc1wiLCBcInF1YXJ0ZXJzXCIsIFwibW9udGhzXCIsIFwid2Vla3NcIiwgb3IgXCJkYXlzXCJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubnVtYmVyaW5nU3lzdGVtIC0gb3ZlcnJpZGUgdGhlIG51bWJlcmluZ1N5c3RlbSBvZiB0aGlzIERhdGVUaW1lLiBUaGUgSW50bCBzeXN0ZW0gbWF5IGNob29zZSBub3QgdG8gaG9ub3IgdGhpc1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKHsgZGF5czogMSB9KS50b1JlbGF0aXZlQ2FsZW5kYXIoKSAvLz0+IFwidG9tb3Jyb3dcIlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5zZXRMb2NhbGUoXCJlc1wiKS5wbHVzKHsgZGF5czogMSB9KS50b1JlbGF0aXZlKCkgLy89PiBcIlwibWHDsWFuYVwiXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoeyBkYXlzOiAxIH0pLnRvUmVsYXRpdmVDYWxlbmRhcih7IGxvY2FsZTogXCJmclwiIH0pIC8vPT4gXCJkZW1haW5cIlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5taW51cyh7IGRheXM6IDIgfSkudG9SZWxhdGl2ZUNhbGVuZGFyKCkgLy89PiBcIjIgZGF5cyBhZ29cIlxuICAgKi9cbiAgdG9SZWxhdGl2ZUNhbGVuZGFyKG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gbnVsbDtcblxuICAgIHJldHVybiBkaWZmUmVsYXRpdmUob3B0aW9ucy5iYXNlIHx8IERhdGVUaW1lLmZyb21PYmplY3Qoe30sIHsgem9uZTogdGhpcy56b25lIH0pLCB0aGlzLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgbnVtZXJpYzogXCJhdXRvXCIsXG4gICAgICB1bml0czogW1wieWVhcnNcIiwgXCJtb250aHNcIiwgXCJkYXlzXCJdLFxuICAgICAgY2FsZW5kYXJ5OiB0cnVlLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbWluIG9mIHNldmVyYWwgZGF0ZSB0aW1lc1xuICAgKiBAcGFyYW0gey4uLkRhdGVUaW1lfSBkYXRlVGltZXMgLSB0aGUgRGF0ZVRpbWVzIGZyb20gd2hpY2ggdG8gY2hvb3NlIHRoZSBtaW5pbXVtXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfSB0aGUgbWluIERhdGVUaW1lLCBvciB1bmRlZmluZWQgaWYgY2FsbGVkIHdpdGggbm8gYXJndW1lbnRcbiAgICovXG4gIHN0YXRpYyBtaW4oLi4uZGF0ZVRpbWVzKSB7XG4gICAgaWYgKCFkYXRlVGltZXMuZXZlcnkoRGF0ZVRpbWUuaXNEYXRlVGltZSkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcIm1pbiByZXF1aXJlcyBhbGwgYXJndW1lbnRzIGJlIERhdGVUaW1lc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIGJlc3RCeShkYXRlVGltZXMsIChpKSA9PiBpLnZhbHVlT2YoKSwgTWF0aC5taW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbWF4IG9mIHNldmVyYWwgZGF0ZSB0aW1lc1xuICAgKiBAcGFyYW0gey4uLkRhdGVUaW1lfSBkYXRlVGltZXMgLSB0aGUgRGF0ZVRpbWVzIGZyb20gd2hpY2ggdG8gY2hvb3NlIHRoZSBtYXhpbXVtXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfSB0aGUgbWF4IERhdGVUaW1lLCBvciB1bmRlZmluZWQgaWYgY2FsbGVkIHdpdGggbm8gYXJndW1lbnRcbiAgICovXG4gIHN0YXRpYyBtYXgoLi4uZGF0ZVRpbWVzKSB7XG4gICAgaWYgKCFkYXRlVGltZXMuZXZlcnkoRGF0ZVRpbWUuaXNEYXRlVGltZSkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcIm1heCByZXF1aXJlcyBhbGwgYXJndW1lbnRzIGJlIERhdGVUaW1lc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIGJlc3RCeShkYXRlVGltZXMsIChpKSA9PiBpLnZhbHVlT2YoKSwgTWF0aC5tYXgpO1xuICB9XG5cbiAgLy8gTUlTQ1xuXG4gIC8qKlxuICAgKiBFeHBsYWluIGhvdyBhIHN0cmluZyB3b3VsZCBiZSBwYXJzZWQgYnkgZnJvbUZvcm1hdCgpXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGhlIHN0cmluZyB0byBwYXJzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZm10IC0gdGhlIGZvcm1hdCB0aGUgc3RyaW5nIGlzIGV4cGVjdGVkIHRvIGJlIGluIChzZWUgZGVzY3JpcHRpb24pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyB0YWtlbiBieSBmcm9tRm9ybWF0KClcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGZyb21Gb3JtYXRFeHBsYWluKHRleHQsIGZtdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBsb2NhbGUgPSBudWxsLCBudW1iZXJpbmdTeXN0ZW0gPSBudWxsIH0gPSBvcHRpb25zLFxuICAgICAgbG9jYWxlVG9Vc2UgPSBMb2NhbGUuZnJvbU9wdHMoe1xuICAgICAgICBsb2NhbGUsXG4gICAgICAgIG51bWJlcmluZ1N5c3RlbSxcbiAgICAgICAgZGVmYXVsdFRvRU46IHRydWUsXG4gICAgICB9KTtcbiAgICByZXR1cm4gZXhwbGFpbkZyb21Ub2tlbnMobG9jYWxlVG9Vc2UsIHRleHQsIGZtdCk7XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGZyb21Gb3JtYXRFeHBsYWluIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBmcm9tU3RyaW5nRXhwbGFpbih0ZXh0LCBmbXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBEYXRlVGltZS5mcm9tRm9ybWF0RXhwbGFpbih0ZXh0LCBmbXQsIG9wdGlvbnMpO1xuICB9XG5cbiAgLy8gRk9STUFUIFBSRVNFVFNcblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAxMC8xNC8xOTgzXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVfU0hPUlQoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURV9TSE9SVDtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdPY3QgMTQsIDE5ODMnXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVfTUVEKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVfTUVEO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ0ZyaSwgT2N0IDE0LCAxOTgzJ1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFX01FRF9XSVRIX1dFRUtEQVkoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURV9NRURfV0lUSF9XRUVLREFZO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ09jdG9iZXIgMTQsIDE5ODMnXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVfRlVMTCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFX0ZVTEw7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnVHVlc2RheSwgT2N0b2JlciAxNCwgMTk4MydcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURV9IVUdFKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVfSFVHRTtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcwOTozMCBBTScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBUSU1FX1NJTVBMRSgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5USU1FX1NJTVBMRTtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcwOTozMDoyMyBBTScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBUSU1FX1dJVEhfU0VDT05EUygpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5USU1FX1dJVEhfU0VDT05EUztcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcwOTozMDoyMyBBTSBFRFQnLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgVElNRV9XSVRIX1NIT1JUX09GRlNFVCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5USU1FX1dJVEhfU0hPUlRfT0ZGU0VUO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwOjIzIEFNIEVhc3Rlcm4gRGF5bGlnaHQgVGltZScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBUSU1FX1dJVEhfTE9OR19PRkZTRVQoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuVElNRV9XSVRIX0xPTkdfT0ZGU0VUO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwJywgYWx3YXlzIDI0LWhvdXIuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IFRJTUVfMjRfU0lNUExFKCkge1xuICAgIHJldHVybiBGb3JtYXRzLlRJTUVfMjRfU0lNUExFO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwOjIzJywgYWx3YXlzIDI0LWhvdXIuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IFRJTUVfMjRfV0lUSF9TRUNPTkRTKCkge1xuICAgIHJldHVybiBGb3JtYXRzLlRJTUVfMjRfV0lUSF9TRUNPTkRTO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwOjIzIEVEVCcsIGFsd2F5cyAyNC1ob3VyLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBUSU1FXzI0X1dJVEhfU0hPUlRfT0ZGU0VUKCkge1xuICAgIHJldHVybiBGb3JtYXRzLlRJTUVfMjRfV0lUSF9TSE9SVF9PRkZTRVQ7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMDk6MzA6MjMgRWFzdGVybiBEYXlsaWdodCBUaW1lJywgYWx3YXlzIDI0LWhvdXIuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IFRJTUVfMjRfV0lUSF9MT05HX09GRlNFVCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5USU1FXzI0X1dJVEhfTE9OR19PRkZTRVQ7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMTAvMTQvMTk4MywgOTozMCBBTScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFVElNRV9TSE9SVCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFVElNRV9TSE9SVDtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcxMC8xNC8xOTgzLCA5OjMwOjMzIEFNJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVUSU1FX1NIT1JUX1dJVEhfU0VDT05EUygpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFVElNRV9TSE9SVF9XSVRIX1NFQ09ORFM7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnT2N0IDE0LCAxOTgzLCA5OjMwIEFNJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVUSU1FX01FRCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFVElNRV9NRUQ7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnT2N0IDE0LCAxOTgzLCA5OjMwOjMzIEFNJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVUSU1FX01FRF9XSVRIX1NFQ09ORFMoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURVRJTUVfTUVEX1dJVEhfU0VDT05EUztcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdGcmksIDE0IE9jdCAxOTgzLCA5OjMwIEFNJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVUSU1FX01FRF9XSVRIX1dFRUtEQVkoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURVRJTUVfTUVEX1dJVEhfV0VFS0RBWTtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdPY3RvYmVyIDE0LCAxOTgzLCA5OjMwIEFNIEVEVCcuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFVElNRV9GVUxMKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVUSU1FX0ZVTEw7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnT2N0b2JlciAxNCwgMTk4MywgOTozMDozMyBBTSBFRFQnLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURVRJTUVfRlVMTF9XSVRIX1NFQ09ORFMoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURVRJTUVfRlVMTF9XSVRIX1NFQ09ORFM7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnRnJpZGF5LCBPY3RvYmVyIDE0LCAxOTgzLCA5OjMwIEFNIEVhc3Rlcm4gRGF5bGlnaHQgVGltZScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFVElNRV9IVUdFKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVUSU1FX0hVR0U7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnRnJpZGF5LCBPY3RvYmVyIDE0LCAxOTgzLCA5OjMwOjMzIEFNIEVhc3Rlcm4gRGF5bGlnaHQgVGltZScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFVElNRV9IVUdFX1dJVEhfU0VDT05EUygpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFVElNRV9IVUdFX1dJVEhfU0VDT05EUztcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcmllbmRseURhdGVUaW1lKGRhdGVUaW1laXNoKSB7XG4gIGlmIChEYXRlVGltZS5pc0RhdGVUaW1lKGRhdGVUaW1laXNoKSkge1xuICAgIHJldHVybiBkYXRlVGltZWlzaDtcbiAgfSBlbHNlIGlmIChkYXRlVGltZWlzaCAmJiBkYXRlVGltZWlzaC52YWx1ZU9mICYmIGlzTnVtYmVyKGRhdGVUaW1laXNoLnZhbHVlT2YoKSkpIHtcbiAgICByZXR1cm4gRGF0ZVRpbWUuZnJvbUpTRGF0ZShkYXRlVGltZWlzaCk7XG4gIH0gZWxzZSBpZiAoZGF0ZVRpbWVpc2ggJiYgdHlwZW9mIGRhdGVUaW1laXNoID09PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIERhdGVUaW1lLmZyb21PYmplY3QoZGF0ZVRpbWVpc2gpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcbiAgICAgIGBVbmtub3duIGRhdGV0aW1lIGFyZ3VtZW50OiAke2RhdGVUaW1laXNofSwgb2YgdHlwZSAke3R5cGVvZiBkYXRlVGltZWlzaH1gXG4gICAgKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IsIEludmFsaWREdXJhdGlvbkVycm9yLCBJbnZhbGlkVW5pdEVycm9yIH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgRm9ybWF0dGVyIGZyb20gXCIuL2ltcGwvZm9ybWF0dGVyLmpzXCI7XG5pbXBvcnQgSW52YWxpZCBmcm9tIFwiLi9pbXBsL2ludmFsaWQuanNcIjtcbmltcG9ydCBMb2NhbGUgZnJvbSBcIi4vaW1wbC9sb2NhbGUuanNcIjtcbmltcG9ydCB7IHBhcnNlSVNPRHVyYXRpb24sIHBhcnNlSVNPVGltZU9ubHkgfSBmcm9tIFwiLi9pbXBsL3JlZ2V4UGFyc2VyLmpzXCI7XG5pbXBvcnQge1xuICBhc051bWJlcixcbiAgaGFzT3duUHJvcGVydHksXG4gIGlzTnVtYmVyLFxuICBpc1VuZGVmaW5lZCxcbiAgbm9ybWFsaXplT2JqZWN0LFxuICByb3VuZFRvLFxufSBmcm9tIFwiLi9pbXBsL3V0aWwuanNcIjtcbmltcG9ydCBTZXR0aW5ncyBmcm9tIFwiLi9zZXR0aW5ncy5qc1wiO1xuaW1wb3J0IERhdGVUaW1lIGZyb20gXCIuL2RhdGV0aW1lLmpzXCI7XG5cbmNvbnN0IElOVkFMSUQgPSBcIkludmFsaWQgRHVyYXRpb25cIjtcblxuLy8gdW5pdCBjb252ZXJzaW9uIGNvbnN0YW50c1xuZXhwb3J0IGNvbnN0IGxvd09yZGVyTWF0cml4ID0ge1xuICAgIHdlZWtzOiB7XG4gICAgICBkYXlzOiA3LFxuICAgICAgaG91cnM6IDcgKiAyNCxcbiAgICAgIG1pbnV0ZXM6IDcgKiAyNCAqIDYwLFxuICAgICAgc2Vjb25kczogNyAqIDI0ICogNjAgKiA2MCxcbiAgICAgIG1pbGxpc2Vjb25kczogNyAqIDI0ICogNjAgKiA2MCAqIDEwMDAsXG4gICAgfSxcbiAgICBkYXlzOiB7XG4gICAgICBob3VyczogMjQsXG4gICAgICBtaW51dGVzOiAyNCAqIDYwLFxuICAgICAgc2Vjb25kczogMjQgKiA2MCAqIDYwLFxuICAgICAgbWlsbGlzZWNvbmRzOiAyNCAqIDYwICogNjAgKiAxMDAwLFxuICAgIH0sXG4gICAgaG91cnM6IHsgbWludXRlczogNjAsIHNlY29uZHM6IDYwICogNjAsIG1pbGxpc2Vjb25kczogNjAgKiA2MCAqIDEwMDAgfSxcbiAgICBtaW51dGVzOiB7IHNlY29uZHM6IDYwLCBtaWxsaXNlY29uZHM6IDYwICogMTAwMCB9LFxuICAgIHNlY29uZHM6IHsgbWlsbGlzZWNvbmRzOiAxMDAwIH0sXG4gIH0sXG4gIGNhc3VhbE1hdHJpeCA9IHtcbiAgICB5ZWFyczoge1xuICAgICAgcXVhcnRlcnM6IDQsXG4gICAgICBtb250aHM6IDEyLFxuICAgICAgd2Vla3M6IDUyLFxuICAgICAgZGF5czogMzY1LFxuICAgICAgaG91cnM6IDM2NSAqIDI0LFxuICAgICAgbWludXRlczogMzY1ICogMjQgKiA2MCxcbiAgICAgIHNlY29uZHM6IDM2NSAqIDI0ICogNjAgKiA2MCxcbiAgICAgIG1pbGxpc2Vjb25kczogMzY1ICogMjQgKiA2MCAqIDYwICogMTAwMCxcbiAgICB9LFxuICAgIHF1YXJ0ZXJzOiB7XG4gICAgICBtb250aHM6IDMsXG4gICAgICB3ZWVrczogMTMsXG4gICAgICBkYXlzOiA5MSxcbiAgICAgIGhvdXJzOiA5MSAqIDI0LFxuICAgICAgbWludXRlczogOTEgKiAyNCAqIDYwLFxuICAgICAgc2Vjb25kczogOTEgKiAyNCAqIDYwICogNjAsXG4gICAgICBtaWxsaXNlY29uZHM6IDkxICogMjQgKiA2MCAqIDYwICogMTAwMCxcbiAgICB9LFxuICAgIG1vbnRoczoge1xuICAgICAgd2Vla3M6IDQsXG4gICAgICBkYXlzOiAzMCxcbiAgICAgIGhvdXJzOiAzMCAqIDI0LFxuICAgICAgbWludXRlczogMzAgKiAyNCAqIDYwLFxuICAgICAgc2Vjb25kczogMzAgKiAyNCAqIDYwICogNjAsXG4gICAgICBtaWxsaXNlY29uZHM6IDMwICogMjQgKiA2MCAqIDYwICogMTAwMCxcbiAgICB9LFxuXG4gICAgLi4ubG93T3JkZXJNYXRyaXgsXG4gIH0sXG4gIGRheXNJblllYXJBY2N1cmF0ZSA9IDE0NjA5Ny4wIC8gNDAwLFxuICBkYXlzSW5Nb250aEFjY3VyYXRlID0gMTQ2MDk3LjAgLyA0ODAwLFxuICBhY2N1cmF0ZU1hdHJpeCA9IHtcbiAgICB5ZWFyczoge1xuICAgICAgcXVhcnRlcnM6IDQsXG4gICAgICBtb250aHM6IDEyLFxuICAgICAgd2Vla3M6IGRheXNJblllYXJBY2N1cmF0ZSAvIDcsXG4gICAgICBkYXlzOiBkYXlzSW5ZZWFyQWNjdXJhdGUsXG4gICAgICBob3VyczogZGF5c0luWWVhckFjY3VyYXRlICogMjQsXG4gICAgICBtaW51dGVzOiBkYXlzSW5ZZWFyQWNjdXJhdGUgKiAyNCAqIDYwLFxuICAgICAgc2Vjb25kczogZGF5c0luWWVhckFjY3VyYXRlICogMjQgKiA2MCAqIDYwLFxuICAgICAgbWlsbGlzZWNvbmRzOiBkYXlzSW5ZZWFyQWNjdXJhdGUgKiAyNCAqIDYwICogNjAgKiAxMDAwLFxuICAgIH0sXG4gICAgcXVhcnRlcnM6IHtcbiAgICAgIG1vbnRoczogMyxcbiAgICAgIHdlZWtzOiBkYXlzSW5ZZWFyQWNjdXJhdGUgLyAyOCxcbiAgICAgIGRheXM6IGRheXNJblllYXJBY2N1cmF0ZSAvIDQsXG4gICAgICBob3VyczogKGRheXNJblllYXJBY2N1cmF0ZSAqIDI0KSAvIDQsXG4gICAgICBtaW51dGVzOiAoZGF5c0luWWVhckFjY3VyYXRlICogMjQgKiA2MCkgLyA0LFxuICAgICAgc2Vjb25kczogKGRheXNJblllYXJBY2N1cmF0ZSAqIDI0ICogNjAgKiA2MCkgLyA0LFxuICAgICAgbWlsbGlzZWNvbmRzOiAoZGF5c0luWWVhckFjY3VyYXRlICogMjQgKiA2MCAqIDYwICogMTAwMCkgLyA0LFxuICAgIH0sXG4gICAgbW9udGhzOiB7XG4gICAgICB3ZWVrczogZGF5c0luTW9udGhBY2N1cmF0ZSAvIDcsXG4gICAgICBkYXlzOiBkYXlzSW5Nb250aEFjY3VyYXRlLFxuICAgICAgaG91cnM6IGRheXNJbk1vbnRoQWNjdXJhdGUgKiAyNCxcbiAgICAgIG1pbnV0ZXM6IGRheXNJbk1vbnRoQWNjdXJhdGUgKiAyNCAqIDYwLFxuICAgICAgc2Vjb25kczogZGF5c0luTW9udGhBY2N1cmF0ZSAqIDI0ICogNjAgKiA2MCxcbiAgICAgIG1pbGxpc2Vjb25kczogZGF5c0luTW9udGhBY2N1cmF0ZSAqIDI0ICogNjAgKiA2MCAqIDEwMDAsXG4gICAgfSxcbiAgICAuLi5sb3dPcmRlck1hdHJpeCxcbiAgfTtcblxuLy8gdW5pdHMgb3JkZXJlZCBieSBzaXplXG5jb25zdCBvcmRlcmVkVW5pdHMgPSBbXG4gIFwieWVhcnNcIixcbiAgXCJxdWFydGVyc1wiLFxuICBcIm1vbnRoc1wiLFxuICBcIndlZWtzXCIsXG4gIFwiZGF5c1wiLFxuICBcImhvdXJzXCIsXG4gIFwibWludXRlc1wiLFxuICBcInNlY29uZHNcIixcbiAgXCJtaWxsaXNlY29uZHNcIixcbl07XG5cbmNvbnN0IHJldmVyc2VVbml0cyA9IG9yZGVyZWRVbml0cy5zbGljZSgwKS5yZXZlcnNlKCk7XG5cbi8vIGNsb25lIHJlYWxseSBtZWFucyBcImNyZWF0ZSBhbm90aGVyIGluc3RhbmNlIGp1c3QgbGlrZSB0aGlzIG9uZSwgYnV0IHdpdGggdGhlc2UgY2hhbmdlc1wiXG5mdW5jdGlvbiBjbG9uZShkdXIsIGFsdHMsIGNsZWFyID0gZmFsc2UpIHtcbiAgLy8gZGVlcCBtZXJnZSBmb3IgdmFsc1xuICBjb25zdCBjb25mID0ge1xuICAgIHZhbHVlczogY2xlYXIgPyBhbHRzLnZhbHVlcyA6IHsgLi4uZHVyLnZhbHVlcywgLi4uKGFsdHMudmFsdWVzIHx8IHt9KSB9LFxuICAgIGxvYzogZHVyLmxvYy5jbG9uZShhbHRzLmxvYyksXG4gICAgY29udmVyc2lvbkFjY3VyYWN5OiBhbHRzLmNvbnZlcnNpb25BY2N1cmFjeSB8fCBkdXIuY29udmVyc2lvbkFjY3VyYWN5LFxuICAgIG1hdHJpeDogYWx0cy5tYXRyaXggfHwgZHVyLm1hdHJpeCxcbiAgfTtcbiAgcmV0dXJuIG5ldyBEdXJhdGlvbihjb25mKTtcbn1cblxuZnVuY3Rpb24gZHVyYXRpb25Ub01pbGxpcyhtYXRyaXgsIHZhbHMpIHtcbiAgbGV0IHN1bSA9IHZhbHMubWlsbGlzZWNvbmRzID8/IDA7XG4gIGZvciAoY29uc3QgdW5pdCBvZiByZXZlcnNlVW5pdHMuc2xpY2UoMSkpIHtcbiAgICBpZiAodmFsc1t1bml0XSkge1xuICAgICAgc3VtICs9IHZhbHNbdW5pdF0gKiBtYXRyaXhbdW5pdF1bXCJtaWxsaXNlY29uZHNcIl07XG4gICAgfVxuICB9XG4gIHJldHVybiBzdW07XG59XG5cbi8vIE5COiBtdXRhdGVzIHBhcmFtZXRlcnNcbmZ1bmN0aW9uIG5vcm1hbGl6ZVZhbHVlcyhtYXRyaXgsIHZhbHMpIHtcbiAgLy8gdGhlIGxvZ2ljIGJlbG93IGFzc3VtZXMgdGhlIG92ZXJhbGwgdmFsdWUgb2YgdGhlIGR1cmF0aW9uIGlzIHBvc2l0aXZlXG4gIC8vIGlmIHRoaXMgaXMgbm90IHRoZSBjYXNlLCBmYWN0b3IgaXMgdXNlZCB0byBtYWtlIGl0IHNvXG4gIGNvbnN0IGZhY3RvciA9IGR1cmF0aW9uVG9NaWxsaXMobWF0cml4LCB2YWxzKSA8IDAgPyAtMSA6IDE7XG5cbiAgb3JkZXJlZFVuaXRzLnJlZHVjZVJpZ2h0KChwcmV2aW91cywgY3VycmVudCkgPT4ge1xuICAgIGlmICghaXNVbmRlZmluZWQodmFsc1tjdXJyZW50XSkpIHtcbiAgICAgIGlmIChwcmV2aW91cykge1xuICAgICAgICBjb25zdCBwcmV2aW91c1ZhbCA9IHZhbHNbcHJldmlvdXNdICogZmFjdG9yO1xuICAgICAgICBjb25zdCBjb252ID0gbWF0cml4W2N1cnJlbnRdW3ByZXZpb3VzXTtcblxuICAgICAgICAvLyBpZiAocHJldmlvdXNWYWwgPCAwKTpcbiAgICAgICAgLy8gbG93ZXIgb3JkZXIgdW5pdCBpcyBuZWdhdGl2ZSAoZS5nLiB7IHllYXJzOiAyLCBkYXlzOiAtMiB9KVxuICAgICAgICAvLyBub3JtYWxpemUgdGhpcyBieSByZWR1Y2luZyB0aGUgaGlnaGVyIG9yZGVyIHVuaXQgYnkgdGhlIGFwcHJvcHJpYXRlIGFtb3VudFxuICAgICAgICAvLyBhbmQgaW5jcmVhc2luZyB0aGUgbG93ZXIgb3JkZXIgdW5pdFxuICAgICAgICAvLyB0aGlzIGNhbiBuZXZlciBtYWtlIHRoZSBoaWdoZXIgb3JkZXIgdW5pdCBuZWdhdGl2ZSwgYmVjYXVzZSB0aGlzIGZ1bmN0aW9uIG9ubHkgb3BlcmF0ZXNcbiAgICAgICAgLy8gb24gcG9zaXRpdmUgZHVyYXRpb25zLCBzbyB0aGUgYW1vdW50IG9mIHRpbWUgcmVwcmVzZW50ZWQgYnkgdGhlIGxvd2VyIG9yZGVyIHVuaXQgY2Fubm90XG4gICAgICAgIC8vIGJlIGxhcmdlciB0aGFuIHRoZSBoaWdoZXIgb3JkZXIgdW5pdFxuICAgICAgICAvLyBlbHNlOlxuICAgICAgICAvLyBsb3dlciBvcmRlciB1bml0IGlzIHBvc2l0aXZlIChlLmcuIHsgeWVhcnM6IDIsIGRheXM6IDQ1MCB9IG9yIHsgeWVhcnM6IC0yLCBkYXlzOiA0NTAgfSlcbiAgICAgICAgLy8gaW4gdGhpcyBjYXNlIHdlIGF0dGVtcHQgdG8gY29udmVydCBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gdGhlIGxvd2VyIG9yZGVyIHVuaXQgaW50b1xuICAgICAgICAvLyB0aGUgaGlnaGVyIG9yZGVyIG9uZVxuICAgICAgICAvL1xuICAgICAgICAvLyBNYXRoLmZsb29yIHRha2VzIGNhcmUgb2YgYm90aCBvZiB0aGVzZSBjYXNlcywgcm91bmRpbmcgYXdheSBmcm9tIDBcbiAgICAgICAgLy8gaWYgcHJldmlvdXNWYWwgPCAwIGl0IG1ha2VzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBsYXJnZXJcbiAgICAgICAgLy8gaWYgcHJldmlvdXNWYWwgPj0gaXQgbWFrZXMgdGhlIGFic29sdXRlIHZhbHVlIHNtYWxsZXJcbiAgICAgICAgY29uc3Qgcm9sbFVwID0gTWF0aC5mbG9vcihwcmV2aW91c1ZhbCAvIGNvbnYpO1xuICAgICAgICB2YWxzW2N1cnJlbnRdICs9IHJvbGxVcCAqIGZhY3RvcjtcbiAgICAgICAgdmFsc1twcmV2aW91c10gLT0gcm9sbFVwICogY29udiAqIGZhY3RvcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcHJldmlvdXM7XG4gICAgfVxuICB9LCBudWxsKTtcblxuICAvLyB0cnkgdG8gY29udmVydCBhbnkgZGVjaW1hbHMgaW50byBzbWFsbGVyIHVuaXRzIGlmIHBvc3NpYmxlXG4gIC8vIGZvciBleGFtcGxlIGZvciB7IHllYXJzOiAyLjUsIGRheXM6IDAsIHNlY29uZHM6IDAgfSB3ZSB3YW50IHRvIGdldCB7IHllYXJzOiAyLCBkYXlzOiAxODIsIGhvdXJzOiAxMiB9XG4gIG9yZGVyZWRVbml0cy5yZWR1Y2UoKHByZXZpb3VzLCBjdXJyZW50KSA9PiB7XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh2YWxzW2N1cnJlbnRdKSkge1xuICAgICAgaWYgKHByZXZpb3VzKSB7XG4gICAgICAgIGNvbnN0IGZyYWN0aW9uID0gdmFsc1twcmV2aW91c10gJSAxO1xuICAgICAgICB2YWxzW3ByZXZpb3VzXSAtPSBmcmFjdGlvbjtcbiAgICAgICAgdmFsc1tjdXJyZW50XSArPSBmcmFjdGlvbiAqIG1hdHJpeFtwcmV2aW91c11bY3VycmVudF07XG4gICAgICB9XG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHByZXZpb3VzO1xuICAgIH1cbiAgfSwgbnVsbCk7XG59XG5cbi8vIFJlbW92ZSBhbGwgcHJvcGVydGllcyB3aXRoIGEgdmFsdWUgb2YgMCBmcm9tIGFuIG9iamVjdFxuZnVuY3Rpb24gcmVtb3ZlWmVyb2VzKHZhbHMpIHtcbiAgY29uc3QgbmV3VmFscyA9IHt9O1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh2YWxzKSkge1xuICAgIGlmICh2YWx1ZSAhPT0gMCkge1xuICAgICAgbmV3VmFsc1trZXldID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXdWYWxzO1xufVxuXG4vKipcbiAqIEEgRHVyYXRpb24gb2JqZWN0IHJlcHJlc2VudHMgYSBwZXJpb2Qgb2YgdGltZSwgbGlrZSBcIjIgbW9udGhzXCIgb3IgXCIxIGRheSwgMSBob3VyXCIuIENvbmNlcHR1YWxseSwgaXQncyBqdXN0IGEgbWFwIG9mIHVuaXRzIHRvIHRoZWlyIHF1YW50aXRpZXMsIGFjY29tcGFuaWVkIGJ5IHNvbWUgYWRkaXRpb25hbCBjb25maWd1cmF0aW9uIGFuZCBtZXRob2RzIGZvciBjcmVhdGluZywgcGFyc2luZywgaW50ZXJyb2dhdGluZywgdHJhbnNmb3JtaW5nLCBhbmQgZm9ybWF0dGluZyB0aGVtLiBUaGV5IGNhbiBiZSB1c2VkIG9uIHRoZWlyIG93biBvciBpbiBjb25qdW5jdGlvbiB3aXRoIG90aGVyIEx1eG9uIHR5cGVzOyBmb3IgZXhhbXBsZSwgeW91IGNhbiB1c2Uge0BsaW5rIERhdGVUaW1lI3BsdXN9IHRvIGFkZCBhIER1cmF0aW9uIG9iamVjdCB0byBhIERhdGVUaW1lLCBwcm9kdWNpbmcgYW5vdGhlciBEYXRlVGltZS5cbiAqXG4gKiBIZXJlIGlzIGEgYnJpZWYgb3ZlcnZpZXcgb2YgY29tbW9ubHkgdXNlZCBtZXRob2RzIGFuZCBnZXR0ZXJzIGluIER1cmF0aW9uOlxuICpcbiAqICogKipDcmVhdGlvbioqIFRvIGNyZWF0ZSBhIER1cmF0aW9uLCB1c2Uge0BsaW5rIER1cmF0aW9uLmZyb21NaWxsaXN9LCB7QGxpbmsgRHVyYXRpb24uZnJvbU9iamVjdH0sIG9yIHtAbGluayBEdXJhdGlvbi5mcm9tSVNPfS5cbiAqICogKipVbml0IHZhbHVlcyoqIFNlZSB0aGUge0BsaW5rIER1cmF0aW9uI3llYXJzfSwge0BsaW5rIER1cmF0aW9uI21vbnRoc30sIHtAbGluayBEdXJhdGlvbiN3ZWVrc30sIHtAbGluayBEdXJhdGlvbiNkYXlzfSwge0BsaW5rIER1cmF0aW9uI2hvdXJzfSwge0BsaW5rIER1cmF0aW9uI21pbnV0ZXN9LCB7QGxpbmsgRHVyYXRpb24jc2Vjb25kc30sIHtAbGluayBEdXJhdGlvbiNtaWxsaXNlY29uZHN9IGFjY2Vzc29ycy5cbiAqICogKipDb25maWd1cmF0aW9uKiogU2VlICB7QGxpbmsgRHVyYXRpb24jbG9jYWxlfSBhbmQge0BsaW5rIER1cmF0aW9uI251bWJlcmluZ1N5c3RlbX0gYWNjZXNzb3JzLlxuICogKiAqKlRyYW5zZm9ybWF0aW9uKiogVG8gY3JlYXRlIG5ldyBEdXJhdGlvbnMgb3V0IG9mIG9sZCBvbmVzIHVzZSB7QGxpbmsgRHVyYXRpb24jcGx1c30sIHtAbGluayBEdXJhdGlvbiNtaW51c30sIHtAbGluayBEdXJhdGlvbiNub3JtYWxpemV9LCB7QGxpbmsgRHVyYXRpb24jc2V0fSwge0BsaW5rIER1cmF0aW9uI3JlY29uZmlndXJlfSwge0BsaW5rIER1cmF0aW9uI3NoaWZ0VG99LCBhbmQge0BsaW5rIER1cmF0aW9uI25lZ2F0ZX0uXG4gKiAqICoqT3V0cHV0KiogVG8gY29udmVydCB0aGUgRHVyYXRpb24gaW50byBvdGhlciByZXByZXNlbnRhdGlvbnMsIHNlZSB7QGxpbmsgRHVyYXRpb24jYXN9LCB7QGxpbmsgRHVyYXRpb24jdG9JU099LCB7QGxpbmsgRHVyYXRpb24jdG9Gb3JtYXR9LCBhbmQge0BsaW5rIER1cmF0aW9uI3RvSlNPTn1cbiAqXG4gKiBUaGVyZSdzIGFyZSBtb3JlIG1ldGhvZHMgZG9jdW1lbnRlZCBiZWxvdy4gSW4gYWRkaXRpb24sIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHN1YnRsZXIgdG9waWNzIGxpa2UgaW50ZXJuYXRpb25hbGl6YXRpb24gYW5kIHZhbGlkaXR5LCBzZWUgdGhlIGV4dGVybmFsIGRvY3VtZW50YXRpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIER1cmF0aW9uIHtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBjb25zdCBhY2N1cmF0ZSA9IGNvbmZpZy5jb252ZXJzaW9uQWNjdXJhY3kgPT09IFwibG9uZ3Rlcm1cIiB8fCBmYWxzZTtcbiAgICBsZXQgbWF0cml4ID0gYWNjdXJhdGUgPyBhY2N1cmF0ZU1hdHJpeCA6IGNhc3VhbE1hdHJpeDtcblxuICAgIGlmIChjb25maWcubWF0cml4KSB7XG4gICAgICBtYXRyaXggPSBjb25maWcubWF0cml4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMudmFsdWVzID0gY29uZmlnLnZhbHVlcztcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmxvYyA9IGNvbmZpZy5sb2MgfHwgTG9jYWxlLmNyZWF0ZSgpO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuY29udmVyc2lvbkFjY3VyYWN5ID0gYWNjdXJhdGUgPyBcImxvbmd0ZXJtXCIgOiBcImNhc3VhbFwiO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaW52YWxpZCA9IGNvbmZpZy5pbnZhbGlkIHx8IG51bGw7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5tYXRyaXggPSBtYXRyaXg7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5pc0x1eG9uRHVyYXRpb24gPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBEdXJhdGlvbiBmcm9tIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IG9mIG1pbGxpc2Vjb25kc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgZm9yIHBhcnNpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nZW4tVVMnXSAtIHRoZSBsb2NhbGUgdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuY29udmVyc2lvbkFjY3VyYWN5PSdjYXN1YWwnXSAtIHRoZSBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzdGF0aWMgZnJvbU1pbGxpcyhjb3VudCwgb3B0cykge1xuICAgIHJldHVybiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgbWlsbGlzZWNvbmRzOiBjb3VudCB9LCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEdXJhdGlvbiBmcm9tIGEgSmF2YVNjcmlwdCBvYmplY3Qgd2l0aCBrZXlzIGxpa2UgJ3llYXJzJyBhbmQgJ2hvdXJzJy5cbiAgICogSWYgdGhpcyBvYmplY3QgaXMgZW1wdHkgdGhlbiBhIHplcm8gbWlsbGlzZWNvbmRzIGR1cmF0aW9uIGlzIHJldHVybmVkLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gdGhlIG9iamVjdCB0byBjcmVhdGUgdGhlIERhdGVUaW1lIGZyb21cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai55ZWFyc1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLnF1YXJ0ZXJzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoubW9udGhzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoud2Vla3NcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5kYXlzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmouaG91cnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5taW51dGVzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmouc2Vjb25kc1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLm1pbGxpc2Vjb25kc1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHM9W11dIC0gb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGhpcyBEdXJhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdlbi1VUyddIC0gdGhlIGxvY2FsZSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5jb252ZXJzaW9uQWNjdXJhY3k9J2Nhc3VhbCddIC0gdGhlIHByZXNldCBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm1hdHJpeD1PYmplY3RdIC0gdGhlIGN1c3RvbSBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzdGF0aWMgZnJvbU9iamVjdChvYmosIG9wdHMgPSB7fSkge1xuICAgIGlmIChvYmogPT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXG4gICAgICAgIGBEdXJhdGlvbi5mcm9tT2JqZWN0OiBhcmd1bWVudCBleHBlY3RlZCB0byBiZSBhbiBvYmplY3QsIGdvdCAke1xuICAgICAgICAgIG9iaiA9PT0gbnVsbCA/IFwibnVsbFwiIDogdHlwZW9mIG9ialxuICAgICAgICB9YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IER1cmF0aW9uKHtcbiAgICAgIHZhbHVlczogbm9ybWFsaXplT2JqZWN0KG9iaiwgRHVyYXRpb24ubm9ybWFsaXplVW5pdCksXG4gICAgICBsb2M6IExvY2FsZS5mcm9tT2JqZWN0KG9wdHMpLFxuICAgICAgY29udmVyc2lvbkFjY3VyYWN5OiBvcHRzLmNvbnZlcnNpb25BY2N1cmFjeSxcbiAgICAgIG1hdHJpeDogb3B0cy5tYXRyaXgsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRHVyYXRpb24gZnJvbSBEdXJhdGlvbkxpa2UuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0IHwgbnVtYmVyIHwgRHVyYXRpb259IGR1cmF0aW9uTGlrZVxuICAgKiBPbmUgb2Y6XG4gICAqIC0gb2JqZWN0IHdpdGgga2V5cyBsaWtlICd5ZWFycycgYW5kICdob3VycycuXG4gICAqIC0gbnVtYmVyIHJlcHJlc2VudGluZyBtaWxsaXNlY29uZHNcbiAgICogLSBEdXJhdGlvbiBpbnN0YW5jZVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHN0YXRpYyBmcm9tRHVyYXRpb25MaWtlKGR1cmF0aW9uTGlrZSkge1xuICAgIGlmIChpc051bWJlcihkdXJhdGlvbkxpa2UpKSB7XG4gICAgICByZXR1cm4gRHVyYXRpb24uZnJvbU1pbGxpcyhkdXJhdGlvbkxpa2UpO1xuICAgIH0gZWxzZSBpZiAoRHVyYXRpb24uaXNEdXJhdGlvbihkdXJhdGlvbkxpa2UpKSB7XG4gICAgICByZXR1cm4gZHVyYXRpb25MaWtlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGR1cmF0aW9uTGlrZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLmZyb21PYmplY3QoZHVyYXRpb25MaWtlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFxuICAgICAgICBgVW5rbm93biBkdXJhdGlvbiBhcmd1bWVudCAke2R1cmF0aW9uTGlrZX0gb2YgdHlwZSAke3R5cGVvZiBkdXJhdGlvbkxpa2V9YFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRHVyYXRpb24gZnJvbSBhbiBJU08gODYwMSBkdXJhdGlvbiBzdHJpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGV4dCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgZm9yIHBhcnNpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nZW4tVVMnXSAtIHRoZSBsb2NhbGUgdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuY29udmVyc2lvbkFjY3VyYWN5PSdjYXN1YWwnXSAtIHRoZSBwcmVzZXQgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5tYXRyaXg9T2JqZWN0XSAtIHRoZSBwcmVzZXQgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDEjRHVyYXRpb25zXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21JU08oJ1AzWTZNMVc0RFQxMkgzME01UycpLnRvT2JqZWN0KCkgLy89PiB7IHllYXJzOiAzLCBtb250aHM6IDYsIHdlZWtzOiAxLCBkYXlzOiA0LCBob3VyczogMTIsIG1pbnV0ZXM6IDMwLCBzZWNvbmRzOiA1IH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbUlTTygnUFQyM0gnKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMjMgfVxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tSVNPKCdQNVkzTScpLnRvT2JqZWN0KCkgLy89PiB7IHllYXJzOiA1LCBtb250aHM6IDMgfVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHN0YXRpYyBmcm9tSVNPKHRleHQsIG9wdHMpIHtcbiAgICBjb25zdCBbcGFyc2VkXSA9IHBhcnNlSVNPRHVyYXRpb24odGV4dCk7XG4gICAgaWYgKHBhcnNlZCkge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLmZyb21PYmplY3QocGFyc2VkLCBvcHRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLmludmFsaWQoXCJ1bnBhcnNhYmxlXCIsIGB0aGUgaW5wdXQgXCIke3RleHR9XCIgY2FuJ3QgYmUgcGFyc2VkIGFzIElTTyA4NjAxYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIER1cmF0aW9uIGZyb20gYW4gSVNPIDg2MDEgdGltZSBzdHJpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGV4dCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgZm9yIHBhcnNpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nZW4tVVMnXSAtIHRoZSBsb2NhbGUgdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuY29udmVyc2lvbkFjY3VyYWN5PSdjYXN1YWwnXSAtIHRoZSBwcmVzZXQgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5tYXRyaXg9T2JqZWN0XSAtIHRoZSBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMSNUaW1lc1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tSVNPVGltZSgnMTE6MjI6MzMuNDQ0JykudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDExLCBtaW51dGVzOiAyMiwgc2Vjb25kczogMzMsIG1pbGxpc2Vjb25kczogNDQ0IH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbUlTT1RpbWUoJzExOjAwJykudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDExLCBtaW51dGVzOiAwLCBzZWNvbmRzOiAwIH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbUlTT1RpbWUoJ1QxMTowMCcpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAxMSwgbWludXRlczogMCwgc2Vjb25kczogMCB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21JU09UaW1lKCcxMTAwJykudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDExLCBtaW51dGVzOiAwLCBzZWNvbmRzOiAwIH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbUlTT1RpbWUoJ1QxMTAwJykudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDExLCBtaW51dGVzOiAwLCBzZWNvbmRzOiAwIH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzdGF0aWMgZnJvbUlTT1RpbWUodGV4dCwgb3B0cykge1xuICAgIGNvbnN0IFtwYXJzZWRdID0gcGFyc2VJU09UaW1lT25seSh0ZXh0KTtcbiAgICBpZiAocGFyc2VkKSB7XG4gICAgICByZXR1cm4gRHVyYXRpb24uZnJvbU9iamVjdChwYXJzZWQsIG9wdHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gRHVyYXRpb24uaW52YWxpZChcInVucGFyc2FibGVcIiwgYHRoZSBpbnB1dCBcIiR7dGV4dH1cIiBjYW4ndCBiZSBwYXJzZWQgYXMgSVNPIDg2MDFgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGludmFsaWQgRHVyYXRpb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWFzb24gLSBzaW1wbGUgc3RyaW5nIG9mIHdoeSB0aGlzIGRhdGV0aW1lIGlzIGludmFsaWQuIFNob3VsZCBub3QgY29udGFpbiBwYXJhbWV0ZXJzIG9yIGFueXRoaW5nIGVsc2UgZGF0YS1kZXBlbmRlbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtleHBsYW5hdGlvbj1udWxsXSAtIGxvbmdlciBleHBsYW5hdGlvbiwgbWF5IGluY2x1ZGUgcGFyYW1ldGVycyBhbmQgb3RoZXIgdXNlZnVsIGRlYnVnZ2luZyBpbmZvcm1hdGlvblxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHN0YXRpYyBpbnZhbGlkKHJlYXNvbiwgZXhwbGFuYXRpb24gPSBudWxsKSB7XG4gICAgaWYgKCFyZWFzb24pIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcIm5lZWQgdG8gc3BlY2lmeSBhIHJlYXNvbiB0aGUgRHVyYXRpb24gaXMgaW52YWxpZFwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbnZhbGlkID0gcmVhc29uIGluc3RhbmNlb2YgSW52YWxpZCA/IHJlYXNvbiA6IG5ldyBJbnZhbGlkKHJlYXNvbiwgZXhwbGFuYXRpb24pO1xuXG4gICAgaWYgKFNldHRpbmdzLnRocm93T25JbnZhbGlkKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZER1cmF0aW9uRXJyb3IoaW52YWxpZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgRHVyYXRpb24oeyBpbnZhbGlkIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhdGljIG5vcm1hbGl6ZVVuaXQodW5pdCkge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSB7XG4gICAgICB5ZWFyOiBcInllYXJzXCIsXG4gICAgICB5ZWFyczogXCJ5ZWFyc1wiLFxuICAgICAgcXVhcnRlcjogXCJxdWFydGVyc1wiLFxuICAgICAgcXVhcnRlcnM6IFwicXVhcnRlcnNcIixcbiAgICAgIG1vbnRoOiBcIm1vbnRoc1wiLFxuICAgICAgbW9udGhzOiBcIm1vbnRoc1wiLFxuICAgICAgd2VlazogXCJ3ZWVrc1wiLFxuICAgICAgd2Vla3M6IFwid2Vla3NcIixcbiAgICAgIGRheTogXCJkYXlzXCIsXG4gICAgICBkYXlzOiBcImRheXNcIixcbiAgICAgIGhvdXI6IFwiaG91cnNcIixcbiAgICAgIGhvdXJzOiBcImhvdXJzXCIsXG4gICAgICBtaW51dGU6IFwibWludXRlc1wiLFxuICAgICAgbWludXRlczogXCJtaW51dGVzXCIsXG4gICAgICBzZWNvbmQ6IFwic2Vjb25kc1wiLFxuICAgICAgc2Vjb25kczogXCJzZWNvbmRzXCIsXG4gICAgICBtaWxsaXNlY29uZDogXCJtaWxsaXNlY29uZHNcIixcbiAgICAgIG1pbGxpc2Vjb25kczogXCJtaWxsaXNlY29uZHNcIixcbiAgICB9W3VuaXQgPyB1bml0LnRvTG93ZXJDYXNlKCkgOiB1bml0XTtcblxuICAgIGlmICghbm9ybWFsaXplZCkgdGhyb3cgbmV3IEludmFsaWRVbml0RXJyb3IodW5pdCk7XG5cbiAgICByZXR1cm4gbm9ybWFsaXplZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBvYmplY3QgaXMgYSBEdXJhdGlvbi4gV29ya3MgYWNyb3NzIGNvbnRleHQgYm91bmRhcmllc1xuICAgKiBAcGFyYW0ge29iamVjdH0gb1xuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzRHVyYXRpb24obykge1xuICAgIHJldHVybiAobyAmJiBvLmlzTHV4b25EdXJhdGlvbikgfHwgZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0ICB0aGUgbG9jYWxlIG9mIGEgRHVyYXRpb24sIHN1Y2ggJ2VuLUdCJ1xuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGxvY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5sb2MubG9jYWxlIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG51bWJlcmluZyBzeXN0ZW0gb2YgYSBEdXJhdGlvbiwgc3VjaCAnYmVuZycuIFRoZSBudW1iZXJpbmcgc3lzdGVtIGlzIHVzZWQgd2hlbiBmb3JtYXR0aW5nIHRoZSBEdXJhdGlvblxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IG51bWJlcmluZ1N5c3RlbSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5sb2MubnVtYmVyaW5nU3lzdGVtIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRHVyYXRpb24gZm9ybWF0dGVkIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIGZvcm1hdCBzdHJpbmcuIFlvdSBtYXkgdXNlIHRoZXNlIHRva2VuczpcbiAgICogKiBgU2AgZm9yIG1pbGxpc2Vjb25kc1xuICAgKiAqIGBzYCBmb3Igc2Vjb25kc1xuICAgKiAqIGBtYCBmb3IgbWludXRlc1xuICAgKiAqIGBoYCBmb3IgaG91cnNcbiAgICogKiBgZGAgZm9yIGRheXNcbiAgICogKiBgd2AgZm9yIHdlZWtzXG4gICAqICogYE1gIGZvciBtb250aHNcbiAgICogKiBgeWAgZm9yIHllYXJzXG4gICAqIE5vdGVzOlxuICAgKiAqIEFkZCBwYWRkaW5nIGJ5IHJlcGVhdGluZyB0aGUgdG9rZW4sIGUuZy4gXCJ5eVwiIHBhZHMgdGhlIHllYXJzIHRvIHR3byBkaWdpdHMsIFwiaGhoaFwiIHBhZHMgdGhlIGhvdXJzIG91dCB0byBmb3VyIGRpZ2l0c1xuICAgKiAqIFRva2VucyBjYW4gYmUgZXNjYXBlZCBieSB3cmFwcGluZyB3aXRoIHNpbmdsZSBxdW90ZXMuXG4gICAqICogVGhlIGR1cmF0aW9uIHdpbGwgYmUgY29udmVydGVkIHRvIHRoZSBzZXQgb2YgdW5pdHMgaW4gdGhlIGZvcm1hdCBzdHJpbmcgdXNpbmcge0BsaW5rIER1cmF0aW9uI3NoaWZ0VG99IGFuZCB0aGUgRHVyYXRpb25zJ3MgY29udmVyc2lvbiBhY2N1cmFjeSBzZXR0aW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZm10IC0gdGhlIGZvcm1hdCBzdHJpbmdcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuZmxvb3I9dHJ1ZV0gLSBmbG9vciBudW1lcmljYWwgdmFsdWVzXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMSwgZGF5czogNiwgc2Vjb25kczogMiB9KS50b0Zvcm1hdChcInkgZCBzXCIpIC8vPT4gXCIxIDYgMlwiXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMSwgZGF5czogNiwgc2Vjb25kczogMiB9KS50b0Zvcm1hdChcInl5IGRkIHNzc1wiKSAvLz0+IFwiMDEgMDYgMDAyXCJcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IHllYXJzOiAxLCBkYXlzOiA2LCBzZWNvbmRzOiAyIH0pLnRvRm9ybWF0KFwiTSBTXCIpIC8vPT4gXCIxMiA1MTg0MDIwMDBcIlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0Zvcm1hdChmbXQsIG9wdHMgPSB7fSkge1xuICAgIC8vIHJldmVyc2UtY29tcGF0IHNpbmNlIDEuMjsgd2UgYWx3YXlzIHJvdW5kIGRvd24gbm93LCBuZXZlciB1cCwgYW5kIHdlIGRvIGl0IGJ5IGRlZmF1bHRcbiAgICBjb25zdCBmbXRPcHRzID0ge1xuICAgICAgLi4ub3B0cyxcbiAgICAgIGZsb29yOiBvcHRzLnJvdW5kICE9PSBmYWxzZSAmJiBvcHRzLmZsb29yICE9PSBmYWxzZSxcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWRcbiAgICAgID8gRm9ybWF0dGVyLmNyZWF0ZSh0aGlzLmxvYywgZm10T3B0cykuZm9ybWF0RHVyYXRpb25Gcm9tU3RyaW5nKHRoaXMsIGZtdClcbiAgICAgIDogSU5WQUxJRDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgRHVyYXRpb24gd2l0aCBhbGwgdW5pdHMgaW5jbHVkZWQuXG4gICAqIFRvIG1vZGlmeSBpdHMgYmVoYXZpb3IgdXNlIHRoZSBgbGlzdFN0eWxlYCBhbmQgYW55IEludGwuTnVtYmVyRm9ybWF0IG9wdGlvbiwgdGhvdWdoIGB1bml0RGlzcGxheWAgaXMgZXNwZWNpYWxseSByZWxldmFudC5cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9JbnRsL051bWJlckZvcm1hdFxuICAgKiBAcGFyYW0gb3B0cyAtIE9uIG9wdGlvbiBvYmplY3QgdG8gb3ZlcnJpZGUgdGhlIGZvcm1hdHRpbmcuIEFjY2VwdHMgdGhlIHNhbWUga2V5cyBhcyB0aGUgb3B0aW9ucyBwYXJhbWV0ZXIgb2YgdGhlIG5hdGl2ZSBgSW50Lk51bWJlckZvcm1hdGAgY29uc3RydWN0b3IsIGFzIHdlbGwgYXMgYGxpc3RTdHlsZWAuXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIHZhciBkdXIgPSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgZGF5czogMSwgaG91cnM6IDUsIG1pbnV0ZXM6IDYgfSlcbiAgICogZHVyLnRvSHVtYW4oKSAvLz0+ICcxIGRheSwgNSBob3VycywgNiBtaW51dGVzJ1xuICAgKiBkdXIudG9IdW1hbih7IGxpc3RTdHlsZTogXCJsb25nXCIgfSkgLy89PiAnMSBkYXksIDUgaG91cnMsIGFuZCA2IG1pbnV0ZXMnXG4gICAqIGR1ci50b0h1bWFuKHsgdW5pdERpc3BsYXk6IFwic2hvcnRcIiB9KSAvLz0+ICcxIGRheSwgNSBociwgNiBtaW4nXG4gICAqIGBgYFxuICAgKi9cbiAgdG9IdW1hbihvcHRzID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIElOVkFMSUQ7XG5cbiAgICBjb25zdCBsID0gb3JkZXJlZFVuaXRzXG4gICAgICAubWFwKCh1bml0KSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbCA9IHRoaXMudmFsdWVzW3VuaXRdO1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQodmFsKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxvY1xuICAgICAgICAgIC5udW1iZXJGb3JtYXR0ZXIoeyBzdHlsZTogXCJ1bml0XCIsIHVuaXREaXNwbGF5OiBcImxvbmdcIiwgLi4ub3B0cywgdW5pdDogdW5pdC5zbGljZSgwLCAtMSkgfSlcbiAgICAgICAgICAuZm9ybWF0KHZhbCk7XG4gICAgICB9KVxuICAgICAgLmZpbHRlcigobikgPT4gbik7XG5cbiAgICByZXR1cm4gdGhpcy5sb2NcbiAgICAgIC5saXN0Rm9ybWF0dGVyKHsgdHlwZTogXCJjb25qdW5jdGlvblwiLCBzdHlsZTogb3B0cy5saXN0U3R5bGUgfHwgXCJuYXJyb3dcIiwgLi4ub3B0cyB9KVxuICAgICAgLmZvcm1hdChsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgSmF2YVNjcmlwdCBvYmplY3Qgd2l0aCB0aGlzIER1cmF0aW9uJ3MgdmFsdWVzLlxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgeWVhcnM6IDEsIGRheXM6IDYsIHNlY29uZHM6IDIgfSkudG9PYmplY3QoKSAvLz0+IHsgeWVhcnM6IDEsIGRheXM6IDYsIHNlY29uZHM6IDIgfVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICB0b09iamVjdCgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHt9O1xuICAgIHJldHVybiB7IC4uLnRoaXMudmFsdWVzIH07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMS1jb21wbGlhbnQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRHVyYXRpb24uXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDEjRHVyYXRpb25zXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMywgc2Vjb25kczogNDUgfSkudG9JU08oKSAvLz0+ICdQM1lUNDVTJ1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgbW9udGhzOiA0LCBzZWNvbmRzOiA0NSB9KS50b0lTTygpIC8vPT4gJ1A0TVQ0NVMnXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBtb250aHM6IDUgfSkudG9JU08oKSAvLz0+ICdQNU0nXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBtaW51dGVzOiA1IH0pLnRvSVNPKCkgLy89PiAnUFQ1TSdcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IG1pbGxpc2Vjb25kczogNiB9KS50b0lTTygpIC8vPT4gJ1BUMC4wMDZTJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0lTTygpIHtcbiAgICAvLyB3ZSBjb3VsZCB1c2UgdGhlIGZvcm1hdHRlciwgYnV0IHRoaXMgaXMgYW4gZWFzaWVyIHdheSB0byBnZXQgdGhlIG1pbmltdW0gc3RyaW5nXG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBudWxsO1xuXG4gICAgbGV0IHMgPSBcIlBcIjtcbiAgICBpZiAodGhpcy55ZWFycyAhPT0gMCkgcyArPSB0aGlzLnllYXJzICsgXCJZXCI7XG4gICAgaWYgKHRoaXMubW9udGhzICE9PSAwIHx8IHRoaXMucXVhcnRlcnMgIT09IDApIHMgKz0gdGhpcy5tb250aHMgKyB0aGlzLnF1YXJ0ZXJzICogMyArIFwiTVwiO1xuICAgIGlmICh0aGlzLndlZWtzICE9PSAwKSBzICs9IHRoaXMud2Vla3MgKyBcIldcIjtcbiAgICBpZiAodGhpcy5kYXlzICE9PSAwKSBzICs9IHRoaXMuZGF5cyArIFwiRFwiO1xuICAgIGlmICh0aGlzLmhvdXJzICE9PSAwIHx8IHRoaXMubWludXRlcyAhPT0gMCB8fCB0aGlzLnNlY29uZHMgIT09IDAgfHwgdGhpcy5taWxsaXNlY29uZHMgIT09IDApXG4gICAgICBzICs9IFwiVFwiO1xuICAgIGlmICh0aGlzLmhvdXJzICE9PSAwKSBzICs9IHRoaXMuaG91cnMgKyBcIkhcIjtcbiAgICBpZiAodGhpcy5taW51dGVzICE9PSAwKSBzICs9IHRoaXMubWludXRlcyArIFwiTVwiO1xuICAgIGlmICh0aGlzLnNlY29uZHMgIT09IDAgfHwgdGhpcy5taWxsaXNlY29uZHMgIT09IDApXG4gICAgICAvLyB0aGlzIHdpbGwgaGFuZGxlIFwiZmxvYXRpbmcgcG9pbnQgbWFkbmVzc1wiIGJ5IHJlbW92aW5nIGV4dHJhIGRlY2ltYWwgcGxhY2VzXG4gICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81ODgwMDQvaXMtZmxvYXRpbmctcG9pbnQtbWF0aC1icm9rZW5cbiAgICAgIHMgKz0gcm91bmRUbyh0aGlzLnNlY29uZHMgKyB0aGlzLm1pbGxpc2Vjb25kcyAvIDEwMDAsIDMpICsgXCJTXCI7XG4gICAgaWYgKHMgPT09IFwiUFwiKSBzICs9IFwiVDBTXCI7XG4gICAgcmV0dXJuIHM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMS1jb21wbGlhbnQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRHVyYXRpb24sIGZvcm1hdHRlZCBhcyBhIHRpbWUgb2YgZGF5LlxuICAgKiBOb3RlIHRoYXQgdGhpcyB3aWxsIHJldHVybiBudWxsIGlmIHRoZSBkdXJhdGlvbiBpcyBpbnZhbGlkLCBuZWdhdGl2ZSwgb3IgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuIDI0IGhvdXJzLlxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxI1RpbWVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnN1cHByZXNzTWlsbGlzZWNvbmRzPWZhbHNlXSAtIGV4Y2x1ZGUgbWlsbGlzZWNvbmRzIGZyb20gdGhlIGZvcm1hdCBpZiB0aGV5J3JlIDBcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zdXBwcmVzc1NlY29uZHM9ZmFsc2VdIC0gZXhjbHVkZSBzZWNvbmRzIGZyb20gdGhlIGZvcm1hdCBpZiB0aGV5J3JlIDBcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlUHJlZml4PWZhbHNlXSAtIGluY2x1ZGUgdGhlIGBUYCBwcmVmaXhcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmZvcm1hdD0nZXh0ZW5kZWQnXSAtIGNob29zZSBiZXR3ZWVuIHRoZSBiYXNpYyBhbmQgZXh0ZW5kZWQgZm9ybWF0XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMTEgfSkudG9JU09UaW1lKCkgLy89PiAnMTE6MDA6MDAuMDAwJ1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDExIH0pLnRvSVNPVGltZSh7IHN1cHByZXNzTWlsbGlzZWNvbmRzOiB0cnVlIH0pIC8vPT4gJzExOjAwOjAwJ1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDExIH0pLnRvSVNPVGltZSh7IHN1cHByZXNzU2Vjb25kczogdHJ1ZSB9KSAvLz0+ICcxMTowMCdcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxMSB9KS50b0lTT1RpbWUoeyBpbmNsdWRlUHJlZml4OiB0cnVlIH0pIC8vPT4gJ1QxMTowMDowMC4wMDAnXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMTEgfSkudG9JU09UaW1lKHsgZm9ybWF0OiAnYmFzaWMnIH0pIC8vPT4gJzExMDAwMC4wMDAnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSVNPVGltZShvcHRzID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIG51bGw7XG5cbiAgICBjb25zdCBtaWxsaXMgPSB0aGlzLnRvTWlsbGlzKCk7XG4gICAgaWYgKG1pbGxpcyA8IDAgfHwgbWlsbGlzID49IDg2NDAwMDAwKSByZXR1cm4gbnVsbDtcblxuICAgIG9wdHMgPSB7XG4gICAgICBzdXBwcmVzc01pbGxpc2Vjb25kczogZmFsc2UsXG4gICAgICBzdXBwcmVzc1NlY29uZHM6IGZhbHNlLFxuICAgICAgaW5jbHVkZVByZWZpeDogZmFsc2UsXG4gICAgICBmb3JtYXQ6IFwiZXh0ZW5kZWRcIixcbiAgICAgIC4uLm9wdHMsXG4gICAgICBpbmNsdWRlT2Zmc2V0OiBmYWxzZSxcbiAgICB9O1xuXG4gICAgY29uc3QgZGF0ZVRpbWUgPSBEYXRlVGltZS5mcm9tTWlsbGlzKG1pbGxpcywgeyB6b25lOiBcIlVUQ1wiIH0pO1xuICAgIHJldHVybiBkYXRlVGltZS50b0lTT1RpbWUob3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIER1cmF0aW9uIGFwcHJvcHJpYXRlIGZvciB1c2UgaW4gSlNPTi5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvSVNPKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIER1cmF0aW9uIGFwcHJvcHJpYXRlIGZvciB1c2UgaW4gZGVidWdnaW5nLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy50b0lTTygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gbWlsbGlzZWNvbmRzIHZhbHVlIG9mIHRoaXMgRHVyYXRpb24uXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHRvTWlsbGlzKCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gTmFOO1xuXG4gICAgcmV0dXJuIGR1cmF0aW9uVG9NaWxsaXModGhpcy5tYXRyaXgsIHRoaXMudmFsdWVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG1pbGxpc2Vjb25kcyB2YWx1ZSBvZiB0aGlzIER1cmF0aW9uLiBBbGlhcyBvZiB7QGxpbmsgdG9NaWxsaXN9XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHZhbHVlT2YoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9NaWxsaXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIHRoaXMgRHVyYXRpb24gbG9uZ2VyIGJ5IHRoZSBzcGVjaWZpZWQgYW1vdW50LiBSZXR1cm4gYSBuZXdseS1jb25zdHJ1Y3RlZCBEdXJhdGlvbi5cbiAgICogQHBhcmFtIHtEdXJhdGlvbnxPYmplY3R8bnVtYmVyfSBkdXJhdGlvbiAtIFRoZSBhbW91bnQgdG8gYWRkLiBFaXRoZXIgYSBMdXhvbiBEdXJhdGlvbiwgYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLCB0aGUgb2JqZWN0IGFyZ3VtZW50IHRvIER1cmF0aW9uLmZyb21PYmplY3QoKVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHBsdXMoZHVyYXRpb24pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG5cbiAgICBjb25zdCBkdXIgPSBEdXJhdGlvbi5mcm9tRHVyYXRpb25MaWtlKGR1cmF0aW9uKSxcbiAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgZm9yIChjb25zdCBrIG9mIG9yZGVyZWRVbml0cykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5KGR1ci52YWx1ZXMsIGspIHx8IGhhc093blByb3BlcnR5KHRoaXMudmFsdWVzLCBrKSkge1xuICAgICAgICByZXN1bHRba10gPSBkdXIuZ2V0KGspICsgdGhpcy5nZXQoayk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIHsgdmFsdWVzOiByZXN1bHQgfSwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogTWFrZSB0aGlzIER1cmF0aW9uIHNob3J0ZXIgYnkgdGhlIHNwZWNpZmllZCBhbW91bnQuIFJldHVybiBhIG5ld2x5LWNvbnN0cnVjdGVkIER1cmF0aW9uLlxuICAgKiBAcGFyYW0ge0R1cmF0aW9ufE9iamVjdHxudW1iZXJ9IGR1cmF0aW9uIC0gVGhlIGFtb3VudCB0byBzdWJ0cmFjdC4gRWl0aGVyIGEgTHV4b24gRHVyYXRpb24sIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgdGhlIG9iamVjdCBhcmd1bWVudCB0byBEdXJhdGlvbi5mcm9tT2JqZWN0KClcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBtaW51cyhkdXJhdGlvbikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcblxuICAgIGNvbnN0IGR1ciA9IER1cmF0aW9uLmZyb21EdXJhdGlvbkxpa2UoZHVyYXRpb24pO1xuICAgIHJldHVybiB0aGlzLnBsdXMoZHVyLm5lZ2F0ZSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTY2FsZSB0aGlzIER1cmF0aW9uIGJ5IHRoZSBzcGVjaWZpZWQgYW1vdW50LiBSZXR1cm4gYSBuZXdseS1jb25zdHJ1Y3RlZCBEdXJhdGlvbi5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gLSBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCB1bml0LiBBcml0eSBpcyAxIG9yIDI6IHRoZSB2YWx1ZSBvZiB0aGUgdW5pdCBhbmQsIG9wdGlvbmFsbHksIHRoZSB1bml0IG5hbWUuIE11c3QgcmV0dXJuIGEgbnVtYmVyLlxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDEsIG1pbnV0ZXM6IDMwIH0pLm1hcFVuaXRzKHggPT4geCAqIDIpIC8vPT4geyBob3VyczogMiwgbWludXRlczogNjAgfVxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDEsIG1pbnV0ZXM6IDMwIH0pLm1hcFVuaXRzKCh4LCB1KSA9PiB1ID09PSBcImhvdXJzXCIgPyB4ICogMiA6IHgpIC8vPT4geyBob3VyczogMiwgbWludXRlczogMzAgfVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIG1hcFVuaXRzKGZuKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3QgayBvZiBPYmplY3Qua2V5cyh0aGlzLnZhbHVlcykpIHtcbiAgICAgIHJlc3VsdFtrXSA9IGFzTnVtYmVyKGZuKHRoaXMudmFsdWVzW2tdLCBrKSk7XG4gICAgfVxuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHZhbHVlczogcmVzdWx0IH0sIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUgb2YgdW5pdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVuaXQgLSBhIHVuaXQgc3VjaCBhcyAnbWludXRlJyBvciAnZGF5J1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHt5ZWFyczogMiwgZGF5czogM30pLmdldCgneWVhcnMnKSAvLz0+IDJcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7eWVhcnM6IDIsIGRheXM6IDN9KS5nZXQoJ21vbnRocycpIC8vPT4gMFxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHt5ZWFyczogMiwgZGF5czogM30pLmdldCgnZGF5cycpIC8vPT4gM1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXQodW5pdCkge1xuICAgIHJldHVybiB0aGlzW0R1cmF0aW9uLm5vcm1hbGl6ZVVuaXQodW5pdCldO1xuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhlIHZhbHVlcyBvZiBzcGVjaWZpZWQgdW5pdHMuIFJldHVybiBhIG5ld2x5LWNvbnN0cnVjdGVkIER1cmF0aW9uLlxuICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVzIC0gYSBtYXBwaW5nIG9mIHVuaXRzIHRvIG51bWJlcnNcbiAgICogQGV4YW1wbGUgZHVyLnNldCh7IHllYXJzOiAyMDE3IH0pXG4gICAqIEBleGFtcGxlIGR1ci5zZXQoeyBob3VyczogOCwgbWludXRlczogMzAgfSlcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzZXQodmFsdWVzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuXG4gICAgY29uc3QgbWl4ZWQgPSB7IC4uLnRoaXMudmFsdWVzLCAuLi5ub3JtYWxpemVPYmplY3QodmFsdWVzLCBEdXJhdGlvbi5ub3JtYWxpemVVbml0KSB9O1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHZhbHVlczogbWl4ZWQgfSk7XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGUgbG9jYWxlIGFuZC9vciBudW1iZXJpbmdTeXN0ZW0uICBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgRHVyYXRpb24uXG4gICAqIEBleGFtcGxlIGR1ci5yZWNvbmZpZ3VyZSh7IGxvY2FsZTogJ2VuLUdCJyB9KVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHJlY29uZmlndXJlKHsgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIGNvbnZlcnNpb25BY2N1cmFjeSwgbWF0cml4IH0gPSB7fSkge1xuICAgIGNvbnN0IGxvYyA9IHRoaXMubG9jLmNsb25lKHsgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0gfSk7XG4gICAgY29uc3Qgb3B0cyA9IHsgbG9jLCBtYXRyaXgsIGNvbnZlcnNpb25BY2N1cmFjeSB9O1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgZHVyYXRpb24gaW4gdGhlIHNwZWNpZmllZCB1bml0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIGEgdW5pdCBzdWNoIGFzICdtaW51dGVzJyBvciAnZGF5cydcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7eWVhcnM6IDF9KS5hcygnZGF5cycpIC8vPT4gMzY1XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3Qoe3llYXJzOiAxfSkuYXMoJ21vbnRocycpIC8vPT4gMTJcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7aG91cnM6IDYwfSkuYXMoJ2RheXMnKSAvLz0+IDIuNVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBhcyh1bml0KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuc2hpZnRUbyh1bml0KS5nZXQodW5pdCkgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogUmVkdWNlIHRoaXMgRHVyYXRpb24gdG8gaXRzIGNhbm9uaWNhbCByZXByZXNlbnRhdGlvbiBpbiBpdHMgY3VycmVudCB1bml0cy5cbiAgICogQXNzdW1pbmcgdGhlIG92ZXJhbGwgdmFsdWUgb2YgdGhlIER1cmF0aW9uIGlzIHBvc2l0aXZlLCB0aGlzIG1lYW5zOlxuICAgKiAtIGV4Y2Vzc2l2ZSB2YWx1ZXMgZm9yIGxvd2VyLW9yZGVyIHVuaXRzIGFyZSBjb252ZXJ0ZWQgdG8gaGlnaGVyLW9yZGVyIHVuaXRzIChpZiBwb3NzaWJsZSwgc2VlIGZpcnN0IGFuZCBzZWNvbmQgZXhhbXBsZSlcbiAgICogLSBuZWdhdGl2ZSBsb3dlci1vcmRlciB1bml0cyBhcmUgY29udmVydGVkIHRvIGhpZ2hlciBvcmRlciB1bml0cyAodGhlcmUgbXVzdCBiZSBzdWNoIGEgaGlnaGVyIG9yZGVyIHVuaXQsIG90aGVyd2lzZVxuICAgKiAgIHRoZSBvdmVyYWxsIHZhbHVlIHdvdWxkIGJlIG5lZ2F0aXZlLCBzZWUgc2Vjb25kIGV4YW1wbGUpXG4gICAqIC0gZnJhY3Rpb25hbCB2YWx1ZXMgZm9yIGhpZ2hlci1vcmRlciB1bml0cyBhcmUgY29udmVydGVkIHRvIGxvd2VyLW9yZGVyIHVuaXRzIChpZiBwb3NzaWJsZSwgc2VlIGZvdXJ0aCBleGFtcGxlKVxuICAgKlxuICAgKiBJZiB0aGUgb3ZlcmFsbCB2YWx1ZSBpcyBuZWdhdGl2ZSwgdGhlIHJlc3VsdCBvZiB0aGlzIG1ldGhvZCBpcyBlcXVpdmFsZW50IHRvIGB0aGlzLm5lZ2F0ZSgpLm5vcm1hbGl6ZSgpLm5lZ2F0ZSgpYC5cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IHllYXJzOiAyLCBkYXlzOiA1MDAwIH0pLm5vcm1hbGl6ZSgpLnRvT2JqZWN0KCkgLy89PiB7IHllYXJzOiAxNSwgZGF5czogMjU1IH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGRheXM6IDUwMDAgfSkubm9ybWFsaXplKCkudG9PYmplY3QoKSAvLz0+IHsgZGF5czogNTAwMCB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMTIsIG1pbnV0ZXM6IC00NSB9KS5ub3JtYWxpemUoKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMTEsIG1pbnV0ZXM6IDE1IH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IHllYXJzOiAyLjUsIGRheXM6IDAsIGhvdXJzOiAwIH0pLm5vcm1hbGl6ZSgpLnRvT2JqZWN0KCkgLy89PiB7IHllYXJzOiAyLCBkYXlzOiAxODIsIGhvdXJzOiAxMiB9XG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgbm9ybWFsaXplKCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCB2YWxzID0gdGhpcy50b09iamVjdCgpO1xuICAgIG5vcm1hbGl6ZVZhbHVlcyh0aGlzLm1hdHJpeCwgdmFscyk7XG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIHsgdmFsdWVzOiB2YWxzIH0sIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2NhbGUgdW5pdHMgdG8gaXRzIGxhcmdlc3QgcmVwcmVzZW50YXRpb25cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IG1pbGxpc2Vjb25kczogOTAwMDAgfSkucmVzY2FsZSgpLnRvT2JqZWN0KCkgLy89PiB7IG1pbnV0ZXM6IDEsIHNlY29uZHM6IDMwIH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICByZXNjYWxlKCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCB2YWxzID0gcmVtb3ZlWmVyb2VzKHRoaXMubm9ybWFsaXplKCkuc2hpZnRUb0FsbCgpLnRvT2JqZWN0KCkpO1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHZhbHVlczogdmFscyB9LCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IHRoaXMgRHVyYXRpb24gaW50byBpdHMgcmVwcmVzZW50YXRpb24gaW4gYSBkaWZmZXJlbnQgc2V0IG9mIHVuaXRzLlxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDEsIHNlY29uZHM6IDMwIH0pLnNoaWZ0VG8oJ21pbnV0ZXMnLCAnbWlsbGlzZWNvbmRzJykudG9PYmplY3QoKSAvLz0+IHsgbWludXRlczogNjAsIG1pbGxpc2Vjb25kczogMzAwMDAgfVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHNoaWZ0VG8oLi4udW5pdHMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAodW5pdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB1bml0cyA9IHVuaXRzLm1hcCgodSkgPT4gRHVyYXRpb24ubm9ybWFsaXplVW5pdCh1KSk7XG5cbiAgICBjb25zdCBidWlsdCA9IHt9LFxuICAgICAgYWNjdW11bGF0ZWQgPSB7fSxcbiAgICAgIHZhbHMgPSB0aGlzLnRvT2JqZWN0KCk7XG4gICAgbGV0IGxhc3RVbml0O1xuXG4gICAgZm9yIChjb25zdCBrIG9mIG9yZGVyZWRVbml0cykge1xuICAgICAgaWYgKHVuaXRzLmluZGV4T2YoaykgPj0gMCkge1xuICAgICAgICBsYXN0VW5pdCA9IGs7XG5cbiAgICAgICAgbGV0IG93biA9IDA7XG5cbiAgICAgICAgLy8gYW55dGhpbmcgd2UgaGF2ZW4ndCBib2lsZWQgZG93biB5ZXQgc2hvdWxkIGdldCBib2lsZWQgdG8gdGhpcyB1bml0XG4gICAgICAgIGZvciAoY29uc3QgYWsgaW4gYWNjdW11bGF0ZWQpIHtcbiAgICAgICAgICBvd24gKz0gdGhpcy5tYXRyaXhbYWtdW2tdICogYWNjdW11bGF0ZWRbYWtdO1xuICAgICAgICAgIGFjY3VtdWxhdGVkW2FrXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwbHVzIGFueXRoaW5nIHRoYXQncyBhbHJlYWR5IGluIHRoaXMgdW5pdFxuICAgICAgICBpZiAoaXNOdW1iZXIodmFsc1trXSkpIHtcbiAgICAgICAgICBvd24gKz0gdmFsc1trXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG9ubHkga2VlcCB0aGUgaW50ZWdlciBwYXJ0IGZvciBub3cgaW4gdGhlIGhvcGVzIG9mIHB1dHRpbmcgYW55IGRlY2ltYWwgcGFydFxuICAgICAgICAvLyBpbnRvIGEgc21hbGxlciB1bml0IGxhdGVyXG4gICAgICAgIGNvbnN0IGkgPSBNYXRoLnRydW5jKG93bik7XG4gICAgICAgIGJ1aWx0W2tdID0gaTtcbiAgICAgICAgYWNjdW11bGF0ZWRba10gPSAob3duICogMTAwMCAtIGkgKiAxMDAwKSAvIDEwMDA7XG5cbiAgICAgICAgLy8gb3RoZXJ3aXNlLCBrZWVwIGl0IGluIHRoZSB3aW5ncyB0byBib2lsIGl0IGxhdGVyXG4gICAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKHZhbHNba10pKSB7XG4gICAgICAgIGFjY3VtdWxhdGVkW2tdID0gdmFsc1trXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhbnl0aGluZyBsZWZ0b3ZlciBiZWNvbWVzIHRoZSBkZWNpbWFsIGZvciB0aGUgbGFzdCB1bml0XG4gICAgLy8gbGFzdFVuaXQgbXVzdCBiZSBkZWZpbmVkIHNpbmNlIHVuaXRzIGlzIG5vdCBlbXB0eVxuICAgIGZvciAoY29uc3Qga2V5IGluIGFjY3VtdWxhdGVkKSB7XG4gICAgICBpZiAoYWNjdW11bGF0ZWRba2V5XSAhPT0gMCkge1xuICAgICAgICBidWlsdFtsYXN0VW5pdF0gKz1cbiAgICAgICAgICBrZXkgPT09IGxhc3RVbml0ID8gYWNjdW11bGF0ZWRba2V5XSA6IGFjY3VtdWxhdGVkW2tleV0gLyB0aGlzLm1hdHJpeFtsYXN0VW5pdF1ba2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBub3JtYWxpemVWYWx1ZXModGhpcy5tYXRyaXgsIGJ1aWx0KTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywgeyB2YWx1ZXM6IGJ1aWx0IH0sIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNoaWZ0IHRoaXMgRHVyYXRpb24gdG8gYWxsIGF2YWlsYWJsZSB1bml0cy5cbiAgICogU2FtZSBhcyBzaGlmdFRvKFwieWVhcnNcIiwgXCJtb250aHNcIiwgXCJ3ZWVrc1wiLCBcImRheXNcIiwgXCJob3Vyc1wiLCBcIm1pbnV0ZXNcIiwgXCJzZWNvbmRzXCIsIFwibWlsbGlzZWNvbmRzXCIpXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgc2hpZnRUb0FsbCgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgcmV0dXJuIHRoaXMuc2hpZnRUbyhcbiAgICAgIFwieWVhcnNcIixcbiAgICAgIFwibW9udGhzXCIsXG4gICAgICBcIndlZWtzXCIsXG4gICAgICBcImRheXNcIixcbiAgICAgIFwiaG91cnNcIixcbiAgICAgIFwibWludXRlc1wiLFxuICAgICAgXCJzZWNvbmRzXCIsXG4gICAgICBcIm1pbGxpc2Vjb25kc1wiXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG5lZ2F0aXZlIG9mIHRoaXMgRHVyYXRpb24uXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMSwgc2Vjb25kczogMzAgfSkubmVnYXRlKCkudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IC0xLCBzZWNvbmRzOiAtMzAgfVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIG5lZ2F0ZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgbmVnYXRlZCA9IHt9O1xuICAgIGZvciAoY29uc3QgayBvZiBPYmplY3Qua2V5cyh0aGlzLnZhbHVlcykpIHtcbiAgICAgIG5lZ2F0ZWRba10gPSB0aGlzLnZhbHVlc1trXSA9PT0gMCA/IDAgOiAtdGhpcy52YWx1ZXNba107XG4gICAgfVxuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHZhbHVlczogbmVnYXRlZCB9LCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHllYXJzLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHllYXJzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy55ZWFycyB8fCAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcXVhcnRlcnMuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgcXVhcnRlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLnF1YXJ0ZXJzIHx8IDAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtb250aHMuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbW9udGhzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy5tb250aHMgfHwgMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHdlZWtzXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgd2Vla3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLndlZWtzIHx8IDAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkYXlzLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGRheXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLmRheXMgfHwgMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGhvdXJzLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGhvdXJzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy5ob3VycyB8fCAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWludXRlcy5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBtaW51dGVzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy5taW51dGVzIHx8IDAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzZWNvbmRzLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgc2Vjb25kcygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMuc2Vjb25kcyB8fCAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWlsbGlzZWNvbmRzLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbWlsbGlzZWNvbmRzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy5taWxsaXNlY29uZHMgfHwgMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIER1cmF0aW9uIGlzIGludmFsaWQuIEludmFsaWQgZHVyYXRpb25zIGFyZSByZXR1cm5lZCBieSBkaWZmIG9wZXJhdGlvbnNcbiAgICogb24gaW52YWxpZCBEYXRlVGltZXMgb3IgSW50ZXJ2YWxzLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZCA9PT0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGVycm9yIGNvZGUgaWYgdGhpcyBEdXJhdGlvbiBiZWNhbWUgaW52YWxpZCwgb3IgbnVsbCBpZiB0aGUgRHVyYXRpb24gaXMgdmFsaWRcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGludmFsaWRSZWFzb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZCA/IHRoaXMuaW52YWxpZC5yZWFzb24gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gZXhwbGFuYXRpb24gb2Ygd2h5IHRoaXMgRHVyYXRpb24gYmVjYW1lIGludmFsaWQsIG9yIG51bGwgaWYgdGhlIER1cmF0aW9uIGlzIHZhbGlkXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgaW52YWxpZEV4cGxhbmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmludmFsaWQgPyB0aGlzLmludmFsaWQuZXhwbGFuYXRpb24gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEVxdWFsaXR5IGNoZWNrXG4gICAqIFR3byBEdXJhdGlvbnMgYXJlIGVxdWFsIGlmZiB0aGV5IGhhdmUgdGhlIHNhbWUgdW5pdHMgYW5kIHRoZSBzYW1lIHZhbHVlcyBmb3IgZWFjaCB1bml0LlxuICAgKiBAcGFyYW0ge0R1cmF0aW9ufSBvdGhlclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQgfHwgIW90aGVyLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMubG9jLmVxdWFscyhvdGhlci5sb2MpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXEodjEsIHYyKSB7XG4gICAgICAvLyBDb25zaWRlciAwIGFuZCB1bmRlZmluZWQgYXMgZXF1YWxcbiAgICAgIGlmICh2MSA9PT0gdW5kZWZpbmVkIHx8IHYxID09PSAwKSByZXR1cm4gdjIgPT09IHVuZGVmaW5lZCB8fCB2MiA9PT0gMDtcbiAgICAgIHJldHVybiB2MSA9PT0gdjI7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCB1IG9mIG9yZGVyZWRVbml0cykge1xuICAgICAgaWYgKCFlcSh0aGlzLnZhbHVlc1t1XSwgb3RoZXIudmFsdWVzW3VdKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG4iLCIvLyB0aGVzZSBhcmVuJ3QgcmVhbGx5IHByaXZhdGUsIGJ1dCBub3IgYXJlIHRoZXkgcmVhbGx5IHVzZWZ1bCB0byBkb2N1bWVudFxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIEx1eG9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7fVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkRGF0ZVRpbWVFcnJvciBleHRlbmRzIEx1eG9uRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihyZWFzb24pIHtcbiAgICBzdXBlcihgSW52YWxpZCBEYXRlVGltZTogJHtyZWFzb24udG9NZXNzYWdlKCl9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZEludGVydmFsRXJyb3IgZXh0ZW5kcyBMdXhvbkVycm9yIHtcbiAgY29uc3RydWN0b3IocmVhc29uKSB7XG4gICAgc3VwZXIoYEludmFsaWQgSW50ZXJ2YWw6ICR7cmVhc29uLnRvTWVzc2FnZSgpfWApO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWREdXJhdGlvbkVycm9yIGV4dGVuZHMgTHV4b25FcnJvciB7XG4gIGNvbnN0cnVjdG9yKHJlYXNvbikge1xuICAgIHN1cGVyKGBJbnZhbGlkIER1cmF0aW9uOiAke3JlYXNvbi50b01lc3NhZ2UoKX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvciBleHRlbmRzIEx1eG9uRXJyb3Ige31cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZFVuaXRFcnJvciBleHRlbmRzIEx1eG9uRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih1bml0KSB7XG4gICAgc3VwZXIoYEludmFsaWQgdW5pdCAke3VuaXR9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZEFyZ3VtZW50RXJyb3IgZXh0ZW5kcyBMdXhvbkVycm9yIHt9XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIFpvbmVJc0Fic3RyYWN0RXJyb3IgZXh0ZW5kcyBMdXhvbkVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJab25lIGlzIGFuIGFic3RyYWN0IGNsYXNzXCIpO1xuICB9XG59XG4iLCJpbXBvcnQge1xuICBpbnRlZ2VyQmV0d2VlbixcbiAgaXNMZWFwWWVhcixcbiAgdGltZU9iamVjdCxcbiAgZGF5c0luWWVhcixcbiAgZGF5c0luTW9udGgsXG4gIHdlZWtzSW5XZWVrWWVhcixcbiAgaXNJbnRlZ2VyLFxufSBmcm9tIFwiLi91dGlsLmpzXCI7XG5pbXBvcnQgSW52YWxpZCBmcm9tIFwiLi9pbnZhbGlkLmpzXCI7XG5cbmNvbnN0IG5vbkxlYXBMYWRkZXIgPSBbMCwgMzEsIDU5LCA5MCwgMTIwLCAxNTEsIDE4MSwgMjEyLCAyNDMsIDI3MywgMzA0LCAzMzRdLFxuICBsZWFwTGFkZGVyID0gWzAsIDMxLCA2MCwgOTEsIDEyMSwgMTUyLCAxODIsIDIxMywgMjQ0LCAyNzQsIDMwNSwgMzM1XTtcblxuZnVuY3Rpb24gdW5pdE91dE9mUmFuZ2UodW5pdCwgdmFsdWUpIHtcbiAgcmV0dXJuIG5ldyBJbnZhbGlkKFxuICAgIFwidW5pdCBvdXQgb2YgcmFuZ2VcIixcbiAgICBgeW91IHNwZWNpZmllZCAke3ZhbHVlfSAob2YgdHlwZSAke3R5cGVvZiB2YWx1ZX0pIGFzIGEgJHt1bml0fSwgd2hpY2ggaXMgaW52YWxpZGBcbiAgKTtcbn1cblxuZnVuY3Rpb24gZGF5T2ZXZWVrKHllYXIsIG1vbnRoLCBkYXkpIHtcbiAgY29uc3QgZCA9IG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoIC0gMSwgZGF5KSk7XG5cbiAgaWYgKHllYXIgPCAxMDAgJiYgeWVhciA+PSAwKSB7XG4gICAgZC5zZXRVVENGdWxsWWVhcihkLmdldFVUQ0Z1bGxZZWFyKCkgLSAxOTAwKTtcbiAgfVxuXG4gIGNvbnN0IGpzID0gZC5nZXRVVENEYXkoKTtcblxuICByZXR1cm4ganMgPT09IDAgPyA3IDoganM7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVPcmRpbmFsKHllYXIsIG1vbnRoLCBkYXkpIHtcbiAgcmV0dXJuIGRheSArIChpc0xlYXBZZWFyKHllYXIpID8gbGVhcExhZGRlciA6IG5vbkxlYXBMYWRkZXIpW21vbnRoIC0gMV07XG59XG5cbmZ1bmN0aW9uIHVuY29tcHV0ZU9yZGluYWwoeWVhciwgb3JkaW5hbCkge1xuICBjb25zdCB0YWJsZSA9IGlzTGVhcFllYXIoeWVhcikgPyBsZWFwTGFkZGVyIDogbm9uTGVhcExhZGRlcixcbiAgICBtb250aDAgPSB0YWJsZS5maW5kSW5kZXgoKGkpID0+IGkgPCBvcmRpbmFsKSxcbiAgICBkYXkgPSBvcmRpbmFsIC0gdGFibGVbbW9udGgwXTtcbiAgcmV0dXJuIHsgbW9udGg6IG1vbnRoMCArIDEsIGRheSB9O1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGdyZWdvcmlhblRvV2VlayhncmVnT2JqKSB7XG4gIGNvbnN0IHsgeWVhciwgbW9udGgsIGRheSB9ID0gZ3JlZ09iaixcbiAgICBvcmRpbmFsID0gY29tcHV0ZU9yZGluYWwoeWVhciwgbW9udGgsIGRheSksXG4gICAgd2Vla2RheSA9IGRheU9mV2Vlayh5ZWFyLCBtb250aCwgZGF5KTtcblxuICBsZXQgd2Vla051bWJlciA9IE1hdGguZmxvb3IoKG9yZGluYWwgLSB3ZWVrZGF5ICsgMTApIC8gNyksXG4gICAgd2Vla1llYXI7XG5cbiAgaWYgKHdlZWtOdW1iZXIgPCAxKSB7XG4gICAgd2Vla1llYXIgPSB5ZWFyIC0gMTtcbiAgICB3ZWVrTnVtYmVyID0gd2Vla3NJbldlZWtZZWFyKHdlZWtZZWFyKTtcbiAgfSBlbHNlIGlmICh3ZWVrTnVtYmVyID4gd2Vla3NJbldlZWtZZWFyKHllYXIpKSB7XG4gICAgd2Vla1llYXIgPSB5ZWFyICsgMTtcbiAgICB3ZWVrTnVtYmVyID0gMTtcbiAgfSBlbHNlIHtcbiAgICB3ZWVrWWVhciA9IHllYXI7XG4gIH1cblxuICByZXR1cm4geyB3ZWVrWWVhciwgd2Vla051bWJlciwgd2Vla2RheSwgLi4udGltZU9iamVjdChncmVnT2JqKSB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2Vla1RvR3JlZ29yaWFuKHdlZWtEYXRhKSB7XG4gIGNvbnN0IHsgd2Vla1llYXIsIHdlZWtOdW1iZXIsIHdlZWtkYXkgfSA9IHdlZWtEYXRhLFxuICAgIHdlZWtkYXlPZkphbjQgPSBkYXlPZldlZWsod2Vla1llYXIsIDEsIDQpLFxuICAgIHllYXJJbkRheXMgPSBkYXlzSW5ZZWFyKHdlZWtZZWFyKTtcblxuICBsZXQgb3JkaW5hbCA9IHdlZWtOdW1iZXIgKiA3ICsgd2Vla2RheSAtIHdlZWtkYXlPZkphbjQgLSAzLFxuICAgIHllYXI7XG5cbiAgaWYgKG9yZGluYWwgPCAxKSB7XG4gICAgeWVhciA9IHdlZWtZZWFyIC0gMTtcbiAgICBvcmRpbmFsICs9IGRheXNJblllYXIoeWVhcik7XG4gIH0gZWxzZSBpZiAob3JkaW5hbCA+IHllYXJJbkRheXMpIHtcbiAgICB5ZWFyID0gd2Vla1llYXIgKyAxO1xuICAgIG9yZGluYWwgLT0gZGF5c0luWWVhcih3ZWVrWWVhcik7XG4gIH0gZWxzZSB7XG4gICAgeWVhciA9IHdlZWtZZWFyO1xuICB9XG5cbiAgY29uc3QgeyBtb250aCwgZGF5IH0gPSB1bmNvbXB1dGVPcmRpbmFsKHllYXIsIG9yZGluYWwpO1xuICByZXR1cm4geyB5ZWFyLCBtb250aCwgZGF5LCAuLi50aW1lT2JqZWN0KHdlZWtEYXRhKSB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ3JlZ29yaWFuVG9PcmRpbmFsKGdyZWdEYXRhKSB7XG4gIGNvbnN0IHsgeWVhciwgbW9udGgsIGRheSB9ID0gZ3JlZ0RhdGE7XG4gIGNvbnN0IG9yZGluYWwgPSBjb21wdXRlT3JkaW5hbCh5ZWFyLCBtb250aCwgZGF5KTtcbiAgcmV0dXJuIHsgeWVhciwgb3JkaW5hbCwgLi4udGltZU9iamVjdChncmVnRGF0YSkgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9yZGluYWxUb0dyZWdvcmlhbihvcmRpbmFsRGF0YSkge1xuICBjb25zdCB7IHllYXIsIG9yZGluYWwgfSA9IG9yZGluYWxEYXRhO1xuICBjb25zdCB7IG1vbnRoLCBkYXkgfSA9IHVuY29tcHV0ZU9yZGluYWwoeWVhciwgb3JkaW5hbCk7XG4gIHJldHVybiB7IHllYXIsIG1vbnRoLCBkYXksIC4uLnRpbWVPYmplY3Qob3JkaW5hbERhdGEpIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNJbnZhbGlkV2Vla0RhdGEob2JqKSB7XG4gIGNvbnN0IHZhbGlkWWVhciA9IGlzSW50ZWdlcihvYmoud2Vla1llYXIpLFxuICAgIHZhbGlkV2VlayA9IGludGVnZXJCZXR3ZWVuKG9iai53ZWVrTnVtYmVyLCAxLCB3ZWVrc0luV2Vla1llYXIob2JqLndlZWtZZWFyKSksXG4gICAgdmFsaWRXZWVrZGF5ID0gaW50ZWdlckJldHdlZW4ob2JqLndlZWtkYXksIDEsIDcpO1xuXG4gIGlmICghdmFsaWRZZWFyKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwid2Vla1llYXJcIiwgb2JqLndlZWtZZWFyKTtcbiAgfSBlbHNlIGlmICghdmFsaWRXZWVrKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwid2Vla1wiLCBvYmoud2Vlayk7XG4gIH0gZWxzZSBpZiAoIXZhbGlkV2Vla2RheSkge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcIndlZWtkYXlcIiwgb2JqLndlZWtkYXkpO1xuICB9IGVsc2UgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzSW52YWxpZE9yZGluYWxEYXRhKG9iaikge1xuICBjb25zdCB2YWxpZFllYXIgPSBpc0ludGVnZXIob2JqLnllYXIpLFxuICAgIHZhbGlkT3JkaW5hbCA9IGludGVnZXJCZXR3ZWVuKG9iai5vcmRpbmFsLCAxLCBkYXlzSW5ZZWFyKG9iai55ZWFyKSk7XG5cbiAgaWYgKCF2YWxpZFllYXIpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJ5ZWFyXCIsIG9iai55ZWFyKTtcbiAgfSBlbHNlIGlmICghdmFsaWRPcmRpbmFsKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwib3JkaW5hbFwiLCBvYmoub3JkaW5hbCk7XG4gIH0gZWxzZSByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNJbnZhbGlkR3JlZ29yaWFuRGF0YShvYmopIHtcbiAgY29uc3QgdmFsaWRZZWFyID0gaXNJbnRlZ2VyKG9iai55ZWFyKSxcbiAgICB2YWxpZE1vbnRoID0gaW50ZWdlckJldHdlZW4ob2JqLm1vbnRoLCAxLCAxMiksXG4gICAgdmFsaWREYXkgPSBpbnRlZ2VyQmV0d2VlbihvYmouZGF5LCAxLCBkYXlzSW5Nb250aChvYmoueWVhciwgb2JqLm1vbnRoKSk7XG5cbiAgaWYgKCF2YWxpZFllYXIpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJ5ZWFyXCIsIG9iai55ZWFyKTtcbiAgfSBlbHNlIGlmICghdmFsaWRNb250aCkge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcIm1vbnRoXCIsIG9iai5tb250aCk7XG4gIH0gZWxzZSBpZiAoIXZhbGlkRGF5KSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwiZGF5XCIsIG9iai5kYXkpO1xuICB9IGVsc2UgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzSW52YWxpZFRpbWVEYXRhKG9iaikge1xuICBjb25zdCB7IGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCB9ID0gb2JqO1xuICBjb25zdCB2YWxpZEhvdXIgPVxuICAgICAgaW50ZWdlckJldHdlZW4oaG91ciwgMCwgMjMpIHx8XG4gICAgICAoaG91ciA9PT0gMjQgJiYgbWludXRlID09PSAwICYmIHNlY29uZCA9PT0gMCAmJiBtaWxsaXNlY29uZCA9PT0gMCksXG4gICAgdmFsaWRNaW51dGUgPSBpbnRlZ2VyQmV0d2VlbihtaW51dGUsIDAsIDU5KSxcbiAgICB2YWxpZFNlY29uZCA9IGludGVnZXJCZXR3ZWVuKHNlY29uZCwgMCwgNTkpLFxuICAgIHZhbGlkTWlsbGlzZWNvbmQgPSBpbnRlZ2VyQmV0d2VlbihtaWxsaXNlY29uZCwgMCwgOTk5KTtcblxuICBpZiAoIXZhbGlkSG91cikge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcImhvdXJcIiwgaG91cik7XG4gIH0gZWxzZSBpZiAoIXZhbGlkTWludXRlKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwibWludXRlXCIsIG1pbnV0ZSk7XG4gIH0gZWxzZSBpZiAoIXZhbGlkU2Vjb25kKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwic2Vjb25kXCIsIHNlY29uZCk7XG4gIH0gZWxzZSBpZiAoIXZhbGlkTWlsbGlzZWNvbmQpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJtaWxsaXNlY29uZFwiLCBtaWxsaXNlY29uZCk7XG4gIH0gZWxzZSByZXR1cm4gZmFsc2U7XG59XG4iLCJpbXBvcnQgRHVyYXRpb24gZnJvbSBcIi4uL2R1cmF0aW9uLmpzXCI7XG5cbmZ1bmN0aW9uIGRheURpZmYoZWFybGllciwgbGF0ZXIpIHtcbiAgY29uc3QgdXRjRGF5U3RhcnQgPSAoZHQpID0+IGR0LnRvVVRDKDAsIHsga2VlcExvY2FsVGltZTogdHJ1ZSB9KS5zdGFydE9mKFwiZGF5XCIpLnZhbHVlT2YoKSxcbiAgICBtcyA9IHV0Y0RheVN0YXJ0KGxhdGVyKSAtIHV0Y0RheVN0YXJ0KGVhcmxpZXIpO1xuICByZXR1cm4gTWF0aC5mbG9vcihEdXJhdGlvbi5mcm9tTWlsbGlzKG1zKS5hcyhcImRheXNcIikpO1xufVxuXG5mdW5jdGlvbiBoaWdoT3JkZXJEaWZmcyhjdXJzb3IsIGxhdGVyLCB1bml0cykge1xuICBjb25zdCBkaWZmZXJzID0gW1xuICAgIFtcInllYXJzXCIsIChhLCBiKSA9PiBiLnllYXIgLSBhLnllYXJdLFxuICAgIFtcInF1YXJ0ZXJzXCIsIChhLCBiKSA9PiBiLnF1YXJ0ZXIgLSBhLnF1YXJ0ZXIgKyAoYi55ZWFyIC0gYS55ZWFyKSAqIDRdLFxuICAgIFtcIm1vbnRoc1wiLCAoYSwgYikgPT4gYi5tb250aCAtIGEubW9udGggKyAoYi55ZWFyIC0gYS55ZWFyKSAqIDEyXSxcbiAgICBbXG4gICAgICBcIndlZWtzXCIsXG4gICAgICAoYSwgYikgPT4ge1xuICAgICAgICBjb25zdCBkYXlzID0gZGF5RGlmZihhLCBiKTtcbiAgICAgICAgcmV0dXJuIChkYXlzIC0gKGRheXMgJSA3KSkgLyA3O1xuICAgICAgfSxcbiAgICBdLFxuICAgIFtcImRheXNcIiwgZGF5RGlmZl0sXG4gIF07XG5cbiAgY29uc3QgcmVzdWx0cyA9IHt9O1xuICBjb25zdCBlYXJsaWVyID0gY3Vyc29yO1xuICBsZXQgbG93ZXN0T3JkZXIsIGhpZ2hXYXRlcjtcblxuICAvKiBUaGlzIGxvb3AgdHJpZXMgdG8gZGlmZiB1c2luZyBsYXJnZXIgdW5pdHMgZmlyc3QuXG4gICAgIElmIHdlIG92ZXJzaG9vdCwgd2UgYmFja3RyYWNrIGFuZCB0cnkgdGhlIG5leHQgc21hbGxlciB1bml0LlxuICAgICBcImN1cnNvclwiIHN0YXJ0cyBvdXQgYXQgdGhlIGVhcmxpZXIgdGltZXN0YW1wIGFuZCBtb3ZlcyBjbG9zZXIgYW5kIGNsb3NlciB0byBcImxhdGVyXCJcbiAgICAgYXMgd2UgdXNlIHNtYWxsZXIgYW5kIHNtYWxsZXIgdW5pdHMuXG4gICAgIGhpZ2hXYXRlciBrZWVwcyB0cmFjayBvZiB3aGVyZSB3ZSB3b3VsZCBiZSBpZiB3ZSBhZGRlZCBvbmUgbW9yZSBvZiB0aGUgc21hbGxlc3QgdW5pdCxcbiAgICAgdGhpcyBpcyB1c2VkIGxhdGVyIHRvIHBvdGVudGlhbGx5IGNvbnZlcnQgYW55IGRpZmZlcmVuY2Ugc21hbGxlciB0aGFuIHRoZSBzbWFsbGVzdCBoaWdoZXIgb3JkZXIgdW5pdFxuICAgICBpbnRvIGEgZnJhY3Rpb24gb2YgdGhhdCBzbWFsbGVzdCBoaWdoZXIgb3JkZXIgdW5pdFxuICAqL1xuICBmb3IgKGNvbnN0IFt1bml0LCBkaWZmZXJdIG9mIGRpZmZlcnMpIHtcbiAgICBpZiAodW5pdHMuaW5kZXhPZih1bml0KSA+PSAwKSB7XG4gICAgICBsb3dlc3RPcmRlciA9IHVuaXQ7XG5cbiAgICAgIHJlc3VsdHNbdW5pdF0gPSBkaWZmZXIoY3Vyc29yLCBsYXRlcik7XG4gICAgICBoaWdoV2F0ZXIgPSBlYXJsaWVyLnBsdXMocmVzdWx0cyk7XG5cbiAgICAgIGlmIChoaWdoV2F0ZXIgPiBsYXRlcikge1xuICAgICAgICAvLyB3ZSBvdmVyc2hvdCB0aGUgZW5kIHBvaW50LCBiYWNrdHJhY2sgY3Vyc29yIGJ5IDFcbiAgICAgICAgcmVzdWx0c1t1bml0XS0tO1xuICAgICAgICBjdXJzb3IgPSBlYXJsaWVyLnBsdXMocmVzdWx0cyk7XG5cbiAgICAgICAgLy8gaWYgd2UgYXJlIHN0aWxsIG92ZXJzaG9vdGluZyBub3csIHdlIG5lZWQgdG8gYmFja3RyYWNrIGFnYWluXG4gICAgICAgIC8vIHRoaXMgaGFwcGVucyBpbiBjZXJ0YWluIHNpdHVhdGlvbnMgd2hlbiBkaWZmaW5nIHRpbWVzIGluIGRpZmZlcmVudCB6b25lcyxcbiAgICAgICAgLy8gYmVjYXVzZSB0aGlzIGNhbGN1bGF0aW9uIGlnbm9yZXMgdGltZSB6b25lc1xuICAgICAgICBpZiAoY3Vyc29yID4gbGF0ZXIpIHtcbiAgICAgICAgICAvLyBrZWVwIHRoZSBcIm92ZXJzaG90IGJ5IDFcIiBhcm91bmQgYXMgaGlnaFdhdGVyXG4gICAgICAgICAgaGlnaFdhdGVyID0gY3Vyc29yO1xuICAgICAgICAgIC8vIGJhY2t0cmFjayBjdXJzb3IgYnkgMVxuICAgICAgICAgIHJlc3VsdHNbdW5pdF0tLTtcbiAgICAgICAgICBjdXJzb3IgPSBlYXJsaWVyLnBsdXMocmVzdWx0cyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnNvciA9IGhpZ2hXYXRlcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gW2N1cnNvciwgcmVzdWx0cywgaGlnaFdhdGVyLCBsb3dlc3RPcmRlcl07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChlYXJsaWVyLCBsYXRlciwgdW5pdHMsIG9wdHMpIHtcbiAgbGV0IFtjdXJzb3IsIHJlc3VsdHMsIGhpZ2hXYXRlciwgbG93ZXN0T3JkZXJdID0gaGlnaE9yZGVyRGlmZnMoZWFybGllciwgbGF0ZXIsIHVuaXRzKTtcblxuICBjb25zdCByZW1haW5pbmdNaWxsaXMgPSBsYXRlciAtIGN1cnNvcjtcblxuICBjb25zdCBsb3dlck9yZGVyVW5pdHMgPSB1bml0cy5maWx0ZXIoXG4gICAgKHUpID0+IFtcImhvdXJzXCIsIFwibWludXRlc1wiLCBcInNlY29uZHNcIiwgXCJtaWxsaXNlY29uZHNcIl0uaW5kZXhPZih1KSA+PSAwXG4gICk7XG5cbiAgaWYgKGxvd2VyT3JkZXJVbml0cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaGlnaFdhdGVyIDwgbGF0ZXIpIHtcbiAgICAgIGhpZ2hXYXRlciA9IGN1cnNvci5wbHVzKHsgW2xvd2VzdE9yZGVyXTogMSB9KTtcbiAgICB9XG5cbiAgICBpZiAoaGlnaFdhdGVyICE9PSBjdXJzb3IpIHtcbiAgICAgIHJlc3VsdHNbbG93ZXN0T3JkZXJdID0gKHJlc3VsdHNbbG93ZXN0T3JkZXJdIHx8IDApICsgcmVtYWluaW5nTWlsbGlzIC8gKGhpZ2hXYXRlciAtIGN1cnNvcik7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgZHVyYXRpb24gPSBEdXJhdGlvbi5mcm9tT2JqZWN0KHJlc3VsdHMsIG9wdHMpO1xuXG4gIGlmIChsb3dlck9yZGVyVW5pdHMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBEdXJhdGlvbi5mcm9tTWlsbGlzKHJlbWFpbmluZ01pbGxpcywgb3B0cylcbiAgICAgIC5zaGlmdFRvKC4uLmxvd2VyT3JkZXJVbml0cylcbiAgICAgIC5wbHVzKGR1cmF0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZHVyYXRpb247XG4gIH1cbn1cbiIsImNvbnN0IG51bWJlcmluZ1N5c3RlbXMgPSB7XG4gIGFyYWI6IFwiW1xcdTA2NjAtXFx1MDY2OV1cIixcbiAgYXJhYmV4dDogXCJbXFx1MDZGMC1cXHUwNkY5XVwiLFxuICBiYWxpOiBcIltcXHUxQjUwLVxcdTFCNTldXCIsXG4gIGJlbmc6IFwiW1xcdTA5RTYtXFx1MDlFRl1cIixcbiAgZGV2YTogXCJbXFx1MDk2Ni1cXHUwOTZGXVwiLFxuICBmdWxsd2lkZTogXCJbXFx1RkYxMC1cXHVGRjE5XVwiLFxuICBndWpyOiBcIltcXHUwQUU2LVxcdTBBRUZdXCIsXG4gIGhhbmlkZWM6IFwiW+OAh3zkuIB85LqMfOS4iXzlm5t85LqUfOWFrXzkuIN85YWrfOS5nV1cIixcbiAga2htcjogXCJbXFx1MTdFMC1cXHUxN0U5XVwiLFxuICBrbmRhOiBcIltcXHUwQ0U2LVxcdTBDRUZdXCIsXG4gIGxhb286IFwiW1xcdTBFRDAtXFx1MEVEOV1cIixcbiAgbGltYjogXCJbXFx1MTk0Ni1cXHUxOTRGXVwiLFxuICBtbHltOiBcIltcXHUwRDY2LVxcdTBENkZdXCIsXG4gIG1vbmc6IFwiW1xcdTE4MTAtXFx1MTgxOV1cIixcbiAgbXltcjogXCJbXFx1MTA0MC1cXHUxMDQ5XVwiLFxuICBvcnlhOiBcIltcXHUwQjY2LVxcdTBCNkZdXCIsXG4gIHRhbWxkZWM6IFwiW1xcdTBCRTYtXFx1MEJFRl1cIixcbiAgdGVsdTogXCJbXFx1MEM2Ni1cXHUwQzZGXVwiLFxuICB0aGFpOiBcIltcXHUwRTUwLVxcdTBFNTldXCIsXG4gIHRpYnQ6IFwiW1xcdTBGMjAtXFx1MEYyOV1cIixcbiAgbGF0bjogXCJcXFxcZFwiLFxufTtcblxuY29uc3QgbnVtYmVyaW5nU3lzdGVtc1VURjE2ID0ge1xuICBhcmFiOiBbMTYzMiwgMTY0MV0sXG4gIGFyYWJleHQ6IFsxNzc2LCAxNzg1XSxcbiAgYmFsaTogWzY5OTIsIDcwMDFdLFxuICBiZW5nOiBbMjUzNCwgMjU0M10sXG4gIGRldmE6IFsyNDA2LCAyNDE1XSxcbiAgZnVsbHdpZGU6IFs2NTI5NiwgNjUzMDNdLFxuICBndWpyOiBbMjc5MCwgMjc5OV0sXG4gIGtobXI6IFs2MTEyLCA2MTIxXSxcbiAga25kYTogWzMzMDIsIDMzMTFdLFxuICBsYW9vOiBbMzc5MiwgMzgwMV0sXG4gIGxpbWI6IFs2NDcwLCA2NDc5XSxcbiAgbWx5bTogWzM0MzAsIDM0MzldLFxuICBtb25nOiBbNjE2MCwgNjE2OV0sXG4gIG15bXI6IFs0MTYwLCA0MTY5XSxcbiAgb3J5YTogWzI5MTgsIDI5MjddLFxuICB0YW1sZGVjOiBbMzA0NiwgMzA1NV0sXG4gIHRlbHU6IFszMTc0LCAzMTgzXSxcbiAgdGhhaTogWzM2NjQsIDM2NzNdLFxuICB0aWJ0OiBbMzg3MiwgMzg4MV0sXG59O1xuXG5jb25zdCBoYW5pZGVjQ2hhcnMgPSBudW1iZXJpbmdTeXN0ZW1zLmhhbmlkZWMucmVwbGFjZSgvW1xcW3xcXF1dL2csIFwiXCIpLnNwbGl0KFwiXCIpO1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VEaWdpdHMoc3RyKSB7XG4gIGxldCB2YWx1ZSA9IHBhcnNlSW50KHN0ciwgMTApO1xuICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgdmFsdWUgPSBcIlwiO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgIGlmIChzdHJbaV0uc2VhcmNoKG51bWJlcmluZ1N5c3RlbXMuaGFuaWRlYykgIT09IC0xKSB7XG4gICAgICAgIHZhbHVlICs9IGhhbmlkZWNDaGFycy5pbmRleE9mKHN0cltpXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBudW1iZXJpbmdTeXN0ZW1zVVRGMTYpIHtcbiAgICAgICAgICBjb25zdCBbbWluLCBtYXhdID0gbnVtYmVyaW5nU3lzdGVtc1VURjE2W2tleV07XG4gICAgICAgICAgaWYgKGNvZGUgPj0gbWluICYmIGNvZGUgPD0gbWF4KSB7XG4gICAgICAgICAgICB2YWx1ZSArPSBjb2RlIC0gbWluO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpZ2l0UmVnZXgoeyBudW1iZXJpbmdTeXN0ZW0gfSwgYXBwZW5kID0gXCJcIikge1xuICByZXR1cm4gbmV3IFJlZ0V4cChgJHtudW1iZXJpbmdTeXN0ZW1zW251bWJlcmluZ1N5c3RlbSB8fCBcImxhdG5cIl19JHthcHBlbmR9YCk7XG59XG4iLCJpbXBvcnQgKiBhcyBGb3JtYXRzIGZyb20gXCIuL2Zvcm1hdHMuanNcIjtcbmltcG9ydCB7IHBpY2sgfSBmcm9tIFwiLi91dGlsLmpzXCI7XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeShvYmopIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaiwgT2JqZWN0LmtleXMob2JqKS5zb3J0KCkpO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuZXhwb3J0IGNvbnN0IG1vbnRoc0xvbmcgPSBbXG4gIFwiSmFudWFyeVwiLFxuICBcIkZlYnJ1YXJ5XCIsXG4gIFwiTWFyY2hcIixcbiAgXCJBcHJpbFwiLFxuICBcIk1heVwiLFxuICBcIkp1bmVcIixcbiAgXCJKdWx5XCIsXG4gIFwiQXVndXN0XCIsXG4gIFwiU2VwdGVtYmVyXCIsXG4gIFwiT2N0b2JlclwiLFxuICBcIk5vdmVtYmVyXCIsXG4gIFwiRGVjZW1iZXJcIixcbl07XG5cbmV4cG9ydCBjb25zdCBtb250aHNTaG9ydCA9IFtcbiAgXCJKYW5cIixcbiAgXCJGZWJcIixcbiAgXCJNYXJcIixcbiAgXCJBcHJcIixcbiAgXCJNYXlcIixcbiAgXCJKdW5cIixcbiAgXCJKdWxcIixcbiAgXCJBdWdcIixcbiAgXCJTZXBcIixcbiAgXCJPY3RcIixcbiAgXCJOb3ZcIixcbiAgXCJEZWNcIixcbl07XG5cbmV4cG9ydCBjb25zdCBtb250aHNOYXJyb3cgPSBbXCJKXCIsIFwiRlwiLCBcIk1cIiwgXCJBXCIsIFwiTVwiLCBcIkpcIiwgXCJKXCIsIFwiQVwiLCBcIlNcIiwgXCJPXCIsIFwiTlwiLCBcIkRcIl07XG5cbmV4cG9ydCBmdW5jdGlvbiBtb250aHMobGVuZ3RoKSB7XG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSBcIm5hcnJvd1wiOlxuICAgICAgcmV0dXJuIFsuLi5tb250aHNOYXJyb3ddO1xuICAgIGNhc2UgXCJzaG9ydFwiOlxuICAgICAgcmV0dXJuIFsuLi5tb250aHNTaG9ydF07XG4gICAgY2FzZSBcImxvbmdcIjpcbiAgICAgIHJldHVybiBbLi4ubW9udGhzTG9uZ107XG4gICAgY2FzZSBcIm51bWVyaWNcIjpcbiAgICAgIHJldHVybiBbXCIxXCIsIFwiMlwiLCBcIjNcIiwgXCI0XCIsIFwiNVwiLCBcIjZcIiwgXCI3XCIsIFwiOFwiLCBcIjlcIiwgXCIxMFwiLCBcIjExXCIsIFwiMTJcIl07XG4gICAgY2FzZSBcIjItZGlnaXRcIjpcbiAgICAgIHJldHVybiBbXCIwMVwiLCBcIjAyXCIsIFwiMDNcIiwgXCIwNFwiLCBcIjA1XCIsIFwiMDZcIiwgXCIwN1wiLCBcIjA4XCIsIFwiMDlcIiwgXCIxMFwiLCBcIjExXCIsIFwiMTJcIl07XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCB3ZWVrZGF5c0xvbmcgPSBbXG4gIFwiTW9uZGF5XCIsXG4gIFwiVHVlc2RheVwiLFxuICBcIldlZG5lc2RheVwiLFxuICBcIlRodXJzZGF5XCIsXG4gIFwiRnJpZGF5XCIsXG4gIFwiU2F0dXJkYXlcIixcbiAgXCJTdW5kYXlcIixcbl07XG5cbmV4cG9ydCBjb25zdCB3ZWVrZGF5c1Nob3J0ID0gW1wiTW9uXCIsIFwiVHVlXCIsIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsIFwiU2F0XCIsIFwiU3VuXCJdO1xuXG5leHBvcnQgY29uc3Qgd2Vla2RheXNOYXJyb3cgPSBbXCJNXCIsIFwiVFwiLCBcIldcIiwgXCJUXCIsIFwiRlwiLCBcIlNcIiwgXCJTXCJdO1xuXG5leHBvcnQgZnVuY3Rpb24gd2Vla2RheXMobGVuZ3RoKSB7XG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSBcIm5hcnJvd1wiOlxuICAgICAgcmV0dXJuIFsuLi53ZWVrZGF5c05hcnJvd107XG4gICAgY2FzZSBcInNob3J0XCI6XG4gICAgICByZXR1cm4gWy4uLndlZWtkYXlzU2hvcnRdO1xuICAgIGNhc2UgXCJsb25nXCI6XG4gICAgICByZXR1cm4gWy4uLndlZWtkYXlzTG9uZ107XG4gICAgY2FzZSBcIm51bWVyaWNcIjpcbiAgICAgIHJldHVybiBbXCIxXCIsIFwiMlwiLCBcIjNcIiwgXCI0XCIsIFwiNVwiLCBcIjZcIiwgXCI3XCJdO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgbWVyaWRpZW1zID0gW1wiQU1cIiwgXCJQTVwiXTtcblxuZXhwb3J0IGNvbnN0IGVyYXNMb25nID0gW1wiQmVmb3JlIENocmlzdFwiLCBcIkFubm8gRG9taW5pXCJdO1xuXG5leHBvcnQgY29uc3QgZXJhc1Nob3J0ID0gW1wiQkNcIiwgXCJBRFwiXTtcblxuZXhwb3J0IGNvbnN0IGVyYXNOYXJyb3cgPSBbXCJCXCIsIFwiQVwiXTtcblxuZXhwb3J0IGZ1bmN0aW9uIGVyYXMobGVuZ3RoKSB7XG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSBcIm5hcnJvd1wiOlxuICAgICAgcmV0dXJuIFsuLi5lcmFzTmFycm93XTtcbiAgICBjYXNlIFwic2hvcnRcIjpcbiAgICAgIHJldHVybiBbLi4uZXJhc1Nob3J0XTtcbiAgICBjYXNlIFwibG9uZ1wiOlxuICAgICAgcmV0dXJuIFsuLi5lcmFzTG9uZ107XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtZXJpZGllbUZvckRhdGVUaW1lKGR0KSB7XG4gIHJldHVybiBtZXJpZGllbXNbZHQuaG91ciA8IDEyID8gMCA6IDFdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2Vla2RheUZvckRhdGVUaW1lKGR0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIHdlZWtkYXlzKGxlbmd0aClbZHQud2Vla2RheSAtIDFdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbW9udGhGb3JEYXRlVGltZShkdCwgbGVuZ3RoKSB7XG4gIHJldHVybiBtb250aHMobGVuZ3RoKVtkdC5tb250aCAtIDFdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXJhRm9yRGF0ZVRpbWUoZHQsIGxlbmd0aCkge1xuICByZXR1cm4gZXJhcyhsZW5ndGgpW2R0LnllYXIgPCAwID8gMCA6IDFdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0UmVsYXRpdmVUaW1lKHVuaXQsIGNvdW50LCBudW1lcmljID0gXCJhbHdheXNcIiwgbmFycm93ID0gZmFsc2UpIHtcbiAgY29uc3QgdW5pdHMgPSB7XG4gICAgeWVhcnM6IFtcInllYXJcIiwgXCJ5ci5cIl0sXG4gICAgcXVhcnRlcnM6IFtcInF1YXJ0ZXJcIiwgXCJxdHIuXCJdLFxuICAgIG1vbnRoczogW1wibW9udGhcIiwgXCJtby5cIl0sXG4gICAgd2Vla3M6IFtcIndlZWtcIiwgXCJ3ay5cIl0sXG4gICAgZGF5czogW1wiZGF5XCIsIFwiZGF5XCIsIFwiZGF5c1wiXSxcbiAgICBob3VyczogW1wiaG91clwiLCBcImhyLlwiXSxcbiAgICBtaW51dGVzOiBbXCJtaW51dGVcIiwgXCJtaW4uXCJdLFxuICAgIHNlY29uZHM6IFtcInNlY29uZFwiLCBcInNlYy5cIl0sXG4gIH07XG5cbiAgY29uc3QgbGFzdGFibGUgPSBbXCJob3Vyc1wiLCBcIm1pbnV0ZXNcIiwgXCJzZWNvbmRzXCJdLmluZGV4T2YodW5pdCkgPT09IC0xO1xuXG4gIGlmIChudW1lcmljID09PSBcImF1dG9cIiAmJiBsYXN0YWJsZSkge1xuICAgIGNvbnN0IGlzRGF5ID0gdW5pdCA9PT0gXCJkYXlzXCI7XG4gICAgc3dpdGNoIChjb3VudCkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gaXNEYXkgPyBcInRvbW9ycm93XCIgOiBgbmV4dCAke3VuaXRzW3VuaXRdWzBdfWA7XG4gICAgICBjYXNlIC0xOlxuICAgICAgICByZXR1cm4gaXNEYXkgPyBcInllc3RlcmRheVwiIDogYGxhc3QgJHt1bml0c1t1bml0XVswXX1gO1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gaXNEYXkgPyBcInRvZGF5XCIgOiBgdGhpcyAke3VuaXRzW3VuaXRdWzBdfWA7XG4gICAgICBkZWZhdWx0OiAvLyBmYWxsIHRocm91Z2hcbiAgICB9XG4gIH1cblxuICBjb25zdCBpc0luUGFzdCA9IE9iamVjdC5pcyhjb3VudCwgLTApIHx8IGNvdW50IDwgMCxcbiAgICBmbXRWYWx1ZSA9IE1hdGguYWJzKGNvdW50KSxcbiAgICBzaW5ndWxhciA9IGZtdFZhbHVlID09PSAxLFxuICAgIGxpbFVuaXRzID0gdW5pdHNbdW5pdF0sXG4gICAgZm10VW5pdCA9IG5hcnJvd1xuICAgICAgPyBzaW5ndWxhclxuICAgICAgICA/IGxpbFVuaXRzWzFdXG4gICAgICAgIDogbGlsVW5pdHNbMl0gfHwgbGlsVW5pdHNbMV1cbiAgICAgIDogc2luZ3VsYXJcbiAgICAgID8gdW5pdHNbdW5pdF1bMF1cbiAgICAgIDogdW5pdDtcbiAgcmV0dXJuIGlzSW5QYXN0ID8gYCR7Zm10VmFsdWV9ICR7Zm10VW5pdH0gYWdvYCA6IGBpbiAke2ZtdFZhbHVlfSAke2ZtdFVuaXR9YDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFN0cmluZyhrbm93bkZvcm1hdCkge1xuICAvLyB0aGVzZSBhbGwgaGF2ZSB0aGUgb2Zmc2V0cyByZW1vdmVkIGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBhY2Nlc3MgdG8gdGhlbVxuICAvLyB3aXRob3V0IGFsbCB0aGUgaW50bCBzdHVmZiB0aGlzIGlzIGJhY2tmaWxsaW5nXG4gIGNvbnN0IGZpbHRlcmVkID0gcGljayhrbm93bkZvcm1hdCwgW1xuICAgICAgXCJ3ZWVrZGF5XCIsXG4gICAgICBcImVyYVwiLFxuICAgICAgXCJ5ZWFyXCIsXG4gICAgICBcIm1vbnRoXCIsXG4gICAgICBcImRheVwiLFxuICAgICAgXCJob3VyXCIsXG4gICAgICBcIm1pbnV0ZVwiLFxuICAgICAgXCJzZWNvbmRcIixcbiAgICAgIFwidGltZVpvbmVOYW1lXCIsXG4gICAgICBcImhvdXJDeWNsZVwiLFxuICAgIF0pLFxuICAgIGtleSA9IHN0cmluZ2lmeShmaWx0ZXJlZCksXG4gICAgZGF0ZVRpbWVIdWdlID0gXCJFRUVFLCBMTExMIGQsIHl5eXksIGg6bW0gYVwiO1xuICBzd2l0Y2ggKGtleSkge1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURV9TSE9SVCk6XG4gICAgICByZXR1cm4gXCJNL2QveXl5eVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURV9NRUQpOlxuICAgICAgcmV0dXJuIFwiTExMIGQsIHl5eXlcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVfTUVEX1dJVEhfV0VFS0RBWSk6XG4gICAgICByZXR1cm4gXCJFRUUsIExMTCBkLCB5eXl5XCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFX0ZVTEwpOlxuICAgICAgcmV0dXJuIFwiTExMTCBkLCB5eXl5XCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFX0hVR0UpOlxuICAgICAgcmV0dXJuIFwiRUVFRSwgTExMTCBkLCB5eXl5XCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5USU1FX1NJTVBMRSk6XG4gICAgICByZXR1cm4gXCJoOm1tIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLlRJTUVfV0lUSF9TRUNPTkRTKTpcbiAgICAgIHJldHVybiBcImg6bW06c3MgYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuVElNRV9XSVRIX1NIT1JUX09GRlNFVCk6XG4gICAgICByZXR1cm4gXCJoOm1tIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLlRJTUVfV0lUSF9MT05HX09GRlNFVCk6XG4gICAgICByZXR1cm4gXCJoOm1tIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLlRJTUVfMjRfU0lNUExFKTpcbiAgICAgIHJldHVybiBcIkhIOm1tXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5USU1FXzI0X1dJVEhfU0VDT05EUyk6XG4gICAgICByZXR1cm4gXCJISDptbTpzc1wiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuVElNRV8yNF9XSVRIX1NIT1JUX09GRlNFVCk6XG4gICAgICByZXR1cm4gXCJISDptbVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuVElNRV8yNF9XSVRIX0xPTkdfT0ZGU0VUKTpcbiAgICAgIHJldHVybiBcIkhIOm1tXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFVElNRV9TSE9SVCk6XG4gICAgICByZXR1cm4gXCJNL2QveXl5eSwgaDptbSBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFVElNRV9NRUQpOlxuICAgICAgcmV0dXJuIFwiTExMIGQsIHl5eXksIGg6bW0gYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURVRJTUVfRlVMTCk6XG4gICAgICByZXR1cm4gXCJMTExMIGQsIHl5eXksIGg6bW0gYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURVRJTUVfSFVHRSk6XG4gICAgICByZXR1cm4gZGF0ZVRpbWVIdWdlO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURVRJTUVfU0hPUlRfV0lUSF9TRUNPTkRTKTpcbiAgICAgIHJldHVybiBcIk0vZC95eXl5LCBoOm1tOnNzIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVUSU1FX01FRF9XSVRIX1NFQ09ORFMpOlxuICAgICAgcmV0dXJuIFwiTExMIGQsIHl5eXksIGg6bW06c3MgYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURVRJTUVfTUVEX1dJVEhfV0VFS0RBWSk6XG4gICAgICByZXR1cm4gXCJFRUUsIGQgTExMIHl5eXksIGg6bW0gYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURVRJTUVfRlVMTF9XSVRIX1NFQ09ORFMpOlxuICAgICAgcmV0dXJuIFwiTExMTCBkLCB5eXl5LCBoOm1tOnNzIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVUSU1FX0hVR0VfV0lUSF9TRUNPTkRTKTpcbiAgICAgIHJldHVybiBcIkVFRUUsIExMTEwgZCwgeXl5eSwgaDptbTpzcyBhXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBkYXRlVGltZUh1Z2U7XG4gIH1cbn1cbiIsIi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5jb25zdCBuID0gXCJudW1lcmljXCIsXG4gIHMgPSBcInNob3J0XCIsXG4gIGwgPSBcImxvbmdcIjtcblxuZXhwb3J0IGNvbnN0IERBVEVfU0hPUlQgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBuLFxuICBkYXk6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgREFURV9NRUQgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBzLFxuICBkYXk6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgREFURV9NRURfV0lUSF9XRUVLREFZID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogcyxcbiAgZGF5OiBuLFxuICB3ZWVrZGF5OiBzLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVfRlVMTCA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IGwsXG4gIGRheTogbixcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFX0hVR0UgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBsLFxuICBkYXk6IG4sXG4gIHdlZWtkYXk6IGwsXG59O1xuXG5leHBvcnQgY29uc3QgVElNRV9TSU1QTEUgPSB7XG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbn07XG5cbmV4cG9ydCBjb25zdCBUSU1FX1dJVEhfU0VDT05EUyA9IHtcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgVElNRV9XSVRIX1NIT1JUX09GRlNFVCA9IHtcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG4gIHRpbWVab25lTmFtZTogcyxcbn07XG5cbmV4cG9ydCBjb25zdCBUSU1FX1dJVEhfTE9OR19PRkZTRVQgPSB7XG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxuICB0aW1lWm9uZU5hbWU6IGwsXG59O1xuXG5leHBvcnQgY29uc3QgVElNRV8yNF9TSU1QTEUgPSB7XG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgaG91ckN5Y2xlOiBcImgyM1wiLFxufTtcblxuZXhwb3J0IGNvbnN0IFRJTUVfMjRfV0lUSF9TRUNPTkRTID0ge1xuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbiAgaG91ckN5Y2xlOiBcImgyM1wiLFxufTtcblxuZXhwb3J0IGNvbnN0IFRJTUVfMjRfV0lUSF9TSE9SVF9PRkZTRVQgPSB7XG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxuICBob3VyQ3ljbGU6IFwiaDIzXCIsXG4gIHRpbWVab25lTmFtZTogcyxcbn07XG5cbmV4cG9ydCBjb25zdCBUSU1FXzI0X1dJVEhfTE9OR19PRkZTRVQgPSB7XG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxuICBob3VyQ3ljbGU6IFwiaDIzXCIsXG4gIHRpbWVab25lTmFtZTogbCxcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFVElNRV9TSE9SVCA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IG4sXG4gIGRheTogbixcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVUSU1FX1NIT1JUX1dJVEhfU0VDT05EUyA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IG4sXG4gIGRheTogbixcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgREFURVRJTUVfTUVEID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogcyxcbiAgZGF5OiBuLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgREFURVRJTUVfTUVEX1dJVEhfU0VDT05EUyA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IHMsXG4gIGRheTogbixcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgREFURVRJTUVfTUVEX1dJVEhfV0VFS0RBWSA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IHMsXG4gIGRheTogbixcbiAgd2Vla2RheTogcyxcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVUSU1FX0ZVTEwgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBsLFxuICBkYXk6IG4sXG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgdGltZVpvbmVOYW1lOiBzLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVUSU1FX0ZVTExfV0lUSF9TRUNPTkRTID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogbCxcbiAgZGF5OiBuLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbiAgdGltZVpvbmVOYW1lOiBzLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVUSU1FX0hVR0UgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBsLFxuICBkYXk6IG4sXG4gIHdlZWtkYXk6IGwsXG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgdGltZVpvbmVOYW1lOiBsLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVUSU1FX0hVR0VfV0lUSF9TRUNPTkRTID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogbCxcbiAgZGF5OiBuLFxuICB3ZWVrZGF5OiBsLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbiAgdGltZVpvbmVOYW1lOiBsLFxufTtcbiIsImltcG9ydCAqIGFzIEVuZ2xpc2ggZnJvbSBcIi4vZW5nbGlzaC5qc1wiO1xuaW1wb3J0ICogYXMgRm9ybWF0cyBmcm9tIFwiLi9mb3JtYXRzLmpzXCI7XG5pbXBvcnQgeyBwYWRTdGFydCB9IGZyb20gXCIuL3V0aWwuanNcIjtcblxuZnVuY3Rpb24gc3RyaW5naWZ5VG9rZW5zKHNwbGl0cywgdG9rZW5Ub1N0cmluZykge1xuICBsZXQgcyA9IFwiXCI7XG4gIGZvciAoY29uc3QgdG9rZW4gb2Ygc3BsaXRzKSB7XG4gICAgaWYgKHRva2VuLmxpdGVyYWwpIHtcbiAgICAgIHMgKz0gdG9rZW4udmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzICs9IHRva2VuVG9TdHJpbmcodG9rZW4udmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHM7XG59XG5cbmNvbnN0IG1hY3JvVG9rZW5Ub0Zvcm1hdE9wdHMgPSB7XG4gIEQ6IEZvcm1hdHMuREFURV9TSE9SVCxcbiAgREQ6IEZvcm1hdHMuREFURV9NRUQsXG4gIERERDogRm9ybWF0cy5EQVRFX0ZVTEwsXG4gIEREREQ6IEZvcm1hdHMuREFURV9IVUdFLFxuICB0OiBGb3JtYXRzLlRJTUVfU0lNUExFLFxuICB0dDogRm9ybWF0cy5USU1FX1dJVEhfU0VDT05EUyxcbiAgdHR0OiBGb3JtYXRzLlRJTUVfV0lUSF9TSE9SVF9PRkZTRVQsXG4gIHR0dHQ6IEZvcm1hdHMuVElNRV9XSVRIX0xPTkdfT0ZGU0VULFxuICBUOiBGb3JtYXRzLlRJTUVfMjRfU0lNUExFLFxuICBUVDogRm9ybWF0cy5USU1FXzI0X1dJVEhfU0VDT05EUyxcbiAgVFRUOiBGb3JtYXRzLlRJTUVfMjRfV0lUSF9TSE9SVF9PRkZTRVQsXG4gIFRUVFQ6IEZvcm1hdHMuVElNRV8yNF9XSVRIX0xPTkdfT0ZGU0VULFxuICBmOiBGb3JtYXRzLkRBVEVUSU1FX1NIT1JULFxuICBmZjogRm9ybWF0cy5EQVRFVElNRV9NRUQsXG4gIGZmZjogRm9ybWF0cy5EQVRFVElNRV9GVUxMLFxuICBmZmZmOiBGb3JtYXRzLkRBVEVUSU1FX0hVR0UsXG4gIEY6IEZvcm1hdHMuREFURVRJTUVfU0hPUlRfV0lUSF9TRUNPTkRTLFxuICBGRjogRm9ybWF0cy5EQVRFVElNRV9NRURfV0lUSF9TRUNPTkRTLFxuICBGRkY6IEZvcm1hdHMuREFURVRJTUVfRlVMTF9XSVRIX1NFQ09ORFMsXG4gIEZGRkY6IEZvcm1hdHMuREFURVRJTUVfSFVHRV9XSVRIX1NFQ09ORFMsXG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRm9ybWF0dGVyIHtcbiAgc3RhdGljIGNyZWF0ZShsb2NhbGUsIG9wdHMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgRm9ybWF0dGVyKGxvY2FsZSwgb3B0cyk7XG4gIH1cblxuICBzdGF0aWMgcGFyc2VGb3JtYXQoZm10KSB7XG4gICAgLy8gd2hpdGUtc3BhY2UgaXMgYWx3YXlzIGNvbnNpZGVyZWQgYSBsaXRlcmFsIGluIHVzZXItcHJvdmlkZWQgZm9ybWF0c1xuICAgIC8vIHRoZSBcIiBcIiB0b2tlbiBoYXMgYSBzcGVjaWFsIG1lYW5pbmcgKHNlZSB1bml0Rm9yVG9rZW4pXG5cbiAgICBsZXQgY3VycmVudCA9IG51bGwsXG4gICAgICBjdXJyZW50RnVsbCA9IFwiXCIsXG4gICAgICBicmFja2V0ZWQgPSBmYWxzZTtcbiAgICBjb25zdCBzcGxpdHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZtdC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYyA9IGZtdC5jaGFyQXQoaSk7XG4gICAgICBpZiAoYyA9PT0gXCInXCIpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRGdWxsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBzcGxpdHMucHVzaCh7IGxpdGVyYWw6IGJyYWNrZXRlZCB8fCAvXlxccyskLy50ZXN0KGN1cnJlbnRGdWxsKSwgdmFsOiBjdXJyZW50RnVsbCB9KTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gbnVsbDtcbiAgICAgICAgY3VycmVudEZ1bGwgPSBcIlwiO1xuICAgICAgICBicmFja2V0ZWQgPSAhYnJhY2tldGVkO1xuICAgICAgfSBlbHNlIGlmIChicmFja2V0ZWQpIHtcbiAgICAgICAgY3VycmVudEZ1bGwgKz0gYztcbiAgICAgIH0gZWxzZSBpZiAoYyA9PT0gY3VycmVudCkge1xuICAgICAgICBjdXJyZW50RnVsbCArPSBjO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGN1cnJlbnRGdWxsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBzcGxpdHMucHVzaCh7IGxpdGVyYWw6IC9eXFxzKyQvLnRlc3QoY3VycmVudEZ1bGwpLCB2YWw6IGN1cnJlbnRGdWxsIH0pO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRGdWxsID0gYztcbiAgICAgICAgY3VycmVudCA9IGM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRGdWxsLmxlbmd0aCA+IDApIHtcbiAgICAgIHNwbGl0cy5wdXNoKHsgbGl0ZXJhbDogYnJhY2tldGVkIHx8IC9eXFxzKyQvLnRlc3QoY3VycmVudEZ1bGwpLCB2YWw6IGN1cnJlbnRGdWxsIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBzcGxpdHM7XG4gIH1cblxuICBzdGF0aWMgbWFjcm9Ub2tlblRvRm9ybWF0T3B0cyh0b2tlbikge1xuICAgIHJldHVybiBtYWNyb1Rva2VuVG9Gb3JtYXRPcHRzW3Rva2VuXTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGxvY2FsZSwgZm9ybWF0T3B0cykge1xuICAgIHRoaXMub3B0cyA9IGZvcm1hdE9wdHM7XG4gICAgdGhpcy5sb2MgPSBsb2NhbGU7XG4gICAgdGhpcy5zeXN0ZW1Mb2MgPSBudWxsO1xuICB9XG5cbiAgZm9ybWF0V2l0aFN5c3RlbURlZmF1bHQoZHQsIG9wdHMpIHtcbiAgICBpZiAodGhpcy5zeXN0ZW1Mb2MgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuc3lzdGVtTG9jID0gdGhpcy5sb2MucmVkZWZhdWx0VG9TeXN0ZW0oKTtcbiAgICB9XG4gICAgY29uc3QgZGYgPSB0aGlzLnN5c3RlbUxvYy5kdEZvcm1hdHRlcihkdCwgeyAuLi50aGlzLm9wdHMsIC4uLm9wdHMgfSk7XG4gICAgcmV0dXJuIGRmLmZvcm1hdCgpO1xuICB9XG5cbiAgZHRGb3JtYXR0ZXIoZHQsIG9wdHMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmxvYy5kdEZvcm1hdHRlcihkdCwgeyAuLi50aGlzLm9wdHMsIC4uLm9wdHMgfSk7XG4gIH1cblxuICBmb3JtYXREYXRlVGltZShkdCwgb3B0cykge1xuICAgIHJldHVybiB0aGlzLmR0Rm9ybWF0dGVyKGR0LCBvcHRzKS5mb3JtYXQoKTtcbiAgfVxuXG4gIGZvcm1hdERhdGVUaW1lUGFydHMoZHQsIG9wdHMpIHtcbiAgICByZXR1cm4gdGhpcy5kdEZvcm1hdHRlcihkdCwgb3B0cykuZm9ybWF0VG9QYXJ0cygpO1xuICB9XG5cbiAgZm9ybWF0SW50ZXJ2YWwoaW50ZXJ2YWwsIG9wdHMpIHtcbiAgICBjb25zdCBkZiA9IHRoaXMuZHRGb3JtYXR0ZXIoaW50ZXJ2YWwuc3RhcnQsIG9wdHMpO1xuICAgIHJldHVybiBkZi5kdGYuZm9ybWF0UmFuZ2UoaW50ZXJ2YWwuc3RhcnQudG9KU0RhdGUoKSwgaW50ZXJ2YWwuZW5kLnRvSlNEYXRlKCkpO1xuICB9XG5cbiAgcmVzb2x2ZWRPcHRpb25zKGR0LCBvcHRzKSB7XG4gICAgcmV0dXJuIHRoaXMuZHRGb3JtYXR0ZXIoZHQsIG9wdHMpLnJlc29sdmVkT3B0aW9ucygpO1xuICB9XG5cbiAgbnVtKG4sIHAgPSAwKSB7XG4gICAgLy8gd2UgZ2V0IHNvbWUgcGVyZiBvdXQgb2YgZG9pbmcgdGhpcyBoZXJlLCBhbm5veWluZ2x5XG4gICAgaWYgKHRoaXMub3B0cy5mb3JjZVNpbXBsZSkge1xuICAgICAgcmV0dXJuIHBhZFN0YXJ0KG4sIHApO1xuICAgIH1cblxuICAgIGNvbnN0IG9wdHMgPSB7IC4uLnRoaXMub3B0cyB9O1xuXG4gICAgaWYgKHAgPiAwKSB7XG4gICAgICBvcHRzLnBhZFRvID0gcDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5sb2MubnVtYmVyRm9ybWF0dGVyKG9wdHMpLmZvcm1hdChuKTtcbiAgfVxuXG4gIGZvcm1hdERhdGVUaW1lRnJvbVN0cmluZyhkdCwgZm10KSB7XG4gICAgY29uc3Qga25vd25FbmdsaXNoID0gdGhpcy5sb2MubGlzdGluZ01vZGUoKSA9PT0gXCJlblwiLFxuICAgICAgdXNlRGF0ZVRpbWVGb3JtYXR0ZXIgPSB0aGlzLmxvYy5vdXRwdXRDYWxlbmRhciAmJiB0aGlzLmxvYy5vdXRwdXRDYWxlbmRhciAhPT0gXCJncmVnb3J5XCIsXG4gICAgICBzdHJpbmcgPSAob3B0cywgZXh0cmFjdCkgPT4gdGhpcy5sb2MuZXh0cmFjdChkdCwgb3B0cywgZXh0cmFjdCksXG4gICAgICBmb3JtYXRPZmZzZXQgPSAob3B0cykgPT4ge1xuICAgICAgICBpZiAoZHQuaXNPZmZzZXRGaXhlZCAmJiBkdC5vZmZzZXQgPT09IDAgJiYgb3B0cy5hbGxvd1opIHtcbiAgICAgICAgICByZXR1cm4gXCJaXCI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZHQuaXNWYWxpZCA/IGR0LnpvbmUuZm9ybWF0T2Zmc2V0KGR0LnRzLCBvcHRzLmZvcm1hdCkgOiBcIlwiO1xuICAgICAgfSxcbiAgICAgIG1lcmlkaWVtID0gKCkgPT5cbiAgICAgICAga25vd25FbmdsaXNoXG4gICAgICAgICAgPyBFbmdsaXNoLm1lcmlkaWVtRm9yRGF0ZVRpbWUoZHQpXG4gICAgICAgICAgOiBzdHJpbmcoeyBob3VyOiBcIm51bWVyaWNcIiwgaG91ckN5Y2xlOiBcImgxMlwiIH0sIFwiZGF5cGVyaW9kXCIpLFxuICAgICAgbW9udGggPSAobGVuZ3RoLCBzdGFuZGFsb25lKSA9PlxuICAgICAgICBrbm93bkVuZ2xpc2hcbiAgICAgICAgICA/IEVuZ2xpc2gubW9udGhGb3JEYXRlVGltZShkdCwgbGVuZ3RoKVxuICAgICAgICAgIDogc3RyaW5nKHN0YW5kYWxvbmUgPyB7IG1vbnRoOiBsZW5ndGggfSA6IHsgbW9udGg6IGxlbmd0aCwgZGF5OiBcIm51bWVyaWNcIiB9LCBcIm1vbnRoXCIpLFxuICAgICAgd2Vla2RheSA9IChsZW5ndGgsIHN0YW5kYWxvbmUpID0+XG4gICAgICAgIGtub3duRW5nbGlzaFxuICAgICAgICAgID8gRW5nbGlzaC53ZWVrZGF5Rm9yRGF0ZVRpbWUoZHQsIGxlbmd0aClcbiAgICAgICAgICA6IHN0cmluZyhcbiAgICAgICAgICAgICAgc3RhbmRhbG9uZSA/IHsgd2Vla2RheTogbGVuZ3RoIH0gOiB7IHdlZWtkYXk6IGxlbmd0aCwgbW9udGg6IFwibG9uZ1wiLCBkYXk6IFwibnVtZXJpY1wiIH0sXG4gICAgICAgICAgICAgIFwid2Vla2RheVwiXG4gICAgICAgICAgICApLFxuICAgICAgbWF5YmVNYWNybyA9ICh0b2tlbikgPT4ge1xuICAgICAgICBjb25zdCBmb3JtYXRPcHRzID0gRm9ybWF0dGVyLm1hY3JvVG9rZW5Ub0Zvcm1hdE9wdHModG9rZW4pO1xuICAgICAgICBpZiAoZm9ybWF0T3B0cykge1xuICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdFdpdGhTeXN0ZW1EZWZhdWx0KGR0LCBmb3JtYXRPcHRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBlcmEgPSAobGVuZ3RoKSA9PlxuICAgICAgICBrbm93bkVuZ2xpc2ggPyBFbmdsaXNoLmVyYUZvckRhdGVUaW1lKGR0LCBsZW5ndGgpIDogc3RyaW5nKHsgZXJhOiBsZW5ndGggfSwgXCJlcmFcIiksXG4gICAgICB0b2tlblRvU3RyaW5nID0gKHRva2VuKSA9PiB7XG4gICAgICAgIC8vIFdoZXJlIHBvc3NpYmxlOiBodHRwczovL2NsZHIudW5pY29kZS5vcmcvdHJhbnNsYXRpb24vZGF0ZS10aW1lL2RhdGUtdGltZS1zeW1ib2xzXG4gICAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgICAvLyBtc1xuICAgICAgICAgIGNhc2UgXCJTXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQubWlsbGlzZWNvbmQpO1xuICAgICAgICAgIGNhc2UgXCJ1XCI6XG4gICAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgICAgIGNhc2UgXCJTU1NcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5taWxsaXNlY29uZCwgMyk7XG4gICAgICAgICAgLy8gc2Vjb25kc1xuICAgICAgICAgIGNhc2UgXCJzXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQuc2Vjb25kKTtcbiAgICAgICAgICBjYXNlIFwic3NcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5zZWNvbmQsIDIpO1xuICAgICAgICAgIC8vIGZyYWN0aW9uYWwgc2Vjb25kc1xuICAgICAgICAgIGNhc2UgXCJ1dVwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKE1hdGguZmxvb3IoZHQubWlsbGlzZWNvbmQgLyAxMCksIDIpO1xuICAgICAgICAgIGNhc2UgXCJ1dXVcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShNYXRoLmZsb29yKGR0Lm1pbGxpc2Vjb25kIC8gMTAwKSk7XG4gICAgICAgICAgLy8gbWludXRlc1xuICAgICAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQubWludXRlKTtcbiAgICAgICAgICBjYXNlIFwibW1cIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5taW51dGUsIDIpO1xuICAgICAgICAgIC8vIGhvdXJzXG4gICAgICAgICAgY2FzZSBcImhcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5ob3VyICUgMTIgPT09IDAgPyAxMiA6IGR0LmhvdXIgJSAxMik7XG4gICAgICAgICAgY2FzZSBcImhoXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQuaG91ciAlIDEyID09PSAwID8gMTIgOiBkdC5ob3VyICUgMTIsIDIpO1xuICAgICAgICAgIGNhc2UgXCJIXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQuaG91cik7XG4gICAgICAgICAgY2FzZSBcIkhIXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQuaG91ciwgMik7XG4gICAgICAgICAgLy8gb2Zmc2V0XG4gICAgICAgICAgY2FzZSBcIlpcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgKzZcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRPZmZzZXQoeyBmb3JtYXQ6IFwibmFycm93XCIsIGFsbG93WjogdGhpcy5vcHRzLmFsbG93WiB9KTtcbiAgICAgICAgICBjYXNlIFwiWlpcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgKzA2OjAwXG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0T2Zmc2V0KHsgZm9ybWF0OiBcInNob3J0XCIsIGFsbG93WjogdGhpcy5vcHRzLmFsbG93WiB9KTtcbiAgICAgICAgICBjYXNlIFwiWlpaXCI6XG4gICAgICAgICAgICAvLyBsaWtlICswNjAwXG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0T2Zmc2V0KHsgZm9ybWF0OiBcInRlY2hpZVwiLCBhbGxvd1o6IHRoaXMub3B0cy5hbGxvd1ogfSk7XG4gICAgICAgICAgY2FzZSBcIlpaWlpcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgRVNUXG4gICAgICAgICAgICByZXR1cm4gZHQuem9uZS5vZmZzZXROYW1lKGR0LnRzLCB7IGZvcm1hdDogXCJzaG9ydFwiLCBsb2NhbGU6IHRoaXMubG9jLmxvY2FsZSB9KTtcbiAgICAgICAgICBjYXNlIFwiWlpaWlpcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgRWFzdGVybiBTdGFuZGFyZCBUaW1lXG4gICAgICAgICAgICByZXR1cm4gZHQuem9uZS5vZmZzZXROYW1lKGR0LnRzLCB7IGZvcm1hdDogXCJsb25nXCIsIGxvY2FsZTogdGhpcy5sb2MubG9jYWxlIH0pO1xuICAgICAgICAgIC8vIHpvbmVcbiAgICAgICAgICBjYXNlIFwielwiOlxuICAgICAgICAgICAgLy8gbGlrZSBBbWVyaWNhL05ld19Zb3JrXG4gICAgICAgICAgICByZXR1cm4gZHQuem9uZU5hbWU7XG4gICAgICAgICAgLy8gbWVyaWRpZW1zXG4gICAgICAgICAgY2FzZSBcImFcIjpcbiAgICAgICAgICAgIHJldHVybiBtZXJpZGllbSgpO1xuICAgICAgICAgIC8vIGRhdGVzXG4gICAgICAgICAgY2FzZSBcImRcIjpcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlciA/IHN0cmluZyh7IGRheTogXCJudW1lcmljXCIgfSwgXCJkYXlcIikgOiB0aGlzLm51bShkdC5kYXkpO1xuICAgICAgICAgIGNhc2UgXCJkZFwiOlxuICAgICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyID8gc3RyaW5nKHsgZGF5OiBcIjItZGlnaXRcIiB9LCBcImRheVwiKSA6IHRoaXMubnVtKGR0LmRheSwgMik7XG4gICAgICAgICAgLy8gd2Vla2RheXMgLSBzdGFuZGFsb25lXG4gICAgICAgICAgY2FzZSBcImNcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LndlZWtkYXkpO1xuICAgICAgICAgIGNhc2UgXCJjY2NcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgJ1R1ZXMnXG4gICAgICAgICAgICByZXR1cm4gd2Vla2RheShcInNob3J0XCIsIHRydWUpO1xuICAgICAgICAgIGNhc2UgXCJjY2NjXCI6XG4gICAgICAgICAgICAvLyBsaWtlICdUdWVzZGF5J1xuICAgICAgICAgICAgcmV0dXJuIHdlZWtkYXkoXCJsb25nXCIsIHRydWUpO1xuICAgICAgICAgIGNhc2UgXCJjY2NjY1wiOlxuICAgICAgICAgICAgLy8gbGlrZSAnVCdcbiAgICAgICAgICAgIHJldHVybiB3ZWVrZGF5KFwibmFycm93XCIsIHRydWUpO1xuICAgICAgICAgIC8vIHdlZWtkYXlzIC0gZm9ybWF0XG4gICAgICAgICAgY2FzZSBcIkVcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LndlZWtkYXkpO1xuICAgICAgICAgIGNhc2UgXCJFRUVcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgJ1R1ZXMnXG4gICAgICAgICAgICByZXR1cm4gd2Vla2RheShcInNob3J0XCIsIGZhbHNlKTtcbiAgICAgICAgICBjYXNlIFwiRUVFRVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAnVHVlc2RheSdcbiAgICAgICAgICAgIHJldHVybiB3ZWVrZGF5KFwibG9uZ1wiLCBmYWxzZSk7XG4gICAgICAgICAgY2FzZSBcIkVFRUVFXCI6XG4gICAgICAgICAgICAvLyBsaWtlICdUJ1xuICAgICAgICAgICAgcmV0dXJuIHdlZWtkYXkoXCJuYXJyb3dcIiwgZmFsc2UpO1xuICAgICAgICAgIC8vIG1vbnRocyAtIHN0YW5kYWxvbmVcbiAgICAgICAgICBjYXNlIFwiTFwiOlxuICAgICAgICAgICAgLy8gbGlrZSAxXG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXJcbiAgICAgICAgICAgICAgPyBzdHJpbmcoeyBtb250aDogXCJudW1lcmljXCIsIGRheTogXCJudW1lcmljXCIgfSwgXCJtb250aFwiKVxuICAgICAgICAgICAgICA6IHRoaXMubnVtKGR0Lm1vbnRoKTtcbiAgICAgICAgICBjYXNlIFwiTExcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMDEsIGRvZXNuJ3Qgc2VlbSB0byB3b3JrXG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXJcbiAgICAgICAgICAgICAgPyBzdHJpbmcoeyBtb250aDogXCIyLWRpZ2l0XCIsIGRheTogXCJudW1lcmljXCIgfSwgXCJtb250aFwiKVxuICAgICAgICAgICAgICA6IHRoaXMubnVtKGR0Lm1vbnRoLCAyKTtcbiAgICAgICAgICBjYXNlIFwiTExMXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEphblxuICAgICAgICAgICAgcmV0dXJuIG1vbnRoKFwic2hvcnRcIiwgdHJ1ZSk7XG4gICAgICAgICAgY2FzZSBcIkxMTExcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgSmFudWFyeVxuICAgICAgICAgICAgcmV0dXJuIG1vbnRoKFwibG9uZ1wiLCB0cnVlKTtcbiAgICAgICAgICBjYXNlIFwiTExMTExcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgSlxuICAgICAgICAgICAgcmV0dXJuIG1vbnRoKFwibmFycm93XCIsIHRydWUpO1xuICAgICAgICAgIC8vIG1vbnRocyAtIGZvcm1hdFxuICAgICAgICAgIGNhc2UgXCJNXCI6XG4gICAgICAgICAgICAvLyBsaWtlIDFcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlclxuICAgICAgICAgICAgICA/IHN0cmluZyh7IG1vbnRoOiBcIm51bWVyaWNcIiB9LCBcIm1vbnRoXCIpXG4gICAgICAgICAgICAgIDogdGhpcy5udW0oZHQubW9udGgpO1xuICAgICAgICAgIGNhc2UgXCJNTVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAwMVxuICAgICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyXG4gICAgICAgICAgICAgID8gc3RyaW5nKHsgbW9udGg6IFwiMi1kaWdpdFwiIH0sIFwibW9udGhcIilcbiAgICAgICAgICAgICAgOiB0aGlzLm51bShkdC5tb250aCwgMik7XG4gICAgICAgICAgY2FzZSBcIk1NTVwiOlxuICAgICAgICAgICAgLy8gbGlrZSBKYW5cbiAgICAgICAgICAgIHJldHVybiBtb250aChcInNob3J0XCIsIGZhbHNlKTtcbiAgICAgICAgICBjYXNlIFwiTU1NTVwiOlxuICAgICAgICAgICAgLy8gbGlrZSBKYW51YXJ5XG4gICAgICAgICAgICByZXR1cm4gbW9udGgoXCJsb25nXCIsIGZhbHNlKTtcbiAgICAgICAgICBjYXNlIFwiTU1NTU1cIjpcbiAgICAgICAgICAgIC8vIGxpa2UgSlxuICAgICAgICAgICAgcmV0dXJuIG1vbnRoKFwibmFycm93XCIsIGZhbHNlKTtcbiAgICAgICAgICAvLyB5ZWFyc1xuICAgICAgICAgIGNhc2UgXCJ5XCI6XG4gICAgICAgICAgICAvLyBsaWtlIDIwMTRcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlciA/IHN0cmluZyh7IHllYXI6IFwibnVtZXJpY1wiIH0sIFwieWVhclwiKSA6IHRoaXMubnVtKGR0LnllYXIpO1xuICAgICAgICAgIGNhc2UgXCJ5eVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAxNFxuICAgICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyXG4gICAgICAgICAgICAgID8gc3RyaW5nKHsgeWVhcjogXCIyLWRpZ2l0XCIgfSwgXCJ5ZWFyXCIpXG4gICAgICAgICAgICAgIDogdGhpcy5udW0oZHQueWVhci50b1N0cmluZygpLnNsaWNlKC0yKSwgMik7XG4gICAgICAgICAgY2FzZSBcInl5eXlcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMDAxMlxuICAgICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyXG4gICAgICAgICAgICAgID8gc3RyaW5nKHsgeWVhcjogXCJudW1lcmljXCIgfSwgXCJ5ZWFyXCIpXG4gICAgICAgICAgICAgIDogdGhpcy5udW0oZHQueWVhciwgNCk7XG4gICAgICAgICAgY2FzZSBcInl5eXl5eVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAwMDAwMTJcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlclxuICAgICAgICAgICAgICA/IHN0cmluZyh7IHllYXI6IFwibnVtZXJpY1wiIH0sIFwieWVhclwiKVxuICAgICAgICAgICAgICA6IHRoaXMubnVtKGR0LnllYXIsIDYpO1xuICAgICAgICAgIC8vIGVyYXNcbiAgICAgICAgICBjYXNlIFwiR1wiOlxuICAgICAgICAgICAgLy8gbGlrZSBBRFxuICAgICAgICAgICAgcmV0dXJuIGVyYShcInNob3J0XCIpO1xuICAgICAgICAgIGNhc2UgXCJHR1wiOlxuICAgICAgICAgICAgLy8gbGlrZSBBbm5vIERvbWluaVxuICAgICAgICAgICAgcmV0dXJuIGVyYShcImxvbmdcIik7XG4gICAgICAgICAgY2FzZSBcIkdHR0dHXCI6XG4gICAgICAgICAgICByZXR1cm4gZXJhKFwibmFycm93XCIpO1xuICAgICAgICAgIGNhc2UgXCJra1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LndlZWtZZWFyLnRvU3RyaW5nKCkuc2xpY2UoLTIpLCAyKTtcbiAgICAgICAgICBjYXNlIFwia2tra1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LndlZWtZZWFyLCA0KTtcbiAgICAgICAgICBjYXNlIFwiV1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LndlZWtOdW1iZXIpO1xuICAgICAgICAgIGNhc2UgXCJXV1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LndlZWtOdW1iZXIsIDIpO1xuICAgICAgICAgIGNhc2UgXCJvXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQub3JkaW5hbCk7XG4gICAgICAgICAgY2FzZSBcIm9vb1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0Lm9yZGluYWwsIDMpO1xuICAgICAgICAgIGNhc2UgXCJxXCI6XG4gICAgICAgICAgICAvLyBsaWtlIDFcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5xdWFydGVyKTtcbiAgICAgICAgICBjYXNlIFwicXFcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMDFcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5xdWFydGVyLCAyKTtcbiAgICAgICAgICBjYXNlIFwiWFwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKE1hdGguZmxvb3IoZHQudHMgLyAxMDAwKSk7XG4gICAgICAgICAgY2FzZSBcInhcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC50cyk7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBtYXliZU1hY3JvKHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgIHJldHVybiBzdHJpbmdpZnlUb2tlbnMoRm9ybWF0dGVyLnBhcnNlRm9ybWF0KGZtdCksIHRva2VuVG9TdHJpbmcpO1xuICB9XG5cbiAgZm9ybWF0RHVyYXRpb25Gcm9tU3RyaW5nKGR1ciwgZm10KSB7XG4gICAgY29uc3QgdG9rZW5Ub0ZpZWxkID0gKHRva2VuKSA9PiB7XG4gICAgICAgIHN3aXRjaCAodG9rZW5bMF0pIHtcbiAgICAgICAgICBjYXNlIFwiU1wiOlxuICAgICAgICAgICAgcmV0dXJuIFwibWlsbGlzZWNvbmRcIjtcbiAgICAgICAgICBjYXNlIFwic1wiOlxuICAgICAgICAgICAgcmV0dXJuIFwic2Vjb25kXCI7XG4gICAgICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgICAgIHJldHVybiBcIm1pbnV0ZVwiO1xuICAgICAgICAgIGNhc2UgXCJoXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJob3VyXCI7XG4gICAgICAgICAgY2FzZSBcImRcIjpcbiAgICAgICAgICAgIHJldHVybiBcImRheVwiO1xuICAgICAgICAgIGNhc2UgXCJ3XCI6XG4gICAgICAgICAgICByZXR1cm4gXCJ3ZWVrXCI7XG4gICAgICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgICAgIHJldHVybiBcIm1vbnRoXCI7XG4gICAgICAgICAgY2FzZSBcInlcIjpcbiAgICAgICAgICAgIHJldHVybiBcInllYXJcIjtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0b2tlblRvU3RyaW5nID0gKGxpbGR1cikgPT4gKHRva2VuKSA9PiB7XG4gICAgICAgIGNvbnN0IG1hcHBlZCA9IHRva2VuVG9GaWVsZCh0b2tlbik7XG4gICAgICAgIGlmIChtYXBwZWQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5udW0obGlsZHVyLmdldChtYXBwZWQpLCB0b2tlbi5sZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRva2VucyA9IEZvcm1hdHRlci5wYXJzZUZvcm1hdChmbXQpLFxuICAgICAgcmVhbFRva2VucyA9IHRva2Vucy5yZWR1Y2UoXG4gICAgICAgIChmb3VuZCwgeyBsaXRlcmFsLCB2YWwgfSkgPT4gKGxpdGVyYWwgPyBmb3VuZCA6IGZvdW5kLmNvbmNhdCh2YWwpKSxcbiAgICAgICAgW11cbiAgICAgICksXG4gICAgICBjb2xsYXBzZWQgPSBkdXIuc2hpZnRUbyguLi5yZWFsVG9rZW5zLm1hcCh0b2tlblRvRmllbGQpLmZpbHRlcigodCkgPT4gdCkpO1xuICAgIHJldHVybiBzdHJpbmdpZnlUb2tlbnModG9rZW5zLCB0b2tlblRvU3RyaW5nKGNvbGxhcHNlZCkpO1xuICB9XG59XG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBJbnZhbGlkIHtcbiAgY29uc3RydWN0b3IocmVhc29uLCBleHBsYW5hdGlvbikge1xuICAgIHRoaXMucmVhc29uID0gcmVhc29uO1xuICAgIHRoaXMuZXhwbGFuYXRpb24gPSBleHBsYW5hdGlvbjtcbiAgfVxuXG4gIHRvTWVzc2FnZSgpIHtcbiAgICBpZiAodGhpcy5leHBsYW5hdGlvbikge1xuICAgICAgcmV0dXJuIGAke3RoaXMucmVhc29ufTogJHt0aGlzLmV4cGxhbmF0aW9ufWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnJlYXNvbjtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7IHBhZFN0YXJ0LCByb3VuZFRvLCBoYXNSZWxhdGl2ZSwgZm9ybWF0T2Zmc2V0IH0gZnJvbSBcIi4vdXRpbC5qc1wiO1xuaW1wb3J0ICogYXMgRW5nbGlzaCBmcm9tIFwiLi9lbmdsaXNoLmpzXCI7XG5pbXBvcnQgU2V0dGluZ3MgZnJvbSBcIi4uL3NldHRpbmdzLmpzXCI7XG5pbXBvcnQgRGF0ZVRpbWUgZnJvbSBcIi4uL2RhdGV0aW1lLmpzXCI7XG5pbXBvcnQgSUFOQVpvbmUgZnJvbSBcIi4uL3pvbmVzL0lBTkFab25lLmpzXCI7XG5cbi8vIHRvZG8gLSByZW1hcCBjYWNoaW5nXG5cbmxldCBpbnRsTEZDYWNoZSA9IHt9O1xuZnVuY3Rpb24gZ2V0Q2FjaGVkTEYobG9jU3RyaW5nLCBvcHRzID0ge30pIHtcbiAgY29uc3Qga2V5ID0gSlNPTi5zdHJpbmdpZnkoW2xvY1N0cmluZywgb3B0c10pO1xuICBsZXQgZHRmID0gaW50bExGQ2FjaGVba2V5XTtcbiAgaWYgKCFkdGYpIHtcbiAgICBkdGYgPSBuZXcgSW50bC5MaXN0Rm9ybWF0KGxvY1N0cmluZywgb3B0cyk7XG4gICAgaW50bExGQ2FjaGVba2V5XSA9IGR0ZjtcbiAgfVxuICByZXR1cm4gZHRmO1xufVxuXG5sZXQgaW50bERUQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGdldENhY2hlZERURihsb2NTdHJpbmcsIG9wdHMgPSB7fSkge1xuICBjb25zdCBrZXkgPSBKU09OLnN0cmluZ2lmeShbbG9jU3RyaW5nLCBvcHRzXSk7XG4gIGxldCBkdGYgPSBpbnRsRFRDYWNoZVtrZXldO1xuICBpZiAoIWR0Zikge1xuICAgIGR0ZiA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY1N0cmluZywgb3B0cyk7XG4gICAgaW50bERUQ2FjaGVba2V5XSA9IGR0ZjtcbiAgfVxuICByZXR1cm4gZHRmO1xufVxuXG5sZXQgaW50bE51bUNhY2hlID0ge307XG5mdW5jdGlvbiBnZXRDYWNoZWRJTkYobG9jU3RyaW5nLCBvcHRzID0ge30pIHtcbiAgY29uc3Qga2V5ID0gSlNPTi5zdHJpbmdpZnkoW2xvY1N0cmluZywgb3B0c10pO1xuICBsZXQgaW5mID0gaW50bE51bUNhY2hlW2tleV07XG4gIGlmICghaW5mKSB7XG4gICAgaW5mID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KGxvY1N0cmluZywgb3B0cyk7XG4gICAgaW50bE51bUNhY2hlW2tleV0gPSBpbmY7XG4gIH1cbiAgcmV0dXJuIGluZjtcbn1cblxubGV0IGludGxSZWxDYWNoZSA9IHt9O1xuZnVuY3Rpb24gZ2V0Q2FjaGVkUlRGKGxvY1N0cmluZywgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IHsgYmFzZSwgLi4uY2FjaGVLZXlPcHRzIH0gPSBvcHRzOyAvLyBleGNsdWRlIGBiYXNlYCBmcm9tIHRoZSBvcHRpb25zXG4gIGNvbnN0IGtleSA9IEpTT04uc3RyaW5naWZ5KFtsb2NTdHJpbmcsIGNhY2hlS2V5T3B0c10pO1xuICBsZXQgaW5mID0gaW50bFJlbENhY2hlW2tleV07XG4gIGlmICghaW5mKSB7XG4gICAgaW5mID0gbmV3IEludGwuUmVsYXRpdmVUaW1lRm9ybWF0KGxvY1N0cmluZywgb3B0cyk7XG4gICAgaW50bFJlbENhY2hlW2tleV0gPSBpbmY7XG4gIH1cbiAgcmV0dXJuIGluZjtcbn1cblxubGV0IHN5c0xvY2FsZUNhY2hlID0gbnVsbDtcbmZ1bmN0aW9uIHN5c3RlbUxvY2FsZSgpIHtcbiAgaWYgKHN5c0xvY2FsZUNhY2hlKSB7XG4gICAgcmV0dXJuIHN5c0xvY2FsZUNhY2hlO1xuICB9IGVsc2Uge1xuICAgIHN5c0xvY2FsZUNhY2hlID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoKS5yZXNvbHZlZE9wdGlvbnMoKS5sb2NhbGU7XG4gICAgcmV0dXJuIHN5c0xvY2FsZUNhY2hlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlTG9jYWxlU3RyaW5nKGxvY2FsZVN0cikge1xuICAvLyBJIHJlYWxseSB3YW50IHRvIGF2b2lkIHdyaXRpbmcgYSBCQ1AgNDcgcGFyc2VyXG4gIC8vIHNlZSwgZS5nLiBodHRwczovL2dpdGh1Yi5jb20vd29vb3JtL2JjcC00N1xuICAvLyBJbnN0ZWFkLCB3ZSdsbCBkbyB0aGlzOlxuXG4gIC8vIGEpIGlmIHRoZSBzdHJpbmcgaGFzIG5vIC11IGV4dGVuc2lvbnMsIGp1c3QgbGVhdmUgaXQgYWxvbmVcbiAgLy8gYikgaWYgaXQgZG9lcywgdXNlIEludGwgdG8gcmVzb2x2ZSBldmVyeXRoaW5nXG4gIC8vIGMpIGlmIEludGwgZmFpbHMsIHRyeSBhZ2FpbiB3aXRob3V0IHRoZSAtdVxuXG4gIC8vIHByaXZhdGUgc3VidGFncyBhbmQgdW5pY29kZSBzdWJ0YWdzIGhhdmUgb3JkZXJpbmcgcmVxdWlyZW1lbnRzLFxuICAvLyBhbmQgd2UncmUgbm90IHByb3Blcmx5IHBhcnNpbmcgdGhpcywgc28ganVzdCBzdHJpcCBvdXQgdGhlXG4gIC8vIHByaXZhdGUgb25lcyBpZiB0aGV5IGV4aXN0LlxuICBjb25zdCB4SW5kZXggPSBsb2NhbGVTdHIuaW5kZXhPZihcIi14LVwiKTtcbiAgaWYgKHhJbmRleCAhPT0gLTEpIHtcbiAgICBsb2NhbGVTdHIgPSBsb2NhbGVTdHIuc3Vic3RyaW5nKDAsIHhJbmRleCk7XG4gIH1cblxuICBjb25zdCB1SW5kZXggPSBsb2NhbGVTdHIuaW5kZXhPZihcIi11LVwiKTtcbiAgaWYgKHVJbmRleCA9PT0gLTEpIHtcbiAgICByZXR1cm4gW2xvY2FsZVN0cl07XG4gIH0gZWxzZSB7XG4gICAgbGV0IG9wdGlvbnM7XG4gICAgbGV0IHNlbGVjdGVkU3RyO1xuICAgIHRyeSB7XG4gICAgICBvcHRpb25zID0gZ2V0Q2FjaGVkRFRGKGxvY2FsZVN0cikucmVzb2x2ZWRPcHRpb25zKCk7XG4gICAgICBzZWxlY3RlZFN0ciA9IGxvY2FsZVN0cjtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zdCBzbWFsbGVyID0gbG9jYWxlU3RyLnN1YnN0cmluZygwLCB1SW5kZXgpO1xuICAgICAgb3B0aW9ucyA9IGdldENhY2hlZERURihzbWFsbGVyKS5yZXNvbHZlZE9wdGlvbnMoKTtcbiAgICAgIHNlbGVjdGVkU3RyID0gc21hbGxlcjtcbiAgICB9XG5cbiAgICBjb25zdCB7IG51bWJlcmluZ1N5c3RlbSwgY2FsZW5kYXIgfSA9IG9wdGlvbnM7XG4gICAgcmV0dXJuIFtzZWxlY3RlZFN0ciwgbnVtYmVyaW5nU3lzdGVtLCBjYWxlbmRhcl07XG4gIH1cbn1cblxuZnVuY3Rpb24gaW50bENvbmZpZ1N0cmluZyhsb2NhbGVTdHIsIG51bWJlcmluZ1N5c3RlbSwgb3V0cHV0Q2FsZW5kYXIpIHtcbiAgaWYgKG91dHB1dENhbGVuZGFyIHx8IG51bWJlcmluZ1N5c3RlbSkge1xuICAgIGlmICghbG9jYWxlU3RyLmluY2x1ZGVzKFwiLXUtXCIpKSB7XG4gICAgICBsb2NhbGVTdHIgKz0gXCItdVwiO1xuICAgIH1cblxuICAgIGlmIChvdXRwdXRDYWxlbmRhcikge1xuICAgICAgbG9jYWxlU3RyICs9IGAtY2EtJHtvdXRwdXRDYWxlbmRhcn1gO1xuICAgIH1cblxuICAgIGlmIChudW1iZXJpbmdTeXN0ZW0pIHtcbiAgICAgIGxvY2FsZVN0ciArPSBgLW51LSR7bnVtYmVyaW5nU3lzdGVtfWA7XG4gICAgfVxuICAgIHJldHVybiBsb2NhbGVTdHI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxvY2FsZVN0cjtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXBNb250aHMoZikge1xuICBjb25zdCBtcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMTsgaSA8PSAxMjsgaSsrKSB7XG4gICAgY29uc3QgZHQgPSBEYXRlVGltZS51dGMoMjAwOSwgaSwgMSk7XG4gICAgbXMucHVzaChmKGR0KSk7XG4gIH1cbiAgcmV0dXJuIG1zO1xufVxuXG5mdW5jdGlvbiBtYXBXZWVrZGF5cyhmKSB7XG4gIGNvbnN0IG1zID0gW107XG4gIGZvciAobGV0IGkgPSAxOyBpIDw9IDc7IGkrKykge1xuICAgIGNvbnN0IGR0ID0gRGF0ZVRpbWUudXRjKDIwMTYsIDExLCAxMyArIGkpO1xuICAgIG1zLnB1c2goZihkdCkpO1xuICB9XG4gIHJldHVybiBtcztcbn1cblxuZnVuY3Rpb24gbGlzdFN0dWZmKGxvYywgbGVuZ3RoLCBlbmdsaXNoRm4sIGludGxGbikge1xuICBjb25zdCBtb2RlID0gbG9jLmxpc3RpbmdNb2RlKCk7XG5cbiAgaWYgKG1vZGUgPT09IFwiZXJyb3JcIikge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2UgaWYgKG1vZGUgPT09IFwiZW5cIikge1xuICAgIHJldHVybiBlbmdsaXNoRm4obGVuZ3RoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaW50bEZuKGxlbmd0aCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3VwcG9ydHNGYXN0TnVtYmVycyhsb2MpIHtcbiAgaWYgKGxvYy5udW1iZXJpbmdTeXN0ZW0gJiYgbG9jLm51bWJlcmluZ1N5c3RlbSAhPT0gXCJsYXRuXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGxvYy5udW1iZXJpbmdTeXN0ZW0gPT09IFwibGF0blwiIHx8XG4gICAgICAhbG9jLmxvY2FsZSB8fFxuICAgICAgbG9jLmxvY2FsZS5zdGFydHNXaXRoKFwiZW5cIikgfHxcbiAgICAgIG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvYy5pbnRsKS5yZXNvbHZlZE9wdGlvbnMoKS5udW1iZXJpbmdTeXN0ZW0gPT09IFwibGF0blwiXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuY2xhc3MgUG9seU51bWJlckZvcm1hdHRlciB7XG4gIGNvbnN0cnVjdG9yKGludGwsIGZvcmNlU2ltcGxlLCBvcHRzKSB7XG4gICAgdGhpcy5wYWRUbyA9IG9wdHMucGFkVG8gfHwgMDtcbiAgICB0aGlzLmZsb29yID0gb3B0cy5mbG9vciB8fCBmYWxzZTtcblxuICAgIGNvbnN0IHsgcGFkVG8sIGZsb29yLCAuLi5vdGhlck9wdHMgfSA9IG9wdHM7XG5cbiAgICBpZiAoIWZvcmNlU2ltcGxlIHx8IE9iamVjdC5rZXlzKG90aGVyT3B0cykubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgaW50bE9wdHMgPSB7IHVzZUdyb3VwaW5nOiBmYWxzZSwgLi4ub3B0cyB9O1xuICAgICAgaWYgKG9wdHMucGFkVG8gPiAwKSBpbnRsT3B0cy5taW5pbXVtSW50ZWdlckRpZ2l0cyA9IG9wdHMucGFkVG87XG4gICAgICB0aGlzLmluZiA9IGdldENhY2hlZElORihpbnRsLCBpbnRsT3B0cyk7XG4gICAgfVxuICB9XG5cbiAgZm9ybWF0KGkpIHtcbiAgICBpZiAodGhpcy5pbmYpIHtcbiAgICAgIGNvbnN0IGZpeGVkID0gdGhpcy5mbG9vciA/IE1hdGguZmxvb3IoaSkgOiBpO1xuICAgICAgcmV0dXJuIHRoaXMuaW5mLmZvcm1hdChmaXhlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRvIG1hdGNoIHRoZSBicm93c2VyJ3MgbnVtYmVyZm9ybWF0dGVyIGRlZmF1bHRzXG4gICAgICBjb25zdCBmaXhlZCA9IHRoaXMuZmxvb3IgPyBNYXRoLmZsb29yKGkpIDogcm91bmRUbyhpLCAzKTtcbiAgICAgIHJldHVybiBwYWRTdGFydChmaXhlZCwgdGhpcy5wYWRUbyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5jbGFzcyBQb2x5RGF0ZUZvcm1hdHRlciB7XG4gIGNvbnN0cnVjdG9yKGR0LCBpbnRsLCBvcHRzKSB7XG4gICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICB0aGlzLm9yaWdpbmFsWm9uZSA9IHVuZGVmaW5lZDtcblxuICAgIGxldCB6ID0gdW5kZWZpbmVkO1xuICAgIGlmICh0aGlzLm9wdHMudGltZVpvbmUpIHtcbiAgICAgIC8vIERvbid0IGFwcGx5IGFueSB3b3JrYXJvdW5kcyBpZiBhIHRpbWVab25lIGlzIGV4cGxpY2l0bHkgcHJvdmlkZWQgaW4gb3B0c1xuICAgICAgdGhpcy5kdCA9IGR0O1xuICAgIH0gZWxzZSBpZiAoZHQuem9uZS50eXBlID09PSBcImZpeGVkXCIpIHtcbiAgICAgIC8vIFVUQy04IG9yIEV0Yy9VVEMtOCBhcmUgbm90IHBhcnQgb2YgdHpkYXRhLCBvbmx5IEV0Yy9HTVQrOCBhbmQgdGhlIGxpa2UuXG4gICAgICAvLyBUaGF0IGlzIHdoeSBmaXhlZC1vZmZzZXQgVFogaXMgc2V0IHRvIHRoYXQgdW5sZXNzIGl0IGlzOlxuICAgICAgLy8gMS4gUmVwcmVzZW50aW5nIG9mZnNldCAwIHdoZW4gVVRDIGlzIHVzZWQgdG8gbWFpbnRhaW4gcHJldmlvdXMgYmVoYXZpb3IgYW5kIGRvZXMgbm90IGJlY29tZSBHTVQuXG4gICAgICAvLyAyLiBVbnN1cHBvcnRlZCBieSB0aGUgYnJvd3NlcjpcbiAgICAgIC8vICAgIC0gc29tZSBkbyBub3Qgc3VwcG9ydCBFdGMvXG4gICAgICAvLyAgICAtIDwgRXRjL0dNVC0xNCwgPiBFdGMvR01UKzEyLCBhbmQgMzAtbWludXRlIG9yIDQ1LW1pbnV0ZSBvZmZzZXRzIGFyZSBub3QgcGFydCBvZiB0emRhdGFcbiAgICAgIGNvbnN0IGdtdE9mZnNldCA9IC0xICogKGR0Lm9mZnNldCAvIDYwKTtcbiAgICAgIGNvbnN0IG9mZnNldFogPSBnbXRPZmZzZXQgPj0gMCA/IGBFdGMvR01UKyR7Z210T2Zmc2V0fWAgOiBgRXRjL0dNVCR7Z210T2Zmc2V0fWA7XG4gICAgICBpZiAoZHQub2Zmc2V0ICE9PSAwICYmIElBTkFab25lLmNyZWF0ZShvZmZzZXRaKS52YWxpZCkge1xuICAgICAgICB6ID0gb2Zmc2V0WjtcbiAgICAgICAgdGhpcy5kdCA9IGR0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm90IGFsbCBmaXhlZC1vZmZzZXQgem9uZXMgbGlrZSBFdGMvKzQ6MzAgYXJlIHByZXNlbnQgaW4gdHpkYXRhIHNvXG4gICAgICAgIC8vIHdlIG1hbnVhbGx5IGFwcGx5IHRoZSBvZmZzZXQgYW5kIHN1YnN0aXR1dGUgdGhlIHpvbmUgYXMgbmVlZGVkLlxuICAgICAgICB6ID0gXCJVVENcIjtcbiAgICAgICAgdGhpcy5kdCA9IGR0Lm9mZnNldCA9PT0gMCA/IGR0IDogZHQuc2V0Wm9uZShcIlVUQ1wiKS5wbHVzKHsgbWludXRlczogZHQub2Zmc2V0IH0pO1xuICAgICAgICB0aGlzLm9yaWdpbmFsWm9uZSA9IGR0LnpvbmU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkdC56b25lLnR5cGUgPT09IFwic3lzdGVtXCIpIHtcbiAgICAgIHRoaXMuZHQgPSBkdDtcbiAgICB9IGVsc2UgaWYgKGR0LnpvbmUudHlwZSA9PT0gXCJpYW5hXCIpIHtcbiAgICAgIHRoaXMuZHQgPSBkdDtcbiAgICAgIHogPSBkdC56b25lLm5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEN1c3RvbSB6b25lcyBjYW4gaGF2ZSBhbnkgb2Zmc2V0IC8gb2Zmc2V0TmFtZSBzbyB3ZSBqdXN0IG1hbnVhbGx5XG4gICAgICAvLyBhcHBseSB0aGUgb2Zmc2V0IGFuZCBzdWJzdGl0dXRlIHRoZSB6b25lIGFzIG5lZWRlZC5cbiAgICAgIHogPSBcIlVUQ1wiO1xuICAgICAgdGhpcy5kdCA9IGR0LnNldFpvbmUoXCJVVENcIikucGx1cyh7IG1pbnV0ZXM6IGR0Lm9mZnNldCB9KTtcbiAgICAgIHRoaXMub3JpZ2luYWxab25lID0gZHQuem9uZTtcbiAgICB9XG5cbiAgICBjb25zdCBpbnRsT3B0cyA9IHsgLi4udGhpcy5vcHRzIH07XG4gICAgaW50bE9wdHMudGltZVpvbmUgPSBpbnRsT3B0cy50aW1lWm9uZSB8fCB6O1xuICAgIHRoaXMuZHRmID0gZ2V0Q2FjaGVkRFRGKGludGwsIGludGxPcHRzKTtcbiAgfVxuXG4gIGZvcm1hdCgpIHtcbiAgICBpZiAodGhpcy5vcmlnaW5hbFpvbmUpIHtcbiAgICAgIC8vIElmIHdlIGhhdmUgdG8gc3Vic3RpdHV0ZSBpbiB0aGUgYWN0dWFsIHpvbmUgbmFtZSwgd2UgaGF2ZSB0byB1c2VcbiAgICAgIC8vIGZvcm1hdFRvUGFydHMgc28gdGhhdCB0aGUgdGltZXpvbmUgY2FuIGJlIHJlcGxhY2VkLlxuICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0VG9QYXJ0cygpXG4gICAgICAgIC5tYXAoKHsgdmFsdWUgfSkgPT4gdmFsdWUpXG4gICAgICAgIC5qb2luKFwiXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kdGYuZm9ybWF0KHRoaXMuZHQudG9KU0RhdGUoKSk7XG4gIH1cblxuICBmb3JtYXRUb1BhcnRzKCkge1xuICAgIGNvbnN0IHBhcnRzID0gdGhpcy5kdGYuZm9ybWF0VG9QYXJ0cyh0aGlzLmR0LnRvSlNEYXRlKCkpO1xuICAgIGlmICh0aGlzLm9yaWdpbmFsWm9uZSkge1xuICAgICAgcmV0dXJuIHBhcnRzLm1hcCgocGFydCkgPT4ge1xuICAgICAgICBpZiAocGFydC50eXBlID09PSBcInRpbWVab25lTmFtZVwiKSB7XG4gICAgICAgICAgY29uc3Qgb2Zmc2V0TmFtZSA9IHRoaXMub3JpZ2luYWxab25lLm9mZnNldE5hbWUodGhpcy5kdC50cywge1xuICAgICAgICAgICAgbG9jYWxlOiB0aGlzLmR0LmxvY2FsZSxcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5vcHRzLnRpbWVab25lTmFtZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ucGFydCxcbiAgICAgICAgICAgIHZhbHVlOiBvZmZzZXROYW1lLFxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcGFydHM7XG4gIH1cblxuICByZXNvbHZlZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZHRmLnJlc29sdmVkT3B0aW9ucygpO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgUG9seVJlbEZvcm1hdHRlciB7XG4gIGNvbnN0cnVjdG9yKGludGwsIGlzRW5nbGlzaCwgb3B0cykge1xuICAgIHRoaXMub3B0cyA9IHsgc3R5bGU6IFwibG9uZ1wiLCAuLi5vcHRzIH07XG4gICAgaWYgKCFpc0VuZ2xpc2ggJiYgaGFzUmVsYXRpdmUoKSkge1xuICAgICAgdGhpcy5ydGYgPSBnZXRDYWNoZWRSVEYoaW50bCwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgZm9ybWF0KGNvdW50LCB1bml0KSB7XG4gICAgaWYgKHRoaXMucnRmKSB7XG4gICAgICByZXR1cm4gdGhpcy5ydGYuZm9ybWF0KGNvdW50LCB1bml0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIEVuZ2xpc2guZm9ybWF0UmVsYXRpdmVUaW1lKHVuaXQsIGNvdW50LCB0aGlzLm9wdHMubnVtZXJpYywgdGhpcy5vcHRzLnN0eWxlICE9PSBcImxvbmdcIik7XG4gICAgfVxuICB9XG5cbiAgZm9ybWF0VG9QYXJ0cyhjb3VudCwgdW5pdCkge1xuICAgIGlmICh0aGlzLnJ0Zikge1xuICAgICAgcmV0dXJuIHRoaXMucnRmLmZvcm1hdFRvUGFydHMoY291bnQsIHVuaXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMb2NhbGUge1xuICBzdGF0aWMgZnJvbU9wdHMob3B0cykge1xuICAgIHJldHVybiBMb2NhbGUuY3JlYXRlKG9wdHMubG9jYWxlLCBvcHRzLm51bWJlcmluZ1N5c3RlbSwgb3B0cy5vdXRwdXRDYWxlbmRhciwgb3B0cy5kZWZhdWx0VG9FTik7XG4gIH1cblxuICBzdGF0aWMgY3JlYXRlKGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhciwgZGVmYXVsdFRvRU4gPSBmYWxzZSkge1xuICAgIGNvbnN0IHNwZWNpZmllZExvY2FsZSA9IGxvY2FsZSB8fCBTZXR0aW5ncy5kZWZhdWx0TG9jYWxlO1xuICAgIC8vIHRoZSBzeXN0ZW0gbG9jYWxlIGlzIHVzZWZ1bCBmb3IgaHVtYW4gcmVhZGFibGUgc3RyaW5ncyBidXQgYW5ub3lpbmcgZm9yIHBhcnNpbmcvZm9ybWF0dGluZyBrbm93biBmb3JtYXRzXG4gICAgY29uc3QgbG9jYWxlUiA9IHNwZWNpZmllZExvY2FsZSB8fCAoZGVmYXVsdFRvRU4gPyBcImVuLVVTXCIgOiBzeXN0ZW1Mb2NhbGUoKSk7XG4gICAgY29uc3QgbnVtYmVyaW5nU3lzdGVtUiA9IG51bWJlcmluZ1N5c3RlbSB8fCBTZXR0aW5ncy5kZWZhdWx0TnVtYmVyaW5nU3lzdGVtO1xuICAgIGNvbnN0IG91dHB1dENhbGVuZGFyUiA9IG91dHB1dENhbGVuZGFyIHx8IFNldHRpbmdzLmRlZmF1bHRPdXRwdXRDYWxlbmRhcjtcbiAgICByZXR1cm4gbmV3IExvY2FsZShsb2NhbGVSLCBudW1iZXJpbmdTeXN0ZW1SLCBvdXRwdXRDYWxlbmRhclIsIHNwZWNpZmllZExvY2FsZSk7XG4gIH1cblxuICBzdGF0aWMgcmVzZXRDYWNoZSgpIHtcbiAgICBzeXNMb2NhbGVDYWNoZSA9IG51bGw7XG4gICAgaW50bERUQ2FjaGUgPSB7fTtcbiAgICBpbnRsTnVtQ2FjaGUgPSB7fTtcbiAgICBpbnRsUmVsQ2FjaGUgPSB7fTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tT2JqZWN0KHsgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG91dHB1dENhbGVuZGFyIH0gPSB7fSkge1xuICAgIHJldHVybiBMb2NhbGUuY3JlYXRlKGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhcik7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihsb2NhbGUsIG51bWJlcmluZywgb3V0cHV0Q2FsZW5kYXIsIHNwZWNpZmllZExvY2FsZSkge1xuICAgIGNvbnN0IFtwYXJzZWRMb2NhbGUsIHBhcnNlZE51bWJlcmluZ1N5c3RlbSwgcGFyc2VkT3V0cHV0Q2FsZW5kYXJdID0gcGFyc2VMb2NhbGVTdHJpbmcobG9jYWxlKTtcblxuICAgIHRoaXMubG9jYWxlID0gcGFyc2VkTG9jYWxlO1xuICAgIHRoaXMubnVtYmVyaW5nU3lzdGVtID0gbnVtYmVyaW5nIHx8IHBhcnNlZE51bWJlcmluZ1N5c3RlbSB8fCBudWxsO1xuICAgIHRoaXMub3V0cHV0Q2FsZW5kYXIgPSBvdXRwdXRDYWxlbmRhciB8fCBwYXJzZWRPdXRwdXRDYWxlbmRhciB8fCBudWxsO1xuICAgIHRoaXMuaW50bCA9IGludGxDb25maWdTdHJpbmcodGhpcy5sb2NhbGUsIHRoaXMubnVtYmVyaW5nU3lzdGVtLCB0aGlzLm91dHB1dENhbGVuZGFyKTtcblxuICAgIHRoaXMud2Vla2RheXNDYWNoZSA9IHsgZm9ybWF0OiB7fSwgc3RhbmRhbG9uZToge30gfTtcbiAgICB0aGlzLm1vbnRoc0NhY2hlID0geyBmb3JtYXQ6IHt9LCBzdGFuZGFsb25lOiB7fSB9O1xuICAgIHRoaXMubWVyaWRpZW1DYWNoZSA9IG51bGw7XG4gICAgdGhpcy5lcmFDYWNoZSA9IHt9O1xuXG4gICAgdGhpcy5zcGVjaWZpZWRMb2NhbGUgPSBzcGVjaWZpZWRMb2NhbGU7XG4gICAgdGhpcy5mYXN0TnVtYmVyc0NhY2hlZCA9IG51bGw7XG4gIH1cblxuICBnZXQgZmFzdE51bWJlcnMoKSB7XG4gICAgaWYgKHRoaXMuZmFzdE51bWJlcnNDYWNoZWQgPT0gbnVsbCkge1xuICAgICAgdGhpcy5mYXN0TnVtYmVyc0NhY2hlZCA9IHN1cHBvcnRzRmFzdE51bWJlcnModGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZmFzdE51bWJlcnNDYWNoZWQ7XG4gIH1cblxuICBsaXN0aW5nTW9kZSgpIHtcbiAgICBjb25zdCBpc0FjdHVhbGx5RW4gPSB0aGlzLmlzRW5nbGlzaCgpO1xuICAgIGNvbnN0IGhhc05vV2VpcmRuZXNzID1cbiAgICAgICh0aGlzLm51bWJlcmluZ1N5c3RlbSA9PT0gbnVsbCB8fCB0aGlzLm51bWJlcmluZ1N5c3RlbSA9PT0gXCJsYXRuXCIpICYmXG4gICAgICAodGhpcy5vdXRwdXRDYWxlbmRhciA9PT0gbnVsbCB8fCB0aGlzLm91dHB1dENhbGVuZGFyID09PSBcImdyZWdvcnlcIik7XG4gICAgcmV0dXJuIGlzQWN0dWFsbHlFbiAmJiBoYXNOb1dlaXJkbmVzcyA/IFwiZW5cIiA6IFwiaW50bFwiO1xuICB9XG5cbiAgY2xvbmUoYWx0cykge1xuICAgIGlmICghYWx0cyB8fCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhbHRzKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gTG9jYWxlLmNyZWF0ZShcbiAgICAgICAgYWx0cy5sb2NhbGUgfHwgdGhpcy5zcGVjaWZpZWRMb2NhbGUsXG4gICAgICAgIGFsdHMubnVtYmVyaW5nU3lzdGVtIHx8IHRoaXMubnVtYmVyaW5nU3lzdGVtLFxuICAgICAgICBhbHRzLm91dHB1dENhbGVuZGFyIHx8IHRoaXMub3V0cHV0Q2FsZW5kYXIsXG4gICAgICAgIGFsdHMuZGVmYXVsdFRvRU4gfHwgZmFsc2VcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcmVkZWZhdWx0VG9FTihhbHRzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSh7IC4uLmFsdHMsIGRlZmF1bHRUb0VOOiB0cnVlIH0pO1xuICB9XG5cbiAgcmVkZWZhdWx0VG9TeXN0ZW0oYWx0cyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoeyAuLi5hbHRzLCBkZWZhdWx0VG9FTjogZmFsc2UgfSk7XG4gIH1cblxuICBtb250aHMobGVuZ3RoLCBmb3JtYXQgPSBmYWxzZSkge1xuICAgIHJldHVybiBsaXN0U3R1ZmYodGhpcywgbGVuZ3RoLCBFbmdsaXNoLm1vbnRocywgKCkgPT4ge1xuICAgICAgY29uc3QgaW50bCA9IGZvcm1hdCA/IHsgbW9udGg6IGxlbmd0aCwgZGF5OiBcIm51bWVyaWNcIiB9IDogeyBtb250aDogbGVuZ3RoIH0sXG4gICAgICAgIGZvcm1hdFN0ciA9IGZvcm1hdCA/IFwiZm9ybWF0XCIgOiBcInN0YW5kYWxvbmVcIjtcbiAgICAgIGlmICghdGhpcy5tb250aHNDYWNoZVtmb3JtYXRTdHJdW2xlbmd0aF0pIHtcbiAgICAgICAgdGhpcy5tb250aHNDYWNoZVtmb3JtYXRTdHJdW2xlbmd0aF0gPSBtYXBNb250aHMoKGR0KSA9PiB0aGlzLmV4dHJhY3QoZHQsIGludGwsIFwibW9udGhcIikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMubW9udGhzQ2FjaGVbZm9ybWF0U3RyXVtsZW5ndGhdO1xuICAgIH0pO1xuICB9XG5cbiAgd2Vla2RheXMobGVuZ3RoLCBmb3JtYXQgPSBmYWxzZSkge1xuICAgIHJldHVybiBsaXN0U3R1ZmYodGhpcywgbGVuZ3RoLCBFbmdsaXNoLndlZWtkYXlzLCAoKSA9PiB7XG4gICAgICBjb25zdCBpbnRsID0gZm9ybWF0XG4gICAgICAgICAgPyB7IHdlZWtkYXk6IGxlbmd0aCwgeWVhcjogXCJudW1lcmljXCIsIG1vbnRoOiBcImxvbmdcIiwgZGF5OiBcIm51bWVyaWNcIiB9XG4gICAgICAgICAgOiB7IHdlZWtkYXk6IGxlbmd0aCB9LFxuICAgICAgICBmb3JtYXRTdHIgPSBmb3JtYXQgPyBcImZvcm1hdFwiIDogXCJzdGFuZGFsb25lXCI7XG4gICAgICBpZiAoIXRoaXMud2Vla2RheXNDYWNoZVtmb3JtYXRTdHJdW2xlbmd0aF0pIHtcbiAgICAgICAgdGhpcy53ZWVrZGF5c0NhY2hlW2Zvcm1hdFN0cl1bbGVuZ3RoXSA9IG1hcFdlZWtkYXlzKChkdCkgPT5cbiAgICAgICAgICB0aGlzLmV4dHJhY3QoZHQsIGludGwsIFwid2Vla2RheVwiKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMud2Vla2RheXNDYWNoZVtmb3JtYXRTdHJdW2xlbmd0aF07XG4gICAgfSk7XG4gIH1cblxuICBtZXJpZGllbXMoKSB7XG4gICAgcmV0dXJuIGxpc3RTdHVmZihcbiAgICAgIHRoaXMsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICAoKSA9PiBFbmdsaXNoLm1lcmlkaWVtcyxcbiAgICAgICgpID0+IHtcbiAgICAgICAgLy8gSW4gdGhlb3J5IHRoZXJlIGNvdWxkIGJlIGFyaWJpdHJhcnkgZGF5IHBlcmlvZHMuIFdlJ3JlIGdvbm5hIGFzc3VtZSB0aGVyZSBhcmUgZXhhY3RseSB0d29cbiAgICAgICAgLy8gZm9yIEFNIGFuZCBQTS4gVGhpcyBpcyBwcm9iYWJseSB3cm9uZywgYnV0IGl0J3MgbWFrZXMgcGFyc2luZyB3YXkgZWFzaWVyLlxuICAgICAgICBpZiAoIXRoaXMubWVyaWRpZW1DYWNoZSkge1xuICAgICAgICAgIGNvbnN0IGludGwgPSB7IGhvdXI6IFwibnVtZXJpY1wiLCBob3VyQ3ljbGU6IFwiaDEyXCIgfTtcbiAgICAgICAgICB0aGlzLm1lcmlkaWVtQ2FjaGUgPSBbRGF0ZVRpbWUudXRjKDIwMTYsIDExLCAxMywgOSksIERhdGVUaW1lLnV0YygyMDE2LCAxMSwgMTMsIDE5KV0ubWFwKFxuICAgICAgICAgICAgKGR0KSA9PiB0aGlzLmV4dHJhY3QoZHQsIGludGwsIFwiZGF5cGVyaW9kXCIpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLm1lcmlkaWVtQ2FjaGU7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuXG4gIGVyYXMobGVuZ3RoKSB7XG4gICAgcmV0dXJuIGxpc3RTdHVmZih0aGlzLCBsZW5ndGgsIEVuZ2xpc2guZXJhcywgKCkgPT4ge1xuICAgICAgY29uc3QgaW50bCA9IHsgZXJhOiBsZW5ndGggfTtcblxuICAgICAgLy8gVGhpcyBpcyBwcm9ibGVtYXRpYy4gRGlmZmVyZW50IGNhbGVuZGFycyBhcmUgZ29pbmcgdG8gZGVmaW5lIGVyYXMgdG90YWxseSBkaWZmZXJlbnRseS4gV2hhdCBJIG5lZWQgaXMgdGhlIG1pbmltdW0gc2V0IG9mIGRhdGVzXG4gICAgICAvLyB0byBkZWZpbml0ZWx5IGVudW1lcmF0ZSB0aGVtLlxuICAgICAgaWYgKCF0aGlzLmVyYUNhY2hlW2xlbmd0aF0pIHtcbiAgICAgICAgdGhpcy5lcmFDYWNoZVtsZW5ndGhdID0gW0RhdGVUaW1lLnV0YygtNDAsIDEsIDEpLCBEYXRlVGltZS51dGMoMjAxNywgMSwgMSldLm1hcCgoZHQpID0+XG4gICAgICAgICAgdGhpcy5leHRyYWN0KGR0LCBpbnRsLCBcImVyYVwiKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5lcmFDYWNoZVtsZW5ndGhdO1xuICAgIH0pO1xuICB9XG5cbiAgZXh0cmFjdChkdCwgaW50bE9wdHMsIGZpZWxkKSB7XG4gICAgY29uc3QgZGYgPSB0aGlzLmR0Rm9ybWF0dGVyKGR0LCBpbnRsT3B0cyksXG4gICAgICByZXN1bHRzID0gZGYuZm9ybWF0VG9QYXJ0cygpLFxuICAgICAgbWF0Y2hpbmcgPSByZXN1bHRzLmZpbmQoKG0pID0+IG0udHlwZS50b0xvd2VyQ2FzZSgpID09PSBmaWVsZCk7XG4gICAgcmV0dXJuIG1hdGNoaW5nID8gbWF0Y2hpbmcudmFsdWUgOiBudWxsO1xuICB9XG5cbiAgbnVtYmVyRm9ybWF0dGVyKG9wdHMgPSB7fSkge1xuICAgIC8vIHRoaXMgZm9yY2VzaW1wbGUgb3B0aW9uIGlzIG5ldmVyIHVzZWQgKHRoZSBvbmx5IGNhbGxlciBzaG9ydC1jaXJjdWl0cyBvbiBpdCwgYnV0IGl0IHNlZW1zIHNhZmVyIHRvIGxlYXZlKVxuICAgIC8vIChpbiBjb250cmFzdCwgdGhlIHJlc3Qgb2YgdGhlIGNvbmRpdGlvbiBpcyB1c2VkIGhlYXZpbHkpXG4gICAgcmV0dXJuIG5ldyBQb2x5TnVtYmVyRm9ybWF0dGVyKHRoaXMuaW50bCwgb3B0cy5mb3JjZVNpbXBsZSB8fCB0aGlzLmZhc3ROdW1iZXJzLCBvcHRzKTtcbiAgfVxuXG4gIGR0Rm9ybWF0dGVyKGR0LCBpbnRsT3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBQb2x5RGF0ZUZvcm1hdHRlcihkdCwgdGhpcy5pbnRsLCBpbnRsT3B0cyk7XG4gIH1cblxuICByZWxGb3JtYXR0ZXIob3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBQb2x5UmVsRm9ybWF0dGVyKHRoaXMuaW50bCwgdGhpcy5pc0VuZ2xpc2goKSwgb3B0cyk7XG4gIH1cblxuICBsaXN0Rm9ybWF0dGVyKG9wdHMgPSB7fSkge1xuICAgIHJldHVybiBnZXRDYWNoZWRMRih0aGlzLmludGwsIG9wdHMpO1xuICB9XG5cbiAgaXNFbmdsaXNoKCkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmxvY2FsZSA9PT0gXCJlblwiIHx8XG4gICAgICB0aGlzLmxvY2FsZS50b0xvd2VyQ2FzZSgpID09PSBcImVuLXVzXCIgfHxcbiAgICAgIG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KHRoaXMuaW50bCkucmVzb2x2ZWRPcHRpb25zKCkubG9jYWxlLnN0YXJ0c1dpdGgoXCJlbi11c1wiKVxuICAgICk7XG4gIH1cblxuICBlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5sb2NhbGUgPT09IG90aGVyLmxvY2FsZSAmJlxuICAgICAgdGhpcy5udW1iZXJpbmdTeXN0ZW0gPT09IG90aGVyLm51bWJlcmluZ1N5c3RlbSAmJlxuICAgICAgdGhpcy5vdXRwdXRDYWxlbmRhciA9PT0gb3RoZXIub3V0cHV0Q2FsZW5kYXJcbiAgICApO1xuICB9XG59XG4iLCJpbXBvcnQge1xuICB1bnRydW5jYXRlWWVhcixcbiAgc2lnbmVkT2Zmc2V0LFxuICBwYXJzZUludGVnZXIsXG4gIHBhcnNlTWlsbGlzLFxuICBpc1VuZGVmaW5lZCxcbiAgcGFyc2VGbG9hdGluZyxcbn0gZnJvbSBcIi4vdXRpbC5qc1wiO1xuaW1wb3J0ICogYXMgRW5nbGlzaCBmcm9tIFwiLi9lbmdsaXNoLmpzXCI7XG5pbXBvcnQgRml4ZWRPZmZzZXRab25lIGZyb20gXCIuLi96b25lcy9maXhlZE9mZnNldFpvbmUuanNcIjtcbmltcG9ydCBJQU5BWm9uZSBmcm9tIFwiLi4vem9uZXMvSUFOQVpvbmUuanNcIjtcblxuLypcbiAqIFRoaXMgZmlsZSBoYW5kbGVzIHBhcnNpbmcgZm9yIHdlbGwtc3BlY2lmaWVkIGZvcm1hdHMuIEhlcmUncyBob3cgaXQgd29ya3M6XG4gKiBUd28gdGhpbmdzIGdvIGludG8gcGFyc2luZzogYSByZWdleCB0byBtYXRjaCB3aXRoIGFuZCBhbiBleHRyYWN0b3IgdG8gdGFrZSBhcGFydCB0aGUgZ3JvdXBzIGluIHRoZSBtYXRjaC5cbiAqIEFuIGV4dHJhY3RvciBpcyBqdXN0IGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHJlZ2V4IG1hdGNoIGFycmF5IGFuZCByZXR1cm5zIGEgeyB5ZWFyOiAuLi4sIG1vbnRoOiAuLi4gfSBvYmplY3RcbiAqIHBhcnNlKCkgZG9lcyB0aGUgd29yayBvZiBleGVjdXRpbmcgdGhlIHJlZ2V4IGFuZCBhcHBseWluZyB0aGUgZXh0cmFjdG9yLiBJdCB0YWtlcyBtdWx0aXBsZSByZWdleC9leHRyYWN0b3IgcGFpcnMgdG8gdHJ5IGluIHNlcXVlbmNlLlxuICogRXh0cmFjdG9ycyBjYW4gdGFrZSBhIFwiY3Vyc29yXCIgcmVwcmVzZW50aW5nIHRoZSBvZmZzZXQgaW4gdGhlIG1hdGNoIHRvIGxvb2sgYXQuIFRoaXMgbWFrZXMgaXQgZWFzeSB0byBjb21iaW5lIGV4dHJhY3RvcnMuXG4gKiBjb21iaW5lRXh0cmFjdG9ycygpIGRvZXMgdGhlIHdvcmsgb2YgY29tYmluaW5nIHRoZW0sIGtlZXBpbmcgdHJhY2sgb2YgdGhlIGN1cnNvciB0aHJvdWdoIG11bHRpcGxlIGV4dHJhY3Rpb25zLlxuICogU29tZSBleHRyYWN0aW9ucyBhcmUgc3VwZXIgZHVtYiBhbmQgc2ltcGxlUGFyc2UgYW5kIGZyb21TdHJpbmdzIGhlbHAgRFJZIHRoZW0uXG4gKi9cblxuY29uc3QgaWFuYVJlZ2V4ID0gL1tBLVphLXpfKy1dezEsMjU2fSg/Ojo/XFwvW0EtWmEtejAtOV8rLV17MSwyNTZ9KD86XFwvW0EtWmEtejAtOV8rLV17MSwyNTZ9KT8pPy87XG5cbmZ1bmN0aW9uIGNvbWJpbmVSZWdleGVzKC4uLnJlZ2V4ZXMpIHtcbiAgY29uc3QgZnVsbCA9IHJlZ2V4ZXMucmVkdWNlKChmLCByKSA9PiBmICsgci5zb3VyY2UsIFwiXCIpO1xuICByZXR1cm4gUmVnRXhwKGBeJHtmdWxsfSRgKTtcbn1cblxuZnVuY3Rpb24gY29tYmluZUV4dHJhY3RvcnMoLi4uZXh0cmFjdG9ycykge1xuICByZXR1cm4gKG0pID0+XG4gICAgZXh0cmFjdG9yc1xuICAgICAgLnJlZHVjZShcbiAgICAgICAgKFttZXJnZWRWYWxzLCBtZXJnZWRab25lLCBjdXJzb3JdLCBleCkgPT4ge1xuICAgICAgICAgIGNvbnN0IFt2YWwsIHpvbmUsIG5leHRdID0gZXgobSwgY3Vyc29yKTtcbiAgICAgICAgICByZXR1cm4gW3sgLi4ubWVyZ2VkVmFscywgLi4udmFsIH0sIHpvbmUgfHwgbWVyZ2VkWm9uZSwgbmV4dF07XG4gICAgICAgIH0sXG4gICAgICAgIFt7fSwgbnVsbCwgMV1cbiAgICAgIClcbiAgICAgIC5zbGljZSgwLCAyKTtcbn1cblxuZnVuY3Rpb24gcGFyc2UocywgLi4ucGF0dGVybnMpIHtcbiAgaWYgKHMgPT0gbnVsbCkge1xuICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gIH1cblxuICBmb3IgKGNvbnN0IFtyZWdleCwgZXh0cmFjdG9yXSBvZiBwYXR0ZXJucykge1xuICAgIGNvbnN0IG0gPSByZWdleC5leGVjKHMpO1xuICAgIGlmIChtKSB7XG4gICAgICByZXR1cm4gZXh0cmFjdG9yKG0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW251bGwsIG51bGxdO1xufVxuXG5mdW5jdGlvbiBzaW1wbGVQYXJzZSguLi5rZXlzKSB7XG4gIHJldHVybiAobWF0Y2gsIGN1cnNvcikgPT4ge1xuICAgIGNvbnN0IHJldCA9IHt9O1xuICAgIGxldCBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJldFtrZXlzW2ldXSA9IHBhcnNlSW50ZWdlcihtYXRjaFtjdXJzb3IgKyBpXSk7XG4gICAgfVxuICAgIHJldHVybiBbcmV0LCBudWxsLCBjdXJzb3IgKyBpXTtcbiAgfTtcbn1cblxuLy8gSVNPIGFuZCBTUUwgcGFyc2luZ1xuY29uc3Qgb2Zmc2V0UmVnZXggPSAvKD86KFopfChbKy1dXFxkXFxkKSg/Ojo/KFxcZFxcZCkpPykvO1xuY29uc3QgaXNvRXh0ZW5kZWRab25lID0gYCg/OiR7b2Zmc2V0UmVnZXguc291cmNlfT8oPzpcXFxcWygke2lhbmFSZWdleC5zb3VyY2V9KVxcXFxdKT8pP2A7XG5jb25zdCBpc29UaW1lQmFzZVJlZ2V4ID0gLyhcXGRcXGQpKD86Oj8oXFxkXFxkKSg/Ojo/KFxcZFxcZCkoPzpbLixdKFxcZHsxLDMwfSkpPyk/KT8vO1xuY29uc3QgaXNvVGltZVJlZ2V4ID0gUmVnRXhwKGAke2lzb1RpbWVCYXNlUmVnZXguc291cmNlfSR7aXNvRXh0ZW5kZWRab25lfWApO1xuY29uc3QgaXNvVGltZUV4dGVuc2lvblJlZ2V4ID0gUmVnRXhwKGAoPzpUJHtpc29UaW1lUmVnZXguc291cmNlfSk/YCk7XG5jb25zdCBpc29ZbWRSZWdleCA9IC8oWystXVxcZHs2fXxcXGR7NH0pKD86LT8oXFxkXFxkKSg/Oi0/KFxcZFxcZCkpPyk/LztcbmNvbnN0IGlzb1dlZWtSZWdleCA9IC8oXFxkezR9KS0/VyhcXGRcXGQpKD86LT8oXFxkKSk/LztcbmNvbnN0IGlzb09yZGluYWxSZWdleCA9IC8oXFxkezR9KS0/KFxcZHszfSkvO1xuY29uc3QgZXh0cmFjdElTT1dlZWtEYXRhID0gc2ltcGxlUGFyc2UoXCJ3ZWVrWWVhclwiLCBcIndlZWtOdW1iZXJcIiwgXCJ3ZWVrRGF5XCIpO1xuY29uc3QgZXh0cmFjdElTT09yZGluYWxEYXRhID0gc2ltcGxlUGFyc2UoXCJ5ZWFyXCIsIFwib3JkaW5hbFwiKTtcbmNvbnN0IHNxbFltZFJlZ2V4ID0gLyhcXGR7NH0pLShcXGRcXGQpLShcXGRcXGQpLzsgLy8gZHVtYmVkLWRvd24gdmVyc2lvbiBvZiB0aGUgSVNPIG9uZVxuY29uc3Qgc3FsVGltZVJlZ2V4ID0gUmVnRXhwKFxuICBgJHtpc29UaW1lQmFzZVJlZ2V4LnNvdXJjZX0gPyg/OiR7b2Zmc2V0UmVnZXguc291cmNlfXwoJHtpYW5hUmVnZXguc291cmNlfSkpP2Bcbik7XG5jb25zdCBzcWxUaW1lRXh0ZW5zaW9uUmVnZXggPSBSZWdFeHAoYCg/OiAke3NxbFRpbWVSZWdleC5zb3VyY2V9KT9gKTtcblxuZnVuY3Rpb24gaW50KG1hdGNoLCBwb3MsIGZhbGxiYWNrKSB7XG4gIGNvbnN0IG0gPSBtYXRjaFtwb3NdO1xuICByZXR1cm4gaXNVbmRlZmluZWQobSkgPyBmYWxsYmFjayA6IHBhcnNlSW50ZWdlcihtKTtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdElTT1ltZChtYXRjaCwgY3Vyc29yKSB7XG4gIGNvbnN0IGl0ZW0gPSB7XG4gICAgeWVhcjogaW50KG1hdGNoLCBjdXJzb3IpLFxuICAgIG1vbnRoOiBpbnQobWF0Y2gsIGN1cnNvciArIDEsIDEpLFxuICAgIGRheTogaW50KG1hdGNoLCBjdXJzb3IgKyAyLCAxKSxcbiAgfTtcblxuICByZXR1cm4gW2l0ZW0sIG51bGwsIGN1cnNvciArIDNdO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0SVNPVGltZShtYXRjaCwgY3Vyc29yKSB7XG4gIGNvbnN0IGl0ZW0gPSB7XG4gICAgaG91cnM6IGludChtYXRjaCwgY3Vyc29yLCAwKSxcbiAgICBtaW51dGVzOiBpbnQobWF0Y2gsIGN1cnNvciArIDEsIDApLFxuICAgIHNlY29uZHM6IGludChtYXRjaCwgY3Vyc29yICsgMiwgMCksXG4gICAgbWlsbGlzZWNvbmRzOiBwYXJzZU1pbGxpcyhtYXRjaFtjdXJzb3IgKyAzXSksXG4gIH07XG5cbiAgcmV0dXJuIFtpdGVtLCBudWxsLCBjdXJzb3IgKyA0XTtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdElTT09mZnNldChtYXRjaCwgY3Vyc29yKSB7XG4gIGNvbnN0IGxvY2FsID0gIW1hdGNoW2N1cnNvcl0gJiYgIW1hdGNoW2N1cnNvciArIDFdLFxuICAgIGZ1bGxPZmZzZXQgPSBzaWduZWRPZmZzZXQobWF0Y2hbY3Vyc29yICsgMV0sIG1hdGNoW2N1cnNvciArIDJdKSxcbiAgICB6b25lID0gbG9jYWwgPyBudWxsIDogRml4ZWRPZmZzZXRab25lLmluc3RhbmNlKGZ1bGxPZmZzZXQpO1xuICByZXR1cm4gW3t9LCB6b25lLCBjdXJzb3IgKyAzXTtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdElBTkFab25lKG1hdGNoLCBjdXJzb3IpIHtcbiAgY29uc3Qgem9uZSA9IG1hdGNoW2N1cnNvcl0gPyBJQU5BWm9uZS5jcmVhdGUobWF0Y2hbY3Vyc29yXSkgOiBudWxsO1xuICByZXR1cm4gW3t9LCB6b25lLCBjdXJzb3IgKyAxXTtcbn1cblxuLy8gSVNPIHRpbWUgcGFyc2luZ1xuXG5jb25zdCBpc29UaW1lT25seSA9IFJlZ0V4cChgXlQ/JHtpc29UaW1lQmFzZVJlZ2V4LnNvdXJjZX0kYCk7XG5cbi8vIElTTyBkdXJhdGlvbiBwYXJzaW5nXG5cbmNvbnN0IGlzb0R1cmF0aW9uID1cbiAgL14tP1AoPzooPzooLT9cXGR7MSwyMH0oPzpcXC5cXGR7MSwyMH0pPylZKT8oPzooLT9cXGR7MSwyMH0oPzpcXC5cXGR7MSwyMH0pPylNKT8oPzooLT9cXGR7MSwyMH0oPzpcXC5cXGR7MSwyMH0pPylXKT8oPzooLT9cXGR7MSwyMH0oPzpcXC5cXGR7MSwyMH0pPylEKT8oPzpUKD86KC0/XFxkezEsMjB9KD86XFwuXFxkezEsMjB9KT8pSCk/KD86KC0/XFxkezEsMjB9KD86XFwuXFxkezEsMjB9KT8pTSk/KD86KC0/XFxkezEsMjB9KSg/OlsuLF0oLT9cXGR7MSwyMH0pKT9TKT8pPykkLztcblxuZnVuY3Rpb24gZXh0cmFjdElTT0R1cmF0aW9uKG1hdGNoKSB7XG4gIGNvbnN0IFtzLCB5ZWFyU3RyLCBtb250aFN0ciwgd2Vla1N0ciwgZGF5U3RyLCBob3VyU3RyLCBtaW51dGVTdHIsIHNlY29uZFN0ciwgbWlsbGlzZWNvbmRzU3RyXSA9XG4gICAgbWF0Y2g7XG5cbiAgY29uc3QgaGFzTmVnYXRpdmVQcmVmaXggPSBzWzBdID09PSBcIi1cIjtcbiAgY29uc3QgbmVnYXRpdmVTZWNvbmRzID0gc2Vjb25kU3RyICYmIHNlY29uZFN0clswXSA9PT0gXCItXCI7XG5cbiAgY29uc3QgbWF5YmVOZWdhdGUgPSAobnVtLCBmb3JjZSA9IGZhbHNlKSA9PlxuICAgIG51bSAhPT0gdW5kZWZpbmVkICYmIChmb3JjZSB8fCAobnVtICYmIGhhc05lZ2F0aXZlUHJlZml4KSkgPyAtbnVtIDogbnVtO1xuXG4gIHJldHVybiBbXG4gICAge1xuICAgICAgeWVhcnM6IG1heWJlTmVnYXRlKHBhcnNlRmxvYXRpbmcoeWVhclN0cikpLFxuICAgICAgbW9udGhzOiBtYXliZU5lZ2F0ZShwYXJzZUZsb2F0aW5nKG1vbnRoU3RyKSksXG4gICAgICB3ZWVrczogbWF5YmVOZWdhdGUocGFyc2VGbG9hdGluZyh3ZWVrU3RyKSksXG4gICAgICBkYXlzOiBtYXliZU5lZ2F0ZShwYXJzZUZsb2F0aW5nKGRheVN0cikpLFxuICAgICAgaG91cnM6IG1heWJlTmVnYXRlKHBhcnNlRmxvYXRpbmcoaG91clN0cikpLFxuICAgICAgbWludXRlczogbWF5YmVOZWdhdGUocGFyc2VGbG9hdGluZyhtaW51dGVTdHIpKSxcbiAgICAgIHNlY29uZHM6IG1heWJlTmVnYXRlKHBhcnNlRmxvYXRpbmcoc2Vjb25kU3RyKSwgc2Vjb25kU3RyID09PSBcIi0wXCIpLFxuICAgICAgbWlsbGlzZWNvbmRzOiBtYXliZU5lZ2F0ZShwYXJzZU1pbGxpcyhtaWxsaXNlY29uZHNTdHIpLCBuZWdhdGl2ZVNlY29uZHMpLFxuICAgIH0sXG4gIF07XG59XG5cbi8vIFRoZXNlIGFyZSBhIGxpdHRsZSBicmFpbmRlYWQuIEVEVCAqc2hvdWxkKiB0ZWxsIHVzIHRoYXQgd2UncmUgaW4sIHNheSwgQW1lcmljYS9OZXdfWW9ya1xuLy8gYW5kIG5vdCBqdXN0IHRoYXQgd2UncmUgaW4gLTI0MCAqcmlnaHQgbm93Ki4gQnV0IHNpbmNlIEkgZG9uJ3QgdGhpbmsgdGhlc2UgYXJlIHVzZWQgdGhhdCBvZnRlblxuLy8gSSdtIGp1c3QgZ29pbmcgdG8gaWdub3JlIHRoYXRcbmNvbnN0IG9ic09mZnNldHMgPSB7XG4gIEdNVDogMCxcbiAgRURUOiAtNCAqIDYwLFxuICBFU1Q6IC01ICogNjAsXG4gIENEVDogLTUgKiA2MCxcbiAgQ1NUOiAtNiAqIDYwLFxuICBNRFQ6IC02ICogNjAsXG4gIE1TVDogLTcgKiA2MCxcbiAgUERUOiAtNyAqIDYwLFxuICBQU1Q6IC04ICogNjAsXG59O1xuXG5mdW5jdGlvbiBmcm9tU3RyaW5ncyh3ZWVrZGF5U3RyLCB5ZWFyU3RyLCBtb250aFN0ciwgZGF5U3RyLCBob3VyU3RyLCBtaW51dGVTdHIsIHNlY29uZFN0cikge1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgeWVhcjogeWVhclN0ci5sZW5ndGggPT09IDIgPyB1bnRydW5jYXRlWWVhcihwYXJzZUludGVnZXIoeWVhclN0cikpIDogcGFyc2VJbnRlZ2VyKHllYXJTdHIpLFxuICAgIG1vbnRoOiBFbmdsaXNoLm1vbnRoc1Nob3J0LmluZGV4T2YobW9udGhTdHIpICsgMSxcbiAgICBkYXk6IHBhcnNlSW50ZWdlcihkYXlTdHIpLFxuICAgIGhvdXI6IHBhcnNlSW50ZWdlcihob3VyU3RyKSxcbiAgICBtaW51dGU6IHBhcnNlSW50ZWdlcihtaW51dGVTdHIpLFxuICB9O1xuXG4gIGlmIChzZWNvbmRTdHIpIHJlc3VsdC5zZWNvbmQgPSBwYXJzZUludGVnZXIoc2Vjb25kU3RyKTtcbiAgaWYgKHdlZWtkYXlTdHIpIHtcbiAgICByZXN1bHQud2Vla2RheSA9XG4gICAgICB3ZWVrZGF5U3RyLmxlbmd0aCA+IDNcbiAgICAgICAgPyBFbmdsaXNoLndlZWtkYXlzTG9uZy5pbmRleE9mKHdlZWtkYXlTdHIpICsgMVxuICAgICAgICA6IEVuZ2xpc2gud2Vla2RheXNTaG9ydC5pbmRleE9mKHdlZWtkYXlTdHIpICsgMTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIFJGQyAyODIyLzUzMjJcbmNvbnN0IHJmYzI4MjIgPVxuICAvXig/OihNb258VHVlfFdlZHxUaHV8RnJpfFNhdHxTdW4pLFxccyk/KFxcZHsxLDJ9KVxccyhKYW58RmVifE1hcnxBcHJ8TWF5fEp1bnxKdWx8QXVnfFNlcHxPY3R8Tm92fERlYylcXHMoXFxkezIsNH0pXFxzKFxcZFxcZCk6KFxcZFxcZCkoPzo6KFxcZFxcZCkpP1xccyg/OihVVHxHTVR8W0VDTVBdW1NEXVQpfChbWnpdKXwoPzooWystXVxcZFxcZCkoXFxkXFxkKSkpJC87XG5cbmZ1bmN0aW9uIGV4dHJhY3RSRkMyODIyKG1hdGNoKSB7XG4gIGNvbnN0IFtcbiAgICAgICxcbiAgICAgIHdlZWtkYXlTdHIsXG4gICAgICBkYXlTdHIsXG4gICAgICBtb250aFN0cixcbiAgICAgIHllYXJTdHIsXG4gICAgICBob3VyU3RyLFxuICAgICAgbWludXRlU3RyLFxuICAgICAgc2Vjb25kU3RyLFxuICAgICAgb2JzT2Zmc2V0LFxuICAgICAgbWlsT2Zmc2V0LFxuICAgICAgb2ZmSG91clN0cixcbiAgICAgIG9mZk1pbnV0ZVN0cixcbiAgICBdID0gbWF0Y2gsXG4gICAgcmVzdWx0ID0gZnJvbVN0cmluZ3Mod2Vla2RheVN0ciwgeWVhclN0ciwgbW9udGhTdHIsIGRheVN0ciwgaG91clN0ciwgbWludXRlU3RyLCBzZWNvbmRTdHIpO1xuXG4gIGxldCBvZmZzZXQ7XG4gIGlmIChvYnNPZmZzZXQpIHtcbiAgICBvZmZzZXQgPSBvYnNPZmZzZXRzW29ic09mZnNldF07XG4gIH0gZWxzZSBpZiAobWlsT2Zmc2V0KSB7XG4gICAgb2Zmc2V0ID0gMDtcbiAgfSBlbHNlIHtcbiAgICBvZmZzZXQgPSBzaWduZWRPZmZzZXQob2ZmSG91clN0ciwgb2ZmTWludXRlU3RyKTtcbiAgfVxuXG4gIHJldHVybiBbcmVzdWx0LCBuZXcgRml4ZWRPZmZzZXRab25lKG9mZnNldCldO1xufVxuXG5mdW5jdGlvbiBwcmVwcm9jZXNzUkZDMjgyMihzKSB7XG4gIC8vIFJlbW92ZSBjb21tZW50cyBhbmQgZm9sZGluZyB3aGl0ZXNwYWNlIGFuZCByZXBsYWNlIG11bHRpcGxlLXNwYWNlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG4gIHJldHVybiBzXG4gICAgLnJlcGxhY2UoL1xcKFteKCldKlxcKXxbXFxuXFx0XS9nLCBcIiBcIilcbiAgICAucmVwbGFjZSgvKFxcc1xccyspL2csIFwiIFwiKVxuICAgIC50cmltKCk7XG59XG5cbi8vIGh0dHAgZGF0ZVxuXG5jb25zdCByZmMxMTIzID1cbiAgICAvXihNb258VHVlfFdlZHxUaHV8RnJpfFNhdHxTdW4pLCAoXFxkXFxkKSAoSmFufEZlYnxNYXJ8QXByfE1heXxKdW58SnVsfEF1Z3xTZXB8T2N0fE5vdnxEZWMpIChcXGR7NH0pIChcXGRcXGQpOihcXGRcXGQpOihcXGRcXGQpIEdNVCQvLFxuICByZmM4NTAgPVxuICAgIC9eKE1vbmRheXxUdWVzZGF5fFdlZG5lc2RheXxUaHVyc2RheXxGcmlkYXl8U2F0dXJkYXl8U3VuZGF5KSwgKFxcZFxcZCktKEphbnxGZWJ8TWFyfEFwcnxNYXl8SnVufEp1bHxBdWd8U2VwfE9jdHxOb3Z8RGVjKS0oXFxkXFxkKSAoXFxkXFxkKTooXFxkXFxkKTooXFxkXFxkKSBHTVQkLyxcbiAgYXNjaWkgPVxuICAgIC9eKE1vbnxUdWV8V2VkfFRodXxGcml8U2F0fFN1bikgKEphbnxGZWJ8TWFyfEFwcnxNYXl8SnVufEp1bHxBdWd8U2VwfE9jdHxOb3Z8RGVjKSAoIFxcZHxcXGRcXGQpIChcXGRcXGQpOihcXGRcXGQpOihcXGRcXGQpIChcXGR7NH0pJC87XG5cbmZ1bmN0aW9uIGV4dHJhY3RSRkMxMTIzT3I4NTAobWF0Y2gpIHtcbiAgY29uc3QgWywgd2Vla2RheVN0ciwgZGF5U3RyLCBtb250aFN0ciwgeWVhclN0ciwgaG91clN0ciwgbWludXRlU3RyLCBzZWNvbmRTdHJdID0gbWF0Y2gsXG4gICAgcmVzdWx0ID0gZnJvbVN0cmluZ3Mod2Vla2RheVN0ciwgeWVhclN0ciwgbW9udGhTdHIsIGRheVN0ciwgaG91clN0ciwgbWludXRlU3RyLCBzZWNvbmRTdHIpO1xuICByZXR1cm4gW3Jlc3VsdCwgRml4ZWRPZmZzZXRab25lLnV0Y0luc3RhbmNlXTtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdEFTQ0lJKG1hdGNoKSB7XG4gIGNvbnN0IFssIHdlZWtkYXlTdHIsIG1vbnRoU3RyLCBkYXlTdHIsIGhvdXJTdHIsIG1pbnV0ZVN0ciwgc2Vjb25kU3RyLCB5ZWFyU3RyXSA9IG1hdGNoLFxuICAgIHJlc3VsdCA9IGZyb21TdHJpbmdzKHdlZWtkYXlTdHIsIHllYXJTdHIsIG1vbnRoU3RyLCBkYXlTdHIsIGhvdXJTdHIsIG1pbnV0ZVN0ciwgc2Vjb25kU3RyKTtcbiAgcmV0dXJuIFtyZXN1bHQsIEZpeGVkT2Zmc2V0Wm9uZS51dGNJbnN0YW5jZV07XG59XG5cbmNvbnN0IGlzb1ltZFdpdGhUaW1lRXh0ZW5zaW9uUmVnZXggPSBjb21iaW5lUmVnZXhlcyhpc29ZbWRSZWdleCwgaXNvVGltZUV4dGVuc2lvblJlZ2V4KTtcbmNvbnN0IGlzb1dlZWtXaXRoVGltZUV4dGVuc2lvblJlZ2V4ID0gY29tYmluZVJlZ2V4ZXMoaXNvV2Vla1JlZ2V4LCBpc29UaW1lRXh0ZW5zaW9uUmVnZXgpO1xuY29uc3QgaXNvT3JkaW5hbFdpdGhUaW1lRXh0ZW5zaW9uUmVnZXggPSBjb21iaW5lUmVnZXhlcyhpc29PcmRpbmFsUmVnZXgsIGlzb1RpbWVFeHRlbnNpb25SZWdleCk7XG5jb25zdCBpc29UaW1lQ29tYmluZWRSZWdleCA9IGNvbWJpbmVSZWdleGVzKGlzb1RpbWVSZWdleCk7XG5cbmNvbnN0IGV4dHJhY3RJU09ZbWRUaW1lQW5kT2Zmc2V0ID0gY29tYmluZUV4dHJhY3RvcnMoXG4gIGV4dHJhY3RJU09ZbWQsXG4gIGV4dHJhY3RJU09UaW1lLFxuICBleHRyYWN0SVNPT2Zmc2V0LFxuICBleHRyYWN0SUFOQVpvbmVcbik7XG5jb25zdCBleHRyYWN0SVNPV2Vla1RpbWVBbmRPZmZzZXQgPSBjb21iaW5lRXh0cmFjdG9ycyhcbiAgZXh0cmFjdElTT1dlZWtEYXRhLFxuICBleHRyYWN0SVNPVGltZSxcbiAgZXh0cmFjdElTT09mZnNldCxcbiAgZXh0cmFjdElBTkFab25lXG4pO1xuY29uc3QgZXh0cmFjdElTT09yZGluYWxEYXRlQW5kVGltZSA9IGNvbWJpbmVFeHRyYWN0b3JzKFxuICBleHRyYWN0SVNPT3JkaW5hbERhdGEsXG4gIGV4dHJhY3RJU09UaW1lLFxuICBleHRyYWN0SVNPT2Zmc2V0LFxuICBleHRyYWN0SUFOQVpvbmVcbik7XG5jb25zdCBleHRyYWN0SVNPVGltZUFuZE9mZnNldCA9IGNvbWJpbmVFeHRyYWN0b3JzKFxuICBleHRyYWN0SVNPVGltZSxcbiAgZXh0cmFjdElTT09mZnNldCxcbiAgZXh0cmFjdElBTkFab25lXG4pO1xuXG4vKlxuICogQHByaXZhdGVcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VJU09EYXRlKHMpIHtcbiAgcmV0dXJuIHBhcnNlKFxuICAgIHMsXG4gICAgW2lzb1ltZFdpdGhUaW1lRXh0ZW5zaW9uUmVnZXgsIGV4dHJhY3RJU09ZbWRUaW1lQW5kT2Zmc2V0XSxcbiAgICBbaXNvV2Vla1dpdGhUaW1lRXh0ZW5zaW9uUmVnZXgsIGV4dHJhY3RJU09XZWVrVGltZUFuZE9mZnNldF0sXG4gICAgW2lzb09yZGluYWxXaXRoVGltZUV4dGVuc2lvblJlZ2V4LCBleHRyYWN0SVNPT3JkaW5hbERhdGVBbmRUaW1lXSxcbiAgICBbaXNvVGltZUNvbWJpbmVkUmVnZXgsIGV4dHJhY3RJU09UaW1lQW5kT2Zmc2V0XVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VSRkMyODIyRGF0ZShzKSB7XG4gIHJldHVybiBwYXJzZShwcmVwcm9jZXNzUkZDMjgyMihzKSwgW3JmYzI4MjIsIGV4dHJhY3RSRkMyODIyXSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUhUVFBEYXRlKHMpIHtcbiAgcmV0dXJuIHBhcnNlKFxuICAgIHMsXG4gICAgW3JmYzExMjMsIGV4dHJhY3RSRkMxMTIzT3I4NTBdLFxuICAgIFtyZmM4NTAsIGV4dHJhY3RSRkMxMTIzT3I4NTBdLFxuICAgIFthc2NpaSwgZXh0cmFjdEFTQ0lJXVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VJU09EdXJhdGlvbihzKSB7XG4gIHJldHVybiBwYXJzZShzLCBbaXNvRHVyYXRpb24sIGV4dHJhY3RJU09EdXJhdGlvbl0pO1xufVxuXG5jb25zdCBleHRyYWN0SVNPVGltZU9ubHkgPSBjb21iaW5lRXh0cmFjdG9ycyhleHRyYWN0SVNPVGltZSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUlTT1RpbWVPbmx5KHMpIHtcbiAgcmV0dXJuIHBhcnNlKHMsIFtpc29UaW1lT25seSwgZXh0cmFjdElTT1RpbWVPbmx5XSk7XG59XG5cbmNvbnN0IHNxbFltZFdpdGhUaW1lRXh0ZW5zaW9uUmVnZXggPSBjb21iaW5lUmVnZXhlcyhzcWxZbWRSZWdleCwgc3FsVGltZUV4dGVuc2lvblJlZ2V4KTtcbmNvbnN0IHNxbFRpbWVDb21iaW5lZFJlZ2V4ID0gY29tYmluZVJlZ2V4ZXMoc3FsVGltZVJlZ2V4KTtcblxuY29uc3QgZXh0cmFjdElTT1RpbWVPZmZzZXRBbmRJQU5BWm9uZSA9IGNvbWJpbmVFeHRyYWN0b3JzKFxuICBleHRyYWN0SVNPVGltZSxcbiAgZXh0cmFjdElTT09mZnNldCxcbiAgZXh0cmFjdElBTkFab25lXG4pO1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VTUUwocykge1xuICByZXR1cm4gcGFyc2UoXG4gICAgcyxcbiAgICBbc3FsWW1kV2l0aFRpbWVFeHRlbnNpb25SZWdleCwgZXh0cmFjdElTT1ltZFRpbWVBbmRPZmZzZXRdLFxuICAgIFtzcWxUaW1lQ29tYmluZWRSZWdleCwgZXh0cmFjdElTT1RpbWVPZmZzZXRBbmRJQU5BWm9uZV1cbiAgKTtcbn1cbiIsImltcG9ydCB7IHBhcnNlTWlsbGlzLCBpc1VuZGVmaW5lZCwgdW50cnVuY2F0ZVllYXIsIHNpZ25lZE9mZnNldCwgaGFzT3duUHJvcGVydHkgfSBmcm9tIFwiLi91dGlsLmpzXCI7XG5pbXBvcnQgRm9ybWF0dGVyIGZyb20gXCIuL2Zvcm1hdHRlci5qc1wiO1xuaW1wb3J0IEZpeGVkT2Zmc2V0Wm9uZSBmcm9tIFwiLi4vem9uZXMvZml4ZWRPZmZzZXRab25lLmpzXCI7XG5pbXBvcnQgSUFOQVpvbmUgZnJvbSBcIi4uL3pvbmVzL0lBTkFab25lLmpzXCI7XG5pbXBvcnQgRGF0ZVRpbWUgZnJvbSBcIi4uL2RhdGV0aW1lLmpzXCI7XG5pbXBvcnQgeyBkaWdpdFJlZ2V4LCBwYXJzZURpZ2l0cyB9IGZyb20gXCIuL2RpZ2l0cy5qc1wiO1xuaW1wb3J0IHsgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IgfSBmcm9tIFwiLi4vZXJyb3JzLmpzXCI7XG5cbmNvbnN0IE1JU1NJTkdfRlRQID0gXCJtaXNzaW5nIEludGwuRGF0ZVRpbWVGb3JtYXQuZm9ybWF0VG9QYXJ0cyBzdXBwb3J0XCI7XG5cbmZ1bmN0aW9uIGludFVuaXQocmVnZXgsIHBvc3QgPSAoaSkgPT4gaSkge1xuICByZXR1cm4geyByZWdleCwgZGVzZXI6IChbc10pID0+IHBvc3QocGFyc2VEaWdpdHMocykpIH07XG59XG5cbmNvbnN0IE5CU1AgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDE2MCk7XG5jb25zdCBzcGFjZU9yTkJTUCA9IGBbICR7TkJTUH1dYDtcbmNvbnN0IHNwYWNlT3JOQlNQUmVnRXhwID0gbmV3IFJlZ0V4cChzcGFjZU9yTkJTUCwgXCJnXCIpO1xuXG5mdW5jdGlvbiBmaXhMaXN0UmVnZXgocykge1xuICAvLyBtYWtlIGRvdHMgb3B0aW9uYWwgYW5kIGFsc28gbWFrZSB0aGVtIGxpdGVyYWxcbiAgLy8gbWFrZSBzcGFjZSBhbmQgbm9uIGJyZWFrYWJsZSBzcGFjZSBjaGFyYWN0ZXJzIGludGVyY2hhbmdlYWJsZVxuICByZXR1cm4gcy5yZXBsYWNlKC9cXC4vZywgXCJcXFxcLj9cIikucmVwbGFjZShzcGFjZU9yTkJTUFJlZ0V4cCwgc3BhY2VPck5CU1ApO1xufVxuXG5mdW5jdGlvbiBzdHJpcEluc2Vuc2l0aXZpdGllcyhzKSB7XG4gIHJldHVybiBzXG4gICAgLnJlcGxhY2UoL1xcLi9nLCBcIlwiKSAvLyBpZ25vcmUgZG90cyB0aGF0IHdlcmUgbWFkZSBvcHRpb25hbFxuICAgIC5yZXBsYWNlKHNwYWNlT3JOQlNQUmVnRXhwLCBcIiBcIikgLy8gaW50ZXJjaGFuZ2Ugc3BhY2UgYW5kIG5ic3BcbiAgICAudG9Mb3dlckNhc2UoKTtcbn1cblxuZnVuY3Rpb24gb25lT2Yoc3RyaW5ncywgc3RhcnRJbmRleCkge1xuICBpZiAoc3RyaW5ncyA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICByZWdleDogUmVnRXhwKHN0cmluZ3MubWFwKGZpeExpc3RSZWdleCkuam9pbihcInxcIikpLFxuICAgICAgZGVzZXI6IChbc10pID0+XG4gICAgICAgIHN0cmluZ3MuZmluZEluZGV4KChpKSA9PiBzdHJpcEluc2Vuc2l0aXZpdGllcyhzKSA9PT0gc3RyaXBJbnNlbnNpdGl2aXRpZXMoaSkpICsgc3RhcnRJbmRleCxcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIG9mZnNldChyZWdleCwgZ3JvdXBzKSB7XG4gIHJldHVybiB7IHJlZ2V4LCBkZXNlcjogKFssIGgsIG1dKSA9PiBzaWduZWRPZmZzZXQoaCwgbSksIGdyb3VwcyB9O1xufVxuXG5mdW5jdGlvbiBzaW1wbGUocmVnZXgpIHtcbiAgcmV0dXJuIHsgcmVnZXgsIGRlc2VyOiAoW3NdKSA9PiBzIH07XG59XG5cbmZ1bmN0aW9uIGVzY2FwZVRva2VuKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKC9bXFwtXFxbXFxde30oKSorPy4sXFxcXFxcXiR8I1xcc10vZywgXCJcXFxcJCZcIik7XG59XG5cbi8qKlxuICogQHBhcmFtIHRva2VuXG4gKiBAcGFyYW0ge0xvY2FsZX0gbG9jXG4gKi9cbmZ1bmN0aW9uIHVuaXRGb3JUb2tlbih0b2tlbiwgbG9jKSB7XG4gIGNvbnN0IG9uZSA9IGRpZ2l0UmVnZXgobG9jKSxcbiAgICB0d28gPSBkaWdpdFJlZ2V4KGxvYywgXCJ7Mn1cIiksXG4gICAgdGhyZWUgPSBkaWdpdFJlZ2V4KGxvYywgXCJ7M31cIiksXG4gICAgZm91ciA9IGRpZ2l0UmVnZXgobG9jLCBcIns0fVwiKSxcbiAgICBzaXggPSBkaWdpdFJlZ2V4KGxvYywgXCJ7Nn1cIiksXG4gICAgb25lT3JUd28gPSBkaWdpdFJlZ2V4KGxvYywgXCJ7MSwyfVwiKSxcbiAgICBvbmVUb1RocmVlID0gZGlnaXRSZWdleChsb2MsIFwiezEsM31cIiksXG4gICAgb25lVG9TaXggPSBkaWdpdFJlZ2V4KGxvYywgXCJ7MSw2fVwiKSxcbiAgICBvbmVUb05pbmUgPSBkaWdpdFJlZ2V4KGxvYywgXCJ7MSw5fVwiKSxcbiAgICB0d29Ub0ZvdXIgPSBkaWdpdFJlZ2V4KGxvYywgXCJ7Miw0fVwiKSxcbiAgICBmb3VyVG9TaXggPSBkaWdpdFJlZ2V4KGxvYywgXCJ7NCw2fVwiKSxcbiAgICBsaXRlcmFsID0gKHQpID0+ICh7IHJlZ2V4OiBSZWdFeHAoZXNjYXBlVG9rZW4odC52YWwpKSwgZGVzZXI6IChbc10pID0+IHMsIGxpdGVyYWw6IHRydWUgfSksXG4gICAgdW5pdGF0ZSA9ICh0KSA9PiB7XG4gICAgICBpZiAodG9rZW4ubGl0ZXJhbCkge1xuICAgICAgICByZXR1cm4gbGl0ZXJhbCh0KTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodC52YWwpIHtcbiAgICAgICAgLy8gZXJhXG4gICAgICAgIGNhc2UgXCJHXCI6XG4gICAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy5lcmFzKFwic2hvcnRcIiksIDApO1xuICAgICAgICBjYXNlIFwiR0dcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLmVyYXMoXCJsb25nXCIpLCAwKTtcbiAgICAgICAgLy8geWVhcnNcbiAgICAgICAgY2FzZSBcInlcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVUb1NpeCk7XG4gICAgICAgIGNhc2UgXCJ5eVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3b1RvRm91ciwgdW50cnVuY2F0ZVllYXIpO1xuICAgICAgICBjYXNlIFwieXl5eVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KGZvdXIpO1xuICAgICAgICBjYXNlIFwieXl5eXlcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChmb3VyVG9TaXgpO1xuICAgICAgICBjYXNlIFwieXl5eXl5XCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQoc2l4KTtcbiAgICAgICAgLy8gbW9udGhzXG4gICAgICAgIGNhc2UgXCJNXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuICAgICAgICBjYXNlIFwiTU1cIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d28pO1xuICAgICAgICBjYXNlIFwiTU1NXCI6XG4gICAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy5tb250aHMoXCJzaG9ydFwiLCB0cnVlKSwgMSk7XG4gICAgICAgIGNhc2UgXCJNTU1NXCI6XG4gICAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy5tb250aHMoXCJsb25nXCIsIHRydWUpLCAxKTtcbiAgICAgICAgY2FzZSBcIkxcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJMTFwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG4gICAgICAgIGNhc2UgXCJMTExcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLm1vbnRocyhcInNob3J0XCIsIGZhbHNlKSwgMSk7XG4gICAgICAgIGNhc2UgXCJMTExMXCI6XG4gICAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy5tb250aHMoXCJsb25nXCIsIGZhbHNlKSwgMSk7XG4gICAgICAgIC8vIGRhdGVzXG4gICAgICAgIGNhc2UgXCJkXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuICAgICAgICBjYXNlIFwiZGRcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d28pO1xuICAgICAgICAvLyBvcmRpbmFsc1xuICAgICAgICBjYXNlIFwib1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZVRvVGhyZWUpO1xuICAgICAgICBjYXNlIFwib29vXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodGhyZWUpO1xuICAgICAgICAvLyB0aW1lXG4gICAgICAgIGNhc2UgXCJISFwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG4gICAgICAgIGNhc2UgXCJIXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuICAgICAgICBjYXNlIFwiaGhcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d28pO1xuICAgICAgICBjYXNlIFwiaFwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcbiAgICAgICAgY2FzZSBcIm1tXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcbiAgICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJxXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuICAgICAgICBjYXNlIFwicXFcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d28pO1xuICAgICAgICBjYXNlIFwic1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcbiAgICAgICAgY2FzZSBcInNzXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcbiAgICAgICAgY2FzZSBcIlNcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVUb1RocmVlKTtcbiAgICAgICAgY2FzZSBcIlNTU1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHRocmVlKTtcbiAgICAgICAgY2FzZSBcInVcIjpcbiAgICAgICAgICByZXR1cm4gc2ltcGxlKG9uZVRvTmluZSk7XG4gICAgICAgIGNhc2UgXCJ1dVwiOlxuICAgICAgICAgIHJldHVybiBzaW1wbGUob25lT3JUd28pO1xuICAgICAgICBjYXNlIFwidXV1XCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lKTtcbiAgICAgICAgLy8gbWVyaWRpZW1cbiAgICAgICAgY2FzZSBcImFcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLm1lcmlkaWVtcygpLCAwKTtcbiAgICAgICAgLy8gd2Vla1llYXIgKGspXG4gICAgICAgIGNhc2UgXCJra2trXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQoZm91cik7XG4gICAgICAgIGNhc2UgXCJra1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3b1RvRm91ciwgdW50cnVuY2F0ZVllYXIpO1xuICAgICAgICAvLyB3ZWVrTnVtYmVyIChXKVxuICAgICAgICBjYXNlIFwiV1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcbiAgICAgICAgY2FzZSBcIldXXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcbiAgICAgICAgLy8gd2Vla2RheXNcbiAgICAgICAgY2FzZSBcIkVcIjpcbiAgICAgICAgY2FzZSBcImNcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmUpO1xuICAgICAgICBjYXNlIFwiRUVFXCI6XG4gICAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy53ZWVrZGF5cyhcInNob3J0XCIsIGZhbHNlKSwgMSk7XG4gICAgICAgIGNhc2UgXCJFRUVFXCI6XG4gICAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy53ZWVrZGF5cyhcImxvbmdcIiwgZmFsc2UpLCAxKTtcbiAgICAgICAgY2FzZSBcImNjY1wiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2Mud2Vla2RheXMoXCJzaG9ydFwiLCB0cnVlKSwgMSk7XG4gICAgICAgIGNhc2UgXCJjY2NjXCI6XG4gICAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy53ZWVrZGF5cyhcImxvbmdcIiwgdHJ1ZSksIDEpO1xuICAgICAgICAvLyBvZmZzZXQvem9uZVxuICAgICAgICBjYXNlIFwiWlwiOlxuICAgICAgICBjYXNlIFwiWlpcIjpcbiAgICAgICAgICByZXR1cm4gb2Zmc2V0KG5ldyBSZWdFeHAoYChbKy1dJHtvbmVPclR3by5zb3VyY2V9KSg/OjooJHt0d28uc291cmNlfSkpP2ApLCAyKTtcbiAgICAgICAgY2FzZSBcIlpaWlwiOlxuICAgICAgICAgIHJldHVybiBvZmZzZXQobmV3IFJlZ0V4cChgKFsrLV0ke29uZU9yVHdvLnNvdXJjZX0pKCR7dHdvLnNvdXJjZX0pP2ApLCAyKTtcbiAgICAgICAgLy8gd2UgZG9uJ3Qgc3VwcG9ydCBaWlpaIChQU1QpIG9yIFpaWlpaIChQYWNpZmljIFN0YW5kYXJkIFRpbWUpIGluIHBhcnNpbmdcbiAgICAgICAgLy8gYmVjYXVzZSB3ZSBkb24ndCBoYXZlIGFueSB3YXkgdG8gZmlndXJlIG91dCB3aGF0IHRoZXkgYXJlXG4gICAgICAgIGNhc2UgXCJ6XCI6XG4gICAgICAgICAgcmV0dXJuIHNpbXBsZSgvW2Etel8rLS9dezEsMjU2fT8vaSk7XG4gICAgICAgIC8vIHRoaXMgc3BlY2lhbC1jYXNlIFwidG9rZW5cIiByZXByZXNlbnRzIGEgcGxhY2Ugd2hlcmUgYSBtYWNyby10b2tlbiBleHBhbmRlZCBpbnRvIGEgd2hpdGUtc3BhY2UgbGl0ZXJhbFxuICAgICAgICAvLyBpbiB0aGlzIGNhc2Ugd2UgYWNjZXB0IGFueSBub24tbmV3bGluZSB3aGl0ZS1zcGFjZVxuICAgICAgICBjYXNlIFwiIFwiOlxuICAgICAgICAgIHJldHVybiBzaW1wbGUoL1teXFxTXFxuXFxyXS8pO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBsaXRlcmFsKHQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgY29uc3QgdW5pdCA9IHVuaXRhdGUodG9rZW4pIHx8IHtcbiAgICBpbnZhbGlkUmVhc29uOiBNSVNTSU5HX0ZUUCxcbiAgfTtcblxuICB1bml0LnRva2VuID0gdG9rZW47XG5cbiAgcmV0dXJuIHVuaXQ7XG59XG5cbmNvbnN0IHBhcnRUeXBlU3R5bGVUb1Rva2VuVmFsID0ge1xuICB5ZWFyOiB7XG4gICAgXCIyLWRpZ2l0XCI6IFwieXlcIixcbiAgICBudW1lcmljOiBcInl5eXl5XCIsXG4gIH0sXG4gIG1vbnRoOiB7XG4gICAgbnVtZXJpYzogXCJNXCIsXG4gICAgXCIyLWRpZ2l0XCI6IFwiTU1cIixcbiAgICBzaG9ydDogXCJNTU1cIixcbiAgICBsb25nOiBcIk1NTU1cIixcbiAgfSxcbiAgZGF5OiB7XG4gICAgbnVtZXJpYzogXCJkXCIsXG4gICAgXCIyLWRpZ2l0XCI6IFwiZGRcIixcbiAgfSxcbiAgd2Vla2RheToge1xuICAgIHNob3J0OiBcIkVFRVwiLFxuICAgIGxvbmc6IFwiRUVFRVwiLFxuICB9LFxuICBkYXlwZXJpb2Q6IFwiYVwiLFxuICBkYXlQZXJpb2Q6IFwiYVwiLFxuICBob3VyMTI6IHtcbiAgICBudW1lcmljOiBcImhcIixcbiAgICBcIjItZGlnaXRcIjogXCJoaFwiLFxuICB9LFxuICBob3VyMjQ6IHtcbiAgICBudW1lcmljOiBcIkhcIixcbiAgICBcIjItZGlnaXRcIjogXCJISFwiLFxuICB9LFxuICBtaW51dGU6IHtcbiAgICBudW1lcmljOiBcIm1cIixcbiAgICBcIjItZGlnaXRcIjogXCJtbVwiLFxuICB9LFxuICBzZWNvbmQ6IHtcbiAgICBudW1lcmljOiBcInNcIixcbiAgICBcIjItZGlnaXRcIjogXCJzc1wiLFxuICB9LFxuICB0aW1lWm9uZU5hbWU6IHtcbiAgICBsb25nOiBcIlpaWlpaXCIsXG4gICAgc2hvcnQ6IFwiWlpaXCIsXG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0b2tlbkZvclBhcnQocGFydCwgZm9ybWF0T3B0cywgcmVzb2x2ZWRPcHRzKSB7XG4gIGNvbnN0IHsgdHlwZSwgdmFsdWUgfSA9IHBhcnQ7XG5cbiAgaWYgKHR5cGUgPT09IFwibGl0ZXJhbFwiKSB7XG4gICAgY29uc3QgaXNTcGFjZSA9IC9eXFxzKyQvLnRlc3QodmFsdWUpO1xuICAgIHJldHVybiB7XG4gICAgICBsaXRlcmFsOiAhaXNTcGFjZSxcbiAgICAgIHZhbDogaXNTcGFjZSA/IFwiIFwiIDogdmFsdWUsXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IHN0eWxlID0gZm9ybWF0T3B0c1t0eXBlXTtcblxuICAvLyBUaGUgdXNlciBtaWdodCBoYXZlIGV4cGxpY2l0bHkgc3BlY2lmaWVkIGhvdXIxMiBvciBob3VyQ3ljbGVcbiAgLy8gaWYgc28sIHJlc3BlY3QgdGhlaXIgZGVjaXNpb25cbiAgLy8gaWYgbm90LCByZWZlciBiYWNrIHRvIHRoZSByZXNvbHZlZE9wdHMsIHdoaWNoIGFyZSBiYXNlZCBvbiB0aGUgbG9jYWxlXG4gIGxldCBhY3R1YWxUeXBlID0gdHlwZTtcbiAgaWYgKHR5cGUgPT09IFwiaG91clwiKSB7XG4gICAgaWYgKGZvcm1hdE9wdHMuaG91cjEyICE9IG51bGwpIHtcbiAgICAgIGFjdHVhbFR5cGUgPSBmb3JtYXRPcHRzLmhvdXIxMiA/IFwiaG91cjEyXCIgOiBcImhvdXIyNFwiO1xuICAgIH0gZWxzZSBpZiAoZm9ybWF0T3B0cy5ob3VyQ3ljbGUgIT0gbnVsbCkge1xuICAgICAgaWYgKGZvcm1hdE9wdHMuaG91ckN5Y2xlID09PSBcImgxMVwiIHx8IGZvcm1hdE9wdHMuaG91ckN5Y2xlID09PSBcImgxMlwiKSB7XG4gICAgICAgIGFjdHVhbFR5cGUgPSBcImhvdXIxMlwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0dWFsVHlwZSA9IFwiaG91cjI0XCI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRva2VucyBvbmx5IGRpZmZlcmVudGlhdGUgYmV0d2VlbiAyNCBob3VycyBvciBub3QsXG4gICAgICAvLyBzbyB3ZSBkbyBub3QgbmVlZCB0byBjaGVjayBob3VyQ3ljbGUgaGVyZSwgd2hpY2ggaXMgbGVzcyBzdXBwb3J0ZWQgYW55d2F5c1xuICAgICAgYWN0dWFsVHlwZSA9IHJlc29sdmVkT3B0cy5ob3VyMTIgPyBcImhvdXIxMlwiIDogXCJob3VyMjRcIjtcbiAgICB9XG4gIH1cbiAgbGV0IHZhbCA9IHBhcnRUeXBlU3R5bGVUb1Rva2VuVmFsW2FjdHVhbFR5cGVdO1xuICBpZiAodHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIikge1xuICAgIHZhbCA9IHZhbFtzdHlsZV07XG4gIH1cblxuICBpZiAodmFsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpdGVyYWw6IGZhbHNlLFxuICAgICAgdmFsLFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBidWlsZFJlZ2V4KHVuaXRzKSB7XG4gIGNvbnN0IHJlID0gdW5pdHMubWFwKCh1KSA9PiB1LnJlZ2V4KS5yZWR1Y2UoKGYsIHIpID0+IGAke2Z9KCR7ci5zb3VyY2V9KWAsIFwiXCIpO1xuICByZXR1cm4gW2BeJHtyZX0kYCwgdW5pdHNdO1xufVxuXG5mdW5jdGlvbiBtYXRjaChpbnB1dCwgcmVnZXgsIGhhbmRsZXJzKSB7XG4gIGNvbnN0IG1hdGNoZXMgPSBpbnB1dC5tYXRjaChyZWdleCk7XG5cbiAgaWYgKG1hdGNoZXMpIHtcbiAgICBjb25zdCBhbGwgPSB7fTtcbiAgICBsZXQgbWF0Y2hJbmRleCA9IDE7XG4gICAgZm9yIChjb25zdCBpIGluIGhhbmRsZXJzKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkoaGFuZGxlcnMsIGkpKSB7XG4gICAgICAgIGNvbnN0IGggPSBoYW5kbGVyc1tpXSxcbiAgICAgICAgICBncm91cHMgPSBoLmdyb3VwcyA/IGguZ3JvdXBzICsgMSA6IDE7XG4gICAgICAgIGlmICghaC5saXRlcmFsICYmIGgudG9rZW4pIHtcbiAgICAgICAgICBhbGxbaC50b2tlbi52YWxbMF1dID0gaC5kZXNlcihtYXRjaGVzLnNsaWNlKG1hdGNoSW5kZXgsIG1hdGNoSW5kZXggKyBncm91cHMpKTtcbiAgICAgICAgfVxuICAgICAgICBtYXRjaEluZGV4ICs9IGdyb3VwcztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFttYXRjaGVzLCBhbGxdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbbWF0Y2hlcywge31dO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRhdGVUaW1lRnJvbU1hdGNoZXMobWF0Y2hlcykge1xuICBjb25zdCB0b0ZpZWxkID0gKHRva2VuKSA9PiB7XG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgY2FzZSBcIlNcIjpcbiAgICAgICAgcmV0dXJuIFwibWlsbGlzZWNvbmRcIjtcbiAgICAgIGNhc2UgXCJzXCI6XG4gICAgICAgIHJldHVybiBcInNlY29uZFwiO1xuICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgcmV0dXJuIFwibWludXRlXCI7XG4gICAgICBjYXNlIFwiaFwiOlxuICAgICAgY2FzZSBcIkhcIjpcbiAgICAgICAgcmV0dXJuIFwiaG91clwiO1xuICAgICAgY2FzZSBcImRcIjpcbiAgICAgICAgcmV0dXJuIFwiZGF5XCI7XG4gICAgICBjYXNlIFwib1wiOlxuICAgICAgICByZXR1cm4gXCJvcmRpbmFsXCI7XG4gICAgICBjYXNlIFwiTFwiOlxuICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgcmV0dXJuIFwibW9udGhcIjtcbiAgICAgIGNhc2UgXCJ5XCI6XG4gICAgICAgIHJldHVybiBcInllYXJcIjtcbiAgICAgIGNhc2UgXCJFXCI6XG4gICAgICBjYXNlIFwiY1wiOlxuICAgICAgICByZXR1cm4gXCJ3ZWVrZGF5XCI7XG4gICAgICBjYXNlIFwiV1wiOlxuICAgICAgICByZXR1cm4gXCJ3ZWVrTnVtYmVyXCI7XG4gICAgICBjYXNlIFwia1wiOlxuICAgICAgICByZXR1cm4gXCJ3ZWVrWWVhclwiO1xuICAgICAgY2FzZSBcInFcIjpcbiAgICAgICAgcmV0dXJuIFwicXVhcnRlclwiO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuXG4gIGxldCB6b25lID0gbnVsbDtcbiAgbGV0IHNwZWNpZmljT2Zmc2V0O1xuICBpZiAoIWlzVW5kZWZpbmVkKG1hdGNoZXMueikpIHtcbiAgICB6b25lID0gSUFOQVpvbmUuY3JlYXRlKG1hdGNoZXMueik7XG4gIH1cblxuICBpZiAoIWlzVW5kZWZpbmVkKG1hdGNoZXMuWikpIHtcbiAgICBpZiAoIXpvbmUpIHtcbiAgICAgIHpvbmUgPSBuZXcgRml4ZWRPZmZzZXRab25lKG1hdGNoZXMuWik7XG4gICAgfVxuICAgIHNwZWNpZmljT2Zmc2V0ID0gbWF0Y2hlcy5aO1xuICB9XG5cbiAgaWYgKCFpc1VuZGVmaW5lZChtYXRjaGVzLnEpKSB7XG4gICAgbWF0Y2hlcy5NID0gKG1hdGNoZXMucSAtIDEpICogMyArIDE7XG4gIH1cblxuICBpZiAoIWlzVW5kZWZpbmVkKG1hdGNoZXMuaCkpIHtcbiAgICBpZiAobWF0Y2hlcy5oIDwgMTIgJiYgbWF0Y2hlcy5hID09PSAxKSB7XG4gICAgICBtYXRjaGVzLmggKz0gMTI7XG4gICAgfSBlbHNlIGlmIChtYXRjaGVzLmggPT09IDEyICYmIG1hdGNoZXMuYSA9PT0gMCkge1xuICAgICAgbWF0Y2hlcy5oID0gMDtcbiAgICB9XG4gIH1cblxuICBpZiAobWF0Y2hlcy5HID09PSAwICYmIG1hdGNoZXMueSkge1xuICAgIG1hdGNoZXMueSA9IC1tYXRjaGVzLnk7XG4gIH1cblxuICBpZiAoIWlzVW5kZWZpbmVkKG1hdGNoZXMudSkpIHtcbiAgICBtYXRjaGVzLlMgPSBwYXJzZU1pbGxpcyhtYXRjaGVzLnUpO1xuICB9XG5cbiAgY29uc3QgdmFscyA9IE9iamVjdC5rZXlzKG1hdGNoZXMpLnJlZHVjZSgociwgaykgPT4ge1xuICAgIGNvbnN0IGYgPSB0b0ZpZWxkKGspO1xuICAgIGlmIChmKSB7XG4gICAgICByW2ZdID0gbWF0Y2hlc1trXTtcbiAgICB9XG5cbiAgICByZXR1cm4gcjtcbiAgfSwge30pO1xuXG4gIHJldHVybiBbdmFscywgem9uZSwgc3BlY2lmaWNPZmZzZXRdO1xufVxuXG5sZXQgZHVtbXlEYXRlVGltZUNhY2hlID0gbnVsbDtcblxuZnVuY3Rpb24gZ2V0RHVtbXlEYXRlVGltZSgpIHtcbiAgaWYgKCFkdW1teURhdGVUaW1lQ2FjaGUpIHtcbiAgICBkdW1teURhdGVUaW1lQ2FjaGUgPSBEYXRlVGltZS5mcm9tTWlsbGlzKDE1NTU1NTU1NTU1NTUpO1xuICB9XG5cbiAgcmV0dXJuIGR1bW15RGF0ZVRpbWVDYWNoZTtcbn1cblxuZnVuY3Rpb24gbWF5YmVFeHBhbmRNYWNyb1Rva2VuKHRva2VuLCBsb2NhbGUpIHtcbiAgaWYgKHRva2VuLmxpdGVyYWwpIHtcbiAgICByZXR1cm4gdG9rZW47XG4gIH1cblxuICBjb25zdCBmb3JtYXRPcHRzID0gRm9ybWF0dGVyLm1hY3JvVG9rZW5Ub0Zvcm1hdE9wdHModG9rZW4udmFsKTtcbiAgY29uc3QgdG9rZW5zID0gZm9ybWF0T3B0c1RvVG9rZW5zKGZvcm1hdE9wdHMsIGxvY2FsZSk7XG5cbiAgaWYgKHRva2VucyA9PSBudWxsIHx8IHRva2Vucy5pbmNsdWRlcyh1bmRlZmluZWQpKSB7XG4gICAgcmV0dXJuIHRva2VuO1xuICB9XG5cbiAgcmV0dXJuIHRva2Vucztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4cGFuZE1hY3JvVG9rZW5zKHRva2VucywgbG9jYWxlKSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0KC4uLnRva2Vucy5tYXAoKHQpID0+IG1heWJlRXhwYW5kTWFjcm9Ub2tlbih0LCBsb2NhbGUpKSk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXhwbGFpbkZyb21Ub2tlbnMobG9jYWxlLCBpbnB1dCwgZm9ybWF0KSB7XG4gIGNvbnN0IHRva2VucyA9IGV4cGFuZE1hY3JvVG9rZW5zKEZvcm1hdHRlci5wYXJzZUZvcm1hdChmb3JtYXQpLCBsb2NhbGUpLFxuICAgIHVuaXRzID0gdG9rZW5zLm1hcCgodCkgPT4gdW5pdEZvclRva2VuKHQsIGxvY2FsZSkpLFxuICAgIGRpc3F1YWxpZnlpbmdVbml0ID0gdW5pdHMuZmluZCgodCkgPT4gdC5pbnZhbGlkUmVhc29uKTtcblxuICBpZiAoZGlzcXVhbGlmeWluZ1VuaXQpIHtcbiAgICByZXR1cm4geyBpbnB1dCwgdG9rZW5zLCBpbnZhbGlkUmVhc29uOiBkaXNxdWFsaWZ5aW5nVW5pdC5pbnZhbGlkUmVhc29uIH07XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgW3JlZ2V4U3RyaW5nLCBoYW5kbGVyc10gPSBidWlsZFJlZ2V4KHVuaXRzKSxcbiAgICAgIHJlZ2V4ID0gUmVnRXhwKHJlZ2V4U3RyaW5nLCBcImlcIiksXG4gICAgICBbcmF3TWF0Y2hlcywgbWF0Y2hlc10gPSBtYXRjaChpbnB1dCwgcmVnZXgsIGhhbmRsZXJzKSxcbiAgICAgIFtyZXN1bHQsIHpvbmUsIHNwZWNpZmljT2Zmc2V0XSA9IG1hdGNoZXNcbiAgICAgICAgPyBkYXRlVGltZUZyb21NYXRjaGVzKG1hdGNoZXMpXG4gICAgICAgIDogW251bGwsIG51bGwsIHVuZGVmaW5lZF07XG4gICAgaWYgKGhhc093blByb3BlcnR5KG1hdGNoZXMsIFwiYVwiKSAmJiBoYXNPd25Qcm9wZXJ0eShtYXRjaGVzLCBcIkhcIikpIHtcbiAgICAgIHRocm93IG5ldyBDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvcihcbiAgICAgICAgXCJDYW4ndCBpbmNsdWRlIG1lcmlkaWVtIHdoZW4gc3BlY2lmeWluZyAyNC1ob3VyIGZvcm1hdFwiXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4geyBpbnB1dCwgdG9rZW5zLCByZWdleCwgcmF3TWF0Y2hlcywgbWF0Y2hlcywgcmVzdWx0LCB6b25lLCBzcGVjaWZpY09mZnNldCB9O1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUZyb21Ub2tlbnMobG9jYWxlLCBpbnB1dCwgZm9ybWF0KSB7XG4gIGNvbnN0IHsgcmVzdWx0LCB6b25lLCBzcGVjaWZpY09mZnNldCwgaW52YWxpZFJlYXNvbiB9ID0gZXhwbGFpbkZyb21Ub2tlbnMobG9jYWxlLCBpbnB1dCwgZm9ybWF0KTtcbiAgcmV0dXJuIFtyZXN1bHQsIHpvbmUsIHNwZWNpZmljT2Zmc2V0LCBpbnZhbGlkUmVhc29uXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdE9wdHNUb1Rva2Vucyhmb3JtYXRPcHRzLCBsb2NhbGUpIHtcbiAgaWYgKCFmb3JtYXRPcHRzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBmb3JtYXR0ZXIgPSBGb3JtYXR0ZXIuY3JlYXRlKGxvY2FsZSwgZm9ybWF0T3B0cyk7XG4gIGNvbnN0IGRmID0gZm9ybWF0dGVyLmR0Rm9ybWF0dGVyKGdldER1bW15RGF0ZVRpbWUoKSk7XG4gIGNvbnN0IHBhcnRzID0gZGYuZm9ybWF0VG9QYXJ0cygpO1xuICBjb25zdCByZXNvbHZlZE9wdHMgPSBkZi5yZXNvbHZlZE9wdGlvbnMoKTtcbiAgcmV0dXJuIHBhcnRzLm1hcCgocCkgPT4gdG9rZW5Gb3JQYXJ0KHAsIGZvcm1hdE9wdHMsIHJlc29sdmVkT3B0cykpO1xufVxuIiwiLypcbiAgVGhpcyBpcyBqdXN0IGEganVuayBkcmF3ZXIsIGNvbnRhaW5pbmcgYW55dGhpbmcgdXNlZCBhY3Jvc3MgbXVsdGlwbGUgY2xhc3Nlcy5cbiAgQmVjYXVzZSBMdXhvbiBpcyBzbWFsbChpc2gpLCB0aGlzIHNob3VsZCBzdGF5IHNtYWxsIGFuZCB3ZSB3b24ndCB3b3JyeSBhYm91dCBzcGxpdHRpbmdcbiAgaXQgdXAgaW50bywgc2F5LCBwYXJzaW5nVXRpbC5qcyBhbmQgYmFzaWNVdGlsLmpzIGFuZCBzbyBvbi4gQnV0IHRoZXkgYXJlIGRpdmlkZWQgdXAgYnkgZmVhdHVyZSBhcmVhLlxuKi9cblxuaW1wb3J0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IgfSBmcm9tIFwiLi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgU2V0dGluZ3MgZnJvbSBcIi4uL3NldHRpbmdzLmpzXCI7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG4vLyBUWVBFU1xuXG5leHBvcnQgZnVuY3Rpb24gaXNVbmRlZmluZWQobykge1xuICByZXR1cm4gdHlwZW9mIG8gPT09IFwidW5kZWZpbmVkXCI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc051bWJlcihvKSB7XG4gIHJldHVybiB0eXBlb2YgbyA9PT0gXCJudW1iZXJcIjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzSW50ZWdlcihvKSB7XG4gIHJldHVybiB0eXBlb2YgbyA9PT0gXCJudW1iZXJcIiAmJiBvICUgMSA9PT0gMDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU3RyaW5nKG8pIHtcbiAgcmV0dXJuIHR5cGVvZiBvID09PSBcInN0cmluZ1wiO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNEYXRlKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSA9PT0gXCJbb2JqZWN0IERhdGVdXCI7XG59XG5cbi8vIENBUEFCSUxJVElFU1xuXG5leHBvcnQgZnVuY3Rpb24gaGFzUmVsYXRpdmUoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHR5cGVvZiBJbnRsICE9PSBcInVuZGVmaW5lZFwiICYmICEhSW50bC5SZWxhdGl2ZVRpbWVGb3JtYXQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLy8gT0JKRUNUUyBBTkQgQVJSQVlTXG5cbmV4cG9ydCBmdW5jdGlvbiBtYXliZUFycmF5KHRoaW5nKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHRoaW5nKSA/IHRoaW5nIDogW3RoaW5nXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJlc3RCeShhcnIsIGJ5LCBjb21wYXJlKSB7XG4gIGlmIChhcnIubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gYXJyLnJlZHVjZSgoYmVzdCwgbmV4dCkgPT4ge1xuICAgIGNvbnN0IHBhaXIgPSBbYnkobmV4dCksIG5leHRdO1xuICAgIGlmICghYmVzdCkge1xuICAgICAgcmV0dXJuIHBhaXI7XG4gICAgfSBlbHNlIGlmIChjb21wYXJlKGJlc3RbMF0sIHBhaXJbMF0pID09PSBiZXN0WzBdKSB7XG4gICAgICByZXR1cm4gYmVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHBhaXI7XG4gICAgfVxuICB9LCBudWxsKVsxXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBpY2sob2JqLCBrZXlzKSB7XG4gIHJldHVybiBrZXlzLnJlZHVjZSgoYSwgaykgPT4ge1xuICAgIGFba10gPSBvYmpba107XG4gICAgcmV0dXJuIGE7XG4gIH0sIHt9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbi8vIE5VTUJFUlMgQU5EIFNUUklOR1NcblxuZXhwb3J0IGZ1bmN0aW9uIGludGVnZXJCZXR3ZWVuKHRoaW5nLCBib3R0b20sIHRvcCkge1xuICByZXR1cm4gaXNJbnRlZ2VyKHRoaW5nKSAmJiB0aGluZyA+PSBib3R0b20gJiYgdGhpbmcgPD0gdG9wO1xufVxuXG4vLyB4ICUgbiBidXQgdGFrZXMgdGhlIHNpZ24gb2YgbiBpbnN0ZWFkIG9mIHhcbmV4cG9ydCBmdW5jdGlvbiBmbG9vck1vZCh4LCBuKSB7XG4gIHJldHVybiB4IC0gbiAqIE1hdGguZmxvb3IoeCAvIG4pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFkU3RhcnQoaW5wdXQsIG4gPSAyKSB7XG4gIGNvbnN0IGlzTmVnID0gaW5wdXQgPCAwO1xuICBsZXQgcGFkZGVkO1xuICBpZiAoaXNOZWcpIHtcbiAgICBwYWRkZWQgPSBcIi1cIiArIChcIlwiICsgLWlucHV0KS5wYWRTdGFydChuLCBcIjBcIik7XG4gIH0gZWxzZSB7XG4gICAgcGFkZGVkID0gKFwiXCIgKyBpbnB1dCkucGFkU3RhcnQobiwgXCIwXCIpO1xuICB9XG4gIHJldHVybiBwYWRkZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUludGVnZXIoc3RyaW5nKSB7XG4gIGlmIChpc1VuZGVmaW5lZChzdHJpbmcpIHx8IHN0cmluZyA9PT0gbnVsbCB8fCBzdHJpbmcgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwYXJzZUludChzdHJpbmcsIDEwKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VGbG9hdGluZyhzdHJpbmcpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHN0cmluZykgfHwgc3RyaW5nID09PSBudWxsIHx8IHN0cmluZyA9PT0gXCJcIikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQoc3RyaW5nKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VNaWxsaXMoZnJhY3Rpb24pIHtcbiAgLy8gUmV0dXJuIHVuZGVmaW5lZCAoaW5zdGVhZCBvZiAwKSBpbiB0aGVzZSBjYXNlcywgd2hlcmUgZnJhY3Rpb24gaXMgbm90IHNldFxuICBpZiAoaXNVbmRlZmluZWQoZnJhY3Rpb24pIHx8IGZyYWN0aW9uID09PSBudWxsIHx8IGZyYWN0aW9uID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBmID0gcGFyc2VGbG9hdChcIjAuXCIgKyBmcmFjdGlvbikgKiAxMDAwO1xuICAgIHJldHVybiBNYXRoLmZsb29yKGYpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByb3VuZFRvKG51bWJlciwgZGlnaXRzLCB0b3dhcmRaZXJvID0gZmFsc2UpIHtcbiAgY29uc3QgZmFjdG9yID0gMTAgKiogZGlnaXRzLFxuICAgIHJvdW5kZXIgPSB0b3dhcmRaZXJvID8gTWF0aC50cnVuYyA6IE1hdGgucm91bmQ7XG4gIHJldHVybiByb3VuZGVyKG51bWJlciAqIGZhY3RvcikgLyBmYWN0b3I7XG59XG5cbi8vIERBVEUgQkFTSUNTXG5cbmV4cG9ydCBmdW5jdGlvbiBpc0xlYXBZZWFyKHllYXIpIHtcbiAgcmV0dXJuIHllYXIgJSA0ID09PSAwICYmICh5ZWFyICUgMTAwICE9PSAwIHx8IHllYXIgJSA0MDAgPT09IDApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGF5c0luWWVhcih5ZWFyKSB7XG4gIHJldHVybiBpc0xlYXBZZWFyKHllYXIpID8gMzY2IDogMzY1O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGF5c0luTW9udGgoeWVhciwgbW9udGgpIHtcbiAgY29uc3QgbW9kTW9udGggPSBmbG9vck1vZChtb250aCAtIDEsIDEyKSArIDEsXG4gICAgbW9kWWVhciA9IHllYXIgKyAobW9udGggLSBtb2RNb250aCkgLyAxMjtcblxuICBpZiAobW9kTW9udGggPT09IDIpIHtcbiAgICByZXR1cm4gaXNMZWFwWWVhcihtb2RZZWFyKSA/IDI5IDogMjg7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFszMSwgbnVsbCwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdW21vZE1vbnRoIC0gMV07XG4gIH1cbn1cblxuLy8gY29udmVydCBhIGNhbGVuZGFyIG9iamVjdCB0byBhIGxvY2FsIHRpbWVzdGFtcCAoZXBvY2gsIGJ1dCB3aXRoIHRoZSBvZmZzZXQgYmFrZWQgaW4pXG5leHBvcnQgZnVuY3Rpb24gb2JqVG9Mb2NhbFRTKG9iaikge1xuICBsZXQgZCA9IERhdGUuVVRDKFxuICAgIG9iai55ZWFyLFxuICAgIG9iai5tb250aCAtIDEsXG4gICAgb2JqLmRheSxcbiAgICBvYmouaG91cixcbiAgICBvYmoubWludXRlLFxuICAgIG9iai5zZWNvbmQsXG4gICAgb2JqLm1pbGxpc2Vjb25kXG4gICk7XG5cbiAgLy8gZm9yIGxlZ2FjeSByZWFzb25zLCB5ZWFycyBiZXR3ZWVuIDAgYW5kIDk5IGFyZSBpbnRlcnByZXRlZCBhcyAxOVhYOyByZXZlcnQgdGhhdFxuICBpZiAob2JqLnllYXIgPCAxMDAgJiYgb2JqLnllYXIgPj0gMCkge1xuICAgIGQgPSBuZXcgRGF0ZShkKTtcbiAgICAvLyBzZXQgdGhlIG1vbnRoIGFuZCBkYXkgYWdhaW4sIHRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgeWVhciAyMDAwIGlzIGEgbGVhcCB5ZWFyLCBidXQgeWVhciAxMDAgaXMgbm90XG4gICAgLy8gc28gaWYgb2JqLnllYXIgaXMgaW4gOTksIGJ1dCBvYmouZGF5IG1ha2VzIGl0IHJvbGwgb3ZlciBpbnRvIHllYXIgMTAwLFxuICAgIC8vIHRoZSBjYWxjdWxhdGlvbnMgZG9uZSBieSBEYXRlLlVUQyBhcmUgdXNpbmcgeWVhciAyMDAwIC0gd2hpY2ggaXMgaW5jb3JyZWN0XG4gICAgZC5zZXRVVENGdWxsWWVhcihvYmoueWVhciwgb2JqLm1vbnRoIC0gMSwgb2JqLmRheSk7XG4gIH1cbiAgcmV0dXJuICtkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2Vla3NJbldlZWtZZWFyKHdlZWtZZWFyKSB7XG4gIGNvbnN0IHAxID1cbiAgICAgICh3ZWVrWWVhciArXG4gICAgICAgIE1hdGguZmxvb3Iod2Vla1llYXIgLyA0KSAtXG4gICAgICAgIE1hdGguZmxvb3Iod2Vla1llYXIgLyAxMDApICtcbiAgICAgICAgTWF0aC5mbG9vcih3ZWVrWWVhciAvIDQwMCkpICVcbiAgICAgIDcsXG4gICAgbGFzdCA9IHdlZWtZZWFyIC0gMSxcbiAgICBwMiA9IChsYXN0ICsgTWF0aC5mbG9vcihsYXN0IC8gNCkgLSBNYXRoLmZsb29yKGxhc3QgLyAxMDApICsgTWF0aC5mbG9vcihsYXN0IC8gNDAwKSkgJSA3O1xuICByZXR1cm4gcDEgPT09IDQgfHwgcDIgPT09IDMgPyA1MyA6IDUyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdW50cnVuY2F0ZVllYXIoeWVhcikge1xuICBpZiAoeWVhciA+IDk5KSB7XG4gICAgcmV0dXJuIHllYXI7XG4gIH0gZWxzZSByZXR1cm4geWVhciA+IFNldHRpbmdzLnR3b0RpZ2l0Q3V0b2ZmWWVhciA/IDE5MDAgKyB5ZWFyIDogMjAwMCArIHllYXI7XG59XG5cbi8vIFBBUlNJTkdcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlWm9uZUluZm8odHMsIG9mZnNldEZvcm1hdCwgbG9jYWxlLCB0aW1lWm9uZSA9IG51bGwpIHtcbiAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHRzKSxcbiAgICBpbnRsT3B0cyA9IHtcbiAgICAgIGhvdXJDeWNsZTogXCJoMjNcIixcbiAgICAgIHllYXI6IFwibnVtZXJpY1wiLFxuICAgICAgbW9udGg6IFwiMi1kaWdpdFwiLFxuICAgICAgZGF5OiBcIjItZGlnaXRcIixcbiAgICAgIGhvdXI6IFwiMi1kaWdpdFwiLFxuICAgICAgbWludXRlOiBcIjItZGlnaXRcIixcbiAgICB9O1xuXG4gIGlmICh0aW1lWm9uZSkge1xuICAgIGludGxPcHRzLnRpbWVab25lID0gdGltZVpvbmU7XG4gIH1cblxuICBjb25zdCBtb2RpZmllZCA9IHsgdGltZVpvbmVOYW1lOiBvZmZzZXRGb3JtYXQsIC4uLmludGxPcHRzIH07XG5cbiAgY29uc3QgcGFyc2VkID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCBtb2RpZmllZClcbiAgICAuZm9ybWF0VG9QYXJ0cyhkYXRlKVxuICAgIC5maW5kKChtKSA9PiBtLnR5cGUudG9Mb3dlckNhc2UoKSA9PT0gXCJ0aW1lem9uZW5hbWVcIik7XG4gIHJldHVybiBwYXJzZWQgPyBwYXJzZWQudmFsdWUgOiBudWxsO1xufVxuXG4vLyBzaWduZWRPZmZzZXQoJy01JywgJzMwJykgLT4gLTMzMFxuZXhwb3J0IGZ1bmN0aW9uIHNpZ25lZE9mZnNldChvZmZIb3VyU3RyLCBvZmZNaW51dGVTdHIpIHtcbiAgbGV0IG9mZkhvdXIgPSBwYXJzZUludChvZmZIb3VyU3RyLCAxMCk7XG5cbiAgLy8gZG9uJ3QgfHwgdGhpcyBiZWNhdXNlIHdlIHdhbnQgdG8gcHJlc2VydmUgLTBcbiAgaWYgKE51bWJlci5pc05hTihvZmZIb3VyKSkge1xuICAgIG9mZkhvdXIgPSAwO1xuICB9XG5cbiAgY29uc3Qgb2ZmTWluID0gcGFyc2VJbnQob2ZmTWludXRlU3RyLCAxMCkgfHwgMCxcbiAgICBvZmZNaW5TaWduZWQgPSBvZmZIb3VyIDwgMCB8fCBPYmplY3QuaXMob2ZmSG91ciwgLTApID8gLW9mZk1pbiA6IG9mZk1pbjtcbiAgcmV0dXJuIG9mZkhvdXIgKiA2MCArIG9mZk1pblNpZ25lZDtcbn1cblxuLy8gQ09FUkNJT05cblxuZXhwb3J0IGZ1bmN0aW9uIGFzTnVtYmVyKHZhbHVlKSB7XG4gIGNvbnN0IG51bWVyaWNWYWx1ZSA9IE51bWJlcih2YWx1ZSk7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiIHx8IHZhbHVlID09PSBcIlwiIHx8IE51bWJlci5pc05hTihudW1lcmljVmFsdWUpKVxuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihgSW52YWxpZCB1bml0IHZhbHVlICR7dmFsdWV9YCk7XG4gIHJldHVybiBudW1lcmljVmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVPYmplY3Qob2JqLCBub3JtYWxpemVyKSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSB7fTtcbiAgZm9yIChjb25zdCB1IGluIG9iaikge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eShvYmosIHUpKSB7XG4gICAgICBjb25zdCB2ID0gb2JqW3VdO1xuICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSBudWxsKSBjb250aW51ZTtcbiAgICAgIG5vcm1hbGl6ZWRbbm9ybWFsaXplcih1KV0gPSBhc051bWJlcih2KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRPZmZzZXQob2Zmc2V0LCBmb3JtYXQpIHtcbiAgY29uc3QgaG91cnMgPSBNYXRoLnRydW5jKE1hdGguYWJzKG9mZnNldCAvIDYwKSksXG4gICAgbWludXRlcyA9IE1hdGgudHJ1bmMoTWF0aC5hYnMob2Zmc2V0ICUgNjApKSxcbiAgICBzaWduID0gb2Zmc2V0ID49IDAgPyBcIitcIiA6IFwiLVwiO1xuXG4gIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgY2FzZSBcInNob3J0XCI6XG4gICAgICByZXR1cm4gYCR7c2lnbn0ke3BhZFN0YXJ0KGhvdXJzLCAyKX06JHtwYWRTdGFydChtaW51dGVzLCAyKX1gO1xuICAgIGNhc2UgXCJuYXJyb3dcIjpcbiAgICAgIHJldHVybiBgJHtzaWdufSR7aG91cnN9JHttaW51dGVzID4gMCA/IGA6JHttaW51dGVzfWAgOiBcIlwifWA7XG4gICAgY2FzZSBcInRlY2hpZVwiOlxuICAgICAgcmV0dXJuIGAke3NpZ259JHtwYWRTdGFydChob3VycywgMil9JHtwYWRTdGFydChtaW51dGVzLCAyKX1gO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVmFsdWUgZm9ybWF0ICR7Zm9ybWF0fSBpcyBvdXQgb2YgcmFuZ2UgZm9yIHByb3BlcnR5IGZvcm1hdGApO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0aW1lT2JqZWN0KG9iaikge1xuICByZXR1cm4gcGljayhvYmosIFtcImhvdXJcIiwgXCJtaW51dGVcIiwgXCJzZWNvbmRcIiwgXCJtaWxsaXNlY29uZFwiXSk7XG59XG4iLCIvKipcbiAqIEBwcml2YXRlXG4gKi9cblxuaW1wb3J0IFpvbmUgZnJvbSBcIi4uL3pvbmUuanNcIjtcbmltcG9ydCBJQU5BWm9uZSBmcm9tIFwiLi4vem9uZXMvSUFOQVpvbmUuanNcIjtcbmltcG9ydCBGaXhlZE9mZnNldFpvbmUgZnJvbSBcIi4uL3pvbmVzL2ZpeGVkT2Zmc2V0Wm9uZS5qc1wiO1xuaW1wb3J0IEludmFsaWRab25lIGZyb20gXCIuLi96b25lcy9pbnZhbGlkWm9uZS5qc1wiO1xuXG5pbXBvcnQgeyBpc1VuZGVmaW5lZCwgaXNTdHJpbmcsIGlzTnVtYmVyIH0gZnJvbSBcIi4vdXRpbC5qc1wiO1xuaW1wb3J0IFN5c3RlbVpvbmUgZnJvbSBcIi4uL3pvbmVzL3N5c3RlbVpvbmUuanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZVpvbmUoaW5wdXQsIGRlZmF1bHRab25lKSB7XG4gIGxldCBvZmZzZXQ7XG4gIGlmIChpc1VuZGVmaW5lZChpbnB1dCkgfHwgaW5wdXQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZGVmYXVsdFpvbmU7XG4gIH0gZWxzZSBpZiAoaW5wdXQgaW5zdGFuY2VvZiBab25lKSB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9IGVsc2UgaWYgKGlzU3RyaW5nKGlucHV0KSkge1xuICAgIGNvbnN0IGxvd2VyZWQgPSBpbnB1dC50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChsb3dlcmVkID09PSBcImRlZmF1bHRcIikgcmV0dXJuIGRlZmF1bHRab25lO1xuICAgIGVsc2UgaWYgKGxvd2VyZWQgPT09IFwibG9jYWxcIiB8fCBsb3dlcmVkID09PSBcInN5c3RlbVwiKSByZXR1cm4gU3lzdGVtWm9uZS5pbnN0YW5jZTtcbiAgICBlbHNlIGlmIChsb3dlcmVkID09PSBcInV0Y1wiIHx8IGxvd2VyZWQgPT09IFwiZ210XCIpIHJldHVybiBGaXhlZE9mZnNldFpvbmUudXRjSW5zdGFuY2U7XG4gICAgZWxzZSByZXR1cm4gRml4ZWRPZmZzZXRab25lLnBhcnNlU3BlY2lmaWVyKGxvd2VyZWQpIHx8IElBTkFab25lLmNyZWF0ZShpbnB1dCk7XG4gIH0gZWxzZSBpZiAoaXNOdW1iZXIoaW5wdXQpKSB7XG4gICAgcmV0dXJuIEZpeGVkT2Zmc2V0Wm9uZS5pbnN0YW5jZShpbnB1dCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSBcIm9iamVjdFwiICYmIFwib2Zmc2V0XCIgaW4gaW5wdXQgJiYgdHlwZW9mIGlucHV0Lm9mZnNldCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgLy8gVGhpcyBpcyBkdW1iLCBidXQgdGhlIGluc3RhbmNlb2YgY2hlY2sgYWJvdmUgZG9lc24ndCBzZWVtIHRvIHJlYWxseSB3b3JrXG4gICAgLy8gc28gd2UncmUgZHVjayBjaGVja2luZyBpdFxuICAgIHJldHVybiBpbnB1dDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEludmFsaWRab25lKGlucHV0KTtcbiAgfVxufVxuIiwiaW1wb3J0IERhdGVUaW1lIGZyb20gXCIuL2RhdGV0aW1lLmpzXCI7XG5pbXBvcnQgU2V0dGluZ3MgZnJvbSBcIi4vc2V0dGluZ3MuanNcIjtcbmltcG9ydCBMb2NhbGUgZnJvbSBcIi4vaW1wbC9sb2NhbGUuanNcIjtcbmltcG9ydCBJQU5BWm9uZSBmcm9tIFwiLi96b25lcy9JQU5BWm9uZS5qc1wiO1xuaW1wb3J0IHsgbm9ybWFsaXplWm9uZSB9IGZyb20gXCIuL2ltcGwvem9uZVV0aWwuanNcIjtcblxuaW1wb3J0IHsgaGFzUmVsYXRpdmUgfSBmcm9tIFwiLi9pbXBsL3V0aWwuanNcIjtcblxuLyoqXG4gKiBUaGUgSW5mbyBjbGFzcyBjb250YWlucyBzdGF0aWMgbWV0aG9kcyBmb3IgcmV0cmlldmluZyBnZW5lcmFsIHRpbWUgYW5kIGRhdGUgcmVsYXRlZCBkYXRhLiBGb3IgZXhhbXBsZSwgaXQgaGFzIG1ldGhvZHMgZm9yIGZpbmRpbmcgb3V0IGlmIGEgdGltZSB6b25lIGhhcyBhIERTVCwgZm9yIGxpc3RpbmcgdGhlIG1vbnRocyBpbiBhbnkgc3VwcG9ydGVkIGxvY2FsZSwgYW5kIGZvciBkaXNjb3ZlcmluZyB3aGljaCBvZiBMdXhvbiBmZWF0dXJlcyBhcmUgYXZhaWxhYmxlIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50LlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbmZvIHtcbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgem9uZSBjb250YWlucyBhIERTVC5cbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW3pvbmU9J2xvY2FsJ10gLSBab25lIHRvIGNoZWNrLiBEZWZhdWx0cyB0byB0aGUgZW52aXJvbm1lbnQncyBsb2NhbCB6b25lLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGhhc0RTVCh6b25lID0gU2V0dGluZ3MuZGVmYXVsdFpvbmUpIHtcbiAgICBjb25zdCBwcm90byA9IERhdGVUaW1lLm5vdygpLnNldFpvbmUoem9uZSkuc2V0KHsgbW9udGg6IDEyIH0pO1xuXG4gICAgcmV0dXJuICF6b25lLmlzVW5pdmVyc2FsICYmIHByb3RvLm9mZnNldCAhPT0gcHJvdG8uc2V0KHsgbW9udGg6IDYgfSkub2Zmc2V0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgem9uZSBpcyBhIHZhbGlkIElBTkEgc3BlY2lmaWVyLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gem9uZSAtIFpvbmUgdG8gY2hlY2tcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc1ZhbGlkSUFOQVpvbmUoem9uZSkge1xuICAgIHJldHVybiBJQU5BWm9uZS5pc1ZhbGlkWm9uZSh6b25lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgaW5wdXQgaW50byBhIHtAbGluayBab25lfSBpbnN0YW5jZS5cbiAgICpcbiAgICogKiBJZiBgaW5wdXRgIGlzIGFscmVhZHkgYSBab25lIGluc3RhbmNlLCBpdCBpcyByZXR1cm5lZCB1bmNoYW5nZWQuXG4gICAqICogSWYgYGlucHV0YCBpcyBhIHN0cmluZyBjb250YWluaW5nIGEgdmFsaWQgdGltZSB6b25lIG5hbWUsIGEgWm9uZSBpbnN0YW5jZVxuICAgKiAgIHdpdGggdGhhdCBuYW1lIGlzIHJldHVybmVkLlxuICAgKiAqIElmIGBpbnB1dGAgaXMgYSBzdHJpbmcgdGhhdCBkb2Vzbid0IHJlZmVyIHRvIGEga25vd24gdGltZSB6b25lLCBhIFpvbmVcbiAgICogICBpbnN0YW5jZSB3aXRoIHtAbGluayBab25lI2lzVmFsaWR9ID09IGZhbHNlIGlzIHJldHVybmVkLlxuICAgKiAqIElmIGBpbnB1dCBpcyBhIG51bWJlciwgYSBab25lIGluc3RhbmNlIHdpdGggdGhlIHNwZWNpZmllZCBmaXhlZCBvZmZzZXRcbiAgICogICBpbiBtaW51dGVzIGlzIHJldHVybmVkLlxuICAgKiAqIElmIGBpbnB1dGAgaXMgYG51bGxgIG9yIGB1bmRlZmluZWRgLCB0aGUgZGVmYXVsdCB6b25lIGlzIHJldHVybmVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfG51bWJlcn0gW2lucHV0XSAtIHRoZSB2YWx1ZSB0byBiZSBjb252ZXJ0ZWRcbiAgICogQHJldHVybiB7Wm9uZX1cbiAgICovXG4gIHN0YXRpYyBub3JtYWxpemVab25lKGlucHV0KSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZVpvbmUoaW5wdXQsIFNldHRpbmdzLmRlZmF1bHRab25lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2Ygc3RhbmRhbG9uZSBtb250aCBuYW1lcy5cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlVGltZUZvcm1hdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2xlbmd0aD0nbG9uZyddIC0gdGhlIGxlbmd0aCBvZiB0aGUgbW9udGggcmVwcmVzZW50YXRpb24sIHN1Y2ggYXMgXCJudW1lcmljXCIsIFwiMi1kaWdpdFwiLCBcIm5hcnJvd1wiLCBcInNob3J0XCIsIFwibG9uZ1wiXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlXSAtIHRoZSBsb2NhbGUgY29kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubnVtYmVyaW5nU3lzdGVtPW51bGxdIC0gdGhlIG51bWJlcmluZyBzeXN0ZW1cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY09iaj1udWxsXSAtIGFuIGV4aXN0aW5nIGxvY2FsZSBvYmplY3QgdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5vdXRwdXRDYWxlbmRhcj0nZ3JlZ29yeSddIC0gdGhlIGNhbGVuZGFyXG4gICAqIEBleGFtcGxlIEluZm8ubW9udGhzKClbMF0gLy89PiAnSmFudWFyeSdcbiAgICogQGV4YW1wbGUgSW5mby5tb250aHMoJ3Nob3J0JylbMF0gLy89PiAnSmFuJ1xuICAgKiBAZXhhbXBsZSBJbmZvLm1vbnRocygnbnVtZXJpYycpWzBdIC8vPT4gJzEnXG4gICAqIEBleGFtcGxlIEluZm8ubW9udGhzKCdzaG9ydCcsIHsgbG9jYWxlOiAnZnItQ0EnIH0gKVswXSAvLz0+ICdqYW52LidcbiAgICogQGV4YW1wbGUgSW5mby5tb250aHMoJ251bWVyaWMnLCB7IGxvY2FsZTogJ2FyJyB9KVswXSAvLz0+ICfZoSdcbiAgICogQGV4YW1wbGUgSW5mby5tb250aHMoJ2xvbmcnLCB7IG91dHB1dENhbGVuZGFyOiAnaXNsYW1pYycgfSlbMF0gLy89PiAnUmFiacq7IEknXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgc3RhdGljIG1vbnRocyhcbiAgICBsZW5ndGggPSBcImxvbmdcIixcbiAgICB7IGxvY2FsZSA9IG51bGwsIG51bWJlcmluZ1N5c3RlbSA9IG51bGwsIGxvY09iaiA9IG51bGwsIG91dHB1dENhbGVuZGFyID0gXCJncmVnb3J5XCIgfSA9IHt9XG4gICkge1xuICAgIHJldHVybiAobG9jT2JqIHx8IExvY2FsZS5jcmVhdGUobG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG91dHB1dENhbGVuZGFyKSkubW9udGhzKGxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGFycmF5IG9mIGZvcm1hdCBtb250aCBuYW1lcy5cbiAgICogRm9ybWF0IG1vbnRocyBkaWZmZXIgZnJvbSBzdGFuZGFsb25lIG1vbnRocyBpbiB0aGF0IHRoZXkncmUgbWVhbnQgdG8gYXBwZWFyIG5leHQgdG8gdGhlIGRheSBvZiB0aGUgbW9udGguIEluIHNvbWUgbGFuZ3VhZ2VzLCB0aGF0XG4gICAqIGNoYW5nZXMgdGhlIHN0cmluZy5cbiAgICogU2VlIHtAbGluayBJbmZvI21vbnRoc31cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsZW5ndGg9J2xvbmcnXSAtIHRoZSBsZW5ndGggb2YgdGhlIG1vbnRoIHJlcHJlc2VudGF0aW9uLCBzdWNoIGFzIFwibnVtZXJpY1wiLCBcIjItZGlnaXRcIiwgXCJuYXJyb3dcIiwgXCJzaG9ydFwiLCBcImxvbmdcIlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZV0gLSB0aGUgbG9jYWxlIGNvZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm51bWJlcmluZ1N5c3RlbT1udWxsXSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NPYmo9bnVsbF0gLSBhbiBleGlzdGluZyBsb2NhbGUgb2JqZWN0IHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMub3V0cHV0Q2FsZW5kYXI9J2dyZWdvcnknXSAtIHRoZSBjYWxlbmRhclxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHN0YXRpYyBtb250aHNGb3JtYXQoXG4gICAgbGVuZ3RoID0gXCJsb25nXCIsXG4gICAgeyBsb2NhbGUgPSBudWxsLCBudW1iZXJpbmdTeXN0ZW0gPSBudWxsLCBsb2NPYmogPSBudWxsLCBvdXRwdXRDYWxlbmRhciA9IFwiZ3JlZ29yeVwiIH0gPSB7fVxuICApIHtcbiAgICByZXR1cm4gKGxvY09iaiB8fCBMb2NhbGUuY3JlYXRlKGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhcikpLm1vbnRocyhsZW5ndGgsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBhcnJheSBvZiBzdGFuZGFsb25lIHdlZWsgbmFtZXMuXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZVRpbWVGb3JtYXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsZW5ndGg9J2xvbmcnXSAtIHRoZSBsZW5ndGggb2YgdGhlIHdlZWtkYXkgcmVwcmVzZW50YXRpb24sIHN1Y2ggYXMgXCJuYXJyb3dcIiwgXCJzaG9ydFwiLCBcImxvbmdcIi5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGVdIC0gdGhlIGxvY2FsZSBjb2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5udW1iZXJpbmdTeXN0ZW09bnVsbF0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jT2JqPW51bGxdIC0gYW4gZXhpc3RpbmcgbG9jYWxlIG9iamVjdCB0byB1c2VcbiAgICogQGV4YW1wbGUgSW5mby53ZWVrZGF5cygpWzBdIC8vPT4gJ01vbmRheSdcbiAgICogQGV4YW1wbGUgSW5mby53ZWVrZGF5cygnc2hvcnQnKVswXSAvLz0+ICdNb24nXG4gICAqIEBleGFtcGxlIEluZm8ud2Vla2RheXMoJ3Nob3J0JywgeyBsb2NhbGU6ICdmci1DQScgfSlbMF0gLy89PiAnbHVuLidcbiAgICogQGV4YW1wbGUgSW5mby53ZWVrZGF5cygnc2hvcnQnLCB7IGxvY2FsZTogJ2FyJyB9KVswXSAvLz0+ICfYp9mE2KfYq9mG2YrZhidcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBzdGF0aWMgd2Vla2RheXMobGVuZ3RoID0gXCJsb25nXCIsIHsgbG9jYWxlID0gbnVsbCwgbnVtYmVyaW5nU3lzdGVtID0gbnVsbCwgbG9jT2JqID0gbnVsbCB9ID0ge30pIHtcbiAgICByZXR1cm4gKGxvY09iaiB8fCBMb2NhbGUuY3JlYXRlKGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBudWxsKSkud2Vla2RheXMobGVuZ3RoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgZm9ybWF0IHdlZWsgbmFtZXMuXG4gICAqIEZvcm1hdCB3ZWVrZGF5cyBkaWZmZXIgZnJvbSBzdGFuZGFsb25lIHdlZWtkYXlzIGluIHRoYXQgdGhleSdyZSBtZWFudCB0byBhcHBlYXIgbmV4dCB0byBtb3JlIGRhdGUgaW5mb3JtYXRpb24uIEluIHNvbWUgbGFuZ3VhZ2VzLCB0aGF0XG4gICAqIGNoYW5nZXMgdGhlIHN0cmluZy5cbiAgICogU2VlIHtAbGluayBJbmZvI3dlZWtkYXlzfVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2xlbmd0aD0nbG9uZyddIC0gdGhlIGxlbmd0aCBvZiB0aGUgbW9udGggcmVwcmVzZW50YXRpb24sIHN1Y2ggYXMgXCJuYXJyb3dcIiwgXCJzaG9ydFwiLCBcImxvbmdcIi5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9bnVsbF0gLSB0aGUgbG9jYWxlIGNvZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm51bWJlcmluZ1N5c3RlbT1udWxsXSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NPYmo9bnVsbF0gLSBhbiBleGlzdGluZyBsb2NhbGUgb2JqZWN0IHRvIHVzZVxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHN0YXRpYyB3ZWVrZGF5c0Zvcm1hdChcbiAgICBsZW5ndGggPSBcImxvbmdcIixcbiAgICB7IGxvY2FsZSA9IG51bGwsIG51bWJlcmluZ1N5c3RlbSA9IG51bGwsIGxvY09iaiA9IG51bGwgfSA9IHt9XG4gICkge1xuICAgIHJldHVybiAobG9jT2JqIHx8IExvY2FsZS5jcmVhdGUobG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG51bGwpKS53ZWVrZGF5cyhsZW5ndGgsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBhcnJheSBvZiBtZXJpZGllbXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlXSAtIHRoZSBsb2NhbGUgY29kZVxuICAgKiBAZXhhbXBsZSBJbmZvLm1lcmlkaWVtcygpIC8vPT4gWyAnQU0nLCAnUE0nIF1cbiAgICogQGV4YW1wbGUgSW5mby5tZXJpZGllbXMoeyBsb2NhbGU6ICdteScgfSkgLy89PiBbICfhgJThgLbhgJThgIDhgLonLCAn4YCK4YCU4YCxJyBdXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgc3RhdGljIG1lcmlkaWVtcyh7IGxvY2FsZSA9IG51bGwgfSA9IHt9KSB7XG4gICAgcmV0dXJuIExvY2FsZS5jcmVhdGUobG9jYWxlKS5tZXJpZGllbXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgZXJhcywgc3VjaCBhcyBbJ0JDJywgJ0FEJ10uIFRoZSBsb2NhbGUgY2FuIGJlIHNwZWNpZmllZCwgYnV0IHRoZSBjYWxlbmRhciBzeXN0ZW0gaXMgYWx3YXlzIEdyZWdvcmlhbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsZW5ndGg9J3Nob3J0J10gLSB0aGUgbGVuZ3RoIG9mIHRoZSBlcmEgcmVwcmVzZW50YXRpb24sIHN1Y2ggYXMgXCJzaG9ydFwiIG9yIFwibG9uZ1wiLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZV0gLSB0aGUgbG9jYWxlIGNvZGVcbiAgICogQGV4YW1wbGUgSW5mby5lcmFzKCkgLy89PiBbICdCQycsICdBRCcgXVxuICAgKiBAZXhhbXBsZSBJbmZvLmVyYXMoJ2xvbmcnKSAvLz0+IFsgJ0JlZm9yZSBDaHJpc3QnLCAnQW5ubyBEb21pbmknIF1cbiAgICogQGV4YW1wbGUgSW5mby5lcmFzKCdsb25nJywgeyBsb2NhbGU6ICdmcicgfSkgLy89PiBbICdhdmFudCBKw6lzdXMtQ2hyaXN0JywgJ2FwcsOocyBKw6lzdXMtQ2hyaXN0JyBdXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgc3RhdGljIGVyYXMobGVuZ3RoID0gXCJzaG9ydFwiLCB7IGxvY2FsZSA9IG51bGwgfSA9IHt9KSB7XG4gICAgcmV0dXJuIExvY2FsZS5jcmVhdGUobG9jYWxlLCBudWxsLCBcImdyZWdvcnlcIikuZXJhcyhsZW5ndGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgc2V0IG9mIGF2YWlsYWJsZSBmZWF0dXJlcyBpbiB0aGlzIGVudmlyb25tZW50LlxuICAgKiBTb21lIGZlYXR1cmVzIG9mIEx1eG9uIGFyZSBub3QgYXZhaWxhYmxlIGluIGFsbCBlbnZpcm9ubWVudHMuIEZvciBleGFtcGxlLCBvbiBvbGRlciBicm93c2VycywgcmVsYXRpdmUgdGltZSBmb3JtYXR0aW5nIHN1cHBvcnQgaXMgbm90IGF2YWlsYWJsZS4gVXNlIHRoaXMgZnVuY3Rpb24gdG8gZmlndXJlIG91dCBpZiB0aGF0J3MgdGhlIGNhc2UuXG4gICAqIEtleXM6XG4gICAqICogYHJlbGF0aXZlYDogd2hldGhlciB0aGlzIGVudmlyb25tZW50IHN1cHBvcnRzIHJlbGF0aXZlIHRpbWUgZm9ybWF0dGluZ1xuICAgKiBAZXhhbXBsZSBJbmZvLmZlYXR1cmVzKCkgLy89PiB7IHJlbGF0aXZlOiBmYWxzZSB9XG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBmZWF0dXJlcygpIHtcbiAgICByZXR1cm4geyByZWxhdGl2ZTogaGFzUmVsYXRpdmUoKSB9O1xuICB9XG59XG4iLCJpbXBvcnQgRGF0ZVRpbWUsIHsgZnJpZW5kbHlEYXRlVGltZSB9IGZyb20gXCIuL2RhdGV0aW1lLmpzXCI7XG5pbXBvcnQgRHVyYXRpb24gZnJvbSBcIi4vZHVyYXRpb24uanNcIjtcbmltcG9ydCBTZXR0aW5ncyBmcm9tIFwiLi9zZXR0aW5ncy5qc1wiO1xuaW1wb3J0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IsIEludmFsaWRJbnRlcnZhbEVycm9yIH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgSW52YWxpZCBmcm9tIFwiLi9pbXBsL2ludmFsaWQuanNcIjtcbmltcG9ydCBGb3JtYXR0ZXIgZnJvbSBcIi4vaW1wbC9mb3JtYXR0ZXIuanNcIjtcbmltcG9ydCAqIGFzIEZvcm1hdHMgZnJvbSBcIi4vaW1wbC9mb3JtYXRzLmpzXCI7XG5cbmNvbnN0IElOVkFMSUQgPSBcIkludmFsaWQgSW50ZXJ2YWxcIjtcblxuLy8gY2hlY2tzIGlmIHRoZSBzdGFydCBpcyBlcXVhbCB0byBvciBiZWZvcmUgdGhlIGVuZFxuZnVuY3Rpb24gdmFsaWRhdGVTdGFydEVuZChzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQgfHwgIXN0YXJ0LmlzVmFsaWQpIHtcbiAgICByZXR1cm4gSW50ZXJ2YWwuaW52YWxpZChcIm1pc3Npbmcgb3IgaW52YWxpZCBzdGFydFwiKTtcbiAgfSBlbHNlIGlmICghZW5kIHx8ICFlbmQuaXNWYWxpZCkge1xuICAgIHJldHVybiBJbnRlcnZhbC5pbnZhbGlkKFwibWlzc2luZyBvciBpbnZhbGlkIGVuZFwiKTtcbiAgfSBlbHNlIGlmIChlbmQgPCBzdGFydCkge1xuICAgIHJldHVybiBJbnRlcnZhbC5pbnZhbGlkKFxuICAgICAgXCJlbmQgYmVmb3JlIHN0YXJ0XCIsXG4gICAgICBgVGhlIGVuZCBvZiBhbiBpbnRlcnZhbCBtdXN0IGJlIGFmdGVyIGl0cyBzdGFydCwgYnV0IHlvdSBoYWQgc3RhcnQ9JHtzdGFydC50b0lTTygpfSBhbmQgZW5kPSR7ZW5kLnRvSVNPKCl9YFxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBJbnRlcnZhbCBvYmplY3QgcmVwcmVzZW50cyBhIGhhbGYtb3BlbiBpbnRlcnZhbCBvZiB0aW1lLCB3aGVyZSBlYWNoIGVuZHBvaW50IGlzIGEge0BsaW5rIERhdGVUaW1lfS4gQ29uY2VwdHVhbGx5LCBpdCdzIGEgY29udGFpbmVyIGZvciB0aG9zZSB0d28gZW5kcG9pbnRzLCBhY2NvbXBhbmllZCBieSBtZXRob2RzIGZvciBjcmVhdGluZywgcGFyc2luZywgaW50ZXJyb2dhdGluZywgY29tcGFyaW5nLCB0cmFuc2Zvcm1pbmcsIGFuZCBmb3JtYXR0aW5nIHRoZW0uXG4gKlxuICogSGVyZSBpcyBhIGJyaWVmIG92ZXJ2aWV3IG9mIHRoZSBtb3N0IGNvbW1vbmx5IHVzZWQgbWV0aG9kcyBhbmQgZ2V0dGVycyBpbiBJbnRlcnZhbDpcbiAqXG4gKiAqICoqQ3JlYXRpb24qKiBUbyBjcmVhdGUgYW4gSW50ZXJ2YWwsIHVzZSB7QGxpbmsgSW50ZXJ2YWwuZnJvbURhdGVUaW1lc30sIHtAbGluayBJbnRlcnZhbC5hZnRlcn0sIHtAbGluayBJbnRlcnZhbC5iZWZvcmV9LCBvciB7QGxpbmsgSW50ZXJ2YWwuZnJvbUlTT30uXG4gKiAqICoqQWNjZXNzb3JzKiogVXNlIHtAbGluayBJbnRlcnZhbCNzdGFydH0gYW5kIHtAbGluayBJbnRlcnZhbCNlbmR9IHRvIGdldCB0aGUgc3RhcnQgYW5kIGVuZC5cbiAqICogKipJbnRlcnJvZ2F0aW9uKiogVG8gYW5hbHl6ZSB0aGUgSW50ZXJ2YWwsIHVzZSB7QGxpbmsgSW50ZXJ2YWwjY291bnR9LCB7QGxpbmsgSW50ZXJ2YWwjbGVuZ3RofSwge0BsaW5rIEludGVydmFsI2hhc1NhbWV9LCB7QGxpbmsgSW50ZXJ2YWwjY29udGFpbnN9LCB7QGxpbmsgSW50ZXJ2YWwjaXNBZnRlcn0sIG9yIHtAbGluayBJbnRlcnZhbCNpc0JlZm9yZX0uXG4gKiAqICoqVHJhbnNmb3JtYXRpb24qKiBUbyBjcmVhdGUgb3RoZXIgSW50ZXJ2YWxzIG91dCBvZiB0aGlzIG9uZSwgdXNlIHtAbGluayBJbnRlcnZhbCNzZXR9LCB7QGxpbmsgSW50ZXJ2YWwjc3BsaXRBdH0sIHtAbGluayBJbnRlcnZhbCNzcGxpdEJ5fSwge0BsaW5rIEludGVydmFsI2RpdmlkZUVxdWFsbHl9LCB7QGxpbmsgSW50ZXJ2YWwubWVyZ2V9LCB7QGxpbmsgSW50ZXJ2YWwueG9yfSwge0BsaW5rIEludGVydmFsI3VuaW9ufSwge0BsaW5rIEludGVydmFsI2ludGVyc2VjdGlvbn0sIG9yIHtAbGluayBJbnRlcnZhbCNkaWZmZXJlbmNlfS5cbiAqICogKipDb21wYXJpc29uKiogVG8gY29tcGFyZSB0aGlzIEludGVydmFsIHRvIGFub3RoZXIgb25lLCB1c2Uge0BsaW5rIEludGVydmFsI2VxdWFsc30sIHtAbGluayBJbnRlcnZhbCNvdmVybGFwc30sIHtAbGluayBJbnRlcnZhbCNhYnV0c1N0YXJ0fSwge0BsaW5rIEludGVydmFsI2FidXRzRW5kfSwge0BsaW5rIEludGVydmFsI2VuZ3VsZnN9XG4gKiAqICoqT3V0cHV0KiogVG8gY29udmVydCB0aGUgSW50ZXJ2YWwgaW50byBvdGhlciByZXByZXNlbnRhdGlvbnMsIHNlZSB7QGxpbmsgSW50ZXJ2YWwjdG9TdHJpbmd9LCB7QGxpbmsgSW50ZXJ2YWwjdG9Mb2NhbGVTdHJpbmd9LCB7QGxpbmsgSW50ZXJ2YWwjdG9JU099LCB7QGxpbmsgSW50ZXJ2YWwjdG9JU09EYXRlfSwge0BsaW5rIEludGVydmFsI3RvSVNPVGltZX0sIHtAbGluayBJbnRlcnZhbCN0b0Zvcm1hdH0sIGFuZCB7QGxpbmsgSW50ZXJ2YWwjdG9EdXJhdGlvbn0uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEludGVydmFsIHtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnMgPSBjb25maWcuc3RhcnQ7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5lID0gY29uZmlnLmVuZDtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmludmFsaWQgPSBjb25maWcuaW52YWxpZCB8fCBudWxsO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaXNMdXhvbkludGVydmFsID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW52YWxpZCBJbnRlcnZhbC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlYXNvbiAtIHNpbXBsZSBzdHJpbmcgb2Ygd2h5IHRoaXMgSW50ZXJ2YWwgaXMgaW52YWxpZC4gU2hvdWxkIG5vdCBjb250YWluIHBhcmFtZXRlcnMgb3IgYW55dGhpbmcgZWxzZSBkYXRhLWRlcGVuZGVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2V4cGxhbmF0aW9uPW51bGxdIC0gbG9uZ2VyIGV4cGxhbmF0aW9uLCBtYXkgaW5jbHVkZSBwYXJhbWV0ZXJzIGFuZCBvdGhlciB1c2VmdWwgZGVidWdnaW5nIGluZm9ybWF0aW9uXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgc3RhdGljIGludmFsaWQocmVhc29uLCBleHBsYW5hdGlvbiA9IG51bGwpIHtcbiAgICBpZiAoIXJlYXNvbikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwibmVlZCB0byBzcGVjaWZ5IGEgcmVhc29uIHRoZSBJbnRlcnZhbCBpcyBpbnZhbGlkXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IGludmFsaWQgPSByZWFzb24gaW5zdGFuY2VvZiBJbnZhbGlkID8gcmVhc29uIDogbmV3IEludmFsaWQocmVhc29uLCBleHBsYW5hdGlvbik7XG5cbiAgICBpZiAoU2V0dGluZ3MudGhyb3dPbkludmFsaWQpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkSW50ZXJ2YWxFcnJvcihpbnZhbGlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBJbnRlcnZhbCh7IGludmFsaWQgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBJbnRlcnZhbCBmcm9tIGEgc3RhcnQgRGF0ZVRpbWUgYW5kIGFuIGVuZCBEYXRlVGltZS4gSW5jbHVzaXZlIG9mIHRoZSBzdGFydCBidXQgbm90IHRoZSBlbmQuXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV8RGF0ZXxPYmplY3R9IHN0YXJ0XG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV8RGF0ZXxPYmplY3R9IGVuZFxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIHN0YXRpYyBmcm9tRGF0ZVRpbWVzKHN0YXJ0LCBlbmQpIHtcbiAgICBjb25zdCBidWlsdFN0YXJ0ID0gZnJpZW5kbHlEYXRlVGltZShzdGFydCksXG4gICAgICBidWlsdEVuZCA9IGZyaWVuZGx5RGF0ZVRpbWUoZW5kKTtcblxuICAgIGNvbnN0IHZhbGlkYXRlRXJyb3IgPSB2YWxpZGF0ZVN0YXJ0RW5kKGJ1aWx0U3RhcnQsIGJ1aWx0RW5kKTtcblxuICAgIGlmICh2YWxpZGF0ZUVycm9yID09IG51bGwpIHtcbiAgICAgIHJldHVybiBuZXcgSW50ZXJ2YWwoe1xuICAgICAgICBzdGFydDogYnVpbHRTdGFydCxcbiAgICAgICAgZW5kOiBidWlsdEVuZCxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmFsaWRhdGVFcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIEludGVydmFsIGZyb20gYSBzdGFydCBEYXRlVGltZSBhbmQgYSBEdXJhdGlvbiB0byBleHRlbmQgdG8uXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV8RGF0ZXxPYmplY3R9IHN0YXJ0XG4gICAqIEBwYXJhbSB7RHVyYXRpb258T2JqZWN0fG51bWJlcn0gZHVyYXRpb24gLSB0aGUgbGVuZ3RoIG9mIHRoZSBJbnRlcnZhbC5cbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqL1xuICBzdGF0aWMgYWZ0ZXIoc3RhcnQsIGR1cmF0aW9uKSB7XG4gICAgY29uc3QgZHVyID0gRHVyYXRpb24uZnJvbUR1cmF0aW9uTGlrZShkdXJhdGlvbiksXG4gICAgICBkdCA9IGZyaWVuZGx5RGF0ZVRpbWUoc3RhcnQpO1xuICAgIHJldHVybiBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0LCBkdC5wbHVzKGR1cikpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBJbnRlcnZhbCBmcm9tIGFuIGVuZCBEYXRlVGltZSBhbmQgYSBEdXJhdGlvbiB0byBleHRlbmQgYmFja3dhcmRzIHRvLlxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfERhdGV8T2JqZWN0fSBlbmRcbiAgICogQHBhcmFtIHtEdXJhdGlvbnxPYmplY3R8bnVtYmVyfSBkdXJhdGlvbiAtIHRoZSBsZW5ndGggb2YgdGhlIEludGVydmFsLlxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIHN0YXRpYyBiZWZvcmUoZW5kLCBkdXJhdGlvbikge1xuICAgIGNvbnN0IGR1ciA9IER1cmF0aW9uLmZyb21EdXJhdGlvbkxpa2UoZHVyYXRpb24pLFxuICAgICAgZHQgPSBmcmllbmRseURhdGVUaW1lKGVuZCk7XG4gICAgcmV0dXJuIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQubWludXMoZHVyKSwgZHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBJbnRlcnZhbCBmcm9tIGFuIElTTyA4NjAxIHN0cmluZy5cbiAgICogQWNjZXB0cyBgPHN0YXJ0Pi88ZW5kPmAsIGA8c3RhcnQ+LzxkdXJhdGlvbj5gLCBhbmQgYDxkdXJhdGlvbj4vPGVuZD5gIGZvcm1hdHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGhlIElTTyBzdHJpbmcgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXSAtIG9wdGlvbnMgdG8gcGFzcyB7QGxpbmsgRGF0ZVRpbWUjZnJvbUlTT30gYW5kIG9wdGlvbmFsbHkge0BsaW5rIER1cmF0aW9uI2Zyb21JU099XG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDEjVGltZV9pbnRlcnZhbHNcbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqL1xuICBzdGF0aWMgZnJvbUlTTyh0ZXh0LCBvcHRzKSB7XG4gICAgY29uc3QgW3MsIGVdID0gKHRleHQgfHwgXCJcIikuc3BsaXQoXCIvXCIsIDIpO1xuICAgIGlmIChzICYmIGUpIHtcbiAgICAgIGxldCBzdGFydCwgc3RhcnRJc1ZhbGlkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RhcnQgPSBEYXRlVGltZS5mcm9tSVNPKHMsIG9wdHMpO1xuICAgICAgICBzdGFydElzVmFsaWQgPSBzdGFydC5pc1ZhbGlkO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBzdGFydElzVmFsaWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgbGV0IGVuZCwgZW5kSXNWYWxpZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGVuZCA9IERhdGVUaW1lLmZyb21JU08oZSwgb3B0cyk7XG4gICAgICAgIGVuZElzVmFsaWQgPSBlbmQuaXNWYWxpZDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZW5kSXNWYWxpZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhcnRJc1ZhbGlkICYmIGVuZElzVmFsaWQpIHtcbiAgICAgICAgcmV0dXJuIEludGVydmFsLmZyb21EYXRlVGltZXMoc3RhcnQsIGVuZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGFydElzVmFsaWQpIHtcbiAgICAgICAgY29uc3QgZHVyID0gRHVyYXRpb24uZnJvbUlTTyhlLCBvcHRzKTtcbiAgICAgICAgaWYgKGR1ci5pc1ZhbGlkKSB7XG4gICAgICAgICAgcmV0dXJuIEludGVydmFsLmFmdGVyKHN0YXJ0LCBkdXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGVuZElzVmFsaWQpIHtcbiAgICAgICAgY29uc3QgZHVyID0gRHVyYXRpb24uZnJvbUlTTyhzLCBvcHRzKTtcbiAgICAgICAgaWYgKGR1ci5pc1ZhbGlkKSB7XG4gICAgICAgICAgcmV0dXJuIEludGVydmFsLmJlZm9yZShlbmQsIGR1cik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEludGVydmFsLmludmFsaWQoXCJ1bnBhcnNhYmxlXCIsIGB0aGUgaW5wdXQgXCIke3RleHR9XCIgY2FuJ3QgYmUgcGFyc2VkIGFzIElTTyA4NjAxYCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gb2JqZWN0IGlzIGFuIEludGVydmFsLiBXb3JrcyBhY3Jvc3MgY29udGV4dCBib3VuZGFyaWVzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNJbnRlcnZhbChvKSB7XG4gICAgcmV0dXJuIChvICYmIG8uaXNMdXhvbkludGVydmFsKSB8fCBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdGFydCBvZiB0aGUgSW50ZXJ2YWxcbiAgICogQHR5cGUge0RhdGVUaW1lfVxuICAgKi9cbiAgZ2V0IHN0YXJ0KCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnMgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVuZCBvZiB0aGUgSW50ZXJ2YWxcbiAgICogQHR5cGUge0RhdGVUaW1lfVxuICAgKi9cbiAgZ2V0IGVuZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5lIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCdzIGVuZCBpcyBhdCBsZWFzdCBpdHMgc3RhcnQsIG1lYW5pbmcgdGhhdCB0aGUgSW50ZXJ2YWwgaXNuJ3QgJ2JhY2t3YXJkcycuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZFJlYXNvbiA9PT0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGVycm9yIGNvZGUgaWYgdGhpcyBJbnRlcnZhbCBpcyBpbnZhbGlkLCBvciBudWxsIGlmIHRoZSBJbnRlcnZhbCBpcyB2YWxpZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGludmFsaWRSZWFzb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZCA/IHRoaXMuaW52YWxpZC5yZWFzb24gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gZXhwbGFuYXRpb24gb2Ygd2h5IHRoaXMgSW50ZXJ2YWwgYmVjYW1lIGludmFsaWQsIG9yIG51bGwgaWYgdGhlIEludGVydmFsIGlzIHZhbGlkXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgaW52YWxpZEV4cGxhbmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmludmFsaWQgPyB0aGlzLmludmFsaWQuZXhwbGFuYXRpb24gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgSW50ZXJ2YWwgaW4gdGhlIHNwZWNpZmllZCB1bml0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIHRoZSB1bml0IChzdWNoIGFzICdob3Vycycgb3IgJ2RheXMnKSB0byByZXR1cm4gdGhlIGxlbmd0aCBpbi5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgbGVuZ3RoKHVuaXQgPSBcIm1pbGxpc2Vjb25kc1wiKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudG9EdXJhdGlvbiguLi5bdW5pdF0pLmdldCh1bml0KSA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb3VudCBvZiBtaW51dGVzLCBob3VycywgZGF5cywgbW9udGhzLCBvciB5ZWFycyBpbmNsdWRlZCBpbiB0aGUgSW50ZXJ2YWwsIGV2ZW4gaW4gcGFydC5cbiAgICogVW5saWtlIHtAbGluayBJbnRlcnZhbCNsZW5ndGh9IHRoaXMgY291bnRzIHNlY3Rpb25zIG9mIHRoZSBjYWxlbmRhciwgbm90IHBlcmlvZHMgb2YgdGltZSwgZS5nLiBzcGVjaWZ5aW5nICdkYXknXG4gICAqIGFza3MgJ3doYXQgZGF0ZXMgYXJlIGluY2x1ZGVkIGluIHRoaXMgaW50ZXJ2YWw/Jywgbm90ICdob3cgbWFueSBkYXlzIGxvbmcgaXMgdGhpcyBpbnRlcnZhbD8nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdW5pdD0nbWlsbGlzZWNvbmRzJ10gLSB0aGUgdW5pdCBvZiB0aW1lIHRvIGNvdW50LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBjb3VudCh1bml0ID0gXCJtaWxsaXNlY29uZHNcIikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gTmFOO1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5zdGFydC5zdGFydE9mKHVuaXQpLFxuICAgICAgZW5kID0gdGhpcy5lbmQuc3RhcnRPZih1bml0KTtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihlbmQuZGlmZihzdGFydCwgdW5pdCkuZ2V0KHVuaXQpKSArIChlbmQudmFsdWVPZigpICE9PSB0aGlzLmVuZC52YWx1ZU9mKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGlzIEludGVydmFsJ3Mgc3RhcnQgYW5kIGVuZCBhcmUgYm90aCBpbiB0aGUgc2FtZSB1bml0IG9mIHRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVuaXQgLSB0aGUgdW5pdCBvZiB0aW1lIHRvIGNoZWNrIHNhbWVuZXNzIG9uXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXNTYW1lKHVuaXQpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5pc0VtcHR5KCkgfHwgdGhpcy5lLm1pbnVzKDEpLmhhc1NhbWUodGhpcy5zLCB1bml0KSA6IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwgaGFzIHRoZSBzYW1lIHN0YXJ0IGFuZCBlbmQgRGF0ZVRpbWVzLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5zLnZhbHVlT2YoKSA9PT0gdGhpcy5lLnZhbHVlT2YoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIEludGVydmFsJ3Mgc3RhcnQgaXMgYWZ0ZXIgdGhlIHNwZWNpZmllZCBEYXRlVGltZS5cbiAgICogQHBhcmFtIHtEYXRlVGltZX0gZGF0ZVRpbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQWZ0ZXIoZGF0ZVRpbWUpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0aGlzLnMgPiBkYXRlVGltZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIEludGVydmFsJ3MgZW5kIGlzIGJlZm9yZSB0aGUgc3BlY2lmaWVkIERhdGVUaW1lLlxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSBkYXRlVGltZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNCZWZvcmUoZGF0ZVRpbWUpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0aGlzLmUgPD0gZGF0ZVRpbWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCBjb250YWlucyB0aGUgc3BlY2lmaWVkIERhdGVUaW1lLlxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSBkYXRlVGltZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgY29udGFpbnMoZGF0ZVRpbWUpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0aGlzLnMgPD0gZGF0ZVRpbWUgJiYgdGhpcy5lID4gZGF0ZVRpbWU7XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRzXCIgdGhlIHN0YXJ0IGFuZC9vciBlbmQgZGF0ZXMuIFJldHVybnMgYSBuZXdseS1jb25zdHJ1Y3RlZCBJbnRlcnZhbC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlcyAtIHRoZSB2YWx1ZXMgdG8gc2V0XG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IHZhbHVlcy5zdGFydCAtIHRoZSBzdGFydGluZyBEYXRlVGltZVxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSB2YWx1ZXMuZW5kIC0gdGhlIGVuZGluZyBEYXRlVGltZVxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIHNldCh7IHN0YXJ0LCBlbmQgfSA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIHJldHVybiBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHN0YXJ0IHx8IHRoaXMucywgZW5kIHx8IHRoaXMuZSk7XG4gIH1cblxuICAvKipcbiAgICogU3BsaXQgdGhpcyBJbnRlcnZhbCBhdCBlYWNoIG9mIHRoZSBzcGVjaWZpZWQgRGF0ZVRpbWVzXG4gICAqIEBwYXJhbSB7Li4uRGF0ZVRpbWV9IGRhdGVUaW1lcyAtIHRoZSB1bml0IG9mIHRpbWUgdG8gY291bnQuXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgc3BsaXRBdCguLi5kYXRlVGltZXMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIFtdO1xuICAgIGNvbnN0IHNvcnRlZCA9IGRhdGVUaW1lc1xuICAgICAgICAubWFwKGZyaWVuZGx5RGF0ZVRpbWUpXG4gICAgICAgIC5maWx0ZXIoKGQpID0+IHRoaXMuY29udGFpbnMoZCkpXG4gICAgICAgIC5zb3J0KCksXG4gICAgICByZXN1bHRzID0gW107XG4gICAgbGV0IHsgcyB9ID0gdGhpcyxcbiAgICAgIGkgPSAwO1xuXG4gICAgd2hpbGUgKHMgPCB0aGlzLmUpIHtcbiAgICAgIGNvbnN0IGFkZGVkID0gc29ydGVkW2ldIHx8IHRoaXMuZSxcbiAgICAgICAgbmV4dCA9ICthZGRlZCA+ICt0aGlzLmUgPyB0aGlzLmUgOiBhZGRlZDtcbiAgICAgIHJlc3VsdHMucHVzaChJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHMsIG5leHQpKTtcbiAgICAgIHMgPSBuZXh0O1xuICAgICAgaSArPSAxO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGl0IHRoaXMgSW50ZXJ2YWwgaW50byBzbWFsbGVyIEludGVydmFscywgZWFjaCBvZiB0aGUgc3BlY2lmaWVkIGxlbmd0aC5cbiAgICogTGVmdCBvdmVyIHRpbWUgaXMgZ3JvdXBlZCBpbnRvIGEgc21hbGxlciBpbnRlcnZhbFxuICAgKiBAcGFyYW0ge0R1cmF0aW9ufE9iamVjdHxudW1iZXJ9IGR1cmF0aW9uIC0gVGhlIGxlbmd0aCBvZiBlYWNoIHJlc3VsdGluZyBpbnRlcnZhbC5cbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBzcGxpdEJ5KGR1cmF0aW9uKSB7XG4gICAgY29uc3QgZHVyID0gRHVyYXRpb24uZnJvbUR1cmF0aW9uTGlrZShkdXJhdGlvbik7XG5cbiAgICBpZiAoIXRoaXMuaXNWYWxpZCB8fCAhZHVyLmlzVmFsaWQgfHwgZHVyLmFzKFwibWlsbGlzZWNvbmRzXCIpID09PSAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgbGV0IHsgcyB9ID0gdGhpcyxcbiAgICAgIGlkeCA9IDEsXG4gICAgICBuZXh0O1xuXG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgIHdoaWxlIChzIDwgdGhpcy5lKSB7XG4gICAgICBjb25zdCBhZGRlZCA9IHRoaXMuc3RhcnQucGx1cyhkdXIubWFwVW5pdHMoKHgpID0+IHggKiBpZHgpKTtcbiAgICAgIG5leHQgPSArYWRkZWQgPiArdGhpcy5lID8gdGhpcy5lIDogYWRkZWQ7XG4gICAgICByZXN1bHRzLnB1c2goSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhzLCBuZXh0KSk7XG4gICAgICBzID0gbmV4dDtcbiAgICAgIGlkeCArPSAxO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGl0IHRoaXMgSW50ZXJ2YWwgaW50byB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBzbWFsbGVyIGludGVydmFscy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlck9mUGFydHMgLSBUaGUgbnVtYmVyIG9mIEludGVydmFscyB0byBkaXZpZGUgdGhlIEludGVydmFsIGludG8uXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgZGl2aWRlRXF1YWxseShudW1iZXJPZlBhcnRzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBbXTtcbiAgICByZXR1cm4gdGhpcy5zcGxpdEJ5KHRoaXMubGVuZ3RoKCkgLyBudW1iZXJPZlBhcnRzKS5zbGljZSgwLCBudW1iZXJPZlBhcnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIEludGVydmFsIG92ZXJsYXBzIHdpdGggdGhlIHNwZWNpZmllZCBJbnRlcnZhbFxuICAgKiBAcGFyYW0ge0ludGVydmFsfSBvdGhlclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgb3ZlcmxhcHMob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5lID4gb3RoZXIucyAmJiB0aGlzLnMgPCBvdGhlci5lO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwncyBlbmQgaXMgYWRqYWNlbnQgdG8gdGhlIHNwZWNpZmllZCBJbnRlcnZhbCdzIHN0YXJ0LlxuICAgKiBAcGFyYW0ge0ludGVydmFsfSBvdGhlclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgYWJ1dHNTdGFydChvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuICt0aGlzLmUgPT09ICtvdGhlci5zO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwncyBzdGFydCBpcyBhZGphY2VudCB0byB0aGUgc3BlY2lmaWVkIEludGVydmFsJ3MgZW5kLlxuICAgKiBAcGFyYW0ge0ludGVydmFsfSBvdGhlclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgYWJ1dHNFbmQob3RoZXIpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiArb3RoZXIuZSA9PT0gK3RoaXMucztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIEludGVydmFsIGVuZ3VsZnMgdGhlIHN0YXJ0IGFuZCBlbmQgb2YgdGhlIHNwZWNpZmllZCBJbnRlcnZhbC5cbiAgICogQHBhcmFtIHtJbnRlcnZhbH0gb3RoZXJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGVuZ3VsZnMob3RoZXIpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0aGlzLnMgPD0gb3RoZXIucyAmJiB0aGlzLmUgPj0gb3RoZXIuZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIEludGVydmFsIGhhcyB0aGUgc2FtZSBzdGFydCBhbmQgZW5kIGFzIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWwuXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBlcXVhbHMob3RoZXIpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCB8fCAhb3RoZXIuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnMuZXF1YWxzKG90aGVyLnMpICYmIHRoaXMuZS5lcXVhbHMob3RoZXIuZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIEludGVydmFsIHJlcHJlc2VudGluZyB0aGUgaW50ZXJzZWN0aW9uIG9mIHRoaXMgSW50ZXJ2YWwgYW5kIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWwuXG4gICAqIFNwZWNpZmljYWxseSwgdGhlIHJlc3VsdGluZyBJbnRlcnZhbCBoYXMgdGhlIG1heGltdW0gc3RhcnQgdGltZSBhbmQgdGhlIG1pbmltdW0gZW5kIHRpbWUgb2YgdGhlIHR3byBJbnRlcnZhbHMuXG4gICAqIFJldHVybnMgbnVsbCBpZiB0aGUgaW50ZXJzZWN0aW9uIGlzIGVtcHR5LCBtZWFuaW5nLCB0aGUgaW50ZXJ2YWxzIGRvbid0IGludGVyc2VjdC5cbiAgICogQHBhcmFtIHtJbnRlcnZhbH0gb3RoZXJcbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqL1xuICBpbnRlcnNlY3Rpb24ob3RoZXIpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgcyA9IHRoaXMucyA+IG90aGVyLnMgPyB0aGlzLnMgOiBvdGhlci5zLFxuICAgICAgZSA9IHRoaXMuZSA8IG90aGVyLmUgPyB0aGlzLmUgOiBvdGhlci5lO1xuXG4gICAgaWYgKHMgPj0gZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHMsIGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gSW50ZXJ2YWwgcmVwcmVzZW50aW5nIHRoZSB1bmlvbiBvZiB0aGlzIEludGVydmFsIGFuZCB0aGUgc3BlY2lmaWVkIEludGVydmFsLlxuICAgKiBTcGVjaWZpY2FsbHksIHRoZSByZXN1bHRpbmcgSW50ZXJ2YWwgaGFzIHRoZSBtaW5pbXVtIHN0YXJ0IHRpbWUgYW5kIHRoZSBtYXhpbXVtIGVuZCB0aW1lIG9mIHRoZSB0d28gSW50ZXJ2YWxzLlxuICAgKiBAcGFyYW0ge0ludGVydmFsfSBvdGhlclxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIHVuaW9uKG90aGVyKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IHMgPSB0aGlzLnMgPCBvdGhlci5zID8gdGhpcy5zIDogb3RoZXIucyxcbiAgICAgIGUgPSB0aGlzLmUgPiBvdGhlci5lID8gdGhpcy5lIDogb3RoZXIuZTtcbiAgICByZXR1cm4gSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhzLCBlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXJnZSBhbiBhcnJheSBvZiBJbnRlcnZhbHMgaW50byBhIGVxdWl2YWxlbnQgbWluaW1hbCBzZXQgb2YgSW50ZXJ2YWxzLlxuICAgKiBDb21iaW5lcyBvdmVybGFwcGluZyBhbmQgYWRqYWNlbnQgSW50ZXJ2YWxzLlxuICAgKiBAcGFyYW0ge0FycmF5fSBpbnRlcnZhbHNcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBzdGF0aWMgbWVyZ2UoaW50ZXJ2YWxzKSB7XG4gICAgY29uc3QgW2ZvdW5kLCBmaW5hbF0gPSBpbnRlcnZhbHNcbiAgICAgIC5zb3J0KChhLCBiKSA9PiBhLnMgLSBiLnMpXG4gICAgICAucmVkdWNlKFxuICAgICAgICAoW3NvZmFyLCBjdXJyZW50XSwgaXRlbSkgPT4ge1xuICAgICAgICAgIGlmICghY3VycmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIFtzb2ZhciwgaXRlbV07XG4gICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50Lm92ZXJsYXBzKGl0ZW0pIHx8IGN1cnJlbnQuYWJ1dHNTdGFydChpdGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtzb2ZhciwgY3VycmVudC51bmlvbihpdGVtKV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbc29mYXIuY29uY2F0KFtjdXJyZW50XSksIGl0ZW1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgW1tdLCBudWxsXVxuICAgICAgKTtcbiAgICBpZiAoZmluYWwpIHtcbiAgICAgIGZvdW5kLnB1c2goZmluYWwpO1xuICAgIH1cbiAgICByZXR1cm4gZm91bmQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGFycmF5IG9mIEludGVydmFscyByZXByZXNlbnRpbmcgdGhlIHNwYW5zIG9mIHRpbWUgdGhhdCBvbmx5IGFwcGVhciBpbiBvbmUgb2YgdGhlIHNwZWNpZmllZCBJbnRlcnZhbHMuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGludGVydmFsc1xuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHN0YXRpYyB4b3IoaW50ZXJ2YWxzKSB7XG4gICAgbGV0IHN0YXJ0ID0gbnVsbCxcbiAgICAgIGN1cnJlbnRDb3VudCA9IDA7XG4gICAgY29uc3QgcmVzdWx0cyA9IFtdLFxuICAgICAgZW5kcyA9IGludGVydmFscy5tYXAoKGkpID0+IFtcbiAgICAgICAgeyB0aW1lOiBpLnMsIHR5cGU6IFwic1wiIH0sXG4gICAgICAgIHsgdGltZTogaS5lLCB0eXBlOiBcImVcIiB9LFxuICAgICAgXSksXG4gICAgICBmbGF0dGVuZWQgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0KC4uLmVuZHMpLFxuICAgICAgYXJyID0gZmxhdHRlbmVkLnNvcnQoKGEsIGIpID0+IGEudGltZSAtIGIudGltZSk7XG5cbiAgICBmb3IgKGNvbnN0IGkgb2YgYXJyKSB7XG4gICAgICBjdXJyZW50Q291bnQgKz0gaS50eXBlID09PSBcInNcIiA/IDEgOiAtMTtcblxuICAgICAgaWYgKGN1cnJlbnRDb3VudCA9PT0gMSkge1xuICAgICAgICBzdGFydCA9IGkudGltZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzdGFydCAmJiArc3RhcnQgIT09ICtpLnRpbWUpIHtcbiAgICAgICAgICByZXN1bHRzLnB1c2goSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhzdGFydCwgaS50aW1lKSk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIEludGVydmFsLm1lcmdlKHJlc3VsdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBJbnRlcnZhbCByZXByZXNlbnRpbmcgdGhlIHNwYW4gb2YgdGltZSBpbiB0aGlzIEludGVydmFsIHRoYXQgZG9lc24ndCBvdmVybGFwIHdpdGggYW55IG9mIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWxzLlxuICAgKiBAcGFyYW0gey4uLkludGVydmFsfSBpbnRlcnZhbHNcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBkaWZmZXJlbmNlKC4uLmludGVydmFscykge1xuICAgIHJldHVybiBJbnRlcnZhbC54b3IoW3RoaXNdLmNvbmNhdChpbnRlcnZhbHMpKVxuICAgICAgLm1hcCgoaSkgPT4gdGhpcy5pbnRlcnNlY3Rpb24oaSkpXG4gICAgICAuZmlsdGVyKChpKSA9PiBpICYmICFpLmlzRW1wdHkoKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIEludGVydmFsIGFwcHJvcHJpYXRlIGZvciBkZWJ1Z2dpbmcuXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gSU5WQUxJRDtcbiAgICByZXR1cm4gYFske3RoaXMucy50b0lTTygpfSDigJMgJHt0aGlzLmUudG9JU08oKX0pYDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbG9jYWxpemVkIHN0cmluZyByZXByZXNlbnRpbmcgdGhpcyBJbnRlcnZhbC4gQWNjZXB0cyB0aGUgc2FtZSBvcHRpb25zIGFzIHRoZVxuICAgKiBJbnRsLkRhdGVUaW1lRm9ybWF0IGNvbnN0cnVjdG9yIGFuZCBhbnkgcHJlc2V0cyBkZWZpbmVkIGJ5IEx1eG9uLCBzdWNoIGFzXG4gICAqIHtAbGluayBEYXRlVGltZS5EQVRFX0ZVTEx9IG9yIHtAbGluayBEYXRlVGltZS5USU1FX1NJTVBMRX0uIFRoZSBleGFjdCBiZWhhdmlvciBvZiB0aGlzIG1ldGhvZFxuICAgKiBpcyBicm93c2VyLXNwZWNpZmljLCBidXQgaW4gZ2VuZXJhbCBpdCB3aWxsIHJldHVybiBhbiBhcHByb3ByaWF0ZSByZXByZXNlbnRhdGlvbiBvZiB0aGVcbiAgICogSW50ZXJ2YWwgaW4gdGhlIGFzc2lnbmVkIGxvY2FsZS4gRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW5cbiAgICogc3BlY2lmaWVkLlxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGVUaW1lRm9ybWF0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbZm9ybWF0T3B0cz1EYXRlVGltZS5EQVRFX1NIT1JUXSAtIEVpdGhlciBhIERhdGVUaW1lIHByZXNldCBvclxuICAgKiBJbnRsLkRhdGVUaW1lRm9ybWF0IGNvbnN0cnVjdG9yIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gT3B0aW9ucyB0byBvdmVycmlkZSB0aGUgY29uZmlndXJhdGlvbiBvZiB0aGUgc3RhcnQgRGF0ZVRpbWUuXG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21JU08oJzIwMjItMTEtMDdUMDk6MDBaLzIwMjItMTEtMDhUMDk6MDBaJykudG9Mb2NhbGVTdHJpbmcoKTsgLy89PiAxMS83LzIwMjIg4oCTIDExLzgvMjAyMlxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tSVNPKCcyMDIyLTExLTA3VDA5OjAwWi8yMDIyLTExLTA4VDA5OjAwWicpLnRvTG9jYWxlU3RyaW5nKERhdGVUaW1lLkRBVEVfRlVMTCk7IC8vPT4gTm92ZW1iZXIgNyDigJMgOCwgMjAyMlxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tSVNPKCcyMDIyLTExLTA3VDA5OjAwWi8yMDIyLTExLTA4VDA5OjAwWicpLnRvTG9jYWxlU3RyaW5nKERhdGVUaW1lLkRBVEVfRlVMTCwgeyBsb2NhbGU6ICdmci1GUicgfSk7IC8vPT4gN+KAkzggbm92ZW1icmUgMjAyMlxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tSVNPKCcyMDIyLTExLTA3VDE3OjAwWi8yMDIyLTExLTA3VDE5OjAwWicpLnRvTG9jYWxlU3RyaW5nKERhdGVUaW1lLlRJTUVfU0lNUExFKTsgLy89PiA2OjAwIOKAkyA4OjAwIFBNXG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21JU08oJzIwMjItMTEtMDdUMTc6MDBaLzIwMjItMTEtMDdUMTk6MDBaJykudG9Mb2NhbGVTdHJpbmcoeyB3ZWVrZGF5OiAnc2hvcnQnLCBtb250aDogJ3Nob3J0JywgZGF5OiAnMi1kaWdpdCcsIGhvdXI6ICcyLWRpZ2l0JywgbWludXRlOiAnMi1kaWdpdCcgfSk7IC8vPT4gTW9uLCBOb3YgMDcsIDY6MDAg4oCTIDg6MDAgcFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0xvY2FsZVN0cmluZyhmb3JtYXRPcHRzID0gRm9ybWF0cy5EQVRFX1NIT1JULCBvcHRzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkXG4gICAgICA/IEZvcm1hdHRlci5jcmVhdGUodGhpcy5zLmxvYy5jbG9uZShvcHRzKSwgZm9ybWF0T3B0cykuZm9ybWF0SW50ZXJ2YWwodGhpcylcbiAgICAgIDogSU5WQUxJRDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBJbnRlcnZhbC5cbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMSNUaW1lX2ludGVydmFsc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIFRoZSBzYW1lIG9wdGlvbnMgYXMge0BsaW5rIERhdGVUaW1lI3RvSVNPfVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0lTTyhvcHRzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBJTlZBTElEO1xuICAgIHJldHVybiBgJHt0aGlzLnMudG9JU08ob3B0cyl9LyR7dGhpcy5lLnRvSVNPKG9wdHMpfWA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMS1jb21wbGlhbnQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGRhdGUgb2YgdGhpcyBJbnRlcnZhbC5cbiAgICogVGhlIHRpbWUgY29tcG9uZW50cyBhcmUgaWdub3JlZC5cbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMSNUaW1lX2ludGVydmFsc1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0lTT0RhdGUoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBJTlZBTElEO1xuICAgIHJldHVybiBgJHt0aGlzLnMudG9JU09EYXRlKCl9LyR7dGhpcy5lLnRvSVNPRGF0ZSgpfWA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMS1jb21wbGlhbnQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRpbWUgb2YgdGhpcyBJbnRlcnZhbC5cbiAgICogVGhlIGRhdGUgY29tcG9uZW50cyBhcmUgaWdub3JlZC5cbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMSNUaW1lX2ludGVydmFsc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIFRoZSBzYW1lIG9wdGlvbnMgYXMge0BsaW5rIERhdGVUaW1lI3RvSVNPfVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0lTT1RpbWUob3B0cykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gSU5WQUxJRDtcbiAgICByZXR1cm4gYCR7dGhpcy5zLnRvSVNPVGltZShvcHRzKX0vJHt0aGlzLmUudG9JU09UaW1lKG9wdHMpfWA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIEludGVydmFsIGZvcm1hdHRlZCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBmb3JtYXRcbiAgICogc3RyaW5nLiAqKllvdSBtYXkgbm90IHdhbnQgdGhpcy4qKiBTZWUge0BsaW5rIEludGVydmFsI3RvTG9jYWxlU3RyaW5nfSBmb3IgYSBtb3JlIGZsZXhpYmxlXG4gICAqIGZvcm1hdHRpbmcgdG9vbC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGVGb3JtYXQgLSBUaGUgZm9ybWF0IHN0cmluZy4gVGhpcyBzdHJpbmcgZm9ybWF0cyB0aGUgc3RhcnQgYW5kIGVuZCB0aW1lLlxuICAgKiBTZWUge0BsaW5rIERhdGVUaW1lI3RvRm9ybWF0fSBmb3IgZGV0YWlscy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBPcHRpb25zLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuc2VwYXJhdG9yID0gICcg4oCTICddIC0gQSBzZXBhcmF0b3IgdG8gcGxhY2UgYmV0d2VlbiB0aGUgc3RhcnQgYW5kIGVuZFxuICAgKiByZXByZXNlbnRhdGlvbnMuXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvRm9ybWF0KGRhdGVGb3JtYXQsIHsgc2VwYXJhdG9yID0gXCIg4oCTIFwiIH0gPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gSU5WQUxJRDtcbiAgICByZXR1cm4gYCR7dGhpcy5zLnRvRm9ybWF0KGRhdGVGb3JtYXQpfSR7c2VwYXJhdG9yfSR7dGhpcy5lLnRvRm9ybWF0KGRhdGVGb3JtYXQpfWA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgRHVyYXRpb24gcmVwcmVzZW50aW5nIHRoZSB0aW1lIHNwYW5uZWQgYnkgdGhpcyBpbnRlcnZhbC5cbiAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IFt1bml0PVsnbWlsbGlzZWNvbmRzJ11dIC0gdGhlIHVuaXQgb3IgdW5pdHMgKHN1Y2ggYXMgJ2hvdXJzJyBvciAnZGF5cycpIHRvIGluY2x1ZGUgaW4gdGhlIGR1cmF0aW9uLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgdGhhdCBhZmZlY3QgdGhlIGNyZWF0aW9uIG9mIHRoZSBEdXJhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuY29udmVyc2lvbkFjY3VyYWN5PSdjYXN1YWwnXSAtIHRoZSBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdDEsIGR0MikudG9EdXJhdGlvbigpLnRvT2JqZWN0KCkgLy89PiB7IG1pbGxpc2Vjb25kczogODg0ODkyNTcgfVxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0MSwgZHQyKS50b0R1cmF0aW9uKCdkYXlzJykudG9PYmplY3QoKSAvLz0+IHsgZGF5czogMS4wMjQxODEyMTUyNzc3Nzc4IH1cbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdDEsIGR0MikudG9EdXJhdGlvbihbJ2hvdXJzJywgJ21pbnV0ZXMnXSkudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDI0LCBtaW51dGVzOiAzNC44MjA5NSB9XG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQxLCBkdDIpLnRvRHVyYXRpb24oWydob3VycycsICdtaW51dGVzJywgJ3NlY29uZHMnXSkudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDI0LCBtaW51dGVzOiAzNCwgc2Vjb25kczogNDkuMjU3IH1cbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdDEsIGR0MikudG9EdXJhdGlvbignc2Vjb25kcycpLnRvT2JqZWN0KCkgLy89PiB7IHNlY29uZHM6IDg4NDg5LjI1NyB9XG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgdG9EdXJhdGlvbih1bml0LCBvcHRzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5pbnZhbGlkKHRoaXMuaW52YWxpZFJlYXNvbik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmUuZGlmZih0aGlzLnMsIHVuaXQsIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1biBtYXBGbiBvbiB0aGUgaW50ZXJ2YWwgc3RhcnQgYW5kIGVuZCwgcmV0dXJuaW5nIGEgbmV3IEludGVydmFsIGZyb20gdGhlIHJlc3VsdGluZyBEYXRlVGltZXNcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gbWFwRm5cbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQxLCBkdDIpLm1hcEVuZHBvaW50cyhlbmRwb2ludCA9PiBlbmRwb2ludC50b1VUQygpKVxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0MSwgZHQyKS5tYXBFbmRwb2ludHMoZW5kcG9pbnQgPT4gZW5kcG9pbnQucGx1cyh7IGhvdXJzOiAyIH0pKVxuICAgKi9cbiAgbWFwRW5kcG9pbnRzKG1hcEZuKSB7XG4gICAgcmV0dXJuIEludGVydmFsLmZyb21EYXRlVGltZXMobWFwRm4odGhpcy5zKSwgbWFwRm4odGhpcy5lKSk7XG4gIH1cbn1cbiIsImltcG9ydCBEYXRlVGltZSBmcm9tIFwiLi9kYXRldGltZS5qc1wiO1xuaW1wb3J0IER1cmF0aW9uIGZyb20gXCIuL2R1cmF0aW9uLmpzXCI7XG5pbXBvcnQgSW50ZXJ2YWwgZnJvbSBcIi4vaW50ZXJ2YWwuanNcIjtcbmltcG9ydCBJbmZvIGZyb20gXCIuL2luZm8uanNcIjtcbmltcG9ydCBab25lIGZyb20gXCIuL3pvbmUuanNcIjtcbmltcG9ydCBGaXhlZE9mZnNldFpvbmUgZnJvbSBcIi4vem9uZXMvZml4ZWRPZmZzZXRab25lLmpzXCI7XG5pbXBvcnQgSUFOQVpvbmUgZnJvbSBcIi4vem9uZXMvSUFOQVpvbmUuanNcIjtcbmltcG9ydCBJbnZhbGlkWm9uZSBmcm9tIFwiLi96b25lcy9pbnZhbGlkWm9uZS5qc1wiO1xuaW1wb3J0IFN5c3RlbVpvbmUgZnJvbSBcIi4vem9uZXMvc3lzdGVtWm9uZS5qc1wiO1xuaW1wb3J0IFNldHRpbmdzIGZyb20gXCIuL3NldHRpbmdzLmpzXCI7XG5cbmNvbnN0IFZFUlNJT04gPSBcIjMuNC4zXCI7XG5cbmV4cG9ydCB7XG4gIFZFUlNJT04sXG4gIERhdGVUaW1lLFxuICBEdXJhdGlvbixcbiAgSW50ZXJ2YWwsXG4gIEluZm8sXG4gIFpvbmUsXG4gIEZpeGVkT2Zmc2V0Wm9uZSxcbiAgSUFOQVpvbmUsXG4gIEludmFsaWRab25lLFxuICBTeXN0ZW1ab25lLFxuICBTZXR0aW5ncyxcbn07XG4iLCJpbXBvcnQgU3lzdGVtWm9uZSBmcm9tIFwiLi96b25lcy9zeXN0ZW1ab25lLmpzXCI7XG5pbXBvcnQgSUFOQVpvbmUgZnJvbSBcIi4vem9uZXMvSUFOQVpvbmUuanNcIjtcbmltcG9ydCBMb2NhbGUgZnJvbSBcIi4vaW1wbC9sb2NhbGUuanNcIjtcblxuaW1wb3J0IHsgbm9ybWFsaXplWm9uZSB9IGZyb20gXCIuL2ltcGwvem9uZVV0aWwuanNcIjtcblxubGV0IG5vdyA9ICgpID0+IERhdGUubm93KCksXG4gIGRlZmF1bHRab25lID0gXCJzeXN0ZW1cIixcbiAgZGVmYXVsdExvY2FsZSA9IG51bGwsXG4gIGRlZmF1bHROdW1iZXJpbmdTeXN0ZW0gPSBudWxsLFxuICBkZWZhdWx0T3V0cHV0Q2FsZW5kYXIgPSBudWxsLFxuICB0d29EaWdpdEN1dG9mZlllYXIgPSA2MCxcbiAgdGhyb3dPbkludmFsaWQ7XG5cbi8qKlxuICogU2V0dGluZ3MgY29udGFpbnMgc3RhdGljIGdldHRlcnMgYW5kIHNldHRlcnMgdGhhdCBjb250cm9sIEx1eG9uJ3Mgb3ZlcmFsbCBiZWhhdmlvci4gTHV4b24gaXMgYSBzaW1wbGUgbGlicmFyeSB3aXRoIGZldyBvcHRpb25zLCBidXQgdGhlIG9uZXMgaXQgZG9lcyBoYXZlIGxpdmUgaGVyZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2V0dGluZ3Mge1xuICAvKipcbiAgICogR2V0IHRoZSBjYWxsYmFjayBmb3IgcmV0dXJuaW5nIHRoZSBjdXJyZW50IHRpbWVzdGFtcC5cbiAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgKi9cbiAgc3RhdGljIGdldCBub3coKSB7XG4gICAgcmV0dXJuIG5vdztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNhbGxiYWNrIGZvciByZXR1cm5pbmcgdGhlIGN1cnJlbnQgdGltZXN0YW1wLlxuICAgKiBUaGUgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIG51bWJlciwgd2hpY2ggd2lsbCBiZSBpbnRlcnByZXRlZCBhcyBhbiBFcG9jaCBtaWxsaXNlY29uZCBjb3VudFxuICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAqIEBleGFtcGxlIFNldHRpbmdzLm5vdyA9ICgpID0+IERhdGUubm93KCkgKyAzMDAwIC8vIHByZXRlbmQgaXQgaXMgMyBzZWNvbmRzIGluIHRoZSBmdXR1cmVcbiAgICogQGV4YW1wbGUgU2V0dGluZ3Mubm93ID0gKCkgPT4gMCAvLyBhbHdheXMgcHJldGVuZCBpdCdzIEphbiAxLCAxOTcwIGF0IG1pZG5pZ2h0IGluIFVUQyB0aW1lXG4gICAqL1xuICBzdGF0aWMgc2V0IG5vdyhuKSB7XG4gICAgbm93ID0gbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGRlZmF1bHQgdGltZSB6b25lIHRvIGNyZWF0ZSBEYXRlVGltZXMgaW4uIERvZXMgbm90IGFmZmVjdCBleGlzdGluZyBpbnN0YW5jZXMuXG4gICAqIFVzZSB0aGUgdmFsdWUgXCJzeXN0ZW1cIiB0byByZXNldCB0aGlzIHZhbHVlIHRvIHRoZSBzeXN0ZW0ncyB0aW1lIHpvbmUuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgc2V0IGRlZmF1bHRab25lKHpvbmUpIHtcbiAgICBkZWZhdWx0Wm9uZSA9IHpvbmU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkZWZhdWx0IHRpbWUgem9uZSBvYmplY3QgY3VycmVudGx5IHVzZWQgdG8gY3JlYXRlIERhdGVUaW1lcy4gRG9lcyBub3QgYWZmZWN0IGV4aXN0aW5nIGluc3RhbmNlcy5cbiAgICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgdGhlIHN5c3RlbSdzIHRpbWUgem9uZSAodGhlIG9uZSBzZXQgb24gdGhlIG1hY2hpbmUgdGhhdCBydW5zIHRoaXMgY29kZSkuXG4gICAqIEB0eXBlIHtab25lfVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0Wm9uZSgpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplWm9uZShkZWZhdWx0Wm9uZSwgU3lzdGVtWm9uZS5pbnN0YW5jZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkZWZhdWx0IGxvY2FsZSB0byBjcmVhdGUgRGF0ZVRpbWVzIHdpdGguIERvZXMgbm90IGFmZmVjdCBleGlzdGluZyBpbnN0YW5jZXMuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRMb2NhbGUoKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRMb2NhbGU7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBkZWZhdWx0IGxvY2FsZSB0byBjcmVhdGUgRGF0ZVRpbWVzIHdpdGguIERvZXMgbm90IGFmZmVjdCBleGlzdGluZyBpbnN0YW5jZXMuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgc2V0IGRlZmF1bHRMb2NhbGUobG9jYWxlKSB7XG4gICAgZGVmYXVsdExvY2FsZSA9IGxvY2FsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRlZmF1bHQgbnVtYmVyaW5nIHN5c3RlbSB0byBjcmVhdGUgRGF0ZVRpbWVzIHdpdGguIERvZXMgbm90IGFmZmVjdCBleGlzdGluZyBpbnN0YW5jZXMuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHROdW1iZXJpbmdTeXN0ZW0oKSB7XG4gICAgcmV0dXJuIGRlZmF1bHROdW1iZXJpbmdTeXN0ZW07XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBkZWZhdWx0IG51bWJlcmluZyBzeXN0ZW0gdG8gY3JlYXRlIERhdGVUaW1lcyB3aXRoLiBEb2VzIG5vdCBhZmZlY3QgZXhpc3RpbmcgaW5zdGFuY2VzLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIHNldCBkZWZhdWx0TnVtYmVyaW5nU3lzdGVtKG51bWJlcmluZ1N5c3RlbSkge1xuICAgIGRlZmF1bHROdW1iZXJpbmdTeXN0ZW0gPSBudW1iZXJpbmdTeXN0ZW07XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkZWZhdWx0IG91dHB1dCBjYWxlbmRhciB0byBjcmVhdGUgRGF0ZVRpbWVzIHdpdGguIERvZXMgbm90IGFmZmVjdCBleGlzdGluZyBpbnN0YW5jZXMuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRPdXRwdXRDYWxlbmRhcigpIHtcbiAgICByZXR1cm4gZGVmYXVsdE91dHB1dENhbGVuZGFyO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZGVmYXVsdCBvdXRwdXQgY2FsZW5kYXIgdG8gY3JlYXRlIERhdGVUaW1lcyB3aXRoLiBEb2VzIG5vdCBhZmZlY3QgZXhpc3RpbmcgaW5zdGFuY2VzLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIHNldCBkZWZhdWx0T3V0cHV0Q2FsZW5kYXIob3V0cHV0Q2FsZW5kYXIpIHtcbiAgICBkZWZhdWx0T3V0cHV0Q2FsZW5kYXIgPSBvdXRwdXRDYWxlbmRhcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1dG9mZiB5ZWFyIGFmdGVyIHdoaWNoIGEgc3RyaW5nIGVuY29kaW5nIGEgeWVhciBhcyB0d28gZGlnaXRzIGlzIGludGVycHJldGVkIHRvIG9jY3VyIGluIHRoZSBjdXJyZW50IGNlbnR1cnkuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0IHR3b0RpZ2l0Q3V0b2ZmWWVhcigpIHtcbiAgICByZXR1cm4gdHdvRGlnaXRDdXRvZmZZZWFyO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY3V0b2ZmIHllYXIgYWZ0ZXIgd2hpY2ggYSBzdHJpbmcgZW5jb2RpbmcgYSB5ZWFyIGFzIHR3byBkaWdpdHMgaXMgaW50ZXJwcmV0ZWQgdG8gb2NjdXIgaW4gdGhlIGN1cnJlbnQgY2VudHVyeS5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGV4YW1wbGUgU2V0dGluZ3MudHdvRGlnaXRDdXRvZmZZZWFyID0gMCAvLyBjdXQtb2ZmIHllYXIgaXMgMCwgc28gYWxsICd5eScgYXJlIGludGVycHJldGVkIGFzIGN1cnJlbnQgY2VudHVyeVxuICAgKiBAZXhhbXBsZSBTZXR0aW5ncy50d29EaWdpdEN1dG9mZlllYXIgPSA1MCAvLyAnNDknIC0+IDE5NDk7ICc1MCcgLT4gMjA1MFxuICAgKiBAZXhhbXBsZSBTZXR0aW5ncy50d29EaWdpdEN1dG9mZlllYXIgPSAxOTUwIC8vIGludGVycHJldGVkIGFzIDUwXG4gICAqIEBleGFtcGxlIFNldHRpbmdzLnR3b0RpZ2l0Q3V0b2ZmWWVhciA9IDIwNTAgLy8gQUxTTyBpbnRlcnByZXRlZCBhcyA1MFxuICAgKi9cbiAgc3RhdGljIHNldCB0d29EaWdpdEN1dG9mZlllYXIoY3V0b2ZmWWVhcikge1xuICAgIHR3b0RpZ2l0Q3V0b2ZmWWVhciA9IGN1dG9mZlllYXIgJSAxMDA7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHdoZXRoZXIgTHV4b24gd2lsbCB0aHJvdyB3aGVuIGl0IGVuY291bnRlcnMgaW52YWxpZCBEYXRlVGltZXMsIER1cmF0aW9ucywgb3IgSW50ZXJ2YWxzXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGdldCB0aHJvd09uSW52YWxpZCgpIHtcbiAgICByZXR1cm4gdGhyb3dPbkludmFsaWQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHdoZXRoZXIgTHV4b24gd2lsbCB0aHJvdyB3aGVuIGl0IGVuY291bnRlcnMgaW52YWxpZCBEYXRlVGltZXMsIER1cmF0aW9ucywgb3IgSW50ZXJ2YWxzXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIHNldCB0aHJvd09uSW52YWxpZCh0KSB7XG4gICAgdGhyb3dPbkludmFsaWQgPSB0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0IEx1eG9uJ3MgZ2xvYmFsIGNhY2hlcy4gU2hvdWxkIG9ubHkgYmUgbmVjZXNzYXJ5IGluIHRlc3Rpbmcgc2NlbmFyaW9zLlxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgc3RhdGljIHJlc2V0Q2FjaGVzKCkge1xuICAgIExvY2FsZS5yZXNldENhY2hlKCk7XG4gICAgSUFOQVpvbmUucmVzZXRDYWNoZSgpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBab25lSXNBYnN0cmFjdEVycm9yIH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5cbi8qKlxuICogQGludGVyZmFjZVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBab25lIHtcbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHpvbmVcbiAgICogQGFic3RyYWN0XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgdHlwZSgpIHtcbiAgICB0aHJvdyBuZXcgWm9uZUlzQWJzdHJhY3RFcnJvcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoaXMgem9uZS5cbiAgICogQGFic3RyYWN0XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgbmFtZSgpIHtcbiAgICB0aHJvdyBuZXcgWm9uZUlzQWJzdHJhY3RFcnJvcigpO1xuICB9XG5cbiAgZ2V0IGlhbmFOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBvZmZzZXQgaXMga25vd24gdG8gYmUgZml4ZWQgZm9yIHRoZSB3aG9sZSB5ZWFyLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNVbml2ZXJzYWwoKSB7XG4gICAgdGhyb3cgbmV3IFpvbmVJc0Fic3RyYWN0RXJyb3IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvZmZzZXQncyBjb21tb24gbmFtZSAoc3VjaCBhcyBFU1QpIGF0IHRoZSBzcGVjaWZpZWQgdGltZXN0YW1wXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge251bWJlcn0gdHMgLSBFcG9jaCBtaWxsaXNlY29uZHMgZm9yIHdoaWNoIHRvIGdldCB0aGUgbmFtZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIE9wdGlvbnMgdG8gYWZmZWN0IHRoZSBmb3JtYXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMuZm9ybWF0IC0gV2hhdCBzdHlsZSBvZiBvZmZzZXQgdG8gcmV0dXJuLiBBY2NlcHRzICdsb25nJyBvciAnc2hvcnQnLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5sb2NhbGUgLSBXaGF0IGxvY2FsZSB0byByZXR1cm4gdGhlIG9mZnNldCBuYW1lIGluLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBvZmZzZXROYW1lKHRzLCBvcHRzKSB7XG4gICAgdGhyb3cgbmV3IFpvbmVJc0Fic3RyYWN0RXJyb3IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvZmZzZXQncyB2YWx1ZSBhcyBhIHN0cmluZ1xuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRzIC0gRXBvY2ggbWlsbGlzZWNvbmRzIGZvciB3aGljaCB0byBnZXQgdGhlIG9mZnNldFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZm9ybWF0IC0gV2hhdCBzdHlsZSBvZiBvZmZzZXQgdG8gcmV0dXJuLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgQWNjZXB0cyAnbmFycm93JywgJ3Nob3J0Jywgb3IgJ3RlY2hpZScuIFJldHVybmluZyAnKzYnLCAnKzA2OjAwJywgb3IgJyswNjAwJyByZXNwZWN0aXZlbHlcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZm9ybWF0T2Zmc2V0KHRzLCBmb3JtYXQpIHtcbiAgICB0aHJvdyBuZXcgWm9uZUlzQWJzdHJhY3RFcnJvcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgb2Zmc2V0IGluIG1pbnV0ZXMgZm9yIHRoaXMgem9uZSBhdCB0aGUgc3BlY2lmaWVkIHRpbWVzdGFtcC5cbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0cyAtIEVwb2NoIG1pbGxpc2Vjb25kcyBmb3Igd2hpY2ggdG8gY29tcHV0ZSB0aGUgb2Zmc2V0XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIG9mZnNldCh0cykge1xuICAgIHRocm93IG5ldyBab25lSXNBYnN0cmFjdEVycm9yKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBab25lIGlzIGVxdWFsIHRvIGFub3RoZXIgem9uZVxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtab25lfSBvdGhlclpvbmUgLSB0aGUgem9uZSB0byBjb21wYXJlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBlcXVhbHMob3RoZXJab25lKSB7XG4gICAgdGhyb3cgbmV3IFpvbmVJc0Fic3RyYWN0RXJyb3IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIFpvbmUgaXMgdmFsaWQuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIHRocm93IG5ldyBab25lSXNBYnN0cmFjdEVycm9yKCk7XG4gIH1cbn1cbiIsImltcG9ydCB7IGZvcm1hdE9mZnNldCwgcGFyc2Vab25lSW5mbywgaXNVbmRlZmluZWQsIG9ialRvTG9jYWxUUyB9IGZyb20gXCIuLi9pbXBsL3V0aWwuanNcIjtcbmltcG9ydCBab25lIGZyb20gXCIuLi96b25lLmpzXCI7XG5cbmxldCBkdGZDYWNoZSA9IHt9O1xuZnVuY3Rpb24gbWFrZURURih6b25lKSB7XG4gIGlmICghZHRmQ2FjaGVbem9uZV0pIHtcbiAgICBkdGZDYWNoZVt6b25lXSA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KFwiZW4tVVNcIiwge1xuICAgICAgaG91cjEyOiBmYWxzZSxcbiAgICAgIHRpbWVab25lOiB6b25lLFxuICAgICAgeWVhcjogXCJudW1lcmljXCIsXG4gICAgICBtb250aDogXCIyLWRpZ2l0XCIsXG4gICAgICBkYXk6IFwiMi1kaWdpdFwiLFxuICAgICAgaG91cjogXCIyLWRpZ2l0XCIsXG4gICAgICBtaW51dGU6IFwiMi1kaWdpdFwiLFxuICAgICAgc2Vjb25kOiBcIjItZGlnaXRcIixcbiAgICAgIGVyYTogXCJzaG9ydFwiLFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBkdGZDYWNoZVt6b25lXTtcbn1cblxuY29uc3QgdHlwZVRvUG9zID0ge1xuICB5ZWFyOiAwLFxuICBtb250aDogMSxcbiAgZGF5OiAyLFxuICBlcmE6IDMsXG4gIGhvdXI6IDQsXG4gIG1pbnV0ZTogNSxcbiAgc2Vjb25kOiA2LFxufTtcblxuZnVuY3Rpb24gaGFja3lPZmZzZXQoZHRmLCBkYXRlKSB7XG4gIGNvbnN0IGZvcm1hdHRlZCA9IGR0Zi5mb3JtYXQoZGF0ZSkucmVwbGFjZSgvXFx1MjAwRS9nLCBcIlwiKSxcbiAgICBwYXJzZWQgPSAvKFxcZCspXFwvKFxcZCspXFwvKFxcZCspIChBRHxCQyksPyAoXFxkKyk6KFxcZCspOihcXGQrKS8uZXhlYyhmb3JtYXR0ZWQpLFxuICAgIFssIGZNb250aCwgZkRheSwgZlllYXIsIGZhZE9yQmMsIGZIb3VyLCBmTWludXRlLCBmU2Vjb25kXSA9IHBhcnNlZDtcbiAgcmV0dXJuIFtmWWVhciwgZk1vbnRoLCBmRGF5LCBmYWRPckJjLCBmSG91ciwgZk1pbnV0ZSwgZlNlY29uZF07XG59XG5cbmZ1bmN0aW9uIHBhcnRzT2Zmc2V0KGR0ZiwgZGF0ZSkge1xuICBjb25zdCBmb3JtYXR0ZWQgPSBkdGYuZm9ybWF0VG9QYXJ0cyhkYXRlKTtcbiAgY29uc3QgZmlsbGVkID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZm9ybWF0dGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgeyB0eXBlLCB2YWx1ZSB9ID0gZm9ybWF0dGVkW2ldO1xuICAgIGNvbnN0IHBvcyA9IHR5cGVUb1Bvc1t0eXBlXTtcblxuICAgIGlmICh0eXBlID09PSBcImVyYVwiKSB7XG4gICAgICBmaWxsZWRbcG9zXSA9IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAoIWlzVW5kZWZpbmVkKHBvcykpIHtcbiAgICAgIGZpbGxlZFtwb3NdID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZpbGxlZDtcbn1cblxubGV0IGlhbmFab25lQ2FjaGUgPSB7fTtcbi8qKlxuICogQSB6b25lIGlkZW50aWZpZWQgYnkgYW4gSUFOQSBpZGVudGlmaWVyLCBsaWtlIEFtZXJpY2EvTmV3X1lvcmtcbiAqIEBpbXBsZW1lbnRzIHtab25lfVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJQU5BWm9uZSBleHRlbmRzIFpvbmUge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBab25lIG5hbWVcbiAgICogQHJldHVybiB7SUFOQVpvbmV9XG4gICAqL1xuICBzdGF0aWMgY3JlYXRlKG5hbWUpIHtcbiAgICBpZiAoIWlhbmFab25lQ2FjaGVbbmFtZV0pIHtcbiAgICAgIGlhbmFab25lQ2FjaGVbbmFtZV0gPSBuZXcgSUFOQVpvbmUobmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBpYW5hWm9uZUNhY2hlW25hbWVdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0IGxvY2FsIGNhY2hlcy4gU2hvdWxkIG9ubHkgYmUgbmVjZXNzYXJ5IGluIHRlc3Rpbmcgc2NlbmFyaW9zLlxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgc3RhdGljIHJlc2V0Q2FjaGUoKSB7XG4gICAgaWFuYVpvbmVDYWNoZSA9IHt9O1xuICAgIGR0ZkNhY2hlID0ge307XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBwcm92aWRlZCBzdHJpbmcgaXMgYSB2YWxpZCBzcGVjaWZpZXIuIFRoaXMgb25seSBjaGVja3MgdGhlIHN0cmluZydzIGZvcm1hdCwgbm90IHRoYXQgdGhlIHNwZWNpZmllciBpZGVudGlmaWVzIGEga25vd24gem9uZTsgc2VlIGlzVmFsaWRab25lIGZvciB0aGF0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcyAtIFRoZSBzdHJpbmcgdG8gY2hlY2sgdmFsaWRpdHkgb25cbiAgICogQGV4YW1wbGUgSUFOQVpvbmUuaXNWYWxpZFNwZWNpZmllcihcIkFtZXJpY2EvTmV3X1lvcmtcIikgLy89PiB0cnVlXG4gICAqIEBleGFtcGxlIElBTkFab25lLmlzVmFsaWRTcGVjaWZpZXIoXCJTcG9ydH5+YmxvcnBcIikgLy89PiBmYWxzZVxuICAgKiBAZGVwcmVjYXRlZCBUaGlzIG1ldGhvZCByZXR1cm5zIGZhbHNlIGZvciBzb21lIHZhbGlkIElBTkEgbmFtZXMuIFVzZSBpc1ZhbGlkWm9uZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzVmFsaWRTcGVjaWZpZXIocykge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWRab25lKHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgcHJvdmlkZWQgc3RyaW5nIGlkZW50aWZpZXMgYSByZWFsIHpvbmVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHpvbmUgLSBUaGUgc3RyaW5nIHRvIGNoZWNrXG4gICAqIEBleGFtcGxlIElBTkFab25lLmlzVmFsaWRab25lKFwiQW1lcmljYS9OZXdfWW9ya1wiKSAvLz0+IHRydWVcbiAgICogQGV4YW1wbGUgSUFOQVpvbmUuaXNWYWxpZFpvbmUoXCJGYW50YXNpYS9DYXN0bGVcIikgLy89PiBmYWxzZVxuICAgKiBAZXhhbXBsZSBJQU5BWm9uZS5pc1ZhbGlkWm9uZShcIlNwb3J0fn5ibG9ycFwiKSAvLz0+IGZhbHNlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNWYWxpZFpvbmUoem9uZSkge1xuICAgIGlmICghem9uZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoXCJlbi1VU1wiLCB7IHRpbWVab25lOiB6b25lIH0pLmZvcm1hdCgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKiBAcHJpdmF0ZSAqKi9cbiAgICB0aGlzLnpvbmVOYW1lID0gbmFtZTtcbiAgICAvKiogQHByaXZhdGUgKiovXG4gICAgdGhpcy52YWxpZCA9IElBTkFab25lLmlzVmFsaWRab25lKG5hbWUpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIFwiaWFuYVwiO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuem9uZU5hbWU7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgaXNVbml2ZXJzYWwoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgb2Zmc2V0TmFtZSh0cywgeyBmb3JtYXQsIGxvY2FsZSB9KSB7XG4gICAgcmV0dXJuIHBhcnNlWm9uZUluZm8odHMsIGZvcm1hdCwgbG9jYWxlLCB0aGlzLm5hbWUpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZm9ybWF0T2Zmc2V0KHRzLCBmb3JtYXQpIHtcbiAgICByZXR1cm4gZm9ybWF0T2Zmc2V0KHRoaXMub2Zmc2V0KHRzKSwgZm9ybWF0KTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIG9mZnNldCh0cykge1xuICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh0cyk7XG5cbiAgICBpZiAoaXNOYU4oZGF0ZSkpIHJldHVybiBOYU47XG5cbiAgICBjb25zdCBkdGYgPSBtYWtlRFRGKHRoaXMubmFtZSk7XG4gICAgbGV0IFt5ZWFyLCBtb250aCwgZGF5LCBhZE9yQmMsIGhvdXIsIG1pbnV0ZSwgc2Vjb25kXSA9IGR0Zi5mb3JtYXRUb1BhcnRzXG4gICAgICA/IHBhcnRzT2Zmc2V0KGR0ZiwgZGF0ZSlcbiAgICAgIDogaGFja3lPZmZzZXQoZHRmLCBkYXRlKTtcblxuICAgIGlmIChhZE9yQmMgPT09IFwiQkNcIikge1xuICAgICAgeWVhciA9IC1NYXRoLmFicyh5ZWFyKSArIDE7XG4gICAgfVxuXG4gICAgLy8gYmVjYXVzZSB3ZSdyZSB1c2luZyBob3VyMTIgYW5kIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTEwMjU1NjQmY2FuPTImcT0lMjIyNCUzQTAwJTIyJTIwZGF0ZXRpbWVmb3JtYXRcbiAgICBjb25zdCBhZGp1c3RlZEhvdXIgPSBob3VyID09PSAyNCA/IDAgOiBob3VyO1xuXG4gICAgY29uc3QgYXNVVEMgPSBvYmpUb0xvY2FsVFMoe1xuICAgICAgeWVhcixcbiAgICAgIG1vbnRoLFxuICAgICAgZGF5LFxuICAgICAgaG91cjogYWRqdXN0ZWRIb3VyLFxuICAgICAgbWludXRlLFxuICAgICAgc2Vjb25kLFxuICAgICAgbWlsbGlzZWNvbmQ6IDAsXG4gICAgfSk7XG5cbiAgICBsZXQgYXNUUyA9ICtkYXRlO1xuICAgIGNvbnN0IG92ZXIgPSBhc1RTICUgMTAwMDtcbiAgICBhc1RTIC09IG92ZXIgPj0gMCA/IG92ZXIgOiAxMDAwICsgb3ZlcjtcbiAgICByZXR1cm4gKGFzVVRDIC0gYXNUUykgLyAoNjAgKiAxMDAwKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGVxdWFscyhvdGhlclpvbmUpIHtcbiAgICByZXR1cm4gb3RoZXJab25lLnR5cGUgPT09IFwiaWFuYVwiICYmIG90aGVyWm9uZS5uYW1lID09PSB0aGlzLm5hbWU7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gdGhpcy52YWxpZDtcbiAgfVxufVxuIiwiaW1wb3J0IHsgZm9ybWF0T2Zmc2V0LCBzaWduZWRPZmZzZXQgfSBmcm9tIFwiLi4vaW1wbC91dGlsLmpzXCI7XG5pbXBvcnQgWm9uZSBmcm9tIFwiLi4vem9uZS5qc1wiO1xuXG5sZXQgc2luZ2xldG9uID0gbnVsbDtcblxuLyoqXG4gKiBBIHpvbmUgd2l0aCBhIGZpeGVkIG9mZnNldCAobWVhbmluZyBubyBEU1QpXG4gKiBAaW1wbGVtZW50cyB7Wm9uZX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRml4ZWRPZmZzZXRab25lIGV4dGVuZHMgWm9uZSB7XG4gIC8qKlxuICAgKiBHZXQgYSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgVVRDXG4gICAqIEByZXR1cm4ge0ZpeGVkT2Zmc2V0Wm9uZX1cbiAgICovXG4gIHN0YXRpYyBnZXQgdXRjSW5zdGFuY2UoKSB7XG4gICAgaWYgKHNpbmdsZXRvbiA9PT0gbnVsbCkge1xuICAgICAgc2luZ2xldG9uID0gbmV3IEZpeGVkT2Zmc2V0Wm9uZSgwKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpbmdsZXRvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYW4gaW5zdGFuY2Ugd2l0aCBhIHNwZWNpZmllZCBvZmZzZXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCAtIFRoZSBvZmZzZXQgaW4gbWludXRlc1xuICAgKiBAcmV0dXJuIHtGaXhlZE9mZnNldFpvbmV9XG4gICAqL1xuICBzdGF0aWMgaW5zdGFuY2Uob2Zmc2V0KSB7XG4gICAgcmV0dXJuIG9mZnNldCA9PT0gMCA/IEZpeGVkT2Zmc2V0Wm9uZS51dGNJbnN0YW5jZSA6IG5ldyBGaXhlZE9mZnNldFpvbmUob2Zmc2V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYW4gaW5zdGFuY2Ugb2YgRml4ZWRPZmZzZXRab25lIGZyb20gYSBVVEMgb2Zmc2V0IHN0cmluZywgbGlrZSBcIlVUQys2XCJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHMgLSBUaGUgb2Zmc2V0IHN0cmluZyB0byBwYXJzZVxuICAgKiBAZXhhbXBsZSBGaXhlZE9mZnNldFpvbmUucGFyc2VTcGVjaWZpZXIoXCJVVEMrNlwiKVxuICAgKiBAZXhhbXBsZSBGaXhlZE9mZnNldFpvbmUucGFyc2VTcGVjaWZpZXIoXCJVVEMrMDZcIilcbiAgICogQGV4YW1wbGUgRml4ZWRPZmZzZXRab25lLnBhcnNlU3BlY2lmaWVyKFwiVVRDLTY6MDBcIilcbiAgICogQHJldHVybiB7Rml4ZWRPZmZzZXRab25lfVxuICAgKi9cbiAgc3RhdGljIHBhcnNlU3BlY2lmaWVyKHMpIHtcbiAgICBpZiAocykge1xuICAgICAgY29uc3QgciA9IHMubWF0Y2goL151dGMoPzooWystXVxcZHsxLDJ9KSg/OjooXFxkezJ9KSk/KT8kL2kpO1xuICAgICAgaWYgKHIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGaXhlZE9mZnNldFpvbmUoc2lnbmVkT2Zmc2V0KHJbMV0sIHJbMl0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihvZmZzZXQpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKiBAcHJpdmF0ZSAqKi9cbiAgICB0aGlzLmZpeGVkID0gb2Zmc2V0O1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIFwiZml4ZWRcIjtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmZpeGVkID09PSAwID8gXCJVVENcIiA6IGBVVEMke2Zvcm1hdE9mZnNldCh0aGlzLmZpeGVkLCBcIm5hcnJvd1wiKX1gO1xuICB9XG5cbiAgZ2V0IGlhbmFOYW1lKCkge1xuICAgIGlmICh0aGlzLmZpeGVkID09PSAwKSB7XG4gICAgICByZXR1cm4gXCJFdGMvVVRDXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBgRXRjL0dNVCR7Zm9ybWF0T2Zmc2V0KC10aGlzLmZpeGVkLCBcIm5hcnJvd1wiKX1gO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIG9mZnNldE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGZvcm1hdE9mZnNldCh0cywgZm9ybWF0KSB7XG4gICAgcmV0dXJuIGZvcm1hdE9mZnNldCh0aGlzLmZpeGVkLCBmb3JtYXQpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IGlzVW5pdmVyc2FsKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgb2Zmc2V0KCkge1xuICAgIHJldHVybiB0aGlzLmZpeGVkO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZXF1YWxzKG90aGVyWm9uZSkge1xuICAgIHJldHVybiBvdGhlclpvbmUudHlwZSA9PT0gXCJmaXhlZFwiICYmIG90aGVyWm9uZS5maXhlZCA9PT0gdGhpcy5maXhlZDtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG4iLCJpbXBvcnQgWm9uZSBmcm9tIFwiLi4vem9uZS5qc1wiO1xuXG4vKipcbiAqIEEgem9uZSB0aGF0IGZhaWxlZCB0byBwYXJzZS4gWW91IHNob3VsZCBuZXZlciBuZWVkIHRvIGluc3RhbnRpYXRlIHRoaXMuXG4gKiBAaW1wbGVtZW50cyB7Wm9uZX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW52YWxpZFpvbmUgZXh0ZW5kcyBab25lIHtcbiAgY29uc3RydWN0b3Ioem9uZU5hbWUpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKiAgQHByaXZhdGUgKi9cbiAgICB0aGlzLnpvbmVOYW1lID0gem9uZU5hbWU7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gXCJpbnZhbGlkXCI7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy56b25lTmFtZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBpc1VuaXZlcnNhbCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBvZmZzZXROYW1lKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZm9ybWF0T2Zmc2V0KCkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgb2Zmc2V0KCkge1xuICAgIHJldHVybiBOYU47XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBlcXVhbHMoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG4iLCJpbXBvcnQgeyBmb3JtYXRPZmZzZXQsIHBhcnNlWm9uZUluZm8gfSBmcm9tIFwiLi4vaW1wbC91dGlsLmpzXCI7XG5pbXBvcnQgWm9uZSBmcm9tIFwiLi4vem9uZS5qc1wiO1xuXG5sZXQgc2luZ2xldG9uID0gbnVsbDtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBsb2NhbCB6b25lIGZvciB0aGlzIEphdmFTY3JpcHQgZW52aXJvbm1lbnQuXG4gKiBAaW1wbGVtZW50cyB7Wm9uZX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3lzdGVtWm9uZSBleHRlbmRzIFpvbmUge1xuICAvKipcbiAgICogR2V0IGEgc2luZ2xldG9uIGluc3RhbmNlIG9mIHRoZSBsb2NhbCB6b25lXG4gICAqIEByZXR1cm4ge1N5c3RlbVpvbmV9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGluc3RhbmNlKCkge1xuICAgIGlmIChzaW5nbGV0b24gPT09IG51bGwpIHtcbiAgICAgIHNpbmdsZXRvbiA9IG5ldyBTeXN0ZW1ab25lKCk7XG4gICAgfVxuICAgIHJldHVybiBzaW5nbGV0b247XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gXCJzeXN0ZW1cIjtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCgpLnJlc29sdmVkT3B0aW9ucygpLnRpbWVab25lO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IGlzVW5pdmVyc2FsKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIG9mZnNldE5hbWUodHMsIHsgZm9ybWF0LCBsb2NhbGUgfSkge1xuICAgIHJldHVybiBwYXJzZVpvbmVJbmZvKHRzLCBmb3JtYXQsIGxvY2FsZSk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBmb3JtYXRPZmZzZXQodHMsIGZvcm1hdCkge1xuICAgIHJldHVybiBmb3JtYXRPZmZzZXQodGhpcy5vZmZzZXQodHMpLCBmb3JtYXQpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgb2Zmc2V0KHRzKSB7XG4gICAgcmV0dXJuIC1uZXcgRGF0ZSh0cykuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGVxdWFscyhvdGhlclpvbmUpIHtcbiAgICByZXR1cm4gb3RoZXJab25lLnR5cGUgPT09IFwic3lzdGVtXCI7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbInJlcXVpcmUiLCJnbG9iYWwiLCJLaW1haVBhZ2luYXRlZEJveFdpZGdldCIsImRlZmF1bHQiLCJLaW1haVJlbG9hZFBhZ2VXaWRnZXQiLCJLaW1haUNvbG9yIiwiS2ltYWlTdG9yYWdlIiwiS2ltYWlDb25maWd1cmF0aW9uIiwiY29uc3RydWN0b3IiLCJjb25maWd1cmF0aW9ucyIsIl9jb25maWd1cmF0aW9ucyIsImdldCIsIm5hbWUiLCJoYXMiLCJpc1JUTCIsImdldExhbmd1YWdlIiwicmVwbGFjZSIsImlzMjRIb3VycyIsImdldEZpcnN0RGF5T2ZXZWVrIiwiaXNvIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwiY29uZmlnIiwiS2ltYWlUcmFuc2xhdGlvbiIsIktpbWFpUGx1Z2luIiwiS2ltYWlDb250YWluZXIiLCJjb25maWd1cmF0aW9uIiwidHJhbnNsYXRpb24iLCJFcnJvciIsIl9jb25maWd1cmF0aW9uIiwiX3RyYW5zbGF0aW9uIiwiX3BsdWdpbnMiLCJyZWdpc3RlclBsdWdpbiIsInBsdWdpbiIsInNldENvbnRhaW5lciIsInB1c2giLCJnZXRQbHVnaW4iLCJnZXRJZCIsImdldFBsdWdpbnMiLCJnZXRUcmFuc2xhdGlvbiIsImdldENvbmZpZ3VyYXRpb24iLCJnZXRVc2VyIiwiU2V0dGluZ3MiLCJLaW1haURhdGF0YWJsZUNvbHVtblZpZXciLCJLaW1haVRoZW1lSW5pdGlhbGl6ZXIiLCJLaW1haURhdGVSYW5nZVBpY2tlciIsIktpbWFpRGF0YXRhYmxlIiwiS2ltYWlUb29sYmFyIiwiS2ltYWlBUEkiLCJLaW1haUFsdGVybmF0aXZlTGlua3MiLCJLaW1haUFqYXhNb2RhbEZvcm0iLCJLaW1haUFjdGl2ZVJlY29yZHMiLCJLaW1haUV2ZW50IiwiS2ltYWlBUElMaW5rIiwiS2ltYWlBbGVydCIsIktpbWFpQXV0b2NvbXBsZXRlIiwiS2ltYWlGb3JtU2VsZWN0IiwiS2ltYWlGb3JtIiwiS2ltYWlEYXRlUGlja2VyIiwiS2ltYWlDb25maXJtYXRpb25MaW5rIiwiS2ltYWlNdWx0aVVwZGF0ZVRhYmxlIiwiS2ltYWlEYXRlVXRpbHMiLCJLaW1haUVzY2FwZSIsIktpbWFpRmV0Y2giLCJLaW1haVRpbWVzaGVldEZvcm0iLCJLaW1haVRlYW1Gb3JtIiwiS2ltYWlDb3B5RGF0YUZvcm0iLCJLaW1haURhdGVOb3dGb3JtIiwiS2ltYWlOb3RpZmljYXRpb24iLCJLaW1haUhvdGtleXMiLCJLaW1haVJlbW90ZU1vZGFsIiwiS2ltYWlVc2VyIiwiS2ltYWlMb2FkZXIiLCJ0cmFuc2xhdGlvbnMiLCJkZWZhdWx0TG9jYWxlIiwidG9Mb3dlckNhc2UiLCJkZWZhdWx0Wm9uZSIsImtpbWFpIiwiZG9jdW1lbnQiLCJkaXNwYXRjaEV2ZW50IiwiQ3VzdG9tRXZlbnQiLCJkZXRhaWwiLCJtYXAiLCJpbml0IiwiZ2V0S2ltYWkiLCJjb3JlIiwiX2NvcmUiLCJnZXRDb250YWluZXIiLCJnZXRDb25maWd1cmF0aW9ucyIsImdldERhdGVVdGlscyIsInRyYW5zbGF0ZSIsImVzY2FwZSIsInRpdGxlIiwiZXNjYXBlRm9ySHRtbCIsInRyaWdnZXIiLCJkZXRhaWxzIiwiZmV0Y2giLCJ1cmwiLCJvcHRpb25zIiwiZmV0Y2hGb3JtIiwiZm9ybSIsImdldEF0dHJpYnV0ZSIsIm1ldGhvZCIsInRvVXBwZXJDYXNlIiwiZGF0YSIsImNvbnZlcnRGb3JtRGF0YVRvUXVlcnlTdHJpbmciLCJpbmNsdWRlcyIsImJvZHkiLCJGb3JtRGF0YSIsImlzTW9iaWxlIiwid2lkdGgiLCJNYXRoIiwibWF4IiwiZG9jdW1lbnRFbGVtZW50IiwiY2xpZW50V2lkdGgiLCJ3aW5kb3ciLCJpbm5lcldpZHRoIiwiX3RyYW5zbGF0aW9ucyIsInJvb3QiLCJmYWN0b3J5IiwiZGVmaW5lIiwiYW1kIiwiS2ltYWlXZWJMb2FkZXIiLCJtb2R1bGUiLCJleHBvcnRzIiwic2VsZiIsIlRvbVNlbGVjdCIsIktpbWFpRm9ybVBsdWdpbiIsInNlbGVjdG9yIiwic3VwcG9ydHNGb3JtIiwiYWN0aXZhdGVGb3JtIiwiQVBJIiwic2xpY2UiLCJjYWxsIiwicXVlcnlTZWxlY3RvckFsbCIsIm5vZGUiLCJhcGlVcmwiLCJkYXRhc2V0IiwibWluQ2hhcnMiLCJwYXJzZUludCIsIm9uSXRlbUFkZCIsInNldFRleHRib3hWYWx1ZSIsIm1heE9wdGlvbnMiLCJjcmVhdGUiLCJvbk9wdGlvbkFkZCIsInZhbHVlIiwicGx1Z2lucyIsInNob3VsZExvYWQiLCJxdWVyeSIsImxvYWQiLCJjYWxsYmFjayIsInJlc3VsdHMiLCJyZXN1bHQiLCJ0ZXh0IiwicmVuZGVyIiwibm90X2xvYWRpbmciLCJvcHRpb25fY3JlYXRlIiwiaW5wdXQiLCJ0cGwiLCJ0cGxSZXBsYWNlZCIsIm5vX3Jlc3VsdHMiLCJkZXN0cm95Rm9ybSIsInRvbXNlbGVjdCIsImRlc3Ryb3kiLCJfZXZlbnRIYW5kbGVyIiwiZXZlbnQiLCJlbGVtZW50IiwidGFyZ2V0IiwibWF0Y2hlcyIsInBhcmVudE5vZGUiLCJxdWVyeVNlbGVjdG9yIiwic3BsaXQiLCJFdmVudCIsImV2ZW50QnViYmxlcyIsImJ1YmJsZXMiLCJwcmV2ZW50RGVmYXVsdCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZm9ybWF0IiwibGlua1RhcmdldCIsImN1cnJlbnRUYXJnZXQiLCJmb3JtRWxlbWVudCIsImdldEVsZW1lbnRCeUlkIiwiZGlzYWJsZWQiLCJMaXRlcGlja2VyIiwiX3NlbGVjdG9yIiwiZGlzYWJsZUxpdGVwaWNrZXJTdHlsZXMiLCJfcGlja2VycyIsIkZJUlNUX0RPVyIsIkxBTkdVQUdFIiwiYnV0dG9uVGV4dCIsInByZXZpb3VzTW9udGgiLCJuZXh0TW9udGgiLCJhcHBseSIsImNhbmNlbCIsIm5ld1BpY2tlcnMiLCJjb25zb2xlIiwibG9nIiwic2hvd1Rvb2x0aXAiLCJsYW5nIiwiYXV0b1JlZnJlc2giLCJmaXJzdERheSIsInNldHVwIiwicGlja2VyIiwib24iLCJkYXRlMSIsImRhdGUyIiwiX3dhc1ByZXNlbGVjdGVkIiwiYmFja2Ryb3AiLCJhcHBlbmRDaGlsZCIsInByZXBhcmVPcHRpb25zIiwiY29uY2F0IiwiaSIsInNwbGljZSIsInNpbmdsZU1vZGUiLCJhcGlTZWxlY3RzIiwiX2FwaVNlbGVjdHMiLCJ0YWdOYW1lIiwic2V0VGltZW91dCIsImZpZWxkcyIsImZpZWxkIiwiYWN0aXZhdGVTZWxlY3RQaWNrZXJCeUVsZW1lbnQiLCJpc011bHRpcGxlIiwibXVsdGlwbGUiLCJpc1JlcXVpcmVkIiwicmVxdWlyZWQiLCJsb2NrT3B0Z3JvdXBPcmRlciIsImFsbG93RW1wdHlPcHRpb24iLCJoaWRlUGxhY2Vob2xkZXIiLCJwZXJzaXN0IiwiZGlzYWJsZVNlYXJjaCIsImNvbnRyb2xJbnB1dCIsIm9wdGlvbiIsIml0ZW0iLCJjb2xvciIsInRyaW0iLCJzZWxlY3QiLCJjbGVhciIsImNsZWFyT3B0aW9uR3JvdXBzIiwiY2xlYXJPcHRpb25zIiwic3luYyIsInNldFZhbHVlIiwicmVmcmVzaEl0ZW1zIiwicmVmcmVzaE9wdGlvbnMiLCJkaXNhYmxlIiwiX3VwZGF0ZVNlbGVjdCIsImVuYWJsZSIsIl9hY3RpdmF0ZUFwaVNlbGVjdHMiLCJfdXBkYXRlT3B0aW9ucyIsInNlbGVjdElkZW50aWZpZXIiLCJlbXB0eU9wdGlvbiIsIkVsZW1lbnQiLCJzZWxlY3RlZFZhbHVlIiwiX2NyZWF0ZU9wdGlvbiIsImVtcHR5T3B0cyIsInRpdGxlUGF0dGVybiIsImtleSIsIk9iamVjdCIsImVudHJpZXMiLCJlbnRpdHkiLCJfZ2V0VGl0bGVGcm9tUGF0dGVybiIsImlkIiwib3B0R3JvdXAiLCJfY3JlYXRlT3B0Z3JvdXAiLCJmb3JFYWNoIiwiY2hpbGQiLCJhbGxPcHRpb25zIiwib3B0aW9uTGVuZ3RoIiwic2VsZWN0T3B0aW9uIiwicGF0dGVybiIsIkRBVEVfVVRJTFMiLCJyZWdleHAiLCJSZWdFeHAiLCJtYXRjaCIsImV4ZWMiLCJnZXRGb3JtYXR0ZWREYXRlIiwic3Vic3RyaW5nIiwiY2hhcnMiLCJzdGFydCIsImVuZCIsImluZGV4T2YiLCJhZGRPcHRpb24iLCJsYWJlbCIsImFkZCIsInJlbW92ZU9wdGlvbiIsInJlbW92ZSIsImNyZWF0ZUVsZW1lbnQiLCJpbm5lclRleHQiLCJfZXZlbnRIYW5kbGVyQXBpU2VsZWN0cyIsImFwaVNlbGVjdCIsInRhcmdldFNlbGVjdElkIiwidGFyZ2V0U2VsZWN0IiwiZm9ybVByZWZpeCIsIm5ld0FwaVVybCIsIl9idWlsZFVybFdpdGhGb3JtRmllbGRzIiwic2VsZWN0VmFsdWUiLCJBcnJheSIsImlzQXJyYXkiLCJkZWNvZGVkIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwidGVzdCIsIm9yaWdpbmFsRmllbGROYW1lIiwidGFyZ2V0RmllbGROYW1lIiwidGFyZ2V0RmllbGQiLCJuZXdWYWx1ZSIsInNlbGVjdGVkT3B0aW9ucyIsIm8iLCJ0eXBlIiwidGltZUlkIiwidGltZUVsZW1lbnQiLCJ0aW1lIiwibmV3RGF0ZSIsImZyb21IdG1sNUlucHV0IiwiZm9ybWF0Rm9yQVBJIiwidGltZUZvcm1hdCIsImZyb21Gb3JtYXQiLCJpc1ZhbGlkRGF0ZVRpbWUiLCJ1cmxQYXJhbXMiLCJ0bXBWYWx1ZSIsImpvaW4iLCJhcGlEYXRhIiwib3JkZXJlZCIsImtleXMiLCJzb3J0IiwidXNlcnNJZCIsIl9nZXRQcm90b3R5cGUiLCJfcmVtb3ZlTWVtYmVyIiwic2VsZWN0ZWRJbmRleCIsIm1lbWJlciIsIl9jcmVhdGVNZW1iZXIiLCJhcHBlbmQiLCJFU0NBUEVSIiwicHJvdG90eXBlIiwiY291bnRlciIsImNoaWxkTm9kZXMiLCJuZXdXaWRnZXQiLCJjYWxjdWxhdGVDb250cmFzdENvbG9yIiwiZGlzcGxheSIsImluaXRpYWxzIiwidG9TdHJpbmciLCJ0ZW1wIiwiaW5uZXJIVE1MIiwibmV3Tm9kZSIsImZpcnN0RWxlbWVudENoaWxkIiwiYnV0dG9uIiwic3RvcFByb3BhZ2F0aW9uIiwiRGF0ZVRpbWUiLCJfYmVnaW5EYXRlIiwiX2JlZ2luTGlzdGVuZXIiLCJfYmVnaW5UaW1lIiwiX2VuZFRpbWUiLCJfZW5kTGlzdGVuZXIiLCJfZHVyYXRpb24iLCJfZHVyYXRpb25MaXN0ZW5lciIsIl9kdXJhdGlvblRvZ2dsZSIsIl9kdXJhdGlvblRvZ2dsZUxpc3RlbmVyIiwiX2FjdGl2aXR5IiwiX2FjdGl2aXR5TGlzdGVuZXIiLCJfcHJvamVjdCIsInByb2plY3QiLCJwb3N0IiwidmlzaWJsZSIsIl9jaGFuZ2VkQmVnaW4iLCJfY2hhbmdlZEVuZCIsIl9jaGFuZ2VkRHVyYXRpb24iLCJjbGFzc0xpc3QiLCJ0b2dnbGUiLCJfaXNEdXJhdGlvbkNvbm5lY3RlZCIsImNvbnRhaW5zIiwiX2dldEJlZ2luIiwiZGF0ZSIsIl9wYXJzZUJlZ2luIiwiaW52YWxpZCIsIl9maXhUaW1lRm9ybWF0IiwiX3BhcnNlRW5kIiwiZW5kRGF0ZSIsInRvRm9ybWF0IiwiX2dldEVuZCIsIm5vdyIsImJlZ2luIiwicGx1cyIsImRheXMiLCJkdXJhdGlvbiIsIl9nZXRQYXJzZWREdXJhdGlvbiIsImhhc0R1cmF0aW9uIiwiYXMiLCJfYXBwbHlEYXRlVG9GaWVsZCIsIl91cGRhdGVEdXJhdGlvbiIsIm1pbnVzIiwibmV3RHVyYXRpb24iLCJkaWZmIiwiX3NldER1cmF0aW9uQXNTdHJpbmciLCJpc1ZhbGlkIiwic2Vjb25kcyIsIm5ld0JlZ2luIiwiaG91cnMiLCJmbG9vciIsIm1pbnV0ZXMiLCJwYXJzZUR1cmF0aW9uIiwiZGF0ZVRpbWUiLCJkYXRlRmllbGQiLCJ0aW1lRmllbGQiLCJfaGVhZGVycyIsImhlYWRlcnMiLCJIZWFkZXJzIiwiY2FsbGJhY2tTdWNjZXNzIiwiY2FsbGJhY2tFcnJvciIsInBhcmFtcyIsIlVSTFNlYXJjaFBhcmFtcyIsImVycm9yIiwiaGFuZGxlRXJyb3IiLCJ0aGVuIiwicmVzcG9uc2UiLCJqc29uIiwiY2F0Y2giLCJfcGFyc2VEYXRhIiwicGF0Y2giLCJzdGF0dXNDb2RlIiwiZGVsZXRlIiwiSlNPTiIsInN0cmluZ2lmeSIsIm1lc3NhZ2UiLCJjb250ZW50VHlwZSIsInJlc3VsdEVycm9yIiwic3RhdHVzIiwiZXJyb3JzIiwiY29sbGVjdGVkIiwiY2hpbGRyZW4iLCJ0bXBGaWVsZCIsInN0YXR1c1RleHQiLCJhdHRyaWJ1dGVzIiwicXVlc3Rpb24iLCJfY2FsbEFwaSIsImV2ZW50TmFtZSIsIkVWRU5UUyIsIkFMRVJUIiwic3VjY2Vzc0hhbmRsZSIsInN1Y2Nlc3MiLCJlcnJvckhhbmRsZSIsIl9zZWxlY3RvckVtcHR5IiwiX2Zhdkljb25VcmwiLCJoYW5kbGVVcGRhdGUiLCJyZWxvYWRBY3RpdmVSZWNvcmRzIiwiX3VwZGF0ZUJyb3dzZXJUaXRsZSIsImhhbmRsZSIsIl91cGRhdGVzSGFuZGxlciIsInNldEludGVydmFsIiwiYWN0aXZlUmVjb3JkcyIsIl9jaGFuZ2VGYXZpY29uIiwiREFURSIsImR1cmF0aW9ucyIsInJlY29yZCIsImZvcm1hdER1cmF0aW9uIiwidGV4dENvbnRlbnQiLCJzaGlmdCIsIl9zZXRFbnRyaWVzIiwiaGFzRW50cmllcyIsIm1lbnVFbXB0eSIsInN0eWxlIiwibWVudSIsInN0b3AiLCJhY2Nlc3NrZXkiLCJfcmVwbGFjZUluTm9kZSIsInRpbWVzaGVldCIsImFsbFJlcGxhY2VyIiwibGluayIsInJlcGxhY2VyTmFtZSIsImFjdGl2aXR5IiwiY3VzdG9tZXIiLCJydW5uaW5nIiwiY2FudmFzIiwib3JpZyIsImhyZWYiLCJjbG9uZU5vZGUiLCJnZXRDb250ZXh0IiwicmF0aW8iLCJkZXZpY2VQaXhlbFJhdGlvIiwiaW1nIiwiaGVpZ2h0Iiwib25sb2FkIiwiY3R4IiwiZHJhd0ltYWdlIiwiZmlsbFN0eWxlIiwiZmlsbFJlY3QiLCJ0b0RhdGFVUkwiLCJoZWFkIiwic3JjIiwiS2ltYWlSZWR1Y2VkQ2xpY2tIYW5kbGVyIiwiTW9kYWwiLCJfaXNEaXJ0eSIsIm1vZGFsRWxlbWVudCIsIl9nZXRNb2RhbEVsZW1lbnQiLCJtc2ciLCJwcmVwZW5kIiwiX2dldEZvcm1JZGVudGlmaWVyIiwicmVwbGFjZVdpdGgiLCJhZGRDbGlja0hhbmRsZXIiLCJvcGVuVXJsSW5Nb2RhbCIsIl9nZXRNb2RhbCIsImdldE9yQ3JlYXRlSW5zdGFuY2UiLCJyZWRpcmVjdCIsIm9rIiwibG9jYXRpb24iLCJodG1sIiwiX29wZW5Gb3JtSW5Nb2RhbCIsInJlYXNvbiIsIl9tYWtlU2NyaXB0RXhlY3V0YWJsZSIsInNjcmlwdCIsInJlcGxhY2VDaGlsZCIsImZvcm1JZGVudGlmaWVyIiwicmVtb3RlTW9kYWwiLCJuZXdGb3JtSHRtbCIsIm5ld01vZGFsQ29udGVudCIsIm1vZGFsRGlhbG9nIiwibGFyZ2VNb2RhbCIsImhpZGUiLCJmbGFzaE1lc3NhZ2VzIiwiX2dldEV2ZW50SGFuZGxlciIsInNob3ciLCJldmVudEhhbmRsZXIiLCJidG4iLCJldmVudHMiLCJhbGVydCIsInJlc3BvbnNlSHRtbCIsImhhc0ZpZWxkRXJyb3IiLCJoYXNGb3JtRXJyb3IiLCJoYXNGbGFzaEVycm9yIiwibW9kYWxDb250ZW50IiwiVG9hc3QiLCJvbGRNb2RhbEVsZW1lbnQiLCJfbWFwQ2xhc3MiLCJfc2hvd01vZGFsIiwid2FybmluZyIsIl9zaG93IiwiX3RvYXN0IiwiaW5mbyIsImNvbnRhaW5lciIsInRlbXBsYXRlIiwiY29udGVudCIsImZpcnN0Q2hpbGQiLCJtb2RhbCIsInJlbW92ZUNoaWxkIiwiaWNvbiIsInRvYXN0IiwiY3NzIiwiYWN0aW9uIiwic3VibWl0IiwiS2ltYWlDb250ZXh0TWVudSIsImNvbnRlbnRBcmVhU2VsZWN0b3IiLCJ0YWJsZVNlbGVjdG9yIiwiX2NvbnRlbnRBcmVhIiwiZGF0YVRhYmxlIiwicmVnaXN0ZXJDb250ZXh0TWVudSIsInJlbG9hZERhdGF0YWJsZSIsImNyZWF0ZUZvckRhdGFUYWJsZSIsInRvb2xiYXJTZWxlY3RvciIsImdldFNlbGVjdG9yIiwibmV3Q29udGVudCIsInJlbG9hZCIsImRhdGFBdHRyaWJ1dGUiLCJfaWQiLCJfbW9kYWwiLCJfZXZhbHVhdGVDaGVja2JveGVzIiwiX3NhdmVWaXNpYmlsaXR5IiwiX3Jlc2V0VmlzaWJpbGl0eSIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwibG9jYWxTdG9yYWdlIiwic2V0SXRlbSIsInNldEF0dHJpYnV0ZSIsImNoZWNrYm94IiwiX2NoYW5nZVZpc2liaWxpdHkiLCJjaGVja2VkIiwidGFibGUiLCJnZXRFbGVtZW50c0J5Q2xhc3NOYW1lIiwiY29sdW1uRWxlbWVudCIsImZpZWxkTmFtZSIsImdldENvbXB1dGVkU3R5bGUiLCJjb2x1bW5OYW1lIiwidGFibGVCb3giLCJ0YXJnZXRDbGFzc2VzIiwicmVtb3ZlQ2xhc3MiLCJhZGRDbGFzcyIsImluZGV4IiwibGlzdE9iaiIsImNsYXNzTmFtZSIsIkR1cmF0aW9uIiwiZHVyYXRpb25Gb3JtYXQiLCJkYXRlRm9ybWF0IiwiX3BhcnNlRm9ybWF0IiwiRGF0ZSIsImZyb21KU0RhdGUiLCJmcm9tSVNPIiwibG9jYWxlIiwiaXNVdGMiLCJ0b1VUQyIsInRvSVNPIiwiaW5jbHVkZU9mZnNldCIsInN1cHByZXNzTWlsbGlzZWNvbmRzIiwiYWRkSHVtYW5EdXJhdGlvbiIsInBhcnNlZCIsInRvZGF5Iiwic3RhcnRPZiIsInRpbWVPZkRheSIsInRvSlNEYXRlIiwic2luY2UiLCJmb3JtYXRMdXhvbkR1cmF0aW9uIiwiZm9ybWF0U2Vjb25kcyIsImZyb21PYmplY3QiLCJzaGlmdFRvIiwiZm9ybWF0QXNEdXJhdGlvbiIsImZvcm1hdFRpbWUiLCJhYnMiLCJnZXRTZWNvbmRzRnJvbUR1cmF0aW9uU3RyaW5nIiwibHV4b25EdXJhdGlvbiIsInBhcnNlRmxvYXQiLCJjIiwiZCIsInRvRml4ZWQiLCJpc05hTiIsInZhbHVlT2YiLCJuZWdhdGUiLCJ0YWdzVG9SZXBsYWNlIiwidGFnIiwidHJpZ2dlckV2ZW50IiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJsb2dpblVybCIsImZvcm1TZWxlY3RvciIsIm92ZXJ3cml0ZXMiLCJyZW1vdmVFbXB0eSIsInNlcmlhbGl6ZWQiLCJzZXQiLCJyb3ciLCJlbmNvZGVVUklDb21wb25lbnQiLCJldiIsImN0cmxLZXkiLCJlbGVtZW50cyIsImZpbHRlciIsImlzVmlzaWJsZSIsIndhcm4iLCJjbGljayIsImdldENsaWVudFJlY3RzIiwiZ2V0UHJvcGVydHlWYWx1ZSIsIl90b2dnbGVGb3JtIiwic2VsZWN0ZWRJdGVtIiwiaWRzIiwiX2dldFNlbGVjdGVkSWRzIiwiYm94Iiwic2V0UHJvcGVydHkiLCJpc1N1cHBvcnRlZCIsIk5vdGlmaWNhdGlvbiIsInBlcm1pc3Npb24iLCJyZXF1ZXN0IiwicmVxdWVzdFBlcm1pc3Npb24iLCJlIiwibm90aWZ5Iiwib3B0cyIsImRpciIsIm5UaXRsZSIsIm5vdGlmaWNhdGlvbiIsIm9uY2xpY2siLCJmb2N1cyIsImNsb3NlIiwiaXNDb250ZW50RWRpdGFibGUiLCJfaGlkZSIsIl9pbml0RWxlbWVudCIsIlRvb2x0aXAiLCJ0b29sdGlwVHJpZ2dlckVsIiwiRk9STVMiLCJfcmVnaXN0ZXJNb2RhbEF1dG9mb2N1cyIsIm92ZXJsYXkiLCJmb3JtQXV0b2ZvY3VzIiwiZm9ybVN1Ym1pdEFjdGlvbkNsYXNzIiwiX2Zvcm1TZWxlY3RvciIsIl9hY3Rpb25DbGFzcyIsIl9yZWdpc3RlclBhZ2luYXRpb24iLCJfcmVnaXN0ZXJTb3J0YWJsZVRhYmxlcyIsIl9yZWdpc3RlckFsdGVybmF0aXZlU3VibWl0QWN0aW9ucyIsInRyaWdnZXJDaGFuZ2UiLCJhY3Rpb25CdG5DbGFzcyIsInByZXZBY3Rpb24iLCJwcmV2TWV0aG9kIiwib3JkZXIiLCJvcmRlckJ5IiwicGFnZXIiLCJ1cmxQYXJ0cyIsInBhZ2VOdW1iZXIiLCJ1c2VyIiwiZ2V0VXNlcklkIiwiZ2V0TmFtZSIsImlzQWRtaW4iLCJhZG1pbiIsImlzU3VwZXJBZG1pbiIsInN1cGVyQWRtaW4iLCJoZXhjb2xvciIsImhleCIsInIiLCJnIiwiYiIsInlpcSIsImdldENvbnRleHRNZW51RWxlbWVudCIsImNyZWF0ZUZyb21BcGkiLCJhdHRyTmFtZSIsInJlcGxhY2VBbGwiLCJjcmVhdGVGcm9tQ2xpY2tFdmVudCIsImRyb3Bkb3duRWxlbWVudCIsInpJbmRleCIsInBvc2l0aW9uIiwidG9wIiwiY2xpZW50WSIsImxlZnQiLCJjbGllbnRYIiwiZHJvcGRvd25MaXN0ZW5lciIsImFjdGlvbnMiLCJqc0V2ZW50IiwiY29udGV4dE1lbnUiLCJib3hJZCIsIndpZGdldCIsInJlbG9hZFBhZ2UiLCJsb2FkUGFnZSIsImVsZW1lbnRJZCIsImhpZGVPdmVybGF5IiwiZnVsbFJlbG9hZCIsIl9sb2FkUGFnZSIsIl9zaG93T3ZlcmxheSIsIl9oaWRlT3ZlcmxheSIsInZhbHVlcyIsImdldEl0ZW0iLCJwYXJzZSIsInJlbW92ZUl0ZW0iXSwic291cmNlUm9vdCI6IiJ9